import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { gelatoReducers, GELATO_PERSISTED_KEYS, useGelatoLimitOrdersLib, useGelatoLimitOrdersHistory, useGelatoLimitOrders, useGasOverhead, GelatoProvider } from '@gelatonetwork/limit-orders-react';
export * from '@gelatonetwork/limit-orders-react';
import { ChainId, Token as Token$1, CHAINS, JSBI as JSBI$1, WAVAX, Percent as Percent$1, Fraction as Fraction$1, ChefType, StakingType, CAVAX, ALL_CHAINS, currencyEquals, Pair, TokenAmount, CurrencyAmount, Trade, FACTORY_ADDRESS, Price, Router, TradeType as TradeType$2, AVALANCHE_MAINNET, Currency, InsufficientInputAmountError } from '@arcanumdex/sdk';
import { useTranslation, Trans, initReactI18next } from 'react-i18next';
export { Trans, useTranslation } from 'react-i18next';
import { useQueryClient, useQuery, useQueries, QueryClient, QueryClientProvider } from 'react-query';
import { createStoreHook, createDispatchHook, createSelectorHook, Provider } from 'react-redux';
import React, { useCallback, useContext, cloneElement, useState, useEffect, useMemo, createContext, useRef, memo } from 'react';
import { isMobile } from 'react-device-detect';
import AutoSizer from 'react-virtualized-auto-sizer';
import { FixedSizeList } from 'react-window';
import { HelpCircle, ChevronDown, ArrowDown, AlertTriangle, ArrowUpCircle, Settings, X, Divide, RefreshCcw, ChevronRight, ChevronUp, Link as Link$4, Plus, ArrowLeft, ArrowRight, EyeOff, Eye, Lock, Search, ChevronLeft, Info, Anchor, Play, Trash } from 'react-feather';
import styled, { css, ThemeProvider as ThemeProvider$1, ThemeContext, keyframes } from 'styled-components';
import ReactSwitch from 'react-switch';
import { __rest, __awaiter } from 'tslib';
import merge from 'lodash.merge';
import ReactGA from 'react-ga';
import get from 'lodash.get';
import { lighten, darken, transparentize, opacify } from 'polished';
import { space, layout, flexbox, typography, border, position } from 'styled-system';
import { isFragment } from 'react-is';
import deepEqual from 'deep-equal';
import { Web3Provider } from '@ethersproject/providers';
import { useWeb3React, UnsupportedChainIdError } from '@web3-react/core';
import BN from 'bn.js';
import { SafeAppConnector } from '@gnosis.pm/safe-apps-web3-react';
import { InjectedConnector } from '@arcanumdex/web3-react-injected-connector';
import { TalismanConnector } from '@talismn/web3react-v6-connector';
import { WalletConnectConnector } from '@web3-react/walletconnect-connector';
import { WalletLinkConnector } from '@web3-react/walletlink-connector';
import { EventEmitter } from 'events';
import { keyStores, Near as Near$1, WalletConnection, utils, Contract as Contract$1, transactions } from 'near-api-js';
import { JsonRpcProvider } from 'near-api-js/lib/providers';
import { createAction, createReducer, nanoid, configureStore, getDefaultMiddleware } from '@reduxjs/toolkit';
import { save, load } from 'redux-localstorage-simple';
import { getVersionUpgrade, VersionUpgrade, minVersionBump } from '@_arcanumdex/token-lists';
import { getAddress } from '@ethersproject/address';
import { BigNumber } from '@ethersproject/bignumber';
import { AddressZero, MaxUint256 } from '@ethersproject/constants';
import { Contract } from '@ethersproject/contracts';
import IArcanumRouter from '@arcanumdex/exchange-contracts/artifacts/contracts/arcanum-periphery/interfaces/IArcanumRouter.sol/IArcanumRouter.json';
import IArcanumRouterSupportingFees from '@arcanumdex/exchange-contracts/artifacts/contracts/arcanum-periphery/interfaces/IArcanumRouterSupportingFees.sol/IArcanumRouterSupportingFees.json';
import ReactTooltip from 'react-tooltip';
import useCollapse from 'react-collapsed';
import { parseBytes32String } from '@ethersproject/strings';
import axios from 'axios';
import flatMap from 'lodash.flatmap';
import { baseDecode } from 'borsh';
import { Interface } from '@ethersproject/abi';
import IArcanumPair, { abi as abi$1 } from '@arcanumdex/exchange-contracts/artifacts/contracts/arcanum-core/interfaces/IArcanumPair.sol/IArcanumPair.json';
import LRUCache from 'lru-cache';
import MiniChefV2 from '@arcanumdex/exchange-contracts/artifacts/contracts/mini-chef/MiniChefV2.sol/MiniChefV2.json';
import '@arcanumdex/exchange-contracts/artifacts/contracts/arcanum-token/Arc.sol/Arc.json';
import StakingRewards from '@arcanumdex/exchange-contracts/artifacts/contracts/staking-rewards/StakingRewards.sol/StakingRewards.json';
import { parseUnits as parseUnits$1, formatUnits, formatEther } from '@ethersproject/units';
import qs, { parse as parse$1 } from 'qs';
import { splitSignature, parseUnits, getAddress as getAddress$1 } from 'ethers/lib/utils';
import { BigNumber as BigNumber$1 } from 'ethers';
import schema from '@_arcanumdex/token-lists/src/tokenlist.schema.json';
import Ajv from 'ajv';
import isEqual from 'lodash.isequal';
import { InMemoryCache } from 'apollo-cache-inmemory';
import { ApolloClient } from 'apollo-client';
import { HttpLink } from 'apollo-link-http';
import { GraphQLClient } from 'graphql-request';
import gql from 'graphql-tag';
import i18next from 'i18next';
export { default as i18n } from 'i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import { Portal } from 'react-portal';
import Scrollbars, { Scrollbars as Scrollbars$1 } from 'react-custom-scrollbars';
import { ResponsiveContainer, LineChart, Line, Tooltip as Tooltip$1 } from 'recharts';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import numeral from 'numeral';
import ReactMarkdown from 'react-markdown';
import Slider from 'react-slick';
import remarkGfm from 'remark-gfm';
import Select from 'react-select';
import ReactHtmlParser from 'react-html-parser';
import { useWindowSize, useMedia } from 'react-use';
import ReactPaginate from 'react-paginate';
import { Tabs as Tabs$2, TabPanel as TabPanel$1, TabList as TabList$1, Tab as Tab$2 } from 'react-tabs';

const MEDIA_WIDTHS = {
    upToExtraSmall: 500,
    upToSmall: 720,
    upToMedium: 960,
    upToLarge: 1280,
};
const mediaWidthTemplates = Object.keys(MEDIA_WIDTHS).reduce((acc, sizeKey) => {
    acc[sizeKey] = (a, b, c) => css`
      @media (max-width: ${MEDIA_WIDTHS[sizeKey]}px) {
        ${css(a, b, c)}
      }
    `;
    return acc;
}, {});
const white = '#FFFFFF';
const black = '#000000';
const philippineYellow = '#FFC800'; //primary
const mustardYellow = '#E1AA00';
const eerieBlack = '#1C1C1C';
const ghostWhite = '#F7F8FA';
const ghostWhite1 = '#FAF9FD';
const chineseBlack = '#111111';
const darkGunmetal = '#212427';
const platinum = '#E5E5E5';
const darkSilver = '#717171';
const venetianRed = '#CC1512';
const oceanBlue = '#18C145';
const quickSilver = '#A3A3A3';
const warning$1 = '#F3841E';
const success = '#18C145';
const defaultColors = {
    // base
    white,
    black,
    // text
    text1: '#000000',
    text2: '#565A69',
    text3: '#888D9B',
    text4: '#C3C5CB',
    text5: '#EDEEF2',
    text6: '#EDEEF2',
    text7: '#000000',
    text8: '#565A69',
    text9: '#000000',
    text10: '#000000',
    text11: '#18C145',
    text12: '#E84142',
    text13: '#000000',
    text14: '#000000',
    text15: '#000000',
    // backgrounds / greys
    bg1: '#FFFFFF',
    bg2: '#F7F8FA',
    bg3: '#EDEEF2',
    bg4: '#CED0D9',
    bg5: '#888D9B',
    bg6: '#FFFFFF',
    bg7: '#FFFFFF',
    bg8: '#FFFFFF',
    bg9: '#000000',
    //specialty colors
    modalBG: 'rgba(0,0,0,0.3)',
    modalBG2: 'rgba(0,0,0,0.8)',
    advancedBG: 'rgba(255,255,255,0.6)',
    closeCircleBG: 'rgba(255,255,255,0.2)',
    //primary colors
    primary1: '#FF6B00',
    primary2: '#FF6B00',
    primary3: '#FF6B00',
    primary4: '#FF6B00',
    primary5: '#FF6B00',
    primary6: '#FFFFFF',
    // color text
    primaryText1: '#ffffff',
    // secondary colors
    secondary1: '#ff007a',
    secondary2: '#F6DDE8',
    secondary3: '#FDEAF1',
    // other
    red1: '#FF6871',
    red2: '#F82D3A',
    green1: '#27AE60',
    yellow1: '#FFE270',
    yellow2: '#F3841E',
    blue1: '#2172E5',
    avaxRed: '#E84142',
    // theme color objects for components
    swapWidget: {
        primary: black,
        secondary: quickSilver,
        backgroundColor: ghostWhite,
        detailsBackground: white,
        interactiveColor: quickSilver,
        interactiveBgColor: platinum,
    },
    drawer: {
        text: black,
        backgroundColor: ghostWhite,
    },
    textInput: {
        text: quickSilver,
        labelText: quickSilver,
        placeholderText: quickSilver,
        backgroundColor: white,
    },
    currencySelect: {
        defaultText: black,
        selectedText: black,
        defaultBackgroundColor: philippineYellow,
        selectedBackgroundColor: ghostWhite,
    },
    loader: {
        text: black,
    },
    numberOptions: {
        text: black,
        activeTextColor: black,
        activeBackgroundColor: philippineYellow,
        inactiveBackgroundColor: white,
        borderColor: white,
    },
    switch: {
        onColor: philippineYellow,
        offColor: '#CED0D9',
        backgroundColor: platinum,
    },
    toggleButton: {
        backgroundColor: platinum,
        selectedColor: ghostWhite,
        fontColor: chineseBlack,
    },
    button: {
        primary: {
            background: philippineYellow,
            color: black,
        },
        secondary: {
            background: chineseBlack,
            color: white,
        },
        outline: {
            borderColor: philippineYellow,
            color: black,
        },
        plain: {
            color: black,
        },
        disable: {
            background: platinum,
            color: darkSilver,
        },
        confirmed: {
            background: oceanBlue,
            color: oceanBlue,
            borderColor: oceanBlue,
        },
    },
    bridge: {
        primaryBgColor: white,
        secondaryBgColor: ghostWhite,
        text: black,
        infoIconColor: black,
        routeInfoColor: platinum,
        transferKeyColor: quickSilver,
        loaderCloseIconColor: mustardYellow,
        informationBoxesBackgroundColor: chineseBlack,
    },
    tabs: {
        tabColor: quickSilver,
        tabListColor: black,
        tabPanelBorderColor: quickSilver,
    },
    dropdown: {
        color: black,
        primaryBgColor: white,
    },
    primary: philippineYellow,
    mustardYellow,
    eerieBlack,
    ghostWhite,
    ghostWhite1,
    chineseBlack,
    darkGunmetal,
    platinum,
    darkSilver,
    venetianRed,
    oceanBlue,
    quickSilver,
    error: venetianRed,
    warning: warning$1,
    success,
    color2: ghostWhite,
    color3: platinum,
    color4: chineseBlack,
    color5: white,
    color6: chineseBlack,
    color7: ghostWhite,
    color8: platinum,
    color9: quickSilver,
    color10: white,
    color11: white,
    color12: platinum,
};
const defaultTheme = Object.assign(Object.assign({}, defaultColors), {
    grids: {
        sm: 8,
        md: 12,
        lg: 24,
    },
    //shadows
    shadow1: '#2F80ED',
    // media queries
    mediaWidth: mediaWidthTemplates,
    // css snippets
    flexColumnNoWrap: css`
    display: flex;
    flex-flow: column nowrap;
  `, flexRowNoWrap: css`
    display: flex;
    flex-flow: row nowrap;
  ` });
function ThemeProvider({ children, theme }) {
    const finalTheme = merge({}, defaultTheme, theme || {});
    return jsx(ThemeProvider$1, Object.assign({ theme: finalTheme }, { children: children }));
}
const useTheme = () => {
    const theme = useContext(ThemeContext);
    if (!theme) {
        throw Error('useTheme is used outside of ThemeContext');
    }
    return theme;
};
const StyledLink = styled.a`
  text-decoration: none;
  cursor: pointer;
  color: ${({ theme }) => theme.primary};
  font-weight: 500;

  :hover {
    text-decoration: underline;
  }

  :focus {
    outline: none;
    text-decoration: underline;
  }

  :active {
    text-decoration: none;
  }
`;
/**
 * Outbound link that handles firing google analytics events
 */
function ExternalLink(_a) {
    var { target = '_blank', href, rel = 'noopener noreferrer' } = _a, rest = __rest(_a, ["target", "href", "rel"]);
    const handleClick = useCallback((event) => {
        // don't prevent default, don't redirect if it's a new tab
        if (target === '_blank' || event.ctrlKey || event.metaKey) {
            // eslint-disable-next-line import/no-named-as-default-member
            ReactGA.outboundLink({ label: href }, () => {
                console.debug('Fired outbound link event', href);
            });
        }
        else {
            event.preventDefault();
            // send a ReactGA event and then trigger a location change
            // eslint-disable-next-line import/no-named-as-default-member
            ReactGA.outboundLink({ label: href }, () => {
                window.location.href = href;
            });
        }
    }, [href, target]);
    return jsx(StyledLink, Object.assign({ target: target, rel: rel, href: href, onClick: handleClick }, rest));
}

// here we need to do some hack, because react-switch package is still in commonjs
// https://github.com/vitejs/vite/issues/2139#issuecomment-824557740
const BaseSwitch = ReactSwitch.default ? ReactSwitch.default : ReactSwitch;
const Switch = (props) => {
    var _a, _b, _c, _d;
    const { checked, onChange, checkedIcon, disabled, height, offColor, offHandleColor, onColor, onHandleColor, uncheckedIcon, width, } = props;
    const theme = useTheme();
    return (jsx(BaseSwitch, { checked: checked, onChange: (isChecked) => onChange === null || onChange === void 0 ? void 0 : onChange(isChecked), onHandleColor: onHandleColor || ((_a = theme.switch) === null || _a === void 0 ? void 0 : _a.onColor), offHandleColor: offHandleColor || ((_b = theme.switch) === null || _b === void 0 ? void 0 : _b.offColor), onColor: onColor || ((_c = theme.switch) === null || _c === void 0 ? void 0 : _c.backgroundColor), offColor: offColor || ((_d = theme.switch) === null || _d === void 0 ? void 0 : _d.backgroundColor), uncheckedIcon: uncheckedIcon || false, checkedIcon: checkedIcon || false, disabled: disabled, height: height, width: width }));
};
Switch.defaultProps = {
    onChange: () => { },
    checked: false,
    checkedIcon: false,
    disabled: false,
    uncheckedIcon: false,
};

const Primary = (props) => props.variant === 'primary' &&
    css`
    background-color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.primary) === null || _b === void 0 ? void 0 : _b.background; }};
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.primary) === null || _b === void 0 ? void 0 : _b.color; }};
  `;
const Secondary = (props) => props.variant === 'secondary' &&
    css`
    background-color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.secondary) === null || _b === void 0 ? void 0 : _b.background; }};
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.secondary) === null || _b === void 0 ? void 0 : _b.background; }};
  `;
const Outline = (props) => props.variant === 'outline' &&
    css`
    border: 1px solid ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.outline) === null || _b === void 0 ? void 0 : _b.borderColor; }};
    background-color: transparent;
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.outline) === null || _b === void 0 ? void 0 : _b.color; }};
  `;
const Plain = (props) => props.variant === 'plain' &&
    css`
    background-color: transparent;
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.plain) === null || _b === void 0 ? void 0 : _b.color; }};
    display: flex;
    justify-content: center;
    align-items: center;
  `;
const Disable = (props) => (props.isDisabled || props.loading) &&
    css`
    background-color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.disable) === null || _b === void 0 ? void 0 : _b.background; }};
    border: 1px solid transparent;
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.disable) === null || _b === void 0 ? void 0 : _b.color; }};
    cursor: auto;
    pointer-events: none;
  `;
const Confirmed = (props) => props.variant === 'confirm' &&
    css`
    background-color: ${({ theme }) => { var _a, _b; return lighten(0.5, ((_b = (_a = theme === null || theme === void 0 ? void 0 : theme.button) === null || _a === void 0 ? void 0 : _a.confirmed) === null || _b === void 0 ? void 0 : _b.background) || (theme === null || theme === void 0 ? void 0 : theme.oceanBlue)); }};
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.confirmed) === null || _b === void 0 ? void 0 : _b.color; }};
    border: 1px solid ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.confirmed) === null || _b === void 0 ? void 0 : _b.borderColor; }};
    opacity: 50%;
    cursor: auto;
  `;
const Root$q = styled.button`
  padding: ${(props) => ((props === null || props === void 0 ? void 0 : props.padding) ? props === null || props === void 0 ? void 0 : props.padding : '0px')};
  width: ${({ width }) => (width ? width : '100%')};
  height: ${({ height }) => (height ? height : '51px')};
  font-weight: 500;
  text-align: center;
  border-radius: ${(props) => { var _a; return (_a = props === null || props === void 0 ? void 0 : props.borderRadius) !== null && _a !== void 0 ? _a : '8px'; }};
  outline: none;
  border: 1px solid transparent;
  color: white;
  text-decoration: none;
  display: flex;
  justify-content: center;
  flex-wrap: nowrap;
  align-items: center;
  cursor: pointer;
  position: relative;
  z-index: 1;
  text-decoration: none;
  box-sizing: border-box;

  ${Primary}
  ${Secondary}
  ${Outline}
  ${Plain}
  ${Disable}
  ${Confirmed}

  /* Customizable Colors */
  color: ${({ color, theme }) => color && get(theme, color, color)};
  background-color: ${({ backgroundColor, theme }) => backgroundColor && get(theme, backgroundColor, backgroundColor)};
  border: ${({ borderColor, theme }) => `1px solid ${borderColor && get(theme, borderColor, borderColor)}`};

  > * {
    user-select: none;
  }
`;
const IconAfter = styled.div`
  color: white;
  margin-left: 10px;
`;
const IconBefore = styled.div`
  color: white;
  margin-right: 10px;
`;

const Button = (props) => {
    const { iconBefore, children, iconAfter, loading, loadingText, as, target } = props, rest = __rest(props, ["iconBefore", "children", "iconAfter", "loading", "loadingText", "as", "target"]);
    return (jsx(Root$q, Object.assign({}, rest, { as: as, target: target }, { children: loading ? (loadingText || 'Loading...') : (jsxs(Fragment, { children: [iconBefore && jsx(IconBefore, { children: iconBefore }), children, iconAfter && jsx(IconAfter, { children: iconAfter })] })) })));
};
Button.defaultProps = {
    target: '_blank',
};

//TODO: set appropriate type
const Box = styled.div`
  color: ${({ color, theme }) => (color ? get(theme, color) : 'black')};
  background-color: ${({ bgColor, theme }) => (bgColor ? get(theme, bgColor) : 'transparent')};
  ${space}
  ${layout}
  ${flexbox}
  ${typography}
  ${border}
  ${position}
`;

const Text = styled.div`
  ${space}
  ${typography}
  ${position}
  color: ${({ color, theme }) => color && get(theme, color, color)};
  cursor: ${(props) => props.cursor && props.cursor};
`;

const InputWrapper$3 = styled(Box)`
  width: 100%;
  border-radius: 8px;
  padding: 10px;
  border: 1px solid transparent;
  display: flex;
  position: relative;
  box-sizing: border-box;
  background-color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.text; }};
  input {
    background-color: inherit;
  }
`;
const StyledInput = styled.input`
  flex: 1;
  border: 1px solid transparent;
  font-size: ${(props) => ((props === null || props === void 0 ? void 0 : props.fontSize) ? `${props === null || props === void 0 ? void 0 : props.fontSize}px` : '18px')};
  color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.text; }};
  background-color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  outline: none;
  width: 100%;
  padding: 0;
  cursor: ${(props) => ((props === null || props === void 0 ? void 0 : props.disabled) ? 'not-allowed' : 'default')};
  -moz-appearance: textfield;
  ::-webkit-inner-spin-button,
  ::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  ::placeholder {
    color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.placeholderText; }};
  }
`;
const AddonAfter = styled(Box)`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
`;
const AddonBefore = styled(Box)`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
`;
const ErrorText = styled(Text)`
  margin-top: 5px;
  color: ${({ theme }) => theme.red2};
  font-size: 12px;
`;

const TextInput = (props) => {
    const { label, addonLabel, addonAfter, addonBefore, error, showErrorMessage = true, onChange, isNumeric, getRef = () => { }, autoComplete = 'off' } = props, rest = __rest(props, ["label", "addonLabel", "addonAfter", "addonBefore", "error", "showErrorMessage", "onChange", "isNumeric", "getRef", "autoComplete"]);
    const inputRegex = new RegExp(`^\\d+\\.?\\d*$`);
    return (jsxs(Box, {
        children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: label ? 'space-between' : 'flex-end' }, { children: [label && jsx(Text, Object.assign({ color: "textInput.labelText" }, { children: label })), addonLabel && addonLabel] })), jsxs(InputWrapper$3, {
            children: [addonBefore && jsx(AddonBefore, { children: addonBefore }), jsx(StyledInput, Object.assign({}, rest, {
                autoComplete: autoComplete, ref: (ref) => getRef(ref), type: isNumeric ? 'number' : 'text', onChange: (e) => {
                    const value = e.target.value;
                    if (isNumeric && !!value) {
                        if (inputRegex.test(value)) {
                            onChange && onChange(value);
                        }
                    }
                    else {
                        onChange && onChange(value);
                    }
                }
            })), addonAfter && jsx(AddonAfter, { children: addonAfter })]
        }), showErrorMessage && !!error && jsx(ErrorText, { children: error })]
    }));
};

const StepWrapper = styled('div')`
  margin-top: auto;
  display: flex;
  justify-content: space-between;
`;
const StepItem = styled.div`
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
  font-weight: ${({ active }) => (active ? 'bold' : 'normal')};
  pointer-events: ${({ disabled }) => (disabled ? 'none' : 'auto')};
  opacity: ${({ disabled }) => (disabled ? 0.4 : 1)};
  cursor: ${({ disabled }) => (disabled ? 'none' : 'pointer')};

  @media (max-width: 768px) {
    font-size: 12px;
  }
  &:before {
    position: absolute;
    content: '';
    border-bottom: ${({ theme }) => `2px solid ${theme.bg5}`};
    width: 100%;
    top: ${({ progressDot }) => (progressDot ? '21px' : '15px')};
    left: ${({ progressDot }) => (progressDot ? '-50%' : '-38%')};
    z-index: 2;
  }
  &:after {
    position: absolute;
    content: '';
    border-bottom: 2px solid;
    border-bottom-color: ${({ completed, theme }) => (completed ? theme.primary : theme.bg5)};
    width: 100%;
    top: ${({ progressDot }) => (progressDot ? '21px' : '15px')};
    left: ${({ progressDot }) => (progressDot ? '50%' : '38%')};
    z-index: ${({ completed }) => (completed ? 3 : 2)};
  }
  &:first-child:before {
    content: none;
  }
  &:last-child::after {
    content: none;
  }
`;
const StepCounter = styled.div`
  position: relative;
  z-index: 5;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background: ${({ completed, active, theme }) => (completed || active ? theme.primary : theme.bg5)};
  color: ${({ completed, active, theme }) => (completed || active ? theme.text6 : theme.white)};
  margin-bottom: 6px;
`;
const StepName = styled('div')`
  margin-top: auto;
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
  color: ${({ theme }) => theme.text4};
`;
const IconDot = styled.div`
  position: relative;
  z-index: 5;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: ${({ completed, active, theme }) => (completed || active ? theme.primary : theme.bg5)};
  margin-top: 17px;
`;

const Step = (props) => {
    const { active, completed, stepNumber, disabled, title, progressDot, stepIndex, onStepClick } = props;
    const renderIconNode = () => {
        let iconNode;
        if (progressDot) {
            iconNode = jsx(IconDot, { completed: completed, active: active });
        }
        else {
            iconNode = (jsx(StepCounter, Object.assign({ completed: completed, active: active }, { children: stepNumber })));
        }
        return iconNode;
    };
    const onClick = () => {
        onStepClick && onStepClick(stepIndex || 0);
    };
    return (jsxs(StepItem, Object.assign({ completed: completed, active: active, onClick: onClick, disabled: disabled, progressDot: progressDot }, { children: [renderIconNode(), active && jsxs(StepName, { children: [" ", title] })] })));
};

const toChildrenArray = (children, option = {}) => {
    let ret = [];
    React.Children.forEach(children, (child) => {
        if ((child === undefined || child === null) && !option.keepEmpty) {
            return;
        }
        if (Array.isArray(child)) {
            ret = ret.concat(toChildrenArray(child));
        }
        else if (isFragment(child) && child.props) {
            ret = ret.concat(toChildrenArray(child.props.children, option));
        }
        else {
            ret.push(child);
        }
    });
    return ret;
};

const Steps = (props) => {
    const { children, current = 0, progressDot = false, onChange, allowChangeOnClick = true } = props;
    const onStepClick = (next) => {
        if (onChange && current !== next && allowChangeOnClick) {
            onChange(next);
        }
    };
    return (jsx(StepWrapper, {
        children: toChildrenArray(children).map((child, index) => {
            const stepNumber = index;
            const childProps = Object.assign({ stepNumber: `${stepNumber + 1}`, stepIndex: stepNumber, key: stepNumber, progressDot, onStepClick: onChange && onStepClick, active: stepNumber === current, completed: stepNumber < (current || 0) }, child.props);
            return cloneElement(child, childProps);
        })
    }));
};

const Root$p = styled.div`
  flex-direction: row;
  align-items: center;
  display: flex;
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  pointer-events: ${({ disabled }) => (disabled ? 'none' : '')};
`;
const OuterSquare = styled.div`
  width: ${(props) => `${props === null || props === void 0 ? void 0 : props.size}px`};
  height: ${(props) => `${props === null || props === void 0 ? void 0 : props.size}px`};
  border: 1px solid;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: ${({ theme }) => theme.bg4};
  border-color: ${({ theme }) => theme.bg4};
  transition: all ease-in 0.2s;
`;
const InnerSquare = styled.div`
  width: ${(props) => `${(props === null || props === void 0 ? void 0 : props.size) / 2}px`};
  height: ${(props) => `${(props === null || props === void 0 ? void 0 : props.size) / 2}px`};
  background-color: ${({ theme, selected }) => (selected ? theme.bg5 : theme.bg4)};
`;
const Label$1 = styled(Text)`
  margin-left: 10px;
  font-size: 14px;
  font-weight: 300;
`;

const Checkbox = (props) => {
    const { value, label, labelColor = 'text1', onChange, disabled, size, checked } = props;
    const [internalChekced, setInternalChecked] = useState(checked);
    useEffect(() => {
        setInternalChecked(checked);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [checked]);
    return (jsxs(Root$p, Object.assign({
        disabled: disabled, onClick: () => {
            onChange && onChange(!internalChekced, value);
            setInternalChecked((prev) => !prev);
        }
    }, { children: [jsx(OuterSquare, Object.assign({ size: size }, { children: jsx(InnerSquare, { selected: internalChekced, size: size }) })), Boolean(label) && jsx(Label$1, Object.assign({ color: labelColor }, { children: label }))] })));
};
Checkbox.defaultProps = {
    size: 15,
};

const Root$o = styled.div`
  flex-direction: ${(props) => ((props === null || props === void 0 ? void 0 : props.type) === 'horizontal' ? 'row' : 'column')};
  display: flex;
`;

const CheckboxGroup = (props) => {
    const { value, onChange, options, type } = props, rest = __rest(props, ["value", "onChange", "options", "type"]);
    const [selected, setSelected] = useState([]);
    const handleOnChange = (isChecked, checkValue) => {
        var _a;
        const index = selected === null || selected === void 0 ? void 0 : selected.indexOf(checkValue);
        const newValues = [...selected];
        if (isChecked) {
            (_a = (newValues || [])) === null || _a === void 0 ? void 0 : _a.push(checkValue);
        }
        else {
            (newValues || []).splice(index, 1);
        }
        setSelected(newValues);
        onChange === null || onChange === void 0 ? void 0 : onChange(newValues);
    };
    useEffect(() => {
        if (value) {
            setSelected(value);
        }
    }, [value]);
    return (jsx(Root$o, Object.assign({ type: type }, {
        children: (options || []).map((option, i) => (jsx(Box, Object.assign({ ml: type === 'horizontal' ? '5px' : '0px' }, {
            children: jsx(Checkbox, Object.assign({
                value: option.value, label: option.label, onChange: (checked, someValue) => {
                    handleOnChange(checked, someValue);
                }, checked: (selected === null || selected === void 0 ? void 0 : selected.indexOf(option.value)) > -1 ? true : false
            }, rest))
        }), i)))
    })));
};

const Root$n = styled.div`
  flex-direction: row;
  align-items: center;
  display: flex;
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  pointer-events: ${({ disabled }) => (disabled ? 'none' : '')};
`;
const OuterCircle = styled.div`
  width: ${(props) => `${props === null || props === void 0 ? void 0 : props.size}px`};
  height: ${(props) => `${props === null || props === void 0 ? void 0 : props.size}px`};
  border-radius: 50%;
  border: 1px solid;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: ${({ theme }) => theme.bg4};
  border-color: ${({ theme }) => theme.bg4};
  transition: all ease-in 0.2s;
`;
const InnerCircle = styled.div`
  width: ${(props) => `${(props === null || props === void 0 ? void 0 : props.size) / 2}px`};
  height: ${(props) => `${(props === null || props === void 0 ? void 0 : props.size) / 2}px`};
  border-radius: 50%;
  background-color: ${({ theme, selected }) => (selected ? theme.bg5 : theme.bg4)};
`;
const Label = styled(Text)`
  margin-left: 10px;
  font-size: 14px;
  font-weight: 300;
`;

const RadioButton = (props) => {
    const { value, label, onChange, disabled, size, checked } = props;
    return (jsxs(Root$n, Object.assign({
        disabled: disabled, onClick: () => {
            onChange && onChange(value);
        }
    }, { children: [jsx(OuterCircle, Object.assign({ size: size }, { children: jsx(InnerCircle, { selected: checked, size: size }) })), Boolean(label) && jsx(Label, { children: label })] })));
};
RadioButton.defaultProps = {
    size: 15,
};

const Root$m = styled.div`
  flex-direction: ${(props) => ((props === null || props === void 0 ? void 0 : props.type) === 'horizontal' ? 'row' : 'column')};
  display: flex;
`;

const RadioButtonGroup = (props) => {
    const { value, onChange, options, type } = props, rest = __rest(props, ["value", "onChange", "options", "type"]);
    const [selected, setSelected] = useState('');
    useEffect(() => {
        setSelected(value);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [value]);
    return (jsx(Root$m, Object.assign({ type: type }, {
        children: (options || []).map((option, i) => (jsx(Box, Object.assign({ ml: type === 'horizontal' ? '5px' : '0px' }, {
            children: jsx(RadioButton, Object.assign({
                checked: selected === option.value, value: option.value, label: option.label, onChange: () => {
                    onChange && onChange(option.value);
                    setSelected(option.value);
                }
            }, rest))
        }), i)))
    })));
};

var NearLogo = "data:image/svg+xml,%3Csvg%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%2050%2050%22%20fill%3D%22none%22%20%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%20%20%3Ccircle%20cx%3D%2225%22%20cy%3D%2225%22%20r%3D%2225%22%20fill%3D%22white%22%3E%3C%2Fcircle%3E%20%20%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M16.1053%2017.7695V31.4934L22.9474%2026.25L23.6316%2026.8654L17.894%2035.1541C15.7622%2037.16%2012%2035.8028%2012%2033.0278V16.0832C12%2013.2131%2015.9825%2011.9058%2018.0379%2014.1012L33.8947%2031.038V17.8772L27.7368%2022.5575L27.0526%2021.9421L31.9327%2014.2049C33.9696%2011.9688%2038%2013.2643%2038%2016.1551V32.7243C38%2035.5944%2034.0175%2036.9017%2031.9621%2034.7063L16.1053%2017.7695Z%22%20fill%3D%22black%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E";

var SongBirdLogo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAD6CAMAAAC/MqoPAAAC8VBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////++/z6/P3FhaTRhJ359fjYeo9Zr9fMiKHLkKrMp77biJnPf5fPmK+/hqPXgJbDkq7lgYzSbYTPobfDi6i8fpzPeJXvgoezia3Jgp307fK4gqWwmbrCmLS8jq/76etittjfg5PteoHFobm6nLa8jKjUip/EfZ19rs7LrcWun8G2krLx4eh8wtnmmab2r7K9dJitdJLHdI/SdIxuvdtOrdLqh5LkeIemr8yfgqbQjaTCpb+5oL7ZpLfHe5XFa4pgrdDhsMCjnr/Im7S8hqv8joO5X4Hy+Pv99PWJxdvWqr2miavyi4/geY7q1+Fvs9SWsM5sqcuxq8iPm76pjLPTk6nsX2frzddonsOCnL+3lLjtprCyeKDjiJnddYTFYoGJqcrVtMehl7rbnK7znaPikJ/abofvbG7r9Pn5295Ap86UqcjqrLiejrFyhq2tgKzalKekeaCcc5S6bo2Ylrqvk7bbi6DtcHd2qcian8Cnlbfgo7WTj7PrkZr3iofeYXnnZnb0d3WUvNarutLQvdCIstDnvMlPpsmQfKFse6Hlbn/SY33T6fOtYofr6PDe4+zeztzdwtG4utGbp8empsW4psLCmsCRg6t5c5r4m5mJcpfzkZWVZpD5hHyl0+Z7t9dfpcmIkraGZ5C62umexduMosR3kriDia5chqrbanyRzOJyx+F/qMavgZ6UXHzgUWLH4O3CuM9Tm8FbkLHObo3UVG1Liq33p6mBf6Oiao3jWm7R0uK/pMgtm8Y/k7lomLb6lY9+X4Le8Peft9H4y873vMB1oMDJWHi+r8ZXdpx9yuOvV3LSOlPn8PbDyd2yydtnaY6fTWyVb6F0bs2XAAAAKHRSTlMA+u70VgceDbwZTT3Nw9x8KuXU4pwjg3ZqNtmtFJVcRa+TiNqXoIuQxwGXyAAAIhNJREFUeNrc1GluwjAQBeCxnXjJ5pCFBAIJe+f+J6yi/kGgSq3A9oTvBk9v3oA/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";

var WgmiLogo = "data:image/png;base64,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";

const Svg = styled.svg`
  @keyframes spinners-react-dotted-shrink {
    50% {
      transform: translate(0, 0);
      opacity: 0;
    }
  }
`;
const Loading = () => {
    return (jsxs(Svg, Object.assign({ fill: "none", viewBox: "0 0 66 66", style: { color: '#e1aa00', overflow: 'visible' }, xmlns: "http://www.w3.org/2000/svg" }, {
        children: [jsx("circle", {
            cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                transform: 'translate(22px, -20px)',
                animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0s infinite normal none running spinners-react-dotted-shrink',
            }
        }), jsx("circle", {
            cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                transform: 'translate(29px)',
                animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.1s infinite normal none running spinners-react-dotted-shrink',
            }
        }), jsx("circle", {
            cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                transform: 'translate(22px, 20px)',
                animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.2s infinite normal none running spinners-react-dotted-shrink',
            }
        }), jsx("circle", {
            cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                transform: 'translate(0px, 30px)',
                animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.3s infinite normal none running spinners-react-dotted-shrink',
            }
        }), jsx("circle", {
            cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                transform: 'translate(-23px, 20px)',
                animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.4s infinite normal none running spinners-react-dotted-shrink',
            }
        }), jsx("circle", {
            cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                transform: 'translate(-30px)',
                animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.5s infinite normal none running spinners-react-dotted-shrink',
            }
        }), jsx("circle", {
            cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                transform: 'translate(-23px, -20px)',
                animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.6s infinite normal none running spinners-react-dotted-shrink',
            }
        }), jsx("circle", {
            cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                transform: 'translate(0px, -30px)',
                animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.7s infinite normal none running spinners-react-dotted-shrink',
            }
        })]
    })));
};

const rotate$1 = keyframes`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`;
const StyledSVG$2 = styled.svg`
  animation: 2s ${rotate$1} linear infinite;
  height: ${({ size }) => size};
  width: ${({ size }) => size};
  path {
    stroke: ${({ stroke, theme }) => stroke !== null && stroke !== void 0 ? stroke : theme.primary1};
  }
`;
/**
 * Takes in custom size and stroke for circle color, default to primary color as fill,
 * need ...rest for layered styles on top
 */
function LoaderIcon(_a) {
    var { size = '16px', stroke } = _a, rest = __rest(_a, ["size", "stroke"]);
    return (jsx(StyledSVG$2, Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", size: size, stroke: stroke }, rest, { children: jsx("path", { d: "M12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 9.27455 20.9097 6.80375 19.1414 5", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round" }) })));
}

const LogoIcon = () => {
    return (jsxs("svg", Object.assign({ width: "50", height: "50", viewBox: "0 0 1053 987", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "M957.158 0.770165L815.237 0.657715L846.697 100.693L857.306 134.444L829.473 155.25L589.981 334.445L801.6 493.282L1052.89 305.289L957.158 0.770165Z", fill: "#FFC800" }), jsx("path", { d: "M223.323 154.888L195.53 134.013L206.18 100.317L237.639 0.646202L96.235 0.53418L0.104492 304.941L251.087 493.327L462.99 334.77L223.323 154.888Z", fill: "#E1AA00" }), jsx("path", { d: "M502.192 161.848L287.451 0.727051L251.21 115.473L502.192 303.859L502.328 303.747V161.82L502.192 161.848Z", fill: "#E1AA00" }), jsx("path", { d: "M765.574 0.890137L550.547 161.759V303.686L801.679 115.804L765.574 0.890137Z", fill: "#FFC800" }), jsx("path", { d: "M278.907 532.814L251.74 553.171L251.21 554.824L502.192 743.21L502.328 743.098V365.654L278.907 532.814Z", fill: "#E1AA00" }), jsx("path", { d: "M801.068 553.29L773.765 532.779L550.832 365.451L550.547 365.662V743.105L801.679 555.224L801.068 553.29Z", fill: "#FFC800" }), jsx("path", { d: "M502.152 803.537L474.36 782.675L297.856 650.22L251.21 797.946L502.192 986.333L502.328 986.221V803.397L502.152 803.537Z", fill: "#E1AA00" }), jsx("path", { d: "M755.169 650.314L578.203 782.714L550.547 803.407V986.231L801.679 798.349L755.169 650.314Z", fill: "#FFC800" })] })));
};

const AvaxLogo = ({ size = '24px' }) => {
    return (jsxs("svg", Object.assign({ version: "1.0", xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 1000.000000 1000.000000", preserveAspectRatio: "xMidYMid meet" }, { children: [jsx("circle", { cx: "500", cy: "500", r: "400", fill: "white" }), jsx("g", Object.assign({ transform: "translate(0.000000,1000.000000) scale(0.100000,-0.100000)", fill: "#E84142", stroke: "none" }, { children: jsx("path", { d: "M4590 9989 c-1442 -124 -2734 -838 -3594 -1984 -572 -761 -904 -1642\n-986 -2610 -13 -155 -13 -635 0 -790 123 -1453 833 -2745 1985 -3609 761 -572\n1642 -904 2610 -986 155 -13 635 -13 790 0 1453 123 2745 833 3609 1985 572\n761 904 1642 986 2610 13 155 13 635 0 790 -123 1453 -833 2745 -1985 3609\n-761 572 -1642 904 -2610 986 -139 11 -666 11 -805 -1z m458 -1530 c39 -19 79\n-50 109 -84 64 -72 782 -1332 824 -1445 41 -113 59 -231 59 -385 0 -159 -19\n-277 -63 -394 -23 -59 -293 -536 -861 -1521 -456 -789 -853 -1472 -882 -1516\n-118 -179 -349 -347 -582 -423 -157 -51 -179 -53 -992 -49 l-755 3 -60 24\nc-86 34 -158 108 -180 185 -19 63 -16 116 10 202 21 70 2972 5247 3025 5307\n114 129 223 159 348 96z m1919 -3378 c50 -23 124 -90 163 -146 42 -62 1009\n-1762 1043 -1835 43 -89 49 -202 17 -278 -28 -65 -92 -123 -169 -154 l-56 -23\n-1110 0 -1110 0 -59 24 c-63 25 -138 87 -162 132 -42 82 -38 189 10 295 36 79\n1035 1807 1076 1862 41 54 118 115 164 130 53 17 147 13 193 -7z" }) }))] })));
};

const CflrLogo = ({ size = '24px ' }) => {
    return (jsxs("svg", Object.assign({ version: "1.1", id: "Layer_1", xmlns: "http://www.w3.org/2000/svg", x: "0px", y: "0px", width: size, height: size, viewBox: "0 0 1920 1920", enableBackground: "new 0 0 1920 1920" }, { children: [jsx("g", { transform: "translate(0.000000,1000.000000) scale(0.100000,-0.100000)", fill: "#ffe669", stroke: "none" }), jsx("image", { id: "image0", width: "1920", height: "1920", x: "0", y: "0", href: "data:image/png;base64,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" })] })));
};

var arrowRightIcon = "data:image/svg+xml,%3Csvg%20width%3D%2218%22%20height%3D%2218%22%20viewBox%3D%220%200%2018%2018%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M9.79261%2016.1108L17.5398%208.36364L9.79261%200.616477L8.25852%202.15057L13.3807%207.25568H0V9.47159H13.3807L8.25852%2014.5852L9.79261%2016.1108Z%22%20fill%3D%22%23333639%22%2F%3E%3C%2Fsvg%3E";

var bitKeepIcon = "data:image/svg+xml,%3Csvg%20width%3D%2236%22%20height%3D%2236%22%20viewBox%3D%220%200%2036%2036%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M18%200C27.942%200%2036%208.05967%2036%2018C36%2027.942%2027.942%2036%2018%2036C8.05967%2036%200%2027.9413%200%2018C0%208.05967%208.05967%200%2018%200Z%22%20fill%3D%22%237524F9%22%2F%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M28%2013.1817V14.2863C28.0002%2014.3931%2027.9714%2014.4981%2027.9165%2014.5907C27.8616%2014.6833%2027.7826%2014.7601%2027.6875%2014.8135L24.0242%2016.8686L27.2969%2018.6995C27.5108%2018.8196%2027.6884%2018.9924%2027.8118%2019.2005C27.9353%2019.4085%2028.0002%2019.6445%2028%2019.8847V22.8302C28.0003%2023.0705%2027.9355%2023.3066%2027.812%2023.5148C27.6886%2023.723%2027.5109%2023.8959%2027.2969%2024.0161L18.6898%2028.8168C18.4761%2028.9368%2018.2336%2029%2017.9867%2029C17.7399%2029%2017.4974%2028.9368%2017.2836%2028.8168L14.4672%2027.235C14.4196%2027.2084%2014.3802%2027.17%2014.3527%2027.1238C14.3253%2027.0776%2014.3108%2027.0252%2014.3108%2026.9718C14.3108%2026.9184%2014.3253%2026.866%2014.3527%2026.8198C14.3802%2026.7736%2014.4196%2026.7352%2014.4672%2026.7086L23.7641%2021.5052C23.7877%2021.4918%2023.8074%2021.4727%2023.8211%2021.4496C23.8347%2021.4265%2023.8419%2021.4004%2023.8419%2021.3738C23.8419%2021.3472%2023.8347%2021.321%2023.8211%2021.2979C23.8074%2021.2749%2023.7877%2021.2557%2023.7641%2021.2423L20.3125%2019.3035C20.2175%2019.2502%2020.1097%2019.2221%2020%2019.2221C19.8903%2019.2221%2019.7825%2019.2502%2019.6875%2019.3035L10.2445%2024.5927C10.1733%2024.6327%2010.0924%2024.6538%2010.0102%2024.6538C9.92788%2024.6538%209.84704%2024.6327%209.77578%2024.5927L8.70625%2023.9979C8.4913%2023.8779%208.31277%2023.7048%208.18875%2023.4961C8.06472%2023.2875%207.99961%2023.0507%208%2022.8096V21.6055C7.99995%2021.5254%208.02158%2021.4468%208.06273%2021.3774C8.10387%2021.3081%208.16307%2021.2505%208.23438%2021.2104L21.7734%2013.6443C21.7971%2013.631%2021.8168%2013.6118%2021.8304%2013.5887C21.8441%2013.5657%2021.8513%2013.5395%2021.8513%2013.5129C21.8513%2013.4863%2021.8441%2013.4601%2021.8304%2013.4371C21.8168%2013.414%2021.7971%2013.3948%2021.7734%2013.3815L18.3164%2011.4358C18.2214%2011.3825%2018.1136%2011.3544%2018.0039%2011.3544C17.8942%2011.3544%2017.7864%2011.3825%2017.6914%2011.4358L8.46875%2016.5936C8.42127%2016.6202%208.36741%2016.6343%208.31258%2016.6343C8.25775%2016.6343%208.20389%2016.6203%208.15639%2016.5937C8.10889%2016.567%208.06944%2016.5287%208.04199%2016.4826C8.01454%2016.4364%208.00006%2016.384%208%2016.3307V13.1672C7.99971%2012.9269%208.06454%2012.6907%208.18798%2012.4825C8.31142%2012.2743%208.4891%2012.1015%208.70313%2011.9813L17.3086%207.18212C17.5219%207.0628%2017.7637%207%2018.0098%207C18.2558%207%2018.4976%207.0628%2018.7109%207.18212L27.2969%2011.998C27.5106%2012.118%2027.688%2012.2905%2027.8114%2012.4983C27.9349%2012.706%2027.9999%2012.9417%2028%2013.1817Z%22%20fill%3D%22white%22%2F%3E%3C%2Fsvg%3E";

var coinbaseWalletIcon = "data:image/png;base64,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";

var gnosisSafeIcon = "data:image/png;base64,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";

var metamaskIcon = "data:image/png;base64,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";

var rabbyIcon = "data:image/svg+xml,%3Csvg%20width%3D%22320%22%20height%3D%22320%22%20viewBox%3D%220%200%20320%20320%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M310.142%20178.941C322.057%20152.322%20263.149%2077.9513%20206.872%2046.9671C171.399%2022.9641%20134.435%2026.2617%20126.949%2036.8008C110.52%2059.93%20181.351%2079.5284%20228.721%20102.398C218.538%20106.821%20208.943%20114.758%20203.3%20124.908C185.64%20105.627%20146.878%2089.0245%20101.396%20102.398C70.7464%20111.411%2045.2741%20132.658%2035.4293%20164.749C33.0371%20163.686%2030.3886%20163.095%2027.6021%20163.095C16.9467%20163.095%208.3087%20171.733%208.3087%20182.389C8.3087%20193.044%2016.9467%20201.682%2027.6021%20201.682C29.5772%20201.682%2035.7526%20200.357%2035.7526%20200.357L134.435%20201.073C94.97%20263.68%2063.7812%20272.832%2063.7812%20283.679C63.7812%20294.525%2093.6234%20291.586%20104.828%20287.543C158.468%20268.189%20216.08%20207.869%20225.966%20190.505C267.482%20195.685%20302.372%20196.298%20310.142%20178.941Z%22%20fill%3D%22url%28%23paint0_linear%29%22%2F%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M228.717%20102.401C228.72%20102.403%20228.722%20102.404%20228.725%20102.405C230.92%20101.54%20230.565%2098.297%20229.962%2095.7505C228.577%2089.8972%20204.667%2066.2872%20182.215%2055.7122C151.62%2041.3023%20129.091%2042.0452%20125.763%2048.6868C131.995%2061.4595%20160.886%2073.4515%20191.061%2085.9761C203.934%2091.3196%20217.041%2096.7599%20228.722%20102.399C228.72%20102.4%20228.719%20102.401%20228.717%20102.401Z%22%20fill%3D%22url%28%23paint1_linear%29%22%2F%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M189.892%20230.954C183.705%20228.59%20176.716%20226.42%20168.77%20224.452C177.242%20209.292%20179.02%20186.849%20171.019%20172.659C159.789%20152.745%20145.693%20142.146%20112.937%20142.146C94.9207%20142.146%2046.4136%20148.214%2045.5525%20188.707C45.4621%20192.956%2045.5502%20196.849%2045.8578%20200.43L134.435%20201.072C122.494%20220.016%20111.31%20234.066%20101.519%20244.75C113.275%20247.762%20122.976%20250.291%20131.883%20252.613C140.334%20254.816%20148.069%20256.832%20156.165%20258.898C168.378%20250%20179.86%20240.298%20189.892%20230.954Z%22%20fill%3D%22url%28%23paint2_linear%29%22%2F%3E%3Cpath%20d%3D%22M34.2473%20196.269C37.8658%20227.03%2055.3476%20239.085%2091.0698%20242.652C126.792%20246.22%20147.283%20243.826%20174.563%20246.308C197.347%20248.381%20217.691%20259.992%20225.238%20255.98C232.03%20252.369%20228.23%20239.323%20219.142%20230.953C207.361%20220.103%20191.056%20212.56%20162.366%20209.883C168.084%20194.228%20166.482%20172.279%20157.602%20160.337C144.763%20143.07%20121.064%20135.263%2091.0699%20138.674C59.733%20142.238%2029.7062%20157.666%2034.2473%20196.269Z%22%20fill%3D%22url%28%23paint3_linear%29%22%2F%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22paint0_linear%22%20x1%3D%2297.8271%22%20y1%3D%22155.368%22%20x2%3D%22307.576%22%20y2%3D%22214.849%22%20gradientUnits%3D%22userSpaceOnUse%22%3E%3Cstop%20stop-color%3D%22%238797FF%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%23AAA8FF%22%2F%3E%3C%2FlinearGradient%3E%3ClinearGradient%20id%3D%22paint1_linear%22%20x1%3D%22272.257%22%20y1%3D%22151.38%22%20x2%3D%22120.914%22%20y2%3D%22-0.332927%22%20gradientUnits%3D%22userSpaceOnUse%22%3E%3Cstop%20stop-color%3D%22%233B22A0%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%235156D8%22%20stop-opacity%3D%220%22%2F%3E%3C%2FlinearGradient%3E%3ClinearGradient%20id%3D%22paint2_linear%22%20x1%3D%22194.103%22%20y1%3D%22236.239%22%20x2%3D%2248.7216%22%20y2%3D%22152.655%22%20gradientUnits%3D%22userSpaceOnUse%22%3E%3Cstop%20stop-color%3D%22%233B1E8F%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%236A6FFB%22%20stop-opacity%3D%220%22%2F%3E%3C%2FlinearGradient%3E%3ClinearGradient%20id%3D%22paint3_linear%22%20x1%3D%22110.349%22%20y1%3D%22153.803%22%20x2%3D%22208.616%22%20y2%3D%22278.661%22%20gradientUnits%3D%22userSpaceOnUse%22%3E%3Cstop%20stop-color%3D%22%238898FF%22%2F%3E%3Cstop%20offset%3D%220.983895%22%20stop-color%3D%22%235F47F1%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3C%2Fsvg%3E";

var talismanIcon = "data:image/svg+xml,%3Csvg%20width%3D%2249%22%20height%3D%2248%22%20viewBox%3D%220%200%2049%2048%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M38.3067%2026.7464C38.7631%2027.7399%2040.1065%2028.0909%2040.8796%2027.3177L42.2961%2025.9013C43.7606%2024.4368%2046.1349%2024.4368%2047.5994%2025.9013C49.0639%2027.3657%2049.0639%2029.7401%2047.5994%2031.2046L36.1465%2042.6575C33.3949%2045.9243%2029.2741%2048%2024.6686%2048C19.8655%2048%2015.5897%2045.7426%2012.8443%2042.2308L1.81877%2031.2052C0.354304%2029.7408%200.354304%2027.3664%201.81877%2025.9019C3.28323%2024.4375%205.65759%2024.4375%207.12206%2025.9019L8.51754%2027.2974C9.2735%2028.0534%2010.5859%2027.7134%2011.0324%2026.742C11.1206%2026.5501%2011.1686%2026.3441%2011.1686%2026.1328L11.1686%208.99993C11.1686%206.92887%2012.8475%205.24994%2014.9186%205.24994C16.9896%205.24994%2018.6686%206.92887%2018.6686%208.99993L18.6686%2017.6675C18.6686%2018.4132%2019.4324%2018.9194%2020.1435%2018.6947C20.5935%2018.5525%2020.9186%2018.1427%2020.9186%2017.6708L20.9186%203.75C20.9186%201.67894%2022.5975%201.44747e-05%2024.6686%201.39315e-05C26.7396%201.33883e-05%2028.4186%201.67894%2028.4186%203.75L28.4186%2017.671C28.4186%2018.1429%2028.7436%2018.5524%2029.1935%2018.6946C29.9043%2018.9192%2030.6679%2018.4132%2030.6679%2017.6678L30.6679%208.99994C30.6679%206.92888%2032.3468%205.24995%2034.4178%205.24995C36.4889%205.24995%2038.1678%206.92887%2038.1678%208.99993L38.1678%2026.1249C38.1678%2026.3404%2038.2168%2026.5505%2038.3067%2026.7464Z%22%20fill%3D%22%23FF3D23%22%2F%3E%3Cpath%20d%3D%22M36.6684%2034.5C36.6684%2034.5%2031.2958%2042%2024.6684%2042C18.041%2042%2012.6685%2034.5%2012.6685%2034.5C12.6685%2034.5%2018.041%2027%2024.6684%2027C31.2958%2027%2036.6684%2034.5%2036.6684%2034.5Z%22%20fill%3D%22%23D5FF5C%22%2F%3E%3Cpath%20d%3D%22M30.3031%2034.5C30.3031%2037.6114%2027.7808%2040.1337%2024.6694%2040.1337C21.558%2040.1337%2019.0357%2037.6114%2019.0357%2034.5C19.0357%2031.3886%2021.558%2028.8663%2024.6694%2028.8663C27.7808%2028.8663%2030.3031%2031.3886%2030.3031%2034.5Z%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cpath%20d%3D%22M28.0522%2034.5002C28.0522%2036.369%2026.5372%2037.884%2024.6685%2037.884C22.7997%2037.884%2021.2847%2036.369%2021.2847%2034.5002C21.2847%2032.6315%2022.7997%2031.1165%2024.6684%2031.1165C26.5372%2031.1165%2028.0522%2032.6315%2028.0522%2034.5002Z%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cpath%20d%3D%22M32.5531%2034.5C32.5531%2038.854%2029.0235%2042.3837%2024.6694%2042.3837C20.3154%2042.3837%2016.7857%2038.854%2016.7857%2034.5C16.7857%2030.1459%2020.3154%2026.6163%2024.6694%2026.6163C29.0235%2026.6163%2032.5531%2030.1459%2032.5531%2034.5Z%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cpath%20d%3D%22M34.8021%2034.5C34.8021%2040.0967%2030.2651%2044.6337%2024.6684%2044.6337C19.0717%2044.6337%2014.5347%2040.0967%2014.5347%2034.5C14.5347%2028.9033%2019.0717%2024.3663%2024.6684%2024.3663C30.2651%2024.3663%2034.8021%2028.9033%2034.8021%2034.5Z%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cpath%20d%3D%22M25.8032%2034.4998C25.8032%2035.1259%2025.2956%2035.6335%2024.6694%2035.6335C24.0433%2035.6335%2023.5357%2035.1259%2023.5357%2034.4998C23.5357%2033.8736%2024.0433%2033.366%2024.6694%2033.366C25.2956%2033.366%2025.8032%2033.8736%2025.8032%2034.4998Z%22%20fill%3D%22%23162BEB%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cellipse%20cx%3D%2224.6694%22%20cy%3D%2234.4998%22%20rx%3D%221.5%22%20ry%3D%221.5%22%20fill%3D%22%23FF3D23%22%2F%3E%3Cpath%20d%3D%22M13.2011%2034.5971C13.1738%2034.562%2013.1487%2034.5296%2013.126%2034.5C13.1487%2034.4704%2013.1738%2034.438%2013.2011%2034.4029C13.3576%2034.2021%2013.5895%2033.9139%2013.8887%2033.5675C14.4874%2032.8742%2015.3535%2031.9502%2016.4225%2031.0272C18.5719%2029.1714%2021.4874%2027.3663%2024.6684%2027.3663C27.8495%2027.3663%2030.765%2029.1714%2032.9143%2031.0272C33.9833%2031.9502%2034.8494%2032.8742%2035.4482%2033.5675C35.7474%2033.9139%2035.9792%2034.2021%2036.1357%2034.4029C36.1631%2034.438%2036.1881%2034.4704%2036.2108%2034.5C36.1881%2034.5296%2036.1631%2034.562%2036.1357%2034.5971C35.9792%2034.7979%2035.7474%2035.086%2035.4482%2035.4325C34.8494%2036.1258%2033.9833%2037.0497%2032.9143%2037.9727C30.765%2039.8286%2027.8495%2041.6337%2024.6684%2041.6337C21.4874%2041.6337%2018.5719%2039.8286%2016.4225%2037.9728C15.3535%2037.0497%2014.4874%2036.1258%2013.8887%2035.4325C13.5895%2035.0861%2013.3576%2034.7979%2013.2011%2034.5971Z%22%20stroke%3D%22%23D5FF5C%22%20stroke-width%3D%220.732536%22%2F%3E%3C%2Fsvg%3E";

var walletConnectIcon = "data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2216%22%20viewBox%3D%220%200%2024%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%20%20%3Crect%20width%3D%2224%22%20height%3D%2215.0867%22%20fill%3D%22url%28%23pattern0%29%22%2F%3E%20%20%3Cdefs%3E%20%20%20%20%3Cpattern%20id%3D%22pattern0%22%20patternContentUnits%3D%22objectBoundingBox%22%20width%3D%221%22%20height%3D%221%22%3E%20%20%20%20%20%20%3Cuse%20xlink%3Ahref%3D%22%23image0%22%20transform%3D%22translate%28-0.00968744%29%20scale%280.00339792%200.00540541%29%22%2F%3E%20%20%20%20%3C%2Fpattern%3E%20%20%20%20%3Cimage%20id%3D%22image0%22%20width%3D%22300%22%20height%3D%22185%22%20xlink%3Ahref%3D%22data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAASwAAAC5CAYAAACSoQIxAAAgAElEQVR4Ae19fZgdVZnn761TnQ%2FCtwmugxhkGPXZDIjDoENIuu9twsAm4CS7EpFhWHYktN23AwzC6Dg6xI%2FVWcGsk%2FTtNgQ0MogQ9lkQDAtLTN%2FuhDjIk5koG10eWRwQdAjRYBLIR9epd5%2B3um%2FS6dx7%2B35U3Vt16tx%2Fqu6pc96P33vqd8%2BtOu85BPuxCFRAYF4%2Fn%2BJ4ONNV3izt0AzycRwRzQBjBgPHEfszfMIMIjqOGDNAmAHguDGRb4HxJhPeZOa3yMFe%2BM5%2BR74DbzHzmyC8ST7vZXJ%2Fs9fFL7Z10e8qmGMvpRwBSrn%2F1n0AF97Np07d753rK2eOw%2F4fENG7ffCZYDrTIZzYTJAY%2BB3AvwDoX5nk6PxcaWfHb2fgJ9v%2FC73RTFusrvghYAkrfjGJ1KL21XyO4%2BgPMvhch%2BhcAHMAzIpUaUjCmfEagP8D4ucA2u6z%2BtFwjn4WkngrJgEIWMJKQJDqNfE%2FfJNnvXVQz3OYLwToAmZ8iAjT65UXy3aMfSD8E3x%2BlhVtPdimtv7wevptLG21RjWMgCWshiGMj4DzvsUnn3RAZx2NLDvcSSAZPaXq4zN8Av8YwCZi2rST1PCOHO1LFQgGO2sJK%2BHB7cjzBWDvcihc7jD9UcLdicR8Zv4hkfOY1s73h5fTc5EosUKbgoAlrKbAHJ6Ss1fx1He26UvIx4dBuBzAO8KTbr4kZvwrgx91GI%2FyLneosII88702x0NLWAmJZTCSIn29A3wMwAkJMTvWZjLjN8z8bZrmDhSupxdibaw1LkDAElaMO8JF9%2FAJ6qB%2FrQP%2FegKdF2NTE28ag7cw0V2vjqj1L9xIBxPvkKEOWMKKYWDb8zzXgV5GhKsATIuhicaa5DP2EHAvjai%2BwZvpeWMdTahjlrBiEjgZTU095P9nH%2F4NxHROTMxKtRkMfpqJ1thRV3y6gSWsFsciczefjUP6UwRcY0dTLQ5GGfWjoy6%2BS7vuys1d9Osy1WxxExCwhNUEkEupGCOqLzJjqUNwStWxZTFDgHGQgbXaVV%2B2xNWa2FjCajLulqiaDHgU6ixxRYFqVTItYVUFU%2BOV2vN8hkP6y2N%2F%2FRoXaCXEAgFm%2FgeP3M9v6aHdsTDIcCMsYUUcYHmY7h7yPuv4dBMIUyNWZ8W3AgHGbhB9aY9yVm%2FropFWmJAWnZawIop0ZgW7fJrf7YD%2FDsDMiNRYsXFCgPGiT%2Fj0UI%2F7UJzMMskWS1gRRDPbN3Kx76DfAb0nAvFWZMwRkEmo2nG7Nn%2BCfhpzUxNnniWsEEMmy7nsP6BXEYIJnyFKtqIShwDDA%2FF%2F36PcFdu66K3E2R9Tgy1hhREYZur8hp%2Fzmb9EwElhiLQyjEHgZQDLB3vcR43xqIWOWMJqEPxsH89h8tYR0R83KMo2NxuBR5lVVyFH%2F2a2m9F6ZwmrXnxXsJM9zf%2B0D77dAabUK8a2Sw8CPvBbYvQUcu6D6fE6XE8tYdWB5%2BjkT%2B8BAp1fR3PbJO0IMP7nm6xu%2BFEv%2FSbtUNTqv00JqQUxZmrP65twUP%2FEklUtwNm6RyFA%2BI%2FTSf80kx%2B57Khy%2B2VSBOwIa1KIRitk1vBMaL2egGyVTWw1i8CkCDCj7%2FVZ6pM7ltKhSSvbCrCEVUUnyPTzn4D1I0R4exXVbRWLQE0IMPO%2F%2BFPc%2FzS8jH5RU8MUVrZ%2FCSsFnZkyffqzBL3FklUloOy1RhAgog%2BoEf3jbL%2F34UbkpKGtHWGVifIH%2B%2Fhtx5F%2BkAgXl6liiy0CoSPgM68ayrXdFLpgQwRawioRyMwafh95%2Bn%2BDcEaJy7bIIhApAj54q4Z7uV0B4liY7V%2FCCZhk%2B7yF5OlnLVlNAMZ%2BbRoCDmiuy%2Fqf5YezaUoTosgS1rhAZfv1Z9jB90E4flyxPbUINB0BIpwpP5zyA9p05TFWaP8SjgUn2%2B99B8DVMY6VNS2lCDDRrYVu9bWUun%2BU26knrGAnZaUfI8IlRyFjv1gEYoQAg79e6Gn7qxiZ1BJTUk1YQlZnuPoJAJmWoG%2BVWgRqQMBnfHOoR10PIq6hmVFVU0tYF67k6dOm6cctWRnVn9PgzEO8U11dWEFeGpyd6GMqH7rPyfPxU6Z5Gy1ZTewO9nsCELgSp%2BlH5d9BAmwN3cTUjbDOvZdnnLrXe4qILgwdTSvQItAkBJh58%2BtwF%2B7I0b4mqYyFmlQR1odW8YnTlfcDu9heCH2PsY%2BB34H4DTkS6HeQ74w34PDosik%2BvQ2EkwGcxOCT4ONkIjopWJXVTh1pOAjM%2FE%2F7tXvpMzfSnoaFJURAaghLUm2mO94mB3RuQmLTOjODjUL5ZSJ6yWe87BC9xOCXoPklV7kvezvxcqPPUGRXIecdmA3fm%2B379C44NJuYZ%2Fs%2BZpOD2QycYRdGnLwLMHj7fs%2FtSAtppYKw%2FnSATzvke1uI6A8m7wKprLELjGENGoZ2hod%2Fix9jBfktRWI9q8xr%2BABcv4OY28GYD8IpLbUppsqFtDy4nWlI5TGesC65h3%2FPO6i3AHh3TPtbK8z6FQPDTDTskzOUiO2omGn%2BAM5xMEpgDLQ7hNNaAV4cdTJ4B5SbKXTRrjjaF5ZNRhPWgjX8Lq31ZgDvCguwBMt5GeAHR%2BA%2BuKWHtiXYj1HTmakjjz8BeVc5oKUg%2FLvE%2B9SgA8z8PFx3nsmkZSxhtef5DEX6GQDvaLAfJLn56wz%2Bjtbu%2F9i8nJ5OsiOT2d45MNKpmT7qMK5M819H%2BXtY6Gn7wGR4JfW6sYSVyY88m9K3gW%2BCcT85%2FMCm7rZNSe2YjdgdJAw7wWa2f9GInMS29fkrg71tn0ms%2FRUMN5KwMnnvOiJ8q4LfJl76NTOt3K%2Bdu9LyxmiyIMqb4RmOn%2FPBNznAqZPVN%2Bj6G4M9rpEvKIwkrGy%2F9z0AqVhulsE%2FZqb%2FNpRzv2vQDRe6K5m893Em%2FmsH9J7QhcdRoK%2F%2BcLCXdsTRtEZschtpHNe2zHwWkZFcPB7yR4n4HwZT%2BrdvPBDVnBdy7j0A7sn2eX%2FGxJ8kovnVtEtqHQLellTbK9ltJGGBYGxiKDMe86E%2BNZyjn1UKrL1WGoHBXldG39%2Bbv4o%2FqFxvJYEuKl0z4aUK%2Fy%2FhHpQ030zCAv1fAOeV9DihhcEra0JvIdcmSdv20yACm2%2BkHwGYlxnwroKPO4lweoMiY9NcUnYGe%2BjV2BgUoiFGrtbgAPeGiFFLRTHjNz5RTyHX9r5CjyWrsINR6HYfwHHqbPbpc8zYH7b8Vshjh77aCr3N0Gnsg56O%2FpGnZTH%2FZoAYlQ5ZZXKvclds6woSi6NSY%2BWOITB%2FDb%2FD9fTfg3BtYkFhfGcw516TWPsnMdxYwjp%2FDR93gqcfTei%2BggXtqBuGP0E%2FnyR%2B9nIECMzr5%2FNdePcQ6P0RiI9OJGP9YM79aHQKWi%2FZyL%2BEAuu2LnrrFa0WMeOp1sNcnQU%2Bw2fmzw%2FuVBdbsqoOsyhqSerSK577IWZ8Iwr5Uchk4IHBWcr4TVSMHWEVO8X5a7jtBE9viPsmE8x4zYX6yMYcSaK2%2FcQEgUy%2Ft5gY%2Fxjnrd%2BErArd6uo0rPVuPGFJvw9IS%2BuHCVgUk%2FvgKDMYGIRSS01OWj3K4YR9yQzwmWDvkVj%2BRWTcO9ijrksDWUm3SQVhiaOyYBxm6fVEWBKb%2B4XhMdFnC93OV9PS4WKDfY2GjI7UvTuI6KYam0ZXnbF2sEd1panvpIawir0m0%2B89QEDLH0wy4RVPq49s6SVZUcJ%2BEoJAZsC7HIz7gmWeW2gzM%2FoKOXd5C01oiWpjH7qXQ7MwU%2F25%2FOcvd70Z5T74J8pVf2zJqhloh6uj0O1%2B33PVBwG8HK7k6qWllawEodSNsIJuwUyZAX0%2FIViCpPqeEkJNeV61V6nL5S1mCOKsiBYhkFnDM6G9Jwh0fjNNSDNZCc7pJCzxnJmy%2FXpdUycJygPSWeovsZR0Mzu51RUNAplv8TTs1w8RcHk0Go6Wysx3FnJttx1dmq5v6SUsifMoaa0BYVn0YafbB3vUF6LXYzU0FQFZqvkb3t87TH8dpV6Zn1fIta2IUkcSZKebsMYilM17d0VFWgyMyCguyFlLQo%2BwNtaFQHveu1YRvglA1SWgQiNmuq2QU3dWqJKaS5awxkKdyY98PYJX1geIeFFalypOzV005mhnfuRPmUiWr5kWnu%2F0ycEetTI8ecmWZAlrXPwyeW81EXrHFdV%2FytinoS4dztHW%2BoXYlklDoD3Pcx3ojUSY3qjtRLR8U7fqa1SOSe0tYU2IZiY%2FIpMDb51QXNtXxj4fqnMoR8%2FW1tDWNgGBMEjLZ9wwlHPXmoBHmD6kbh7WZODJWxh5wDlZvXLXfcYeS1bl0ElHuYyqfagFYOyr1WMG2JJVedTsCKsMNpm8vpWI7yhzuXQxYzdDdRZytL10BVuaJgQ68nyBA72p2sTpMbK6bjjnGrMAZdjxtoRVAdEaSWsXfJUxcaeSChDZS5MgIKQF6I0O4cRKVYWsQLjavk2uhFKaJ45WxuXw1c4B3cvMqw8XlD7ZhUNq3uDN9Hzpy7Y0zQhk8nweQw9VIC3NhGssWU3eS%2BwIa3KM0JH3ljmEu0pVlXWsaER1WLIqhY4tKyJQgbS0T7hyqNt9uFjXHssjYB%2B6l8fm8BV5W0Og7sMFR05%2B5Ss135LVEUDsWWkE5LkmQXXIKh3jarzpM5ZYshqHyCSndoQ1CUDjL49NDPwbBhOBdrpT1c1PfZx%2BNb6OPbcIVELgvG%2FxySfv84It6BzX%2FfmmbjO346qEgb1mEbAIWAQsAhYBi4BFwCJgEbAIWAQsAhaBOhCI5BnWJffw740c8JaDcGFgE9Mb5PDAYHfbk3XYaJskBIHsKn4%2FlL6FiWeLycT0kvbVncPL6bmEuGDNrAOB7MDIpexTN4hPDuLuY6vX5q7e3EW%2FrkNcxSahE1YmP3InEX2ylFYGb%2FMd92N2z71S6CS37Pw1fNIJWq8jYHEZLx7ao9Qyu4N1GXQSWjz%2FG%2FzvHd%2F7rgM6t6QLPn9lsLftMyWv1VkYGmFVu5WW5NoBaoFNDK4zYjFrdvFafrs%2B5A0R0XsrmcbMz6spbscPltFrlerZa8lAoIYZ%2FBv2KrVkWxeNhOFZKPOwzl7FU4PNSqvY909m%2B0p%2B1ajDYbhgZbQKgc4BPt0%2FpLdORlZin9SRukJwrbLX6g0HgbHVKDZVmLl%2FWJHsBSrcIBxxuLCBk4ZHWGLIGa5%2BQrb%2Bq8kOu15UTXDFrXJAVqyfJiB4XlW1fYwXyVHtdv5R1YjFqmIDS%2BcUfumpy164kQ424lBDhHXhSp4%2BbZp%2BvGayGrOYGfvh88LC8rZCI07Yts1FoPNunu0f0kM1k1Ux7sBLzhTVsel6eqm5llttjSCQWT2SgUOPN7A4YeHAAbXwh7fQ%2FnrtqPsv4Zw8Hz9lmrexXrISg8VxcuiJAIh6PbDtmopAQFYH6xhZjbNSiM4%2FqJ8WWeOK7WmMEejoG7lE7tUGyEq8ywhnCHfU62pdI6wPreITp7veRgJdUK%2Fio9oxDvrMVwz1tj11VLn9EisEFvTzWR7rYSKcHoZhzHjVJdW%2BsYdeDEOelRENAmNktYGAtjA0MPjZ%2FZ674JkbaU%2Bt8momrHn9fIoLbxOBgnyoWhWWqy%2B7yxCwZLDH3VCuji1vHQLZr%2FN7uU0PESHUh%2Bay2oVLaq4lrdbFtpLmbL%2B3iIGHwyKroi4Gb9%2FvuR21klZNhDVGVpsJNKeoONQjwwNhsSWtUFFtWJiQFaboLQBmNiyshAC7RE8JUGJQJGQFxiMguFGYI6Tlwe3c0kO7q5Vf9TMs2ZrbhRcdWYnFAgzjkY4Bb0m1Dth60SKQ7eM5UZJVEHYZtU3RWwJd0bpjpVeJQHAPRkhWQdxB5wmnCLdUaRaqIqxg7oznbYlsZDXeWoLrMB6ypDUelNacy6JzIL05qpHVBK9mii5LWhNQacHXzIB3ldyDUY2sxrsUcIrnbal2ft6kfwllvg37ehiEs8YrasK5XTa2CSCXU1FhhcxyTcIptxt5hINjnVKErMC4n5q9fDrjRWeKmjtZJkTFEVZxcmALyErgVgKcbAFeJ%2Fa2WZ0ISBbCJGuQ1ym5imaEU0S3zYSoAquQqwT3WivISvwgnCWZEMI5ldwqS1jBfJt6ZjJX0lbjNWF5h7DOklaNwDVQXYhCUqeqSbtoQE3FpjZ9qyI8kVwc27dAEtgn%2FdcViQEiVEiLK8%2FPK0lYMt9GJvbVO5M5TIeKpCWAhinXyjoWgWKOWLX76B0rIcQSwvFCnGJTiFKtqBIIFDdZaSlZjdlVnFQsHFTC1GMfussrbI8loTWcyYGllNZaNkZad8mWW7W2tfWrQ0CyDRzojbEgq6LJo6S10ZJWEZDwj3JPldsRKnxt1UkU7hEOCqbTTGhy1PAv6vk2E3TX9ZWIlm%2FqVn11NbaNSiIgZCVpFyCEklFfUkkDhTbntAHwKjStcs%2FNChIiv3TMfp%2BH%2FxI2Y75NGO7JpqayI3MYsqwMoJgjFleykhgVc07FVhuzcBCQe6iKDYLDUVa%2FlJkT5%2BcFI6yArJxgJnOwxGn98pvZkv52sEd9uZkaTdOV7fMWwkGiUqEIWLipx%2F1fpsWimf5k%2BvRnyeEvNlNng7re8Bx10eZP0E%2Bd89fwcXD0YwASRFbiPv%2FXzMDIlxoEIrXNs33enyWNrIKoA49n%2B70PpzZwDTqe7Rv5csLISjw%2BWfn6UTlxTvD8vwLw7gZxaElzYvrbTH7kKy1RnmClmbz3ETh4JMEufC%2FT75VbPz7BbkVrekffyNfg0N9EqyUa6QT8frZf3%2BIAfqIDT0Sflo0vooHJPKmZvPdRIjyUdM8IeDjb5y1Nuh%2FNsr9jYGSl49AtzdIXjR6%2BwiGis6MR3jypsktPJu%2Btbp7GZGqStAsifCeZ1pew2sH9QSpJiUu26AgC2bx3l8Mk%2F6SS%2FWG8T94Sesn2YtR6IvRKYMB81FQNE3wLw4di2kWQ8hSGwHjICNK3LGmVCQYzBfcEwYhJ1z7gOMz8szLuJq%2BYsCwzoO9KnuHRWpzJex9XhG%2FHYSZz2J6KT8T4bvuA95dhy066vGy%2FXgtDyEpiQcBzDoiMusEJuL4j792T9M4Wlv3ZvO4hwt1hyYurHMW4J9uvb4irfc22K9vv3QvCx5utN0p9BPSPzsPq92Qt9QVRKmu2bAbuK%2FS4f9FsvXHS19GvlzvgVXGyKWpbNKh3uEflo9YTZ%2FnZvHcfCH8eZxtrtY2B7xd63CuCme67p6srmflfahUS5%2FoEXJPp974bZxujtG30FXC6yErwVOC%2Bzn59c5TYxll2Nu89aBpZ%2BcT%2FvN9TAQEffkAd%2Bk44MYkqMx7G62ppYQUZ8XKhGlgl7YKI76imrql1mOm2Qk6lZrpLZgW7mKXXE8Go5cUn7rBzmLCk48p%2BYbMo2BEnnO27YnI3MLABO9XiNJBWdkB%2FDsxfiAn0LTUjLaR1%2FhpuO0Fr2dlmUUsBD1m5D966i91Ld%2BRoX1H04eRnKZALr7PbKRWLFUw4BoE8TT8igTXBn3I%2BZPIjd1iyOoKOjDIzA%2Fr2IyXmnQVk5WnZM9A4sjp0wF0wnqwkekcRlhRIBakIwKjt4yWgJ3h6w9mrOJZLqDR6KwlZEZFdxWICkMS8IiDyCeUmfJW%2BLH2aCKatYlEQDiq1pf1RfwnHB1HAeKfSj5kIxi89ddkLN9LB8f4m%2BVxm%2BcvE2ST7ELXtzHxnIdd2W9R6miX%2FwpU8fdo0%2Fbhs%2F94snc3Qw4ynXtHqinL3Z1nCEuMODzcNZPADB9TCUgzejKCEqcOSVfVoMqOvkHOXV98injWFrKZM8zY6IKOWjxay2uuqRdu6aKQc8hUJSxqZ%2FECv3LCzHFixKpe0i369xqSZzE3Bl7F2MOcmdoKpvBibSd6TxpEVsGGvUksqkZX0j2OeYU3sNIGAnWpxMD1g4sUEf5eAy6%2BUdIDEuTFKVussWdUROcKypOacFt%2FiG0dWMvVop1o8GVlJtCcdYR3uEutZZXbp%2Bwi46nCZAScT53nE3qUjZGX3a2wkWIx7B3vUdUEmYiNymtTW2HmSwAOFmeoaLCVdDZTVE5ZIY6bMgJZdYU0jre37PbfjmRtpTzWgtayOoT8arcKT5WbpVlfHnbTm9fMpLoL5kee1Cqso9NaDf22EJVYb%2BgvP4O0e3M4tPbQ7iuA0LFPI6nX9kGkzmRvGpUEBwU1Twy98g%2Bpqbj5GVpsJNKfmxnFuUOcIt3bCEhAMfeDL4B1QbqbQRbviFGtT0y7igrE8ny3MUldW%2B7ekWXZn1vBMaK9gIFmtHexRXfWMbOsjrLGImbQ4WLETMvPzcN15cSGtgKxO04%2BYNpO5iHdcjnHLOb14Lb9dH%2FKGiOi9ccEoDDsanVrSEGGJAybOAxLSUlPcjh8so9fCCFK9MkydUlIvHlG3k5zTal6tR22HkJV%2FSG8FoeR27VHrj0p%2Bo2Qldk06rWEy42Uinswinqxekq7Lr5p0GOk4rbL7cNqFYTlircKzGr3F9C35oaimfhR1Ogf4dDPJSjINGp%2B02zBhSdAk5cH3DVshgHCWdBzpQFF0zEoyhazOcPUTBqZFVXI7FtcE81blnHbezbN91k%2BbN7Liz4eVFtXwX8LxvczEdZgYeMmZojo2XU8vjfc1qnNTc8SiwitCuYVm5pwGZHVQP02Epv9ARoihvJ8LdV2yUAlLHDeStBivOlPVRVGTlqlpF1HeEBHLLjQj53RBP5%2FlsR42jayIaPmmbtUXZoxCJywxrnNA9zKzUfsEMuNVl1T7xh56McwAFGUV0y4IZNTiiUX%2FknostYhcmL6MkdVWIrTseWmY%2FhRlRUFWIjsSwhLBHXlvGRHWmLS1FDNec0nNDZu0TE27KHbepB8lfUsWtpy4mFyjfmW%2Fzu%2FlNj1kElmxzNJkdA3l3LWN4lOqfWSEJcpk806HsM400qIR1TF4Mz1fCtBay0xNu6gVh7jXDzvnNNvHc%2BBoWSRzZtx9r9Y%2BISufcd1wzr232ja11gvlLWE5pYHhDKM2uAx%2BDafozZkB%2FsNyfldbfuHdfKpL3hCBjMoR88E%2FYeLnqsUhCfXkr%2Fp05RXkB6ZRe9tX8zm%2Bo4dNIivBJGqyEh2REpYoKOTcdRpm7ZEGYBazHsqu4vfX23kl7WLKIW%2BQmM6pV0Yc2zFj3VBP2%2FsL3W3nAvh2HG2s1yYi%2BoAkITdCWvP7%2BI%2BUo4cc4NR67YhjOyZ8LMqRVdHnSP8SFpXIsWPAW%2BL4WA%2BCO7480eeM3QzVWcjR9lr8CHLEPG%2BLaWkXmJjQam6ifF05px15vgDQGx3CibX0l1jXZXi%2Bg6VD3e7DzbAz8hFW0YnAIcJiMMzZH5BwCkMPjXbEoqeVj8HseTPJShJaj15fioiDMkYkD2ArIx3d1SAZ2fO2BD88VaqRPuJAbzKNrEBY3CyyEqibRliibLDH3SAOMlB2zeYq4x%2BbatIBpSNWQ1rFtAvTRlaSIxYsO0zExwRGSCvn3iB1jrmW4IIghp63pZr0rfY8z5U%2BAkLyVrctE6PgHiYsDu7pMnWiKG4qYYkD4iD7vAgMY3atkY4oHVI6ZrkgBWRlZtpFVTliJuecVkrfGiOrjSaRldy7cg83m6zk3mo6YYnSod62p9jnywwkrY2lSKuYI0bA7HKElsTyWrfOknwy0xLlJe9P8v9KkVZm9UjGgd5IhOlJjG8pm5mxX%2B5duYdLXY%2B6rCWEJU4VlrcVxHEBIGonmyVfOqZ0UOmoRZ0yk9mXHDHDyApEf1dPQutoGzJqN2aJbUBad%2FPhH6SOvpFLyCFJYDeKrHyoBXLvFvt3s49Ne0tYzrH5q%2Fki19FPGDVkBg744JUM51cO8%2BdMmskscQwjoTXbr28D%2BKvl%2BkUiyxn%2F5jv0BdL%2BbHLoU4n0oZzRjH0a6tLhHG0tV6UZ5S0nLHHSyNe9zYheC3SEmSNmYs5pC0ISuUqfsQdQC4Zy9GzkyiZREAvCEhszeT5PpggY9dp3EvCTdDmqHDHJOXUIdyUJi1TZWudcw6gwig1hiYNCWjT6%2Brfh9IeoAEuj3KhzxExMlDeinzB2g9X8wV7aERd%2FYkVYAoqJSaFxCXY9dkRNVkWbTEyUL%2FqW0OMu%2BCoTJ7ISHGNHWGKUictuJLTTaiZcU%2Bh2H2iG%2FZkB7ypi3AdANUOf1VEaAVlGKcwVSUprqa80loQlrpi6sFl9YWpBqybniBU9DHJOGQ9Z0ioi0txjVGu%2BheVFy%2BZhTeaALJIni%2BXJSp%2BT1bXXQ0ZA8j2bnCNW9EDy0nzClUblnBadi%2FlxbFXd0BeoDNPt2I6wik4Gs8QP6SHjJl4WHYzZUXLECFjSirSL8VBk%2B71FDDxMQMu23Bpvj%2Bnnzd5spV48YzvCKjokGz84pC4CI5K11It67FFmhLYuR2wi%2FkbmnE50Mi7fGS%2FKPRb1JithuBv7EVbRSVN3wy361%2BpjkCLl88JWpl2UwkDSnCTFBYSppa7bsgYRELKaoua2epfzar2I%2FQir6IgAKsDKNvLFMnsMCQHGvlbniJXzxMSc03K%2BNrtc7qUkkZXgk5gRVjGYwaJp2isEi6gVC%2B2xfgRGyaozDmkXlZyQVTAU9JOG5ZxWcjnSawyua9XUSI2qQnjiCEt8GttpZrMlrSoiXKFKnHLEKph5%2BJLNOT0MRUMnDN7uwe3c0kO7GxLUgsaJJCzByW6P1WBviVmOWLXe2PStapEqXU%2FIar%2FndjxzI%2B0pXSPepYl5hjURRvl1EOBlv7iJ1%2Bz3SRHYJTlitW6eManUJlQIbGY1H5LnZj81ITC2t2JiyUqcTewIqxgp2eJ9JnlPOqCyyxMX69pjgMAuHFLzwtoItlWY2pzT2pD3wVt3sXtp2LtX12ZF47UTO8Iqui4BOHTAXSABKZbZY2kEJO3CBLIS74Kk3ENqXuBTaXdt6REECnKPJJ2sxJ3Ej7CKMblwJU%2BfNk0%2FLqvUFMvs8QgCY2kX7ZLydKQ0%2BWdjOafDRDg9%2Bd5E4kHhl5667IUbyYhNX4whLAn12at46qA5Wb8AAAVoSURBVDuVfowIl0QS%2BoQKTUraRb3wBulbsm6%2BJa2jIGTGU69odYUpZCXOJf4v4fgISWD2ukpy0DaML0%2F1eYLSLuqNU5C%2BNVVdJMRcrwzT2sk9IPeCSWQlMTKKsMShbV00gp1KNmu1pDWWdrGpm4xf8cLmnB6h3KDv71SLg3vhSLERZ8YRlkSlsIK8gLQYDxsRpTqcSGLaRR1uHtVEiDnt6VssfX6nWhzcA0ehY8YXo55hHROS9awyu%2FR9BFx1zDWDC5KadhFWSIL0Lc%2FbEmwnH5bQBMhh4IHCTHUNlpJOgLl1mWg2YQkkzJTt1%2BtAuLYuhBLWKMlpF2FCnbqcU8a9gz3qOhBxmDjGTZb5hCWIp4S0kp52EfbNkZr0rZSQlfQPI59hHdPxiTj49WGsPeaaIQUmpF2EHYpUpG8x1qZhZFXsG%2BkYYRW9DfY%2B9FYToXdcUeJPTUm7iCoQpqZvMaOvkHOXR4VbHOWmY4Q1DnkJsAR6XFHST41Ju4gqECambzHznWkjK%2BkfqRthFW%2BKTH7kDiK6tfg9iUcTZzJHGQdT0rdGyarttiixiqvs1BKWBCQzoG8n5hVxDU4lu4SsZCaziZMDK%2Fnd6LXkp2%2FR7YM96guN4pDU9qkmLAlaJq9vJeI7khTAIO1CqSWWrOqL2vlruO0ErWULsUX1SWhNK2a6rZBTd7ZGezy0pu4Z1kTYpQMQUWIeXBZnMluymhjJ6r8H2CUsfUv6aNrJSiKc%2BhFWsZt3DuheZl5d%2FB7HYxpmMjcT98wKdjFLryfCkmbqrVWXz7hhKOcaOyWnFjwsYY1DqyPvLSPCGoohkQdk1a2uNn0m87hwNOc0xulbLFOeGV2WrI50BUtYR7AIztrz3rUOYV2sSCtFM5knhKM5X2OYCSFk5TOuG8659zYHhGRosYRVIk6ZAe8qMO6PBWmNzmTusiOrEoEKsyhGpCVkBcLVhW73gTBdNEFW6h%2B6lwpi0FEIVwNoada7THAdzLk3WLIqFaWQy%2BKTvqUtWZWPrR1hlccGHQPeEsfHehDcCtUiuZTmyYGRAFqD0Ey%2BRelbDM93sHSo203tOm6ThcmOsCogFHQcgqxeOlKhWuiXLFmFDmlNAkfTt7ip852CPkZYbMmqcqgsYVXGB4M97gb2WdaJbxJp0e2FXDrTLiYJRVMvBzFg%2FmIzlErfkj4mfa0Z%2BpKsw%2F4lrDJ6HX0jlzhEj4EwtcomNVezM5lrhizyBpFnQjAO%2BsxXDPW2PRW5MwYosIRVQxAzq0cycOhxIkyvoVlVVWUm86ZuZdIqElX5nYRKUZEWM%2FbD54WF5W2FJOAQBxstYdUYhfY8z3WgN4ZJWnYmc41BaEH10DMhGPs01KXDObI7ltcQT0tYNYBVrCqkpaCfBOH4Ylk9RzuTuR7UWtcmtEwIxj4fqnMoR8%2B2zptkaraEVWfcOvJ8AaA3OoQT6xFhZzLXg1rr2zSaCeEz9gBqgSWr%2BmJpCas%2B3IJWmTyfR9CbQDilRjGaCdfYmcw1ohaT6nWTFmM3Q3UWcrQ9Jq4kzgxLWA2GLNvHc0B6c9WkZScHNoh4PJpL%2BhYx7gOgqrRoF3yVGeylHVXWt9VKIGAJqwQotRYFpOVoedMzs2JbhgfCYjvfpiJKiblYQybELhxS8wZvpucT41xMDbUTR0MIjPxqakfN9X3%2BaVlxjN0%2B80JLVmURStwFmZVO4EWjz6VKmy%2B7cEvfsGRVGp9aS%2B0Iq1bEJqnfPqC7iP1bHNB7pCozXiOiVXuUk9%2FWRb%2BbpLm9nEAEZMPWNvJ7wSwr184K4g7%2BGZi%2BVsi59yTQJWty2hBoX8vvnt%2FP56bN77T7KzHvvJtnpx2HqPz%2F%2F6omxnsqyGCHAAAAAElFTkSuQmCC%22%2F%3E%20%20%3C%2Fdefs%3E%3C%2Fsvg%3E";

var xDefiIcon = "data:image/png;base64,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";

var ConnectorEvent;

(function (ConnectorEvent) {
    ConnectorEvent["Update"] = "Web3ReactUpdate";
    ConnectorEvent["Error"] = "Web3ReactError";
    ConnectorEvent["Deactivate"] = "Web3ReactDeactivate";
})(ConnectorEvent || (ConnectorEvent = {}));

function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}

var AbstractConnector =
    /*#__PURE__*/
    function (_EventEmitter) {
        _inheritsLoose$1(AbstractConnector, _EventEmitter);

        function AbstractConnector(_temp) {
            var _this;

            var _ref = _temp === void 0 ? {} : _temp,
                supportedChainIds = _ref.supportedChainIds;

            _this = _EventEmitter.call(this) || this;
            _this.supportedChainIds = supportedChainIds;
            return _this;
        }

        var _proto = AbstractConnector.prototype;

        _proto.emitUpdate = function emitUpdate(update) {
            if (process.env.NODE_ENV !== "production") {
                console.log("Emitting '" + ConnectorEvent.Update + "' with payload", update);
            }

            this.emit(ConnectorEvent.Update, update);
        };

        _proto.emitError = function emitError(error) {
            if (process.env.NODE_ENV !== "production") {
                console.log("Emitting '" + ConnectorEvent.Error + "' with payload", error);
            }

            this.emit(ConnectorEvent.Error, error);
        };

        _proto.emitDeactivate = function emitDeactivate() {
            if (process.env.NODE_ENV !== "production") {
                console.log("Emitting '" + ConnectorEvent.Deactivate + "'");
            }

            this.emit(ConnectorEvent.Deactivate);
        };

        return AbstractConnector;
    }(EventEmitter);

var isProduction$1 = process.env.NODE_ENV === 'production';
function warning(condition, message) {
    if (!isProduction$1) {
        if (condition) {
            return;
        }

        var text = "Warning: " + message;

        if (typeof console !== 'undefined') {
            console.warn(text);
        }

        try {
            throw Error(text);
        } catch (x) { }
    }
}

function parseSendReturn(sendReturn) {
    return sendReturn.hasOwnProperty('result') ? sendReturn.result : sendReturn;
}
class NoEthereumProviderError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
        this.message = 'No Ethereum provider was found on window.xfi.ethereum.';
    }
}
class UserRejectedRequestError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
        this.message = 'The user rejected the request.';
    }
}
class DefiConnector extends AbstractConnector {
    constructor(kwargs) {
        super(kwargs);
        this.handleNetworkChanged = this.handleNetworkChanged.bind(this);
        this.handleChainChanged = this.handleChainChanged.bind(this);
        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
        this.handleClose = this.handleClose.bind(this);
    }
    handleChainChanged(chainId) {
        var _a;
        console.log("Handling 'chainChanged' event with payload", chainId);
        this.emitUpdate({ chainId, provider: (_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum });
    }
    handleAccountsChanged(accounts) {
        console.log("Handling 'accountsChanged' event with payload", accounts);
        if (accounts.length === 0) {
            this.emitDeactivate();
        }
        else {
            this.emitUpdate({ account: accounts[0] });
        }
    }
    handleClose(code, reason) {
        console.log("Handling 'close' event with payload", code, reason);
        this.emitDeactivate();
    }
    handleNetworkChanged(networkId) {
        var _a;
        console.log("Handling 'networkChanged' event with payload", networkId);
        this.emitUpdate({ chainId: networkId, provider: (_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum });
    }
    activate() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            if ((_b = window === null || window === void 0 ? void 0 : window.xfi) === null || _b === void 0 ? void 0 : _b.ethereum.on) {
                window.xfi.ethereum.on('chainChanged', this.handleChainChanged);
                window.xfi.ethereum.on('accountsChanged', this.handleAccountsChanged);
                window.xfi.ethereum.on('close', this.handleClose);
                window.xfi.ethereum.on('networkChanged', this.handleNetworkChanged);
            }
            if ((_c = window === null || window === void 0 ? void 0 : window.xfi) === null || _c === void 0 ? void 0 : _c.ethereum.isXDEFI) {
                window.xfi.ethereum.autoRefreshOnNetworkChange = false;
            }
            // try to activate + get account via eth_requestAccounts
            let account;
            try {
                account = yield window.xfi.ethereum.send('eth_requestAccounts').then((sendReturn) => parseSendReturn(sendReturn)[0]);
            }
            catch (error) {
                if (error.code === 4001) {
                    throw new UserRejectedRequestError();
                }
                warning(false, 'eth_requestAccounts was unsuccessful, falling back to enable');
            }
            // if unsuccessful, try enable
            if (!account) {
                // if enable is successful but doesn't return accounts, fall back to getAccount (not happy i have to do this...)
                account = yield window.xfi.ethereum
                    .enable()
                    .then((sendReturn) => sendReturn && parseSendReturn(sendReturn)[0]);
            }
            return Object.assign({ provider: window.xfi.ethereum }, (account ? { account } : {}));
        });
    }
    getProvider() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum;
        });
    }
    getChainId() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            let chainId;
            try {
                chainId = yield window.xfi.ethereum.send('eth_chainId').then(parseSendReturn);
            }
            catch (_c) {
                warning(false, 'eth_chainId was unsuccessful, falling back to net_version');
            }
            if (!chainId) {
                try {
                    chainId = yield window.xfi.ethereum.send('net_version').then(parseSendReturn);
                }
                catch (_d) {
                    warning(false, 'net_version was unsuccessful, falling back to net version v2');
                }
            }
            if (!chainId) {
                try {
                    chainId = parseSendReturn(window.xfi.ethereum.send({ method: 'net_version' }));
                }
                catch (_e) {
                    warning(false, 'net_version v2 was unsuccessful, falling back to manual matches and static properties');
                }
            }
            if (!chainId) {
                if ((_b = window === null || window === void 0 ? void 0 : window.xfi) === null || _b === void 0 ? void 0 : _b.ethereum.isDapper) {
                    chainId = parseSendReturn(window.xfi.ethereum.cachedResults.net_version);
                }
                else {
                    chainId =
                        window.xfi.ethereum.chainId ||
                        window.xfi.ethereum.netVersion ||
                        window.xfi.ethereum.networkVersion ||
                        window.xfi.ethereum._chainId;
                }
            }
            return chainId;
        });
    }
    getAccount() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            let account;
            try {
                account = yield window.xfi.ethereum.send('eth_accounts').then((sendReturn) => parseSendReturn(sendReturn)[0]);
            }
            catch (_b) {
                warning(false, 'eth_accounts was unsuccessful, falling back to enable');
            }
            if (!account) {
                try {
                    account = yield window.xfi.ethereum.enable().then((sendReturn) => parseSendReturn(sendReturn)[0]);
                }
                catch (_c) {
                    warning(false, 'enable was unsuccessful, falling back to eth_accounts v2');
                }
            }
            if (!account) {
                account = parseSendReturn(window.xfi.ethereum.send({ method: 'eth_accounts' }))[0];
            }
            return account;
        });
    }
    deactivate() {
        var _a, _b;
        if (((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum) && ((_b = window === null || window === void 0 ? void 0 : window.xfi) === null || _b === void 0 ? void 0 : _b.ethereum.removeListener)) {
            window.xfi.ethereum.removeListener('chainChanged', this.handleChainChanged);
            window.xfi.ethereum.removeListener('accountsChanged', this.handleAccountsChanged);
            window.xfi.ethereum.removeListener('close', this.handleClose);
            window.xfi.ethereum.removeListener('networkChanged', this.handleNetworkChanged);
        }
    }
    isAuthorized() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                return false;
            }
            try {
                return yield window.xfi.ethereum.send('eth_accounts').then((sendReturn) => {
                    if (parseSendReturn(sendReturn).length > 0) {
                        return true;
                    }
                    else {
                        return false;
                    }
                });
            }
            catch (_b) {
                return false;
            }
        });
    }
}

class BitKeepConnector extends AbstractConnector {
    constructor(kwargs) {
        super(kwargs);
        this.handleNetworkChanged = this.handleNetworkChanged.bind(this);
        this.handleChainChanged = this.handleChainChanged.bind(this);
        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
        this.handleClose = this.handleClose.bind(this);
    }
    handleChainChanged(chainId) {
        var _a;
        console.log("Handling 'chainChanged' event with payload", chainId);
        this.emitUpdate({ chainId, provider: (_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum });
    }
    handleAccountsChanged(accounts) {
        console.log("Handling 'accountsChanged' event with payload", accounts);
        if (accounts.length === 0) {
            this.emitDeactivate();
        }
        else {
            this.emitUpdate({ account: accounts[0] });
        }
    }
    handleClose(code, reason) {
        console.log("Handling 'close' event with payload", code, reason);
        this.emitDeactivate();
    }
    handleNetworkChanged(networkId) {
        var _a;
        console.log("Handling 'networkChanged' event with payload", networkId);
        this.emitUpdate({ chainId: networkId, provider: (_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum });
    }
    activate() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            if ((_b = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _b === void 0 ? void 0 : _b.ethereum.on) {
                window.bitkeep.ethereum.on('chainChanged', this.handleChainChanged);
                window.bitkeep.ethereum.on('accountsChanged', this.handleAccountsChanged);
                window.bitkeep.ethereum.on('close', this.handleClose);
                window.bitkeep.ethereum.on('networkChanged', this.handleNetworkChanged);
            }
            if ((_c = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _c === void 0 ? void 0 : _c.ethereum.isBitKeep) {
                window.bitkeep.ethereum.autoRefreshOnNetworkChange = false;
            }
            // try to activate + get account via eth_requestAccounts
            let account;
            try {
                const _account = yield this.getAccount();
                if (_account)
                    account = _account;
            }
            catch (error) {
                if (error.code === 4001) {
                    throw new UserRejectedRequestError();
                }
                else {
                    warning(false, 'eth_requestAccounts was unsuccessful, falling back to enable');
                }
            }
            return { provider: window.bitkeep.ethereum, account };
        });
    }
    getProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            return window.bitkeep && window.bitkeep.ethereum;
        });
    }
    getChainId() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            let chainId = window.bitkeep.ethereum.chainId || window.bitkeep.ethereum.networkVersion;
            if (!chainId) {
                chainId = yield ((_b = window.bitkeep) === null || _b === void 0 ? void 0 : _b.ethereum.request({ method: 'eth_chainId' }));
            }
            return chainId;
        });
    }
    getAccount() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            const accounts = yield ((_b = window.bitkeep) === null || _b === void 0 ? void 0 : _b.ethereum.request({ method: 'eth_accounts' }));
            return accounts && accounts.length > 0 ? accounts[0] : null;
        });
    }
    deactivate() {
        var _a, _b;
        if (((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum) && ((_b = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _b === void 0 ? void 0 : _b.ethereum.removeListener)) {
            window.bitkeep.ethereum.removeListener('chainChanged', this.handleChainChanged);
            window.bitkeep.ethereum.removeListener('accountsChanged', this.handleAccountsChanged);
            window.bitkeep.ethereum.removeListener('close', this.handleClose);
            window.bitkeep.ethereum.removeListener('networkChanged', this.handleNetworkChanged);
        }
    }
    isAuthorized() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                return false;
            }
            try {
                const account = yield this.getAccount();
                return !!account;
            }
            catch (_b) {
                return false;
            }
        });
    }
}

class NearConnector extends AbstractConnector {
    constructor(kwargs) {
        var _a;
        super(kwargs);
        const keyStore = new keyStores.BrowserLocalStorageKeyStore();
        // connect to NEAR
        this.near = new Near$1(Object.assign({ keyStore, headers: {} }, kwargs.config));
        this.wallet = new WalletConnection(this.near, 'pangolin');
        this.normalizeChainId = kwargs === null || kwargs === void 0 ? void 0 : kwargs.normalizeChainId;
        this.normalizeAccount = kwargs === null || kwargs === void 0 ? void 0 : kwargs.normalizeAccount;
        this.chainId = (_a = kwargs === null || kwargs === void 0 ? void 0 : kwargs.config) === null || _a === void 0 ? void 0 : _a.chainId;
        this.handleNetworkChanged = this.handleNetworkChanged.bind(this);
        this.handleChainChanged = this.handleChainChanged.bind(this);
        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
        this.handleClose = this.handleClose.bind(this);
        this.provider = new JsonRpcProvider(kwargs.config.nodeUrl);
    }
    handleChainChanged(chainId) {
        console.log("Handling 'chainChanged' event with payload", chainId);
        this.emitUpdate({ chainId, provider: this.provider });
    }
    handleAccountsChanged(accounts) {
        console.log("Handling 'accountsChanged' event with payload", accounts);
        if (accounts.length === 0) {
            this.emitDeactivate();
        }
        else {
            this.emitUpdate({ account: accounts[0] });
        }
    }
    handleClose(code, reason) {
        console.log("Handling 'close' event with payload", code, reason);
        this.emitDeactivate();
    }
    handleNetworkChanged(networkId) {
        console.log("Handling 'networkChanged' event with payload", networkId);
        this.emitUpdate({ chainId: networkId, provider: this.provider });
    }
    getChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wallet) {
                return this.chainId;
            }
            return null;
        });
    }
    getProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider;
        });
    }
    activate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wallet) {
                const isAuthorized = yield this.isAuthorized();
                if (isAuthorized) {
                    const account = yield this.getAccount();
                    const chainId = yield this.getChainId();
                    return { chainId: chainId, provider: this.provider, account: account };
                }
                else {
                    this.wallet.requestSignIn(this.near.config.contractId);
                    return { provider: this.provider };
                }
            }
        });
    }
    getAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wallet && this.wallet.isSignedIn()) {
                return this.wallet.getAccountId();
            }
            return null;
        });
    }
    deactivate() {
        return __awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wallet) {
                this.wallet.signOut();
            }
        });
    }
    getAccountBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wallet) {
                const account = this.wallet.account();
                return account.getAccountBalance();
            }
            return undefined;
        });
    }
    isAuthorized() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wallet && this.wallet.isSignedIn()) {
                return true;
            }
            return false;
        });
    }
}

var isProduction = process.env.NODE_ENV === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    var provided = typeof message === 'function' ? message() : message;
    var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
}

class RequestError extends Error {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    constructor(message, code, data) {
        super(message);
    }
}
class MiniRpcProvider {
    constructor(chainId, url, batchWaitTimeMs) {
        this.isMetaMask = false;
        this.isXDEFI = false;
        this.nextId = 1;
        this.batchTimeoutId = null;
        this.batch = [];
        this.clearBatch = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            console.debug('Clearing batch', this.batch);
            const batch = this.batch;
            this.batch = [];
            this.batchTimeoutId = null;
            let response;
            try {
                response = yield fetch(this.url, {
                    method: 'POST',
                    headers: { 'content-type': 'application/json', accept: 'application/json' },
                    body: JSON.stringify(batch.map((item) => item.request)),
                });
            }
            catch (error) {
                batch.forEach(({ reject }) => reject(new Error('Failed to send batch call')));
                return;
            }
            if (!response.ok) {
                batch.forEach(({ reject }) => reject(new RequestError(`${response.status}: ${response.statusText}`, -32000)));
                return;
            }
            let json;
            try {
                json = yield response.json();
            }
            catch (error) {
                batch.forEach(({ reject }) => reject(new Error('Failed to parse JSON response')));
                return;
            }
            const byKey = batch.reduce((memo, current) => {
                memo[current.request.id] = current;
                return memo;
            }, {});
            for (const result of json) {
                const { resolve, reject, request: { method }, } = byKey[result.id];
                // eslint-disable-next-line  @typescript-eslint/ban-ts-comment
                // @ts-ignore
                if (resolve && reject) {
                    if ('error' in result) {
                        reject(new RequestError((_a = result === null || result === void 0 ? void 0 : result.error) === null || _a === void 0 ? void 0 : _a.message, (_b = result === null || result === void 0 ? void 0 : result.error) === null || _b === void 0 ? void 0 : _b.code, (_c = result === null || result === void 0 ? void 0 : result.error) === null || _c === void 0 ? void 0 : _c.data));
                    }
                    else if ('result' in result) {
                        resolve(result.result);
                    }
                    else {
                        reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result));
                    }
                }
            }
        });
        this.sendAsync = (request, callback) => {
            this.request(request.method, request.params)
                .then((result) => callback(null, { jsonrpc: '2.0', id: request.id, result }))
                .catch((error) => callback(error, null));
        };
        this.request = (method, params) => __awaiter(this, void 0, void 0, function* () {
            var _d;
            if (typeof method !== 'string') {
                return this.request(method.method, method.params);
            }
            if (method === 'eth_chainId') {
                return `0x${this.chainId.toString(16)}`;
            }
            const promise = new Promise((resolve, reject) => {
                this.batch.push({
                    request: {
                        jsonrpc: '2.0',
                        id: this.nextId++,
                        method,
                        params,
                    },
                    resolve,
                    reject,
                });
            });
            this.batchTimeoutId = (_d = this.batchTimeoutId) !== null && _d !== void 0 ? _d : setTimeout(this.clearBatch, this.batchWaitTimeMs);
            return promise;
        });
        this.chainId = chainId;
        this.url = url;
        const parsed = new URL(url);
        this.host = parsed.host;
        this.path = parsed.pathname;
        // how long to wait to batch calls
        this.batchWaitTimeMs = batchWaitTimeMs !== null && batchWaitTimeMs !== void 0 ? batchWaitTimeMs : 50;
    }
}
class NetworkConnector extends AbstractConnector {
    constructor({ urls, defaultChainId }) {
        invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url');
        super({ supportedChainIds: Object.keys(urls).map((k) => Number(k)) });
        this.currentChainId = defaultChainId || Number(Object.keys(urls)[0]);
        this.providers = Object.keys(urls).reduce((accumulator, chainId) => {
            accumulator[Number(chainId)] = new MiniRpcProvider(Number(chainId), urls[Number(chainId)]);
            return accumulator;
        }, {});
    }
    get provider() {
        return this.providers[this.currentChainId];
    }
    activate() {
        return __awaiter(this, void 0, void 0, function* () {
            return { provider: this.providers[this.currentChainId], chainId: this.currentChainId, account: null };
        });
    }
    getProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.providers[this.currentChainId];
        });
    }
    getChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.currentChainId;
        });
    }
    getAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    deactivate() {
        return;
    }
}

var _a$2;
const NETWORK_URL = 'https://api.avax.network/ext/bc/C/rpc';
// Near Exchnage Contract
const NEAR_EXCHANGE_CONTRACT_ADDRESS = {
    [ChainId.NEAR_MAINNET]: 'png-exchange-v1.mainnet',
    [ChainId.NEAR_TESTNET]: 'png-exchange-v1.testnet',
};
const NETWORK_CHAIN_ID = parseInt((_a$2 = process.env.REACT_APP_CHAIN_ID) !== null && _a$2 !== void 0 ? _a$2 : '43114');
const network = new NetworkConnector({
    urls: { [NETWORK_CHAIN_ID]: NETWORK_URL },
    defaultChainId: NETWORK_CHAIN_ID,
});
let networkLibrary;
function getNetworkLibrary() {
    networkLibrary = networkLibrary !== null && networkLibrary !== void 0 ? networkLibrary : new Web3Provider(network.provider);
    return networkLibrary;
}
const injected = new InjectedConnector({
    supportedChainIds: [43113, 43114, 11111, 16, 19],
});
const talisman = new TalismanConnector({
    supportedChainIds: [43113, 43114, 11111, 16, 19],
});
const gnosisSafe = new SafeAppConnector({
    supportedChainIds: [43113, 43114, 11111, 16, 19],
});
const walletlink = new WalletLinkConnector({
    url: NETWORK_URL,
    supportedChainIds: [43113, 43114, 11111, 16, 19],
    appName: 'Arcanum',
    appLogoUrl: 'https://raw.githubusercontent.com/pangolindex/interface/master/public/images/384x384_App_Icon.png',
});
const walletconnect = new WalletConnectConnector({
    rpc: {
        43114: NETWORK_URL,
    },
    qrcode: true,
    bridge: 'https://bridge.walletconnect.org',
});
const xDefi = new DefiConnector({
    supportedChainIds: [1, 43114, 11111, 16, 19],
});
const bitKeep = new BitKeepConnector({
    supportedChainIds: [43113, 43114, 11111, 16, 19],
});
function getNearMainnetConfig() {
    return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
        explorerUrl: 'https://nearblocks.io',
        indexerUrl: 'https://indexer.ref-finance.net',
        chainId: ChainId.NEAR_MAINNET,
        contractId: NEAR_EXCHANGE_CONTRACT_ADDRESS[ChainId.NEAR_MAINNET],
    };
}
// TODO: set configuration dynemically as per env
function getNearConfig(env = 'testnet') {
    switch (env) {
        case 'production':
        case 'mainnet':
            return getNearMainnetConfig();
        case 'testnet':
            return {
                networkId: 'testnet',
                nodeUrl: 'https://rpc.testnet.near.org',
                walletUrl: 'https://wallet.testnet.near.org',
                helperUrl: 'https://helper.testnet.near.org',
                explorerUrl: 'https://testnet.nearblocks.io',
                chainId: ChainId.NEAR_TESTNET,
                contractId: NEAR_EXCHANGE_CONTRACT_ADDRESS[ChainId.NEAR_TESTNET],
            };
        default:
            return getNearMainnetConfig();
    }
}
const near = new NearConnector({
    normalizeChainId: false,
    normalizeAccount: false,
    config: getNearConfig('testnet'),
});

const CommonEVMProvider = (provider) => {
    if (provider) {
        provider.getTransactionReceipt = (hash) => __awaiter(void 0, void 0, void 0, function* () {
            const receipt = yield provider.request({
                method: 'eth_getTransactionReceipt',
                params: [hash],
            });
            if (!receipt.blockNumber || !receipt.blockHash) {
                return undefined;
            }
            receipt.blockNumber = Number(receipt.blockNumber);
            receipt.transactionIndex = Number(receipt.transactionIndex);
            receipt.hash = receipt.transactionHash;
            receipt.status = Number(receipt.status);
            return receipt;
        });
        provider.getBlockNumber = () => __awaiter(void 0, void 0, void 0, function* () {
            const block = yield provider.request({
                method: 'eth_blockNumber',
                params: [],
            });
            return Number(block);
        });
        provider.execute = (method, params) => __awaiter(void 0, void 0, void 0, function* () {
            const res = yield provider.request({ method: method, params: params });
            return res;
        });
        provider.getBlockTimestamp = (blockNumber) => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const result = yield provider.request({
                method: 'eth_getBlockByNumber',
                params: [`0x${blockNumber.toString(16)}`, false],
            });
            if (!result) {
                return 0;
            }
            return (_a = parseInt(result === null || result === void 0 ? void 0 : result.timestamp, 16).toString()) !== null && _a !== void 0 ? _a : 0;
        });
    }
    return provider;
};

const NearProvider = (provider) => {
    if (provider) {
        provider.getTransactionReceipt = (hash) => __awaiter(void 0, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            try {
                const accountId = (_c = (_b = (_a = near === null || near === void 0 ? void 0 : near.wallet) === null || _a === void 0 ? void 0 : _a.account) === null || _b === void 0 ? void 0 : _b.call(_a)) === null || _c === void 0 ? void 0 : _c.accountId;
                const res = yield (provider === null || provider === void 0 ? void 0 : provider.txStatus(hash, accountId));
                const isSuccess = (_d = res === null || res === void 0 ? void 0 : res.receipts_outcome) === null || _d === void 0 ? void 0 : _d.every((item) => { var _a, _b; return !((_b = (_a = item === null || item === void 0 ? void 0 : item.outcome) === null || _a === void 0 ? void 0 : _a.status) === null || _b === void 0 ? void 0 : _b.Failure); });
                const blockHash = (_e = res === null || res === void 0 ? void 0 : res.transaction_outcome) === null || _e === void 0 ? void 0 : _e.block_hash;
                let blockNumber = 0;
                try {
                    const block = yield provider.block({ blockId: blockHash });
                    blockNumber = (_f = block === null || block === void 0 ? void 0 : block.header) === null || _f === void 0 ? void 0 : _f.height;
                }
                catch (error) {
                    console.log(error);
                }
                return {
                    blockHash: blockHash,
                    blockNumber,
                    contractAddress: '',
                    from: (_g = res === null || res === void 0 ? void 0 : res.transaction) === null || _g === void 0 ? void 0 : _g.signer_id,
                    status: isSuccess ? 1 : 0,
                    to: (_h = res === null || res === void 0 ? void 0 : res.transaction) === null || _h === void 0 ? void 0 : _h.receiver_id,
                    hash,
                    transactionHash: hash,
                    transactionIndex: (_j = res === null || res === void 0 ? void 0 : res.transaction) === null || _j === void 0 ? void 0 : _j.nonce,
                };
            }
            catch (error) {
                console.log(error);
            }
        });
        provider.getBlockNumber = () => __awaiter(void 0, void 0, void 0, function* () {
            var _k;
            const block = yield provider.block({ finality: 'optimistic' });
            return (_k = block === null || block === void 0 ? void 0 : block.header) === null || _k === void 0 ? void 0 : _k.height;
        });
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        provider.execute = (_method, _params) => __awaiter(void 0, void 0, void 0, function* () {
            //  implement it
        });
        provider.getBlockTimestamp = (blockNumber) => __awaiter(void 0, void 0, void 0, function* () {
            var _l, _m, _o;
            const block = yield provider.block(blockNumber);
            return (_o = (_m = (_l = block === null || block === void 0 ? void 0 : block.header) === null || _l === void 0 ? void 0 : _l.timestamp) === null || _m === void 0 ? void 0 : _m.toString()) !== null && _o !== void 0 ? _o : '0';
        });
    }
    return provider;
};

const ZERO_ADDRESS$1 = '0x0000000000000000000000000000000000000000';
const PNG = {
    [ChainId.FUJI]: new Token$1(ChainId.FUJI, CHAINS[ChainId.FUJI].contracts.png, 18, CHAINS[ChainId.FUJI].png_symbol, 'Arcanum'),
    [ChainId.AVALANCHE]: new Token$1(ChainId.AVALANCHE, CHAINS[ChainId.AVALANCHE].contracts.png, 18, CHAINS[ChainId.AVALANCHE].png_symbol, 'Arcanum'),
    [ChainId.WAGMI]: new Token$1(ChainId.WAGMI, CHAINS[ChainId.WAGMI].contracts.png, 18, CHAINS[ChainId.WAGMI].png_symbol, 'Wagmi Arcanum'),
    [ChainId.COSTON]: new Token$1(ChainId.COSTON, CHAINS[ChainId.COSTON].contracts.png, 18, CHAINS[ChainId.COSTON].png_symbol, 'Coston Arcanum'),
    [ChainId.SONGBIRD]: new Token$1(ChainId.SONGBIRD, CHAINS[ChainId.SONGBIRD].contracts.png, 18, CHAINS[ChainId.SONGBIRD].png_symbol, 'Songbird Arcanum'),
    [ChainId.NEAR_MAINNET]: new Token$1(ChainId.NEAR_MAINNET, CHAINS[ChainId.NEAR_MAINNET].contracts.png, 18, CHAINS[ChainId.NEAR_MAINNET].png_symbol, 'Arcanum Near'),
    [ChainId.NEAR_TESTNET]: new Token$1(ChainId.NEAR_TESTNET, CHAINS[ChainId.NEAR_TESTNET].contracts.png, 18, CHAINS[ChainId.NEAR_TESTNET].png_symbol, 'Arcanum Near'),
};
const DAIe = {
    [ChainId.FUJI]: new Token$1(ChainId.FUJI, ZERO_ADDRESS$1, 18, 'DAI.e', 'Dai Stablecoin'),
    [ChainId.AVALANCHE]: new Token$1(ChainId.AVALANCHE, '0xd586E7F844cEa2F87f50152665BCbc2C279D8d70', 18, 'DAI.e', 'Dai Stablecoin'),
    [ChainId.WAGMI]: new Token$1(ChainId.WAGMI, ZERO_ADDRESS$1, 18, 'DAI.e', 'Dai Stablecoin'),
    [ChainId.COSTON]: new Token$1(ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.SONGBIRD]: new Token$1(ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.NEAR_MAINNET]: new Token$1(ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.NEAR_TESTNET]: new Token$1(ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};
const USDCe = {
    [ChainId.FUJI]: new Token$1(ChainId.FUJI, ZERO_ADDRESS$1, 6, 'USDC.e', 'USD Coin'),
    [ChainId.AVALANCHE]: new Token$1(ChainId.AVALANCHE, '0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664', 6, 'USDC.e', 'USD Coin'),
    [ChainId.WAGMI]: new Token$1(ChainId.WAGMI, ZERO_ADDRESS$1, 6, 'USDC.e', 'USD Coin'),
    [ChainId.COSTON]: new Token$1(ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.SONGBIRD]: new Token$1(ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.NEAR_MAINNET]: new Token$1(ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.NEAR_TESTNET]: new Token$1(ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};
const USDC = {
    [ChainId.FUJI]: new Token$1(ChainId.FUJI, ZERO_ADDRESS$1, 6, 'USDC', 'USD Coin'),
    [ChainId.AVALANCHE]: new Token$1(ChainId.AVALANCHE, '0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E', 6, 'USDC', 'USD Coin'),
    [ChainId.WAGMI]: new Token$1(ChainId.WAGMI, ZERO_ADDRESS$1, 6, 'USDC', 'USD Coin'),
    [ChainId.COSTON]: new Token$1(ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.SONGBIRD]: new Token$1(ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, 'USDC', 'USD Coin'),
    [ChainId.NEAR_MAINNET]: new Token$1(ChainId.NEAR_MAINNET, 'usdc.fakes.testnet', 18, 'USDC', 'USDC'),
    [ChainId.NEAR_TESTNET]: new Token$1(ChainId.NEAR_TESTNET, 'usdc.fakes.testnet', 18, 'USDC', 'USDC'),
};
const USDTe = {
    [ChainId.FUJI]: new Token$1(ChainId.FUJI, ZERO_ADDRESS$1, 6, 'USDT.e', 'Tether USD'),
    [ChainId.AVALANCHE]: new Token$1(ChainId.AVALANCHE, '0xc7198437980c041c805A1EDcbA50c1Ce5db95118', 6, 'USDT.e', 'Tether USD'),
    [ChainId.WAGMI]: new Token$1(ChainId.WAGMI, ZERO_ADDRESS$1, 6, 'USDT.e', 'Tether USD'),
    [ChainId.COSTON]: new Token$1(ChainId.COSTON, ZERO_ADDRESS$1, 6, '', ''),
    [ChainId.SONGBIRD]: new Token$1(ChainId.SONGBIRD, ZERO_ADDRESS$1, 6, '', ''),
    [ChainId.NEAR_MAINNET]: new Token$1(ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.NEAR_TESTNET]: new Token$1(ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};
const axlUST = {
    [ChainId.FUJI]: new Token$1(ChainId.FUJI, ZERO_ADDRESS$1, 6, 'axlUST', 'Axelar Wrapped UST'),
    [ChainId.AVALANCHE]: new Token$1(ChainId.AVALANCHE, '0x260Bbf5698121EB85e7a74f2E45E16Ce762EbE11', 6, 'axlUST', 'Axelar Wrapped UST'),
    [ChainId.WAGMI]: new Token$1(ChainId.WAGMI, ZERO_ADDRESS$1, 18, 'axlUST', 'Axelar Wrapped UST'),
    [ChainId.COSTON]: new Token$1(ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.SONGBIRD]: new Token$1(ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.NEAR_MAINNET]: new Token$1(ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.NEAR_TESTNET]: new Token$1(ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};
const UST = {
    [ChainId.FUJI]: new Token$1(ChainId.FUJI, ZERO_ADDRESS$1, 6, 'UST', 'Wormhole UST'),
    [ChainId.AVALANCHE]: new Token$1(ChainId.AVALANCHE, '0xb599c3590F42f8F995ECfa0f85D2980B76862fc1', 6, 'UST', 'Wormhole UST'),
    [ChainId.WAGMI]: new Token$1(ChainId.WAGMI, ZERO_ADDRESS$1, 6, 'UST', 'Wormhole UST'),
    [ChainId.COSTON]: new Token$1(ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.SONGBIRD]: new Token$1(ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.NEAR_MAINNET]: new Token$1(ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [ChainId.NEAR_TESTNET]: new Token$1(ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};

var _a$1, _b$1, _c$1, _d$1, _e$1, _f$1, _g$1, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
const BIG_INT_ZERO = JSBI$1.BigInt(0);
const BIG_INT_TWO = JSBI$1.BigInt(2);
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const NATIVE = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
const BIG_INT_SECONDS_IN_WEEK = JSBI$1.BigInt(60 * 60 * 24 * 7);
const ONE_TOKEN = JSBI$1.exponentiate(JSBI$1.BigInt(10), JSBI$1.BigInt(18));
const ROUTER_ADDRESS = {
    [ChainId.FUJI]: CHAINS[ChainId.FUJI].contracts.router,
    [ChainId.AVALANCHE]: CHAINS[ChainId.AVALANCHE].contracts.router,
    [ChainId.WAGMI]: CHAINS[ChainId.WAGMI].contracts.router,
    [ChainId.COSTON]: CHAINS[ChainId.COSTON].contracts.router,
    [ChainId.SONGBIRD]: CHAINS[ChainId.SONGBIRD].contracts.router,
    [ChainId.NEAR_MAINNET]: (_a$1 = CHAINS[ChainId.NEAR_MAINNET]) === null || _a$1 === void 0 ? void 0 : _a$1.contracts.router,
    [ChainId.NEAR_TESTNET]: (_b$1 = CHAINS[ChainId.NEAR_TESTNET]) === null || _b$1 === void 0 ? void 0 : _b$1.contracts.router,
};
const ROUTER_DAAS_ADDRESS = {
    [ChainId.FUJI]: (_e$1 = (_d$1 = (_c$1 = CHAINS[ChainId.FUJI]) === null || _c$1 === void 0 ? void 0 : _c$1.contracts) === null || _d$1 === void 0 ? void 0 : _d$1.router_daas) !== null && _e$1 !== void 0 ? _e$1 : ZERO_ADDRESS,
    [ChainId.AVALANCHE]: (_h = (_g$1 = (_f$1 = CHAINS[ChainId.AVALANCHE]) === null || _f$1 === void 0 ? void 0 : _f$1.contracts) === null || _g$1 === void 0 ? void 0 : _g$1.router_daas) !== null && _h !== void 0 ? _h : ZERO_ADDRESS,
    [ChainId.WAGMI]: (_l = (_k = (_j = CHAINS[ChainId.WAGMI]) === null || _j === void 0 ? void 0 : _j.contracts) === null || _k === void 0 ? void 0 : _k.router_daas) !== null && _l !== void 0 ? _l : ZERO_ADDRESS,
    [ChainId.COSTON]: (_p = (_o = (_m = CHAINS[ChainId.COSTON]) === null || _m === void 0 ? void 0 : _m.contracts) === null || _o === void 0 ? void 0 : _o.router_daas) !== null && _p !== void 0 ? _p : ZERO_ADDRESS,
    [ChainId.SONGBIRD]: (_s = (_r = (_q = CHAINS[ChainId.SONGBIRD]) === null || _q === void 0 ? void 0 : _q.contracts) === null || _r === void 0 ? void 0 : _r.router_daas) !== null && _s !== void 0 ? _s : ZERO_ADDRESS,
    [ChainId.NEAR_MAINNET]: (_v = (_u = (_t = CHAINS[ChainId.NEAR_MAINNET]) === null || _t === void 0 ? void 0 : _t.contracts) === null || _u === void 0 ? void 0 : _u.router_daas) !== null && _v !== void 0 ? _v : ZERO_ADDRESS,
    [ChainId.NEAR_TESTNET]: (_y = (_x = (_w = CHAINS[ChainId.NEAR_TESTNET]) === null || _w === void 0 ? void 0 : _w.contracts) === null || _x === void 0 ? void 0 : _x.router_daas) !== null && _y !== void 0 ? _y : ZERO_ADDRESS,
};
/**
 * Some tokens can only be swapped via certain pairs, so we override the list of bases that are considered for these
 * tokens.
 */
const CUSTOM_BASES = {
    [ChainId.AVALANCHE]: {},
};
const NetworkContextName = 'NETWORK';
// default allowed slippage, in bips
const INITIAL_ALLOWED_SLIPPAGE = 50;
// 10 minutes, denominated in seconds
const DEFAULT_DEADLINE_FROM_NOW = '600';
const getMiniChefAddress = (chainId) => {
    var _a;
    const minichefObj = (_a = CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef;
    if ((minichefObj === null || minichefObj === void 0 ? void 0 : minichefObj.type) === ChefType.MINI_CHEF_V2) {
        return minichefObj.address;
    }
    return undefined;
};
const MINICHEF_ADDRESS = {
    [ChainId.FUJI]: getMiniChefAddress(ChainId.FUJI),
    [ChainId.AVALANCHE]: getMiniChefAddress(ChainId.AVALANCHE),
    [ChainId.WAGMI]: getMiniChefAddress(ChainId.WAGMI),
    [ChainId.COSTON]: getMiniChefAddress(ChainId.COSTON),
    [ChainId.SONGBIRD]: getMiniChefAddress(ChainId.SONGBIRD),
    [ChainId.NEAR_MAINNET]: getMiniChefAddress(ChainId.NEAR_MAINNET),
    [ChainId.NEAR_TESTNET]: getMiniChefAddress(ChainId.NEAR_TESTNET),
};
const getPangoChefAddress = (chainId) => {
    var _a;
    const minichefObj = (_a = CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef;
    if ((minichefObj === null || minichefObj === void 0 ? void 0 : minichefObj.type) === ChefType.PANGO_CHEF) {
        return minichefObj.address;
    }
    return undefined;
};
const PANGOCHEF_ADDRESS = {
    [ChainId.FUJI]: getPangoChefAddress(ChainId.FUJI),
    [ChainId.AVALANCHE]: getPangoChefAddress(ChainId.AVALANCHE),
    [ChainId.WAGMI]: getPangoChefAddress(ChainId.WAGMI),
    [ChainId.COSTON]: getPangoChefAddress(ChainId.COSTON),
    [ChainId.SONGBIRD]: getPangoChefAddress(ChainId.SONGBIRD),
    [ChainId.NEAR_MAINNET]: undefined,
    [ChainId.NEAR_TESTNET]: undefined,
};
// these tokens can be directly linked to (via url params) in the swap page without prompting a warning
const TRUSTED_TOKEN_ADDRESSES = {
    [ChainId.FUJI]: [],
    [ChainId.AVALANCHE]: [WAVAX[ChainId.AVALANCHE].address, PNG[ChainId.AVALANCHE].address],
    [ChainId.WAGMI]: [WAVAX[ChainId.WAGMI].address, PNG[ChainId.WAGMI].address],
    [ChainId.COSTON]: [WAVAX[ChainId.COSTON].address, PNG[ChainId.COSTON].address],
    [ChainId.SONGBIRD]: [WAVAX[ChainId.SONGBIRD].address, PNG[ChainId.SONGBIRD].address],
    [ChainId.NEAR_MAINNET]: [WAVAX[ChainId.NEAR_MAINNET].address, PNG[ChainId.NEAR_MAINNET].address],
    [ChainId.NEAR_TESTNET]: [WAVAX[ChainId.NEAR_TESTNET].address, PNG[ChainId.NEAR_TESTNET].address],
};
const SWAP_DEFAULT_CURRENCY = {
    [ChainId.AVALANCHE]: {
        inputCurrency: 'AVAX',
        outputCurrency: USDC[ChainId.AVALANCHE].address,
    },
    [ChainId.FUJI]: {
        inputCurrency: '',
        outputCurrency: '',
    },
    [ChainId.WAGMI]: {
        inputCurrency: '',
        outputCurrency: '',
    },
    [ChainId.COSTON]: {
        inputCurrency: '',
        outputCurrency: '',
    },
    [ChainId.SONGBIRD]: {
        inputCurrency: 'SGB',
        outputCurrency: PNG[ChainId.SONGBIRD].address,
    },
    [ChainId.NEAR_MAINNET]: {
        inputCurrency: WAVAX[ChainId.NEAR_MAINNET].address,
        outputCurrency: PNG[ChainId.NEAR_MAINNET].address,
    },
    [ChainId.NEAR_TESTNET]: {
        inputCurrency: WAVAX[ChainId.NEAR_TESTNET].address,
        outputCurrency: PNG[ChainId.NEAR_TESTNET].address,
    },
};
// used to construct intermediary pairs for trading
const BASES_TO_CHECK_TRADES_AGAINST = {
    [ChainId.FUJI]: [WAVAX[ChainId.FUJI], PNG[ChainId.FUJI]],
    [ChainId.AVALANCHE]: [
        WAVAX[ChainId.AVALANCHE],
        PNG[ChainId.AVALANCHE],
        USDTe[ChainId.AVALANCHE],
        DAIe[ChainId.AVALANCHE],
        USDCe[ChainId.AVALANCHE],
        UST[ChainId.AVALANCHE],
        axlUST[ChainId.AVALANCHE],
        USDC[ChainId.AVALANCHE],
    ],
    [ChainId.WAGMI]: [WAVAX[ChainId.WAGMI], PNG[ChainId.WAGMI]],
    [ChainId.COSTON]: [WAVAX[ChainId.COSTON], PNG[ChainId.COSTON]],
    [ChainId.SONGBIRD]: [WAVAX[ChainId.SONGBIRD], PNG[ChainId.SONGBIRD]],
    [ChainId.NEAR_MAINNET]: [WAVAX[ChainId.NEAR_MAINNET], PNG[ChainId.NEAR_MAINNET]],
    [ChainId.NEAR_TESTNET]: [WAVAX[ChainId.NEAR_TESTNET], PNG[ChainId.NEAR_TESTNET]],
};
// one basis point
const ONE_BIPS = new Percent$1(JSBI$1.BigInt(1), JSBI$1.BigInt(10000));
const BIPS_BASE = JSBI$1.BigInt(10000);
// used for warning states
const ALLOWED_PRICE_IMPACT_LOW = new Percent$1(JSBI$1.BigInt(100), BIPS_BASE); // 1%
const ALLOWED_PRICE_IMPACT_MEDIUM = new Percent$1(JSBI$1.BigInt(300), BIPS_BASE); // 3%
const ALLOWED_PRICE_IMPACT_HIGH = new Percent$1(JSBI$1.BigInt(500), BIPS_BASE); // 5%
// if the price slippage exceeds this number, force the user to type 'confirm' to execute
const PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN = new Percent$1(JSBI$1.BigInt(1000), BIPS_BASE); // 10%
// for non expert mode disable swaps above this
const BLOCKED_PRICE_IMPACT_NON_EXPERT = new Percent$1(JSBI$1.BigInt(1500), BIPS_BASE); // 15%
// used to ensure the user doesn't send so much ETH so they end up with <.01
const MIN_ETH = JSBI$1.exponentiate(JSBI$1.BigInt(10), JSBI$1.BigInt(16)); // .01 ETH
const PANGOLIN_TOKENS_REPO_RAW_BASE_URL = `https://raw.githubusercontent.com/pangolindex/tokens`;
const ANALYTICS_PAGE = 'https://info.pangolin.exchange';
const PANGOLIN_API_BASE_URL = `https://api.pangolin.exchange`;
const TIMEFRAME = [
    {
        description: 'DAY',
        label: '1D',
        interval: 3600,
        momentIdentifier: 'day',
        days: '1',
    },
    {
        description: 'WEEK',
        label: '1W',
        interval: 86400,
        momentIdentifier: 'week',
        days: '7',
    },
    {
        description: 'MONTH',
        label: '1M',
        interval: 604800,
        momentIdentifier: 'month',
        days: '30',
    },
    {
        description: 'YEAR',
        label: '1Y',
        interval: 2629746,
        momentIdentifier: 'year',
        days: '365',
    },
    {
        description: 'ALL',
        label: 'ALL',
        interval: 2629746,
        momentIdentifier: '',
        days: 'max',
    },
];
const SUBGRAPH_BASE_URL = `https://api.thegraph.com/subgraphs/name/pangolindex`;
const LANDING_PAGE = 'https://pangolin.exchange';
const SUPPORTED_WALLETS = {
    INJECTED: {
        connector: injected,
        name: 'Injected',
        iconName: arrowRightIcon,
        description: 'Injected web3 provider.',
        href: null,
        color: '#010101',
        primary: true,
        isEVM: true,
    },
    METAMASK: {
        connector: injected,
        name: 'MetaMask',
        iconName: metamaskIcon,
        description: 'Easy-to-use browser extension.',
        href: null,
        color: '#E8831D',
        isEVM: true,
    },
    GNOSISSAFE: {
        connector: gnosisSafe,
        name: 'Gnosis Safe',
        iconName: gnosisSafeIcon,
        description: 'Gnosis Safe Multisig Wallet.',
        href: null,
        color: '#010101',
        isEVM: true,
    },
    WALLET_LINK: {
        connector: walletlink,
        name: 'Coinbase Wallet',
        iconName: coinbaseWalletIcon,
        description: 'Use Coinbase Wallet app on mobile device',
        href: null,
        color: '#315CF5',
        isEVM: true,
    },
    WALLET_CONNECT: {
        connector: walletconnect,
        name: 'Wallet Connect',
        iconName: walletConnectIcon,
        description: 'Use Wallet Connect',
        href: null,
        color: '#315CF5',
        isEVM: true,
    },
    XDEFI: {
        connector: xDefi,
        name: 'XDEFI Wallet',
        iconName: xDefiIcon,
        description: window.xfi && window.xfi.ethereum ? 'Easy-to-use browser extension.' : 'Please Install',
        href: null,
        color: '#315CF5',
        isEVM: true,
    },
    RABBY: {
        connector: injected,
        name: 'Rabby Wallet',
        iconName: rabbyIcon,
        description: 'Easy-to-use browser extension.',
        href: null,
        color: '#7a7cff',
        isEVM: true,
    },
    TALISMAN: {
        connector: talisman,
        name: 'Talisman',
        iconName: talismanIcon,
        description: 'Enter the Paraverse.',
        href: null,
        color: '#FF3D23',
        isEVM: true,
    },
    BITKEEP: {
        connector: bitKeep,
        name: 'BitKeep',
        iconName: bitKeepIcon,
        description: 'Easy-to-use browser extension.',
        href: null,
        color: '#7524f9',
        isEVM: true,
    },
    NEAR: {
        connector: near,
        name: 'Near',
        iconName: NearLogo,
        description: 'Near Web',
        href: null,
        color: '#315CF5',
        primary: true,
        isEVM: false,
    },
};
const PROVIDER_MAPPING = {
    [ChainId.FUJI]: CommonEVMProvider,
    [ChainId.AVALANCHE]: CommonEVMProvider,
    [ChainId.WAGMI]: CommonEVMProvider,
    [ChainId.COSTON]: CommonEVMProvider,
    [ChainId.SONGBIRD]: CommonEVMProvider,
    [ChainId.NEAR_MAINNET]: NearProvider,
    [ChainId.NEAR_TESTNET]: NearProvider,
};
const AVALANCHE_CHAIN_PARAMS = {
    chainId: '0xa86a',
    chainName: 'Avalanche Mainnet C-Chain',
    nativeCurrency: {
        name: 'Avalanche',
        symbol: 'AVAX',
        decimals: 18,
    },
    rpcUrls: ['https://api.avax.network/ext/bc/C/rpc'],
    blockExplorerUrls: ['https://snowtrace.io//'],
};
const IS_IN_IFRAME = window.parent !== window;
const DIRECTUS_URL_NEWS = `https://pangolin.directus.app`;
const COINGEKO_BASE_URL = `https://api.coingecko.com/api/v3`;
const NEAR_API_BASE_URL = `https://testnet-indexer.ref-finance.com`;
const OPEN_API_DEBANK = 'https://openapi.debank.com/v1/user';
const COINGECKO_API = 'https://api.coingecko.com/api/v3';
const ONE_YOCTO_NEAR = '0.000000000000000000000001';
const NEAR_STORAGE_PER_TOKEN = '0.005';
const NEAR_STORAGE_TO_REGISTER_WITH_FT = '0.1';
const NEAR_MIN_DEPOSIT_PER_TOKEN = new BN('5000000000000000000000');
const NEAR_MIN_DEPOSIT_PER_TOKEN_FARM = new BN('45000000000000000000000');
const NEAR_ACCOUNT_MIN_STORAGE_AMOUNT = '0.005';
const NEAR_LP_STORAGE_AMOUNT = '0.01';
const ONLY_ZEROS = /^0*\.?0*$/;
const WAVAX_AND_PNG_ONLY = {
    [ChainId.FUJI]: [WAVAX[ChainId.FUJI], PNG[ChainId.FUJI]],
    [ChainId.AVALANCHE]: [WAVAX[ChainId.AVALANCHE], PNG[ChainId.AVALANCHE]],
    [ChainId.WAGMI]: [WAVAX[ChainId.WAGMI], PNG[ChainId.WAGMI]],
    [ChainId.COSTON]: [WAVAX[ChainId.COSTON], PNG[ChainId.COSTON]],
    [ChainId.SONGBIRD]: [WAVAX[ChainId.SONGBIRD], PNG[ChainId.SONGBIRD]],
    [ChainId.NEAR_MAINNET]: [WAVAX[ChainId.NEAR_MAINNET], PNG[ChainId.NEAR_MAINNET]],
    [ChainId.NEAR_TESTNET]: [WAVAX[ChainId.NEAR_TESTNET], PNG[ChainId.NEAR_TESTNET]],
};
// used to construct the list of all pairs we consider by default in the frontend
const BASES_TO_TRACK_LIQUIDITY_FOR = Object.assign({}, WAVAX_AND_PNG_ONLY);
const PINNED_PAIRS = {
    [ChainId.AVALANCHE]: [],
};
const getSarAddress = (chainId) => {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.contracts) === null || _b === void 0 ? void 0 : _b.staking) === null || _c === void 0 ? void 0 : _c.find((c) => c.type === StakingType.SAR_POSITIONS && c.active)) === null || _d === void 0 ? void 0 : _d.address;
};
const SAR_STAKING_ADDRESS = {
    [ChainId.FUJI]: getSarAddress(ChainId.FUJI),
    [ChainId.AVALANCHE]: getSarAddress(ChainId.AVALANCHE),
    [ChainId.WAGMI]: getSarAddress(ChainId.WAGMI),
    [ChainId.COSTON]: getSarAddress(ChainId.COSTON),
    [ChainId.SONGBIRD]: getSarAddress(ChainId.SONGBIRD),
    [ChainId.NEAR_MAINNET]: getSarAddress(ChainId.NEAR_MAINNET),
    [ChainId.NEAR_TESTNET]: getSarAddress(ChainId.NEAR_TESTNET),
};
/* eslint-enable max-lines */
var SwapTypes;
(function (SwapTypes) {
    SwapTypes["MARKET"] = "MARKET";
    SwapTypes["LIMIT"] = "LIMIT";
})(SwapTypes || (SwapTypes = {}));
const PANGOCHEF_COMPOUND_SLIPPAGE = new Fraction$1('1', '50'); // 2% of slippage tolerange
const ONE_FRACTION = new Fraction$1('1');
const COINGECKO_CURRENCY_ID = {
    [ChainId.FUJI]: undefined,
    [ChainId.AVALANCHE]: 'avalanche-2',
    [ChainId.WAGMI]: undefined,
    [ChainId.COSTON]: undefined,
    [ChainId.SONGBIRD]: 'songbird',
    [ChainId.NEAR_MAINNET]: 'near',
    [ChainId.NEAR_TESTNET]: undefined,
};

var ApplicationModal;
(function (ApplicationModal) {
    ApplicationModal[ApplicationModal["WALLET"] = 0] = "WALLET";
    ApplicationModal[ApplicationModal["POOL_DETAIL"] = 1] = "POOL_DETAIL";
})(ApplicationModal || (ApplicationModal = {}));
const updateBlockNumber = createAction('papplication/updateBlockNumber');
const setOpenModal = createAction('papplication/setOpenModal');
const addPopup = createAction('papplication/addPopup');
const removePopup = createAction('papplication/removePopup');

const initialState$a = {
    blockNumber: {},
    popupList: [],
    openModal: null,
};
var papplication = createReducer(initialState$a, (builder) => builder
    .addCase(updateBlockNumber, (state, action) => {
        var _a, _b;
        const { chainId, blockNumber } = action.payload;
        if (typeof ((_a = state === null || state === void 0 ? void 0 : state.blockNumber) === null || _a === void 0 ? void 0 : _a[chainId]) !== 'number') {
            state.blockNumber[chainId] = blockNumber;
        }
        else {
            state.blockNumber[chainId] = Math.max(blockNumber, (_b = state === null || state === void 0 ? void 0 : state.blockNumber) === null || _b === void 0 ? void 0 : _b[chainId]);
        }
    })
    .addCase(setOpenModal, (state, action) => {
        state.openModal = action.payload;
    })
    .addCase(addPopup, (state, { payload: { content, key, removeAfterMs = 15000 } }) => {
        state.popupList = (key ? state.popupList.filter((popup) => popup.key !== key) : state.popupList).concat([
            {
                key: key || nanoid(),
                show: true,
                content,
                removeAfterMs,
            },
        ]);
    })
    .addCase(removePopup, (state, { payload: { key } }) => {
        state.popupList.forEach((p) => {
            if (p.key === key) {
                p.show = false;
            }
        });
    }));

var Field$2;
(function (Field) {
    Field["LIQUIDITY_PERCENT"] = "LIQUIDITY_PERCENT";
    Field["LIQUIDITY"] = "LIQUIDITY";
    Field["CURRENCY_A"] = "CURRENCY_A";
    Field["CURRENCY_B"] = "CURRENCY_B";
})(Field$2 || (Field$2 = {}));
const typeInput$2 = createAction('burn/typeInputBurn');

const initialState$9 = {
    independentField: Field$2.LIQUIDITY_PERCENT,
    typedValue: '0',
};
var pburn = createReducer(initialState$9, (builder) => builder.addCase(typeInput$2, (state, { payload: { field, typedValue } }) => {
    return Object.assign(Object.assign({}, state), { independentField: field, typedValue });
}));

// the Arcanum Default token list lives here
const PANGOLIN_LIST = 'https://raw.githubusercontent.com/pangolindex/tokenlists/main/pangolin.tokenlist.json';
const DEFAULT_TOKEN_LISTS_SELECTED = [PANGOLIN_LIST];
const DEFAULT_TOKEN_LISTS = [PANGOLIN_LIST];
// Token addresses (excluding PNG and WAVAX) ported from:
// https://raw.githubusercontent.com/pangolindex/tokenlists/main/aeb.tokenlist.json
const AEB_TOKENS = [
    '0xf20d962a6c8f70c731bd838a3a388D7d48fA6e15',
    '0xE54EB2C3009Fa411BF24fB017F9725b973CE36F0',
    '0x8cE2Dee54bB9921a2AE0A63dBb2DF8eD88B91dD9',
    '0x6b329326E0F6b95B93b52229b213334278D6f277',
    '0xaEb044650278731Ef3DC244692AB9F64C78FfaEA',
    '0xB3fe5374F67D7a22886A0eE082b2E2f9d2651651',
    '0xbA7dEebBFC5fA1100Fb055a87773e1E99Cd3507a',
    '0x46C54b16aF7747067f412c78eBaDaE203a26aDa0',
    '0xE1463E8991c8A62e64b77b5Fb6B22F190344C2A9',
    '0x39cf1BD5f15fb22eC3D9Ff86b0727aFc203427cc',
    '0x68e44C4619db40ae1a0725e77C02587bC8fBD1c9',
    '0xde3A24028580884448a5397872046a019649b084',
    '0x390ba0fb0Bd3Aa2a5484001606329701148074e6',
    '0xC84d7bfF2555955b44BDF6A307180810412D751B',
    '0xf39f9671906d8630812f9d9863bBEf5D523c84Ab',
    '0x408D4cD0ADb7ceBd1F1A1C33A0Ba2098E1295bAB',
    '0x99519AcB025a0e0d44c3875A4BbF03af65933627',
];

// fired once when the app reloads but before the app renders
// allows any updates to be applied to store data loaded from localStorage
const updateVersion = createAction('pglobal/updateVersion');

const fetchTokenList = {
    pending: createAction('plists/fetchTokenList/pending'),
    fulfilled: createAction('plists/fetchTokenList/fulfilled'),
    rejected: createAction('plists/fetchTokenList/rejected'),
};
const acceptListUpdate = createAction('plists/acceptListUpdate');
const addList = createAction('plists/addList');
const removeList = createAction('plists/removeList');
const selectList = createAction('plists/selectList');
createAction('plists/rejectVersionUpdate');

const NEW_LIST_STATE = {
    error: null,
    current: null,
    loadingRequestId: null,
    pendingUpdate: null,
};
const initialState$8 = {
    lastInitializedDefaultListOfLists: DEFAULT_TOKEN_LISTS,
    byUrl: Object.assign({}, DEFAULT_TOKEN_LISTS.reduce((memo, listUrl) => {
        memo[listUrl] = NEW_LIST_STATE;
        return memo;
    }, {})),
    selectedListUrl: DEFAULT_TOKEN_LISTS_SELECTED,
};
var plists = createReducer(initialState$8, (builder) => builder
    .addCase(fetchTokenList.pending, (state, { payload: { requestId, url } }) => {
        state.byUrl[url] = Object.assign(Object.assign({
            // eslint-disable-next-line  @typescript-eslint/ban-ts-comment
            // @ts-ignore
            current: null,
            // eslint-disable-next-line  @typescript-eslint/ban-ts-comment
            // @ts-ignore
            pendingUpdate: null
        }, state.byUrl[url]), { loadingRequestId: requestId, error: null });
    })
    .addCase(fetchTokenList.fulfilled, (state, { payload: { requestId, tokenList, url } }) => {
        var _a, _b;
        const current = (_a = state.byUrl[url]) === null || _a === void 0 ? void 0 : _a.current;
        const loadingRequestId = (_b = state.byUrl[url]) === null || _b === void 0 ? void 0 : _b.loadingRequestId;
        // no-op if update does nothing
        if (current) {
            const upgradeType = getVersionUpgrade(current.version, tokenList.version);
            if (upgradeType === VersionUpgrade.NONE)
                return;
            if (loadingRequestId === null || loadingRequestId === requestId) {
                state.byUrl[url] = Object.assign(Object.assign({}, state.byUrl[url]), { loadingRequestId: null, error: null, current: current, pendingUpdate: tokenList });
            }
        }
        else {
            state.byUrl[url] = Object.assign(Object.assign({}, state.byUrl[url]), { loadingRequestId: null, error: null, current: tokenList, pendingUpdate: null });
        }
    })
    .addCase(fetchTokenList.rejected, (state, { payload: { url, requestId, errorMessage } }) => {
        var _a;
        if (((_a = state.byUrl[url]) === null || _a === void 0 ? void 0 : _a.loadingRequestId) !== requestId) {
            // no-op since it's not the latest request
            return;
        }
        state.byUrl[url] = Object.assign(Object.assign({}, state.byUrl[url]), { loadingRequestId: null, error: errorMessage, current: null, pendingUpdate: null });
    })
    .addCase(selectList, (state, { payload: { url, shouldSelect } }) => {
        const existingSelectedListUrl = [].concat(state.selectedListUrl || []);
        if (shouldSelect) {
            // if user want to select the list, then just push it into selected array
            existingSelectedListUrl.push(url);
            state.selectedListUrl = existingSelectedListUrl;
        }
        else {
            const index = existingSelectedListUrl.indexOf(url);
            if (index !== -1) {
                if ((existingSelectedListUrl === null || existingSelectedListUrl === void 0 ? void 0 : existingSelectedListUrl.length) === 1) {
                    // if user want to deselect the list and if there is only one item in the list
                    state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
                }
                else {
                    existingSelectedListUrl.splice(index, 1);
                    state.selectedListUrl = existingSelectedListUrl;
                }
            }
        }
        // automatically adds list
        if (!state.byUrl[url]) {
            state.byUrl[url] = NEW_LIST_STATE;
        }
    })
    .addCase(addList, (state, { payload: url }) => {
        if (!state.byUrl[url]) {
            state.byUrl[url] = NEW_LIST_STATE;
        }
    })
    .addCase(removeList, (state, { payload: url }) => {
        if (state.byUrl[url]) {
            delete state.byUrl[url];
        }
        const existingList = [].concat(state.selectedListUrl || []);
        const index = existingList.indexOf(url);
        if (index !== -1) {
            if ((existingList === null || existingList === void 0 ? void 0 : existingList.length) === 1) {
                // if user want to remove the list and if there is only one item in the selected list
                state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
            }
            else {
                existingList.splice(index, 1);
                state.selectedListUrl = existingList;
            }
        }
    })
    .addCase(acceptListUpdate, (state, { payload: url }) => {
        var _a;
        if (!((_a = state.byUrl[url]) === null || _a === void 0 ? void 0 : _a.pendingUpdate)) {
            throw new Error('accept list update called without pending update');
        }
        state.byUrl[url] = Object.assign(Object.assign({}, state.byUrl[url]), { pendingUpdate: null, current: state.byUrl[url].pendingUpdate });
    })
    .addCase(updateVersion, (state) => {
        // state loaded from localStorage, but new lists have never been initialized
        if (!state.lastInitializedDefaultListOfLists) {
            state.byUrl = initialState$8.byUrl;
            state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
        }
        else if (state.lastInitializedDefaultListOfLists) {
            const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce((s, l) => s.add(l), new Set());
            const newListOfListsSet = DEFAULT_TOKEN_LISTS.reduce((s, l) => s.add(l), new Set());
            // Detected addition of default token lists
            DEFAULT_TOKEN_LISTS.forEach((listUrl) => {
                if (!lastInitializedSet.has(listUrl)) {
                    state.byUrl[listUrl] = NEW_LIST_STATE;
                    if (DEFAULT_TOKEN_LISTS_SELECTED.includes(listUrl)) {
                        if (!state.selectedListUrl || !state.selectedListUrl.includes(listUrl)) {
                            state.selectedListUrl = (state.selectedListUrl || []).concat([listUrl]);
                        }
                    }
                }
            });
            // Detected removal of default token lists
            state.lastInitializedDefaultListOfLists.forEach((listUrl) => {
                if (!newListOfListsSet.has(listUrl)) {
                    delete state.byUrl[listUrl];
                    if (!!state.selectedListUrl && state.selectedListUrl.includes(listUrl)) {
                        state.selectedListUrl = state.selectedListUrl.filter((url) => url !== listUrl);
                        if (state.selectedListUrl.length === 0) {
                            state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
                        }
                    }
                }
            });
        }
        state.lastInitializedDefaultListOfLists = DEFAULT_TOKEN_LISTS;
        if (!state.selectedListUrl) {
            state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
            DEFAULT_TOKEN_LISTS.forEach((listUrl) => {
                if (!state.byUrl[listUrl]) {
                    state.byUrl[listUrl] = NEW_LIST_STATE;
                }
            });
        }
    }));

var Field$1;
(function (Field) {
    Field["CURRENCY_A"] = "CURRENCY_A";
    Field["CURRENCY_B"] = "CURRENCY_B";
})(Field$1 || (Field$1 = {}));
const typeInput$1 = createAction('mint/typeInputMint');
const resetMintState = createAction('mint/resetMintState');

const initialState$7 = {
    independentField: Field$1.CURRENCY_A,
    typedValue: '',
    otherTypedValue: '',
};
var pmint = createReducer(initialState$7, (builder) => builder
    .addCase(resetMintState, () => initialState$7)
    .addCase(typeInput$1, (state, { payload: { field, typedValue, noLiquidity } }) => {
        if (noLiquidity) {
            // they're typing into the field they've last typed in
            if (field === state.independentField) {
                return Object.assign(Object.assign({}, state), { independentField: field, typedValue });
            }
            // they're typing into a new field, store the other value
            else {
                return Object.assign(Object.assign({}, state), { independentField: field, typedValue, otherTypedValue: state.typedValue });
            }
        }
        else {
            return Object.assign(Object.assign({}, state), { independentField: field, typedValue, otherTypedValue: '' });
        }
    }));

const ADDRESS_REGEX$1 = /^0x[a-fA-F0-9]{40}$/;
const LOWER_HEX_REGEX = /^0x[a-f0-9]*$/;
function toCallKey(call) {
    if (!ADDRESS_REGEX$1.test(call.address)) {
        throw new Error(`Invalid address: ${call.address}`);
    }
    if (!LOWER_HEX_REGEX.test(call.callData)) {
        throw new Error(`Invalid hex: ${call.callData}`);
    }
    return `${call.address}-${call.callData}`;
}
function parseCallKey(callKey) {
    const pcs = callKey.split('-');
    if (pcs.length !== 2) {
        throw new Error(`Invalid call key: ${callKey}`);
    }
    return {
        address: pcs[0],
        callData: pcs[1],
    };
}
const addMulticallListeners = createAction('pmulticall/addMulticallListeners');
const removeMulticallListeners = createAction('pmulticall/removeMulticallListeners');
const fetchingMulticallResults = createAction('pmulticall/fetchingMulticallResults');
const errorFetchingMulticallResults = createAction('pmulticall/errorFetchingMulticallResults');
const updateMulticallResults = createAction('pmulticall/updateMulticallResults');

const initialState$6 = {
    callResults: {},
};
var pmulticall = createReducer(initialState$6, (builder) => builder
    .addCase(addMulticallListeners, (state, { payload: { calls, chainId, options: { blocksPerFetch = 1 } = {} } }) => {
        var _a;
        const listeners = state.callListeners
            ? state.callListeners
            : (state.callListeners = {});
        listeners[chainId] = (_a = listeners[chainId]) !== null && _a !== void 0 ? _a : {};
        calls.forEach((call) => {
            var _a, _b;
            const callKey = toCallKey(call);
            listeners[chainId][callKey] = (_a = listeners[chainId][callKey]) !== null && _a !== void 0 ? _a : {};
            listeners[chainId][callKey][blocksPerFetch] = ((_b = listeners[chainId][callKey][blocksPerFetch]) !== null && _b !== void 0 ? _b : 0) + 1;
        });
    })
    .addCase(removeMulticallListeners, (state, { payload: { chainId, calls, options: { blocksPerFetch = 1 } = {} } }) => {
        const listeners = state.callListeners
            ? state.callListeners
            : (state.callListeners = {});
        if (!listeners[chainId])
            return;
        calls.forEach((call) => {
            const callKey = toCallKey(call);
            if (!listeners[chainId][callKey])
                return;
            if (!listeners[chainId][callKey][blocksPerFetch])
                return;
            if (listeners[chainId][callKey][blocksPerFetch] === 1) {
                delete listeners[chainId][callKey][blocksPerFetch];
            }
            else {
                listeners[chainId][callKey][blocksPerFetch]--;
            }
        });
    })
    .addCase(fetchingMulticallResults, (state, { payload: { chainId, fetchingBlockNumber, calls } }) => {
        var _a;
        state.callResults[chainId] = (_a = state.callResults[chainId]) !== null && _a !== void 0 ? _a : {};
        calls.forEach((call) => {
            var _a;
            const callKey = toCallKey(call);
            const current = state.callResults[chainId][callKey];
            if (!current) {
                state.callResults[chainId][callKey] = {
                    fetchingBlockNumber,
                };
            }
            else {
                if (((_a = current.fetchingBlockNumber) !== null && _a !== void 0 ? _a : 0) >= fetchingBlockNumber)
                    return;
                state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber;
            }
        });
    })
    .addCase(errorFetchingMulticallResults, (state, { payload: { fetchingBlockNumber, chainId, calls } }) => {
        var _a;
        state.callResults[chainId] = (_a = state.callResults[chainId]) !== null && _a !== void 0 ? _a : {};
        calls.forEach((call) => {
            const callKey = toCallKey(call);
            const current = state.callResults[chainId][callKey];
            if (!current)
                return; // only should be dispatched if we are already fetching
            if (current.fetchingBlockNumber === fetchingBlockNumber) {
                delete current.fetchingBlockNumber;
                current.data = null;
                current.blockNumber = fetchingBlockNumber;
            }
        });
    })
    .addCase(updateMulticallResults, (state, { payload: { chainId, results, blockNumber } }) => {
        var _a;
        state.callResults[chainId] = (_a = state.callResults[chainId]) !== null && _a !== void 0 ? _a : {};
        Object.keys(results).forEach((callKey) => {
            var _a;
            const current = state.callResults[chainId][callKey];
            if (((_a = current === null || current === void 0 ? void 0 : current.blockNumber) !== null && _a !== void 0 ? _a : 0) > blockNumber)
                return;
            state.callResults[chainId][callKey] = {
                data: results[callKey],
                blockNumber,
            };
        });
    }));

const updateMinichefStakingAllData = createAction('pstake/updateMinichefStakingAllData');
const updateMinichefStakingAllAprs = createAction('pstake/updateMinichefStakingAllAprs');
const updateMinichefStakingAllFarmsEarnedAmount = createAction('pstake/updateMinichefStakingAllFarmsEarnedAmount');

const initialState$5 = {
    minichefStakingData: {},
    aprs: {},
    earnedAmounts: {},
};
var SortingType$1;
(function (SortingType) {
    SortingType["totalStakedInUsd"] = "totalStakedInUsd";
    SortingType["totalApr"] = "totalApr";
})(SortingType$1 || (SortingType$1 = {}));
var pstake = createReducer(initialState$5, (builder) => builder
    .addCase(updateMinichefStakingAllData, (state, { payload: { data: { chainId, data }, }, }) => {
        // console.info('updateMinichefStakingAllData')
        const existingData = Object.assign(Object.assign({}, (state.minichefStakingData[chainId] || {})), data);
        state.minichefStakingData[chainId] = existingData;
    })
    .addCase(updateMinichefStakingAllAprs, (state, { payload: { data: { chainId, data }, }, }) => {
        // console.info('updateMinichefStakingALLAprs')
        state.aprs[chainId] = data;
    })
    .addCase(updateMinichefStakingAllFarmsEarnedAmount, (state, { payload: { data: { chainId, data }, }, }) => {
        // console.info('updateMinichefStakingAllFarmsEarnedAmount')
        state.earnedAmounts[chainId] = data;
    }));

var Field;
(function (Field) {
    Field["INPUT"] = "INPUT";
    Field["OUTPUT"] = "OUTPUT";
})(Field || (Field = {}));
var LimitField;
(function (LimitField) {
    LimitField["INPUT"] = "input";
    LimitField["OUTPUT"] = "output";
    LimitField["PRICE"] = "price";
})(LimitField || (LimitField = {}));
var LimitNewField;
(function (LimitNewField) {
    LimitNewField["INPUT"] = "INPUT";
    LimitNewField["OUTPUT"] = "OUTPUT";
    LimitNewField["PRICE"] = "PRICE";
})(LimitNewField || (LimitNewField = {}));
const selectCurrency = createAction('pswap/selectCurrency');
const switchCurrencies = createAction('pswap/switchCurrencies');
const typeInput = createAction('pswap/typeInput');
const replaceSwapState = createAction('pswap/replaceSwapState');
const setRecipient = createAction('pswap/setRecipient');
const updateFeeTo = createAction('pswap/updateFeeTo');
const updateFeeInfo = createAction('pswap/updateFeeInfo');

const initialState$4 = {
    independentField: Field.INPUT,
    typedValue: '',
    [Field.INPUT]: {
        currencyId: '',
    },
    [Field.OUTPUT]: {
        currencyId: '',
    },
    recipient: null,
    feeTo: ZERO_ADDRESS,
    feeInfo: {
        feePartner: 0,
        feeProtocol: 0,
        feeTotal: 0,
        feeCut: 5000,
        initialized: false,
    },
};
var pswap = createReducer(initialState$4, (builder) => builder
    .addCase(replaceSwapState, (state, { payload: { typedValue, recipient, field, inputCurrencyId, outputCurrencyId } }) => {
        return Object.assign(Object.assign({}, state), {
            [Field.INPUT]: {
                currencyId: inputCurrencyId,
            }, [Field.OUTPUT]: {
                currencyId: outputCurrencyId,
            }, independentField: field, typedValue: typedValue, recipient
        });
    })
    .addCase(selectCurrency, (state, { payload: { currencyId, field } }) => {
        const otherField = field === Field.INPUT ? Field.OUTPUT : Field.INPUT;
        if (currencyId === state[otherField].currencyId) {
            // the case where we have to swap the order
            return Object.assign(Object.assign({}, state), { independentField: state.independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT, [field]: { currencyId: currencyId }, [otherField]: { currencyId: state[field].currencyId } });
        }
        else {
            // the normal case
            return Object.assign(Object.assign({}, state), { [field]: { currencyId: currencyId } });
        }
    })
    .addCase(switchCurrencies, (state) => {
        return Object.assign(Object.assign({}, state), { independentField: state.independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT, [Field.INPUT]: { currencyId: state[Field.OUTPUT].currencyId }, [Field.OUTPUT]: { currencyId: state[Field.INPUT].currencyId } });
    })
    .addCase(typeInput, (state, { payload: { field, typedValue } }) => {
        return Object.assign(Object.assign({}, state), { independentField: field, typedValue });
    })
    .addCase(setRecipient, (state, { payload: { recipient } }) => {
        state.recipient = recipient;
    })
    .addCase(updateFeeTo, (state, { payload: { feeTo } }) => {
        state.feeTo = feeTo;
    })
    .addCase(updateFeeInfo, (state, { payload: { feeInfo } }) => {
        state.feeInfo = feeInfo;
    }));

const updateTokenWeeklyPriceChartData = createAction('token/updateTokenWeeklyPriceChartData');
const updateTokenPriceChartData = createAction('token/updateTokenPriceChartData');

const initialState$3 = {
    weekly: {},
    tokenPrices: {},
};
var ptoken = createReducer(initialState$3, (builder) => builder
    .addCase(updateTokenWeeklyPriceChartData, (state, { payload: { address, chartData } }) => {
        const container = {};
        container[address] = chartData;
        const existingChartData = Object.assign(Object.assign({}, (state.weekly || {})), container);
        state.weekly = existingChartData;
    })
    .addCase(updateTokenPriceChartData, (state, { payload: { address, chartData } }) => {
        const container = {};
        container[address] = chartData;
        const existingChartData = Object.assign(Object.assign({}, (state.tokenPrices || {})), container);
        state.tokenPrices = existingChartData;
    }));

const addTransaction = createAction('ptransactions/addTransaction');
const clearAllTransactions = createAction('ptransactions/clearAllTransactions');
const finalizeTransaction = createAction('ptransactions/finalizeTransaction');
const checkedTransaction = createAction('ptransactions/checkedTransaction');

const now = () => new Date().getTime();
const initialState$2 = {};
var ptransactions = createReducer(initialState$2, (builder) => builder
    .addCase(addTransaction, (transactions, { payload: { chainId, from, hash, approval, summary, claim } }) => {
        var _a, _b;
        // if transaction is already exist then do nothing
        if ((_a = transactions[chainId]) === null || _a === void 0 ? void 0 : _a[hash]) {
            return;
        }
        const txs = (_b = transactions[chainId]) !== null && _b !== void 0 ? _b : {};
        txs[hash] = { hash, approval, summary, claim, from, addedTime: now() };
        transactions[chainId] = txs;
    })
    .addCase(clearAllTransactions, (transactions, { payload: { chainId } }) => {
        if (!transactions[chainId])
            return;
        transactions[chainId] = {};
    })
    .addCase(checkedTransaction, (transactions, { payload: { chainId, hash, blockNumber } }) => {
        var _a;
        const tx = (_a = transactions[chainId]) === null || _a === void 0 ? void 0 : _a[hash];
        if (!tx) {
            return;
        }
        if (!tx.lastCheckedBlockNumber) {
            tx.lastCheckedBlockNumber = blockNumber;
        }
        else {
            tx.lastCheckedBlockNumber = Math.max(blockNumber, tx.lastCheckedBlockNumber);
        }
    })
    .addCase(finalizeTransaction, (transactions, { payload: { hash, chainId, receipt } }) => {
        var _a;
        const tx = (_a = transactions[chainId]) === null || _a === void 0 ? void 0 : _a[hash];
        if (!tx) {
            return;
        }
        tx.receipt = receipt;
        tx.confirmedTime = now();
    }));

const updateUserSlippageTolerance = createAction('puser/updateUserSlippageTolerance');
const updateUserExpertMode = createAction('puser/updateUserExpertMode');
const updateUserDeadline = createAction('puser/updateUserDeadline');
const addSerializedToken = createAction('puser/addSerializedToken');
const removeSerializedToken = createAction('puser/removeSerializedToken');
const addSerializedPair = createAction('puser/addSerializedPair');

const currentTimestamp = () => new Date().getTime();
function pairKey(token0Address, token1Address) {
    return `${token0Address};${token1Address}`;
}
const initialState$1 = {
    userSlippageTolerance: INITIAL_ALLOWED_SLIPPAGE,
    tokens: {},
    timestamp: currentTimestamp(),
    userExpertMode: false,
    userDeadline: DEFAULT_DEADLINE_FROM_NOW,
    pairs: {},
};
var puser = createReducer(initialState$1, (builder) => builder
    .addCase(updateUserSlippageTolerance, (state, action) => {
        state.userSlippageTolerance = action.payload.userSlippageTolerance;
        state.timestamp = currentTimestamp();
    })
    .addCase(updateUserExpertMode, (state, action) => {
        state.userExpertMode = action.payload.userExpertMode;
        state.timestamp = currentTimestamp();
    })
    .addCase(updateUserDeadline, (state, action) => {
        state.userDeadline = action.payload.userDeadline;
        state.timestamp = currentTimestamp();
    })
    .addCase(addSerializedToken, (state, { payload: { serializedToken } }) => {
        state.tokens[serializedToken.chainId] = state.tokens[serializedToken.chainId] || {};
        state.tokens[serializedToken.chainId][serializedToken.address] = serializedToken;
        state.timestamp = currentTimestamp();
    })
    .addCase(removeSerializedToken, (state, { payload: { address, chainId } }) => {
        state.tokens[chainId] = state.tokens[chainId] || {};
        delete state.tokens[chainId][address];
        state.timestamp = currentTimestamp();
    })
    .addCase(addSerializedPair, (state, { payload: { serializedPair } }) => {
        if (serializedPair.token0.chainId === serializedPair.token1.chainId &&
            serializedPair.token0.address !== serializedPair.token1.address) {
            state.pairs = state.pairs || {};
            const chainId = serializedPair.token0.chainId;
            state.pairs[chainId] = state.pairs[chainId] || {};
            state.pairs[chainId][pairKey(serializedPair.token0.address, serializedPair.token1.address)] = serializedPair;
        }
        state.timestamp = currentTimestamp();
    }));

const addCurrency = createAction('watchlists/addCurrency');
const removeCurrency = createAction('watchlists/removeCurrency');

const initialState = {
    currencies: [],
};
var pwatchlists = createReducer(initialState, (builder) => builder
    .addCase(addCurrency, (state, { payload: address }) => {
        const existingSelectedListUrl = [].concat(state.currencies || []);
        existingSelectedListUrl.push(address);
        state.currencies = existingSelectedListUrl;
    })
    .addCase(removeCurrency, (state, { payload: address }) => {
        const existingList = [].concat(state.currencies || []);
        const index = existingList.indexOf(address);
        if (index !== -1) {
            if ((existingList === null || existingList === void 0 ? void 0 : existingList.length) === 1) {
                // if user want to remove the list and if there is only one item in the selected list
                state.currencies = [];
            }
            else {
                existingList.splice(index, 1);
                state.currencies = existingList;
            }
        }
    }));

const PANGOLIN_PERSISTED_KEYS = [
    'puser',
    'plists',
    'ptransactions',
    'pwatchlists',
    'ptoken',
    'pstake',
];
const pangolinReducers = {
    papplication,
    ptransactions,
    pswap,
    plists,
    pmulticall,
    puser,
    pwatchlists,
    ptoken,
    pstake,
    pmint,
    pburn,
};
const store = configureStore({
    reducer: pangolinReducers,
    middleware: [...getDefaultMiddleware({ thunk: false }), save({ states: PANGOLIN_PERSISTED_KEYS })],
    preloadedState: load({ states: PANGOLIN_PERSISTED_KEYS }),
});
const StoreContext = React.createContext(null);
// Export your custom hooks if you wish to use them in other files.
createStoreHook(StoreContext);
const useDispatch = createDispatchHook(StoreContext);
const useSelector = createSelectorHook(StoreContext);
/**
 * create separate galeto store
 */
const galetoStore = configureStore({
    reducer: gelatoReducers,
    middleware: [...getDefaultMiddleware({ thunk: false }), save({ states: GELATO_PERSISTED_KEYS })],
    preloadedState: load({ states: GELATO_PERSISTED_KEYS }),
});

function useBlockNumber() {
    const chainId = useChainId();
    return useSelector((state) => { var _a, _b; return (_b = (_a = state === null || state === void 0 ? void 0 : state.papplication) === null || _a === void 0 ? void 0 : _a.blockNumber) === null || _b === void 0 ? void 0 : _b[chainId]; });
}
function useModalOpen(modal) {
    const openModal = useSelector((state) => state.papplication.openModal);
    return openModal === modal;
}
function useToggleModal(modal) {
    const open = useModalOpen(modal);
    const dispatch = useDispatch();
    return useCallback(() => dispatch(setOpenModal(open ? null : modal)), [dispatch, modal, open]);
}
function useWalletModalToggle() {
    return useToggleModal(ApplicationModal.WALLET);
}
function usePoolDetailnModalToggle() {
    return useToggleModal(ApplicationModal.POOL_DETAIL);
}
// returns a function that allows adding a popup
function useAddPopup() {
    const dispatch = useDispatch();
    return useCallback((content, key) => {
        dispatch(addPopup({ content, key }));
    }, [dispatch]);
}
// returns a function that allows removing a popup via its key
function useRemovePopup() {
    const dispatch = useDispatch();
    return useCallback((key) => {
        dispatch(removePopup({ key }));
    }, [dispatch]);
}
// get the list of active popups
function useActivePopups() {
    const list = useSelector((state) => state.papplication.popupList);
    return useMemo(() => list.filter((item) => item.show), [list]);
}

function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
function waitRandom(min, max) {
    return wait(min + Math.round(Math.random() * Math.max(0, max - min)));
}
/**
 * This error is thrown if the function is cancelled before completing
 */
class CancelledError extends Error {
    constructor() {
        super('Cancelled');
    }
}
/**
 * Throw this error if the function should retry
 */
class RetryableError extends Error {
}
/**
 * Retries the function that returns the promise until the promise successfully resolves up to n retries
 * @param fn function to retry
 * @param n how many times to retry
 * @param minWait min wait between retries in ms
 * @param maxWait max wait between retries in ms
 */
function retry(fn, { n, minWait, maxWait }) {
    let completed = false;
    let rejectCancelled;
    const promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        rejectCancelled = reject;
        while (true) {
            let result;
            try {
                result = yield fn();
                if (!completed) {
                    resolve(result);
                    completed = true;
                }
                break;
            }
            catch (error) {
                if (completed) {
                    break;
                }
                if (n <= 0 || !(error instanceof RetryableError)) {
                    reject(error);
                    completed = true;
                    break;
                }
                n--;
            }
            yield waitRandom(minWait, maxWait);
        }
    }));
    return {
        promise,
        cancel: () => {
            if (completed)
                return;
            completed = true;
            rejectCancelled(new CancelledError());
        },
    };
}

var _a, _b, _c, _d, _e, _f, _g;
// returns the checksummed address if the address is valid, otherwise returns false
function isAddress(value) {
    try {
        return getAddress(value);
    }
    catch (_a) {
        return false;
    }
}
const ETHERSCAN_PREFIXES = {
    43113: ((_a = CHAINS[ChainId.FUJI].blockExplorerUrls) === null || _a === void 0 ? void 0 : _a[0]) || '',
    43114: ((_b = CHAINS[ChainId.AVALANCHE].blockExplorerUrls) === null || _b === void 0 ? void 0 : _b[0]) || '',
    11111: ((_c = CHAINS[ChainId.WAGMI].blockExplorerUrls) === null || _c === void 0 ? void 0 : _c[0]) || '',
    16: ((_d = CHAINS[ChainId.COSTON].blockExplorerUrls) === null || _d === void 0 ? void 0 : _d[0]) || '',
    19: ((_e = CHAINS[ChainId.SONGBIRD].blockExplorerUrls) === null || _e === void 0 ? void 0 : _e[0]) || '',
    329847900: ((_f = CHAINS[ChainId.NEAR_MAINNET].blockExplorerUrls) === null || _f === void 0 ? void 0 : _f[0]) || '',
    329847901: ((_g = CHAINS[ChainId.NEAR_TESTNET].blockExplorerUrls) === null || _g === void 0 ? void 0 : _g[0]) || '',
};
const transactionPath = {
    [ChainId.FUJI]: 'tx',
    [ChainId.AVALANCHE]: 'tx',
    [ChainId.WAGMI]: 'tx',
    [ChainId.COSTON]: 'tx',
    [ChainId.SONGBIRD]: 'tx',
    [ChainId.NEAR_MAINNET]: 'transactions',
    [ChainId.NEAR_TESTNET]: 'transactions',
};
const addressPath = {
    [ChainId.FUJI]: 'address',
    [ChainId.AVALANCHE]: 'address',
    [ChainId.WAGMI]: 'address',
    [ChainId.COSTON]: 'address',
    [ChainId.SONGBIRD]: 'address',
    [ChainId.NEAR_MAINNET]: 'accounts',
    [ChainId.NEAR_TESTNET]: 'accounts',
};
const blockPath = {
    [ChainId.FUJI]: 'block',
    [ChainId.AVALANCHE]: 'block',
    [ChainId.WAGMI]: 'block',
    [ChainId.COSTON]: 'block',
    [ChainId.SONGBIRD]: 'block',
    [ChainId.NEAR_MAINNET]: 'blocks',
    [ChainId.NEAR_TESTNET]: 'blocks',
};
const tokenPath = {
    [ChainId.FUJI]: 'token',
    [ChainId.AVALANCHE]: 'token',
    [ChainId.WAGMI]: 'token',
    [ChainId.COSTON]: 'token',
    [ChainId.SONGBIRD]: 'token',
    [ChainId.NEAR_MAINNET]: 'accounts',
    [ChainId.NEAR_TESTNET]: 'accounts',
};
function getEtherscanLink(chainId, data, type) {
    const prefix = `${ETHERSCAN_PREFIXES[chainId] || ETHERSCAN_PREFIXES[43114]}`;
    switch (type) {
        case 'transaction': {
            return `${prefix}/${transactionPath[chainId]}/${data}`;
        }
        case 'token': {
            return `${prefix}/${tokenPath[chainId]}/${data}`;
        }
        case 'block': {
            return `${prefix}/${blockPath[chainId]}/${data}`;
        }
        case 'address':
        default: {
            return `${prefix}/${addressPath[chainId]}/${data}`;
        }
    }
}
// shorten the checksummed version of the input address to have 0x + 4 characters at start and end
function shortenAddress(address, chainId = ChainId.AVALANCHE, chars = 4) {
    const parsed = isEvmChain(chainId) ? isAddress(address) : address;
    if (!parsed) {
        throw Error(`Invalid 'address' parameter '${address}'.`);
    }
    return `${parsed.substring(0, chars)}...${parsed.substring(parsed.length - chars)}`;
}
// add 10%
function calculateGasMargin(value) {
    return value.mul(BigNumber.from(10000).add(BigNumber.from(1000))).div(BigNumber.from(10000));
}
// converts a basis points value to a sdk percent
function basisPointsToPercent(num) {
    return new Percent$1(JSBI$1.BigInt(num), JSBI$1.BigInt(10000));
}
// account is not optional
function getSigner(library, account) {
    return library.getSigner(account).connectUnchecked();
}
// account is optional
function getProviderOrSigner(library, account) {
    return account ? getSigner(library, account) : library;
}
// account is optional
function getContract(address, ABI, library, account) {
    if (!isAddress(address) || address === AddressZero) {
        return null;
    }
    return new Contract(address, ABI, getProviderOrSigner(library, account));
}
// account is optional
function getRouterContract(chainId, library, account) {
    return getContract(ROUTER_ADDRESS[chainId], IArcanumRouter.abi, library, account);
}
function getRouterContractDaaS(chainId, library, account) {
    return getContract(ROUTER_DAAS_ADDRESS[chainId], IArcanumRouterSupportingFees.abi, library, account);
}
function isTokenOnList(defaultTokens, chainId, currency) {
    var _a;
    if (chainId && currency === CAVAX[chainId])
        return true;
    return Boolean(currency instanceof Token$1 && ((_a = defaultTokens[currency.chainId]) === null || _a === void 0 ? void 0 : _a[currency.address]));
}
/**
 * Returns true if the trade requires a confirmation of details before we can submit it
 * @param tradeA trade A
 * @param tradeB trade B
 */
function tradeMeaningfullyDiffers(tradeA, tradeB) {
    return (tradeA.tradeType !== tradeB.tradeType ||
        !currencyEquals(tradeA.inputAmount.currency, tradeB.inputAmount.currency) ||
        !tradeA.inputAmount.equalTo(tradeB.inputAmount) ||
        !currencyEquals(tradeA.outputAmount.currency, tradeB.outputAmount.currency) ||
        !tradeA.outputAmount.equalTo(tradeB.outputAmount));
}
function getChainByNumber(chainId) {
    return ALL_CHAINS.find((chain) => chain.chain_id === chainId);
}
function calculateSlippageAmount(value, slippage) {
    if (slippage < 0 || slippage > 10000) {
        throw Error(`Unexpected slippage value: ${slippage}`);
    }
    return [
        JSBI$1.divide(JSBI$1.multiply(value.raw, JSBI$1.BigInt(10000 - slippage)), JSBI$1.BigInt(10000)),
        JSBI$1.divide(JSBI$1.multiply(value.raw, JSBI$1.BigInt(10000 + slippage)), JSBI$1.BigInt(10000)),
    ];
}
// check if exist address of sar contract of a certain chain
function existSarContract(chainId) {
    return SAR_STAKING_ADDRESS[chainId] !== undefined;
}
// https://github.com/ethers-io/ethers.js/issues/945#issuecomment-1074683436
// wait for transaction confirmation or set timeout
function waitForTransaction(tx, confirmations, timeout = 10000) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.race([
            tx.wait(confirmations),
            (() => __awaiter(this, void 0, void 0, function* () {
                yield wait(timeout);
            }))(),
        ]);
    });
}
function getBuyUrl(token, chainId) {
    const origin = window.location.origin;
    const path = `/#/swap?inputCurrency=${chainId ? CAVAX[chainId].symbol : ZERO_ADDRESS}&outputCurrency=${token.address}`;
    return origin.includes('localhost') || origin.includes('pangolin.exchange') ? path : `app.pangolin.exchange${path}`;
}
// some browsers do not support scrollIntoView
// https://stackoverflow.com/a/50411076/18268694
function scrollElementIntoView(element, behavior) {
    if (element) {
        const scrollTop = window.scrollY || element.scrollTop;
        const finalOffset = element.getBoundingClientRect().top + scrollTop;
        window.parent.scrollTo({
            top: finalOffset,
            behavior: behavior || 'auto',
        });
    }
}
function isEvmChain(chainId = 43114) {
    var _a;
    if ((_a = CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.evm) {
        return true;
    }
    return false;
}
// http://jsfiddle.net/5QrhQ/5/
function decimalToFraction(number) {
    const gcd = (a, b) => {
        if (b < 0.0000001)
            return a; // Since there is a limited precision we need to limit the value.
        return gcd(b, Math.floor(a % b)); // Discard any fractions due to limitations in precision.
    };
    const len = number.toString().length - 2;
    let denominator = Math.pow(10, len);
    let numerator = number * denominator;
    const divisor = gcd(numerator, denominator);
    numerator /= divisor;
    denominator /= divisor;
    return new Fraction$1(Math.floor(numerator).toString(), Math.floor(denominator).toString());
}

const initialWeb3State = {
    library: undefined,
    chainId: undefined,
    account: undefined,
};
const Web3Context = createContext({});
const usePangolinWeb3 = () => {
    const context = useContext(Web3Context);
    if (context === undefined) {
        throw new Error('usePangolinWeb3 must be used within a component wrapped with PangolinWeb3Provider');
    }
    return context;
};
const PangolinWeb3Provider = ({ children, library, chainId, account, }) => {
    const [state, setState] = useState(initialWeb3State);
    useEffect(() => {
        var _a;
        let normalizedAccount;
        if (chainId) {
            normalizedAccount = ((_a = CHAINS === null || CHAINS === void 0 ? void 0 : CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.evm) ? isAddress(account) : account;
        }
        setState({
            library,
            chainId: chainId || ChainId.AVALANCHE,
            account: normalizedAccount,
        });
    }, [library, chainId, account]);
    return (jsx(Web3Context.Provider, Object.assign({ value: Object.assign({}, state) }, { children: children })));
};
const useChainId = () => {
    const { chainId } = usePangolinWeb3();
    return (chainId || ChainId.AVALANCHE);
};
// library -> web3.js
// provider -> ethers.js
// extendedProvider -> extended library
function useLibrary() {
    const [result, setResult] = useState({});
    const { connector } = useWeb3React();
    const chainId = useChainId();
    const { library: userProvidedLibrary } = usePangolinWeb3();
    useEffect(() => {
        function load() {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                // const walletKey = Object.keys(SUPPORTED_WALLETS).find(
                //   (key) => SUPPORTED_WALLETS[key].connector === connector,
                // ) as string;
                const web3jsProvider = (yield (connector === null || connector === void 0 ? void 0 : connector.getProvider())) || userProvidedLibrary || window.ethereum;
                const finalWeb3jsProvider = web3jsProvider || window.ethereum;
                const extendedWeb3Provider = finalWeb3jsProvider && ((_b = (_a = PROVIDER_MAPPING)[chainId]) === null || _b === void 0 ? void 0 : _b.call(_a, finalWeb3jsProvider));
                let finalEthersLibrary;
                try {
                    finalEthersLibrary = new Web3Provider(finalWeb3jsProvider, 'any');
                }
                catch (error) {
                    finalEthersLibrary = finalWeb3jsProvider;
                }
                setResult({ library: finalEthersLibrary, provider: extendedWeb3Provider });
            });
        }
        load();
    }, [connector]);
    return result;
}
const useRefetchMinichefSubgraph = () => {
    const { account } = usePangolinWeb3();
    const queryClient = useQueryClient();
    return () => __awaiter(void 0, void 0, void 0, function* () { return yield queryClient.refetchQueries(['get-minichef-farms-v2', account]); });
};
function useGetBlockTimestamp(blockNumber) {
    const latestBlockNumber = useBlockNumber();
    const _blockNumber = blockNumber !== null && blockNumber !== void 0 ? blockNumber : latestBlockNumber;
    const { provider } = useLibrary();
    const [timestamp, setTimestamp] = useState(undefined);
    const getTimestamp = useMemo(() => __awaiter(this, void 0, void 0, function* () {
        if (!_blockNumber || !provider)
            return;
        const result = yield (provider === null || provider === void 0 ? void 0 : provider.getBlockTimestamp(_blockNumber));
        return result;
    }), [_blockNumber, provider]);
    useEffect(() => {
        const getResult = () => __awaiter(this, void 0, void 0, function* () {
            const result = yield getTimestamp;
            setTimestamp(result);
        });
        getResult();
    }, [_blockNumber, getTimestamp]);
    return timestamp;
}

const getTokenLogoURL = (address, chainId, size = 24) => `${PANGOLIN_TOKENS_REPO_RAW_BASE_URL}/main/assets/${chainId}/${address}/logo_${size}.png`;

const BAD_SRCS = {};
const Logo$1 = (_a) => {
    var { srcs, alt } = _a, rest = __rest(_a, ["srcs", "alt"]);
    const [, refresh] = useState(0);
    const src = srcs.find((srcVal) => !BAD_SRCS[srcVal]);
    if (src) {
        return (jsx("img", Object.assign({}, rest, {
            alt: alt, src: src, onError: () => {
                BAD_SRCS[src] = true;
                refresh((i) => i + 1);
            }
        })));
    }
    return jsx(HelpCircle, Object.assign({}, rest));
};

const StyledLogo = styled(Logo$1)`
  width: ${({ size }) => size};
  height: ${({ size }) => size};
  border-radius: ${({ size }) => size};
  /* box-shadow: 0px 6px 10px rgba(0, 0, 0, 0.075); */
`;

function CurrencyLogo({ currency, size = 24, style, imageSize = size, }) {
    var _a;
    const chainId = useChainId();
    const srcs = useMemo(() => {
        if (currency === CAVAX[ChainId.AVALANCHE] ||
            currency === CAVAX[ChainId.WAGMI] ||
            currency === CAVAX[ChainId.COSTON] ||
            currency === CAVAX[ChainId.SONGBIRD] ||
            currency === CAVAX[ChainId.NEAR_TESTNET] ||
            currency === CAVAX[ChainId.NEAR_MAINNET])
            return [];
        if (currency instanceof Token$1 || !!currency.address) {
            const primarySrc = getTokenLogoURL(currency === null || currency === void 0 ? void 0 : currency.address, chainId, imageSize);
            return [primarySrc];
        }
        return [];
    }, [currency]);
    if (deepEqual(currency, CAVAX[ChainId.AVALANCHE])) {
        return jsx(AvaxLogo, { size: `${size}px` });
    }
    else if (deepEqual(currency, CAVAX[ChainId.WAGMI])) {
        return jsx("img", { src: WgmiLogo, width: `${size}px`, height: `${size}px` });
    }
    else if (deepEqual(currency, CAVAX[ChainId.COSTON])) {
        return jsx(CflrLogo, { size: `${size}px` });
    }
    else if (deepEqual(currency, CAVAX[ChainId.NEAR_TESTNET]) || deepEqual(currency, CAVAX[ChainId.NEAR_MAINNET])) {
        return jsx("img", { src: NearLogo, width: `${size}px`, height: `${size}px` });
    }
    else if (deepEqual(currency, CAVAX[ChainId.SONGBIRD])) {
        return jsx("img", { src: SongBirdLogo, width: `${size}px`, height: `${size}px` });
    }
    return jsx(StyledLogo, { size: `${size}px`, srcs: srcs, alt: `${(_a = currency === null || currency === void 0 ? void 0 : currency.symbol) !== null && _a !== void 0 ? _a : 'token'} logo`, style: style });
}

const Wrapper$d = styled.div`
  position: relative;
  display: flex;
  flex-direction: row;
  align-items: center;
  margin-right: ${({ sizeraw, margin }) => margin && (sizeraw / 3 + 8).toString() + 'px'};
`;
const HigherLogo = styled(CurrencyLogo)`
  z-index: 2;
`;
const CoveredLogo$1 = styled(CurrencyLogo)`
  position: absolute;
  left: ${({ sizeraw }) => '-' + (sizeraw / 2).toString() + 'px'} !important;
`;

const DoubleCurrencyLogo = ({ currency0, currency1, size = 24, margin = false }) => {
    return (jsxs(Wrapper$d, Object.assign({ sizeraw: size, margin: margin }, { children: [currency0 && jsx(HigherLogo, { currency: currency0, size: size }), currency1 && (jsx(Box, Object.assign({ ml: '-5px', display: 'flex' }, { children: jsx(CoveredLogo$1, { currency: currency1, size: size, sizeraw: size }) })))] })));
};

const CurrencySelect = styled.button`
  align-items: center;
  height: 100%;
  font-size: 20px;
  font-weight: 500;
  background-color: ${({ selected, theme }) => { var _a, _b; return selected ? (_a = theme.currencySelect) === null || _a === void 0 ? void 0 : _a.selectedBackgroundColor : (_b = theme.currencySelect) === null || _b === void 0 ? void 0 : _b.defaultBackgroundColor; }};
  color: ${({ selected, theme }) => { var _a, _b; return selected ? (_a = theme.currencySelect) === null || _a === void 0 ? void 0 : _a.selectedText : (_b = theme.currencySelect) === null || _b === void 0 ? void 0 : _b.defaultText; }};
  border-radius: 12px;
  box-shadow: ${({ selected }) => (selected ? 'none' : '0px 6px 10px rgba(0, 0, 0, 0.075)')};
  outline: none;
  cursor: pointer;
  user-select: none;
  border: none;
  padding: 0 0.5rem;

  /* :focus,
  :hover {
    background-color: ${({ selected, theme }) => (selected ? theme.bg2 : darken(0.05, theme.primary))};
  } */

  ${({ buttonStyle }) => buttonStyle}
`;
const Aligner = styled.span`
  display: flex;
  align-items: center;
  justify-content: space-between;
  color: inherit;
  svg {
    stroke: ${({ active, theme }) => { var _a, _b; return (active ? (_a = theme.currencySelect) === null || _a === void 0 ? void 0 : _a.selectedText : (_b = theme.currencySelect) === null || _b === void 0 ? void 0 : _b.defaultText); }};
  }
`;
const StyledTokenName = styled.span`
  ${({ active }) => (active ? '  margin: 0 0.25rem 0 0.75rem;' : '  margin: 0 0.25rem 0 0.25rem;')}
  font-size:  ${({ active }) => (active ? '20px' : '16px')};
  color: inherit;
`;

const CurrencyInput = (_a) => {
    var { buttonStyle, pair, currency, isShowTextInput = true, onTokenClick } = _a, rest = __rest(_a, ["buttonStyle", "pair", "currency", "isShowTextInput", "onTokenClick"]);
    const renderCurrency = () => {
        if (pair) {
            return jsx(DoubleCurrencyLogo, { currency0: pair.token0, currency1: pair.token1, size: 24, margin: true });
        }
        else if (currency) {
            return jsx(CurrencyLogo, { currency: currency, size: 24, imageSize: 48 });
        }
        else {
            return null;
        }
    };
    const renderStyletoken = () => {
        if (pair) {
            return (jsxs(StyledTokenName, Object.assign({ className: "pair-name-container" }, { children: [pair === null || pair === void 0 ? void 0 : pair.token0.symbol, ":", pair === null || pair === void 0 ? void 0 : pair.token1.symbol] })));
        }
        else
            return (jsx(StyledTokenName, Object.assign({ className: "token-symbol-container", active: Boolean(currency && currency.symbol) }, {
                children: (currency && currency.symbol && currency.symbol.length > 20
                    ? currency.symbol.slice(0, 4) +
                    '...' +
                    currency.symbol.slice(currency.symbol.length - 5, currency.symbol.length)
                    : currency === null || currency === void 0 ? void 0 : currency.symbol) || 'Select Token'
            })));
    };
    const addonAfter = () => {
        return (jsx(CurrencySelect, Object.assign({
            selected: !!currency, className: "open-currency-select-button", onClick: () => {
                onTokenClick && onTokenClick();
            }, buttonStyle: buttonStyle
        }, { children: jsxs(Aligner, Object.assign({ active: Boolean(currency && currency.symbol) }, { children: [renderCurrency(), renderStyletoken(), jsx(ChevronDown, { color: !Boolean(currency && currency.symbol) ? 'black' : undefined })] })) })));
    };
    return jsxs(Box, { children: [isShowTextInput ? jsx(TextInput, Object.assign({}, rest, { addonAfter: addonAfter() })) : addonAfter(), " "] });
};

const Tooltip = (props) => {
    return jsx(ReactTooltip, Object.assign({}, props));
};

const Root$l = styled.div`
  width: 100%;
  position: relative;
`;

const Collapsed = (props) => {
    const { getCollapseProps, getToggleProps, isExpanded } = useCollapse();
    return (jsxs(Root$l, { children: [jsx("div", Object.assign({}, getToggleProps(), { children: isExpanded ? props.collapse || 'Collapse' : props.expand || 'Expand' })), jsx("section", Object.assign({}, getCollapseProps(), { children: props.children }))] }));
};

const Root$k = styled.div`
  flex-direction: row;
  display: inline-flex;
  background: ${({ theme }) => { var _a; return (_a = theme.toggleButton) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  border-radius: 4px;
  align-items: center;
  padding: 2px;
  width: 100%;
  box-sizing: border-box;
`;
const TextButton = styled.div`
  margin-right: 4px;
  background: ${({ theme, selected }) => { var _a, _b; return selected ? (_a = theme.toggleButton) === null || _a === void 0 ? void 0 : _a.selectedColor : (_b = theme.toggleButton) === null || _b === void 0 ? void 0 : _b.backgroundColor; }};
  color: ${({ theme }) => { var _a; return (_a = theme.toggleButton) === null || _a === void 0 ? void 0 : _a.fontColor; }};
  border-radius: 4px;
  padding: 3px 5px;
  cursor: pointer;
  text-align: center;
  width: 100%;

  &:last-child {
    margin-right: 0px;
  }
`;

const ToggleButtons = (props) => {
    const { value, onChange, options } = props;
    return (jsx(Root$k, {
        children: (options || []).map((option, i) => (jsx(TextButton, Object.assign({
            selected: option === value, onClick: () => {
                onChange && onChange(option);
            }
        }, { children: option }), i)))
    }));
};

const PendingWrapper = styled(Box)`
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  height: ${({ height }) => height};
`;
const Loader = (props) => {
    const { size, label, height } = props;
    return (jsx(PendingWrapper, Object.assign({ height: height || '100%' }, { children: jsxs(Box, Object.assign({ mb: '15px', display: "flex", alignItems: "center", flexDirection: "column" }, { children: [jsxs(Box, Object.assign({ width: size, height: size, position: "relative", display: "flex", alignItems: "center", justifyContent: "center" }, { children: [jsx(Loading, {}), jsx(Box, Object.assign({ position: "absolute" }, { children: jsx(LogoIcon, {}) }))] })), label && (jsx(Text, Object.assign({ color: "loader.text", fontWeight: 500, fontSize: 20, textAlign: "center", mt: 10 }, { children: label })))] })) })));
};

/**
 * Token instances created from token info.
 */
class WrappedTokenInfo extends Token$1 {
    constructor(tokenInfo, tags) {
        super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name);
        this.tokenInfo = tokenInfo;
        this.tags = tags;
    }
    get logoURI() {
        return this.tokenInfo.logoURI;
    }
}
/**
 * An empty result, useful as a default.
 */
const EMPTY_LIST = {
    [ChainId.FUJI]: {},
    [ChainId.AVALANCHE]: {},
    [ChainId.WAGMI]: {},
    [ChainId.COSTON]: {},
    [ChainId.SONGBIRD]: {},
    [ChainId.NEAR_MAINNET]: {},
    [ChainId.NEAR_TESTNET]: {},
};
const listCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;
function listToTokenMap(list) {
    const result = listCache === null || listCache === void 0 ? void 0 : listCache.get(list);
    if (result)
        return result;
    const map = list.tokens.reduce((tokenMap, tokenInfo) => {
        var _a, _b, _c, _d;
        const tags = (_c = (_b = (_a = tokenInfo.tags) === null || _a === void 0 ? void 0 : _a.map((tagId) => {
            var _a;
            if (!((_a = list.tags) === null || _a === void 0 ? void 0 : _a[tagId]))
                return undefined;
            return Object.assign(Object.assign({}, list.tags[tagId]), { id: tagId });
        })) === null || _b === void 0 ? void 0 : _b.filter((x) => Boolean(x))) !== null && _c !== void 0 ? _c : [];
        if (!CHAINS[tokenInfo.chainId]) {
            return tokenMap;
        }
        const token = new WrappedTokenInfo(tokenInfo, tags);
        if (((_d = tokenMap === null || tokenMap === void 0 ? void 0 : tokenMap[token.chainId]) === null || _d === void 0 ? void 0 : _d[token.address]) !== undefined)
            throw Error('Duplicate tokens.');
        return Object.assign(Object.assign({}, tokenMap), { [token.chainId]: Object.assign(Object.assign({}, tokenMap[token.chainId]), { [token.address]: token }) });
    }, Object.assign({}, EMPTY_LIST));
    listCache === null || listCache === void 0 ? void 0 : listCache.set(list, map);
    return map;
}
function useTokenList(urls) {
    const lists = useSelector((state) => state.plists.byUrl);
    const tokenList = {};
    return useMemo(() => {
        [].concat(urls || []).forEach((url) => {
            var _a;
            const current = (_a = lists[url]) === null || _a === void 0 ? void 0 : _a.current;
            if (url && current) {
                try {
                    const data = listToTokenMap(current);
                    for (const [chainId, tokens] of Object.entries(data)) {
                        tokenList[chainId] = tokenList[chainId] || {};
                        tokenList[chainId] = Object.assign(Object.assign({}, tokenList[chainId]), tokens);
                    }
                }
                catch (error) {
                    console.error('Could not show token list due to error', error);
                }
            }
        });
        return tokenList;
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [lists, urls]);
}
function useSelectedListUrl() {
    return useSelector((state) => { var _a; return [].concat(((_a = state === null || state === void 0 ? void 0 : state.plists) === null || _a === void 0 ? void 0 : _a.selectedListUrl) || []); });
}
function useSelectedTokenList() {
    return useTokenList(useSelectedListUrl());
}
function useSelectedListInfo() {
    var _a, _b, _c, _d, _e;
    const selectedListUrl = useSelectedListUrl();
    const firstSelectedUrl = (_a = (selectedListUrl || [])) === null || _a === void 0 ? void 0 : _a[0];
    const listsByUrl = useSelector((state) => state.plists.byUrl);
    const list = firstSelectedUrl ? listsByUrl[firstSelectedUrl] : undefined;
    return {
        current: (_b = list === null || list === void 0 ? void 0 : list.current) !== null && _b !== void 0 ? _b : null,
        pending: (_c = list === null || list === void 0 ? void 0 : list.pendingUpdate) !== null && _c !== void 0 ? _c : null,
        loading: (list === null || list === void 0 ? void 0 : list.loadingRequestId) !== null,
        multipleSelected: ((_d = (selectedListUrl || [])) === null || _d === void 0 ? void 0 : _d.length) > 1,
        selectedCount: (_e = (selectedListUrl || [])) === null || _e === void 0 ? void 0 : _e.length,
    };
}
function useIsSelectedAEBToken() {
    const selectedOutputToken = useSelector((state) => state.pswap.OUTPUT);
    return AEB_TOKENS.some((tokenAddress) => tokenAddress === (selectedOutputToken === null || selectedOutputToken === void 0 ? void 0 : selectedOutputToken.currencyId));
}

function isMethodArg(x) {
    return ['string', 'number'].indexOf(typeof x) !== -1;
}
function isValidMethodArgs(x) {
    return (x === undefined ||
        (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg)))));
}
const INVALID_RESULT = { valid: false, blockNumber: undefined, data: undefined };
// use this options object
const NEVER_RELOAD = {
    blocksPerFetch: Infinity,
};
// the lowest level call for subscribing to contract data
function useCallsData(calls, options) {
    const { chainId } = usePangolinWeb3();
    const callResults = useSelector((state) => state.pmulticall.callResults);
    const dispatch = useDispatch();
    const serializedCallKeys = useMemo(() => {
        var _a, _b, _c;
        return JSON.stringify((_c = (_b = (_a = calls === null || calls === void 0 ? void 0 : calls.filter((c) => Boolean(c))) === null || _a === void 0 ? void 0 : _a.map(toCallKey)) === null || _b === void 0 ? void 0 : _b.sort()) !== null && _c !== void 0 ? _c : []);
    }, [calls]);
    // update listeners when there is an actual change that persists for at least 100ms
    useEffect(() => {
        const callKeys = JSON.parse(serializedCallKeys);
        if (!chainId || callKeys.length === 0)
            return undefined;
        const calls = callKeys.map((key) => parseCallKey(key));
        dispatch(addMulticallListeners({
            chainId,
            calls,
            options,
        }));
        return () => {
            dispatch(removeMulticallListeners({
                chainId,
                calls,
                options,
            }));
        };
    }, [chainId, dispatch, options, serializedCallKeys]);
    return useMemo(() => calls.map((call) => {
        var _a;
        if (!chainId || !call)
            return INVALID_RESULT;
        const result = (_a = callResults[chainId]) === null || _a === void 0 ? void 0 : _a[toCallKey(call)];
        let data;
        if ((result === null || result === void 0 ? void 0 : result.data) && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {
            data = result.data;
        }
        return { valid: true, data, blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber };
    }), [callResults, calls, chainId]);
}
const INVALID_CALL_STATE = { valid: false, result: undefined, loading: false, syncing: false, error: false };
const LOADING_CALL_STATE = { valid: true, result: undefined, loading: true, syncing: true, error: false };
function toCallState(callResult, contractInterface, fragment, latestBlockNumber) {
    if (!callResult)
        return INVALID_CALL_STATE;
    const { valid, data, blockNumber } = callResult;
    if (!valid)
        return INVALID_CALL_STATE;
    if (valid && !blockNumber)
        return LOADING_CALL_STATE;
    if (!contractInterface || !fragment || !latestBlockNumber)
        return LOADING_CALL_STATE;
    const success = data && data.length > 2;
    const syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;
    let result = undefined;
    if (success && data) {
        try {
            result = contractInterface.decodeFunctionResult(fragment, data);
        }
        catch (error) {
            console.debug('Result data parsing failed', fragment, data);
            return {
                valid: true,
                loading: false,
                error: true,
                syncing,
                result,
            };
        }
    }
    return {
        valid: true,
        loading: false,
        syncing,
        result: result,
        error: !success,
    };
}
function useSingleContractMultipleData(contract, methodName, callInputs, options) {
    const fragment = useMemo(() => { var _a; return (_a = contract === null || contract === void 0 ? void 0 : contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(methodName); }, [contract, methodName]);
    const calls = useMemo(() => contract && fragment && callInputs && callInputs.length > 0
        ? callInputs.map((inputs) => {
            return {
                address: contract.address,
                callData: contract.interface.encodeFunctionData(fragment, inputs),
            };
        })
        : [], [callInputs, contract, fragment]);
    const results = useCallsData(calls, options);
    const latestBlockNumber = useBlockNumber();
    return useMemo(() => {
        return results.map((result) => toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber));
    }, [fragment, contract, results, latestBlockNumber]);
}
function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options) {
    const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);
    const callData = useMemo(() => fragment && isValidMethodArgs(callInputs)
        ? contractInterface.encodeFunctionData(fragment, callInputs)
        : undefined, [callInputs, contractInterface, fragment]);
    const calls = useMemo(() => fragment && addresses && addresses.length > 0 && callData
        ? addresses.map((address) => {
            return address && callData
                ? {
                    address,
                    callData,
                }
                : undefined;
        })
        : [], [addresses, callData, fragment]);
    const results = useCallsData(calls, options);
    const latestBlockNumber = useBlockNumber();
    return useMemo(() => {
        return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber));
    }, [fragment, results, contractInterface, latestBlockNumber]);
}
function useSingleCallResult(contract, methodName, inputs, options) {
    const fragment = useMemo(() => { var _a; return (_a = contract === null || contract === void 0 ? void 0 : contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(methodName); }, [contract, methodName]);
    const calls = useMemo(() => {
        return contract && fragment && isValidMethodArgs(inputs)
            ? [
                {
                    address: contract.address,
                    callData: contract.interface.encodeFunctionData(fragment, inputs),
                },
            ]
            : [];
    }, [contract, fragment, inputs]);
    const result = useCallsData(calls, options)[0];
    const latestBlockNumber = useBlockNumber();
    return useMemo(() => {
        return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);
    }, [result, contract, fragment, latestBlockNumber]);
}

function serializeToken(token) {
    return {
        chainId: token.chainId,
        address: token.address,
        decimals: token.decimals,
        symbol: token.symbol,
        name: token.name,
    };
}
function deserializeToken(serializedToken) {
    return new Token$1(serializedToken.chainId, serializedToken.address, serializedToken.decimals, serializedToken.symbol, serializedToken.name);
}
function useUserSlippageTolerance() {
    const dispatch = useDispatch();
    const userSlippageTolerance = useSelector((state) => {
        return state.puser.userSlippageTolerance;
    });
    const setUserSlippageTolerance = useCallback((userSlippageTolerance) => {
        dispatch(updateUserSlippageTolerance({ userSlippageTolerance: userSlippageTolerance }));
    }, [dispatch]);
    return [userSlippageTolerance, setUserSlippageTolerance];
}
function useUserAddedTokens() {
    const { chainId } = usePangolinWeb3();
    const serializedTokensMap = useSelector(({ puser: { tokens } }) => tokens);
    return useMemo(() => {
        var _a;
        if (!chainId)
            return [];
        return Object.values((_a = serializedTokensMap[chainId]) !== null && _a !== void 0 ? _a : {}).map(deserializeToken);
    }, [serializedTokensMap, chainId]);
}
function useIsExpertMode() {
    return useSelector((state) => state.puser.userExpertMode);
}
function useExpertModeManager() {
    const dispatch = useDispatch();
    const expertMode = useIsExpertMode();
    const setExpertMode = useCallback((value) => {
        dispatch(updateUserExpertMode({ userExpertMode: value }));
    }, [dispatch]);
    return [expertMode, setExpertMode];
}
function useUserDeadline() {
    const dispatch = useDispatch();
    const userDeadline = useSelector((state) => state.puser.userDeadline);
    const setUserDeadline = useCallback((userDeadline) => {
        dispatch(updateUserDeadline({ userDeadline: userDeadline }));
    }, [dispatch]);
    return [userDeadline, setUserDeadline];
}
/**
 * Given two tokens return the liquidity token that represents its liquidity shares
 * @param tokenA one of the two tokens
 * @param tokenB the other token
 */
function toV2LiquidityToken([tokenA, tokenB], chainId) {
    return new Token$1(tokenA.chainId, Pair.getAddress(tokenA, tokenB, chainId), 18, 'ARL', 'Arcanum Liquidity');
}
/**
 * Returns all the pairs of tokens that are tracked by the user for the current chain ID.
 */
function useTrackedTokenPairs() {
    const { chainId } = usePangolinWeb3();
    const tokens = useAllTokens();
    // pinned pairs
    const pinnedPairs = useMemo(() => { var _a; return (chainId ? (_a = PINNED_PAIRS[chainId]) !== null && _a !== void 0 ? _a : [] : []); }, [chainId]);
    // pairs for every token against every base
    const generatedPairs = useMemo(() => chainId
        ? flatMap(Object.keys(tokens), (tokenAddress) => {
            var _a;
            const token = tokens[tokenAddress];
            // for each token on the current chain,
            return (
                // loop though all bases on the current chain
                ((_a = BASES_TO_TRACK_LIQUIDITY_FOR[chainId]) !== null && _a !== void 0 ? _a : [])
                    // to construct pairs of the given token with each base
                    .map((base) => {
                        if (base.address === token.address) {
                            return null;
                        }
                        else {
                            return [base, token];
                        }
                    })
                    .filter((p) => p !== null));
        })
        : [], [tokens, chainId]);
    // pairs saved by users
    const savedSerializedPairs = useSelector(({ puser: { pairs } }) => pairs);
    const userPairs = useMemo(() => {
        if (!chainId || !savedSerializedPairs)
            return [];
        const forChain = savedSerializedPairs[chainId];
        if (!forChain)
            return [];
        return Object.keys(forChain).map((pairId) => {
            return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)];
        });
    }, [savedSerializedPairs, chainId]);
    const combinedList = useMemo(() => userPairs.concat(generatedPairs).concat(pinnedPairs), [generatedPairs, pinnedPairs, userPairs]);
    return useMemo(() => {
        // dedupes pairs of tokens in the combined list
        const keyed = combinedList.reduce((memo, [tokenA, tokenB]) => {
            const sorted = tokenA.sortsBefore(tokenB);
            const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`;
            if (memo[key])
                return memo;
            memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA];
            return memo;
        }, {});
        return Object.keys(keyed).map((key) => keyed[key]);
    }, [combinedList]);
}
function serializePair(pair) {
    return {
        token0: serializeToken(pair.token0),
        token1: serializeToken(pair.token1),
    };
}
function usePairAdder() {
    const dispatch = useDispatch();
    return useCallback((pair) => {
        dispatch(addSerializedPair({ serializedPair: serializePair(pair) }));
    }, [dispatch]);
}

function wrappedCurrency(currency, chainId) {
    return chainId && currency === CAVAX[chainId] ? WAVAX[chainId] : currency instanceof Token$1 ? currency : undefined;
}
function wrappedCurrencyAmount(currencyAmount, chainId) {
    const token = currencyAmount && chainId ? wrappedCurrency(currencyAmount.currency, chainId) : undefined;
    return token && currencyAmount ? new TokenAmount(token, currencyAmount.raw) : undefined;
}
function convertToPangolinToken(token) {
    return new Token$1(token.chainId, token.address, token.decimals, token === null || token === void 0 ? void 0 : token.symbol, token === null || token === void 0 ? void 0 : token.name);
}
function wrappedGelatoCurrency(currency, chainId) {
    return chainId && !(currency === null || currency === void 0 ? void 0 : currency.isToken)
        ? WAVAX[chainId]
        : currency.isToken
            ? convertToPangolinToken(currency)
            : undefined;
}
function unwrappedToken(token, chainId) {
    var _a;
    if ((_a = token === null || token === void 0 ? void 0 : token.equals) === null || _a === void 0 ? void 0 : _a.call(token, WAVAX[token.chainId]))
        return CAVAX[chainId];
    return token;
}

const usePairsHook = {
    [ChainId.FUJI]: usePairs,
    [ChainId.AVALANCHE]: usePairs,
    [ChainId.WAGMI]: usePairs,
    [ChainId.COSTON]: usePairs,
    [ChainId.SONGBIRD]: usePairs,
    [ChainId.NEAR_MAINNET]: useNearPairs,
    [ChainId.NEAR_TESTNET]: useNearPairs,
};

const PAIR_INTERFACE = new Interface(IArcanumPair.abi);
var PairState;
(function (PairState) {
    PairState[PairState["LOADING"] = 0] = "LOADING";
    PairState[PairState["NOT_EXISTS"] = 1] = "NOT_EXISTS";
    PairState[PairState["EXISTS"] = 2] = "EXISTS";
    PairState[PairState["INVALID"] = 3] = "INVALID";
})(PairState || (PairState = {}));
var PoolType$2;
(function (PoolType) {
    PoolType["SIMPLE_POOL"] = "SIMPLE_POOL";
    PoolType["STABLE_SWAP"] = "STABLE_SWAP";
    PoolType["RATED_SWAP"] = "RATED_SWAP";
})(PoolType$2 || (PoolType$2 = {}));
function usePairs(currencies) {
    const chainId = useChainId();
    const tokens = useMemo(() => currencies.map(([currencyA, currencyB]) => [
        wrappedCurrency(currencyA, chainId),
        wrappedCurrency(currencyB, chainId),
    ]), [chainId, currencies]);
    const pairAddresses = useMemo(() => tokens.map(([tokenA, tokenB]) => {
        return tokenA && tokenB && !tokenA.equals(tokenB)
            ? Pair.getAddress(tokenA, tokenB, chainId ? chainId : ChainId.AVALANCHE)
            : undefined;
    }), [tokens, chainId]);
    const results = useMultipleContractSingleData(pairAddresses, PAIR_INTERFACE, 'getReserves');
    return useMemo(() => {
        return results.map((result, i) => {
            const { result: reserves, loading } = result;
            const tokenA = tokens[i][0];
            const tokenB = tokens[i][1];
            if (loading)
                return [PairState.LOADING, null];
            if (!tokenA || !tokenB || tokenA.equals(tokenB))
                return [PairState.INVALID, null];
            if (!reserves)
                return [PairState.NOT_EXISTS, null];
            const { reserve0, reserve1 } = reserves;
            const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
            return [
                PairState.EXISTS,
                new Pair(new TokenAmount(token0, reserve0.toString()), new TokenAmount(token1, reserve1.toString()), chainId ? chainId : ChainId.AVALANCHE),
            ];
        });
    }, [results, tokens, chainId]);
}
function usePair(tokenA, tokenB) {
    const chainId = useChainId();
    const tokens = useMemo(() => [[tokenA, tokenB]], [tokenA, tokenB]);
    const usePairs_ = usePairsHook[chainId];
    return usePairs_(tokens)[0];
}
function useGetNearAllPool() {
    const chainId = useChainId();
    return useQuery(['get-near-pools'], () => __awaiter(this, void 0, void 0, function* () {
        return nearFn.getAllPools(chainId);
    }));
}
function useNearPairs(currencies) {
    const chainId = useChainId();
    const tokens = useMemo(() => currencies.map(([currencyA, currencyB]) => [
        wrappedCurrency(currencyA, chainId),
        wrappedCurrency(currencyB, chainId),
    ]), [chainId, currencies]);
    const allPools = useGetNearAllPool();
    return useMemo(() => {
        if (allPools && !allPools.isLoading && tokens) {
            const results = allPools.data || [];
            return tokens.map(([tokenA, tokenB]) => {
                let indexOfToken0 = 0;
                let indexOfToken1 = 1;
                let reserveAmounts = [];
                if (!tokenA || !tokenB || tokenA.equals(tokenB))
                    return [PairState.INVALID, null];
                const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
                const filterResults = results.filter((v) => {
                    if ((v === null || v === void 0 ? void 0 : v.pool_kind) !== PoolType$2.SIMPLE_POOL)
                        return false;
                    const tokenIds = (v === null || v === void 0 ? void 0 : v.token_account_ids) || [];
                    if (tokenIds.includes(token0 === null || token0 === void 0 ? void 0 : token0.address) && tokenIds.includes(token1 === null || token1 === void 0 ? void 0 : token1.address)) {
                        return true;
                    }
                });
                const result = filterResults === null || filterResults === void 0 ? void 0 : filterResults[0];
                if (result) {
                    const tokenIds = result.token_account_ids || [];
                    indexOfToken0 = tokenIds.findIndex((element) => element.includes(token0 === null || token0 === void 0 ? void 0 : token0.address));
                    indexOfToken1 = tokenIds.findIndex((element) => element.includes(token1 === null || token1 === void 0 ? void 0 : token1.address));
                    reserveAmounts = result.amounts || [];
                }
                if (reserveAmounts.length === 0)
                    return [PairState.NOT_EXISTS, null];
                return [
                    PairState.EXISTS,
                    new Pair(new TokenAmount(token0, reserveAmounts[indexOfToken0].toString()), new TokenAmount(token1, reserveAmounts[indexOfToken1].toString()), chainId ? chainId : ChainId.AVALANCHE),
                ];
            });
        }
        return [[PairState.LOADING, null]];
    }, [allPools === null || allPools === void 0 ? void 0 : allPools.data, allPools === null || allPools === void 0 ? void 0 : allPools.isLoading, tokens, chainId]);
}
function useGetNearPoolId(tokenA, tokenB) {
    const allPools = useGetNearAllPool();
    return useMemo(() => {
        if (!(allPools === null || allPools === void 0 ? void 0 : allPools.isLoading)) {
            const results = (allPools === null || allPools === void 0 ? void 0 : allPools.data) || [];
            return results.findIndex((element) => {
                if ((element === null || element === void 0 ? void 0 : element.pool_kind) !== PoolType$2.SIMPLE_POOL)
                    return false;
                const tokenIds = (element === null || element === void 0 ? void 0 : element.token_account_ids) || [];
                if (tokenIds.includes(tokenA === null || tokenA === void 0 ? void 0 : tokenA.address) && tokenIds.includes(tokenB === null || tokenB === void 0 ? void 0 : tokenB.address)) {
                    return true;
                }
                return false;
            });
        }
        return null;
    }, [allPools === null || allPools === void 0 ? void 0 : allPools.data, allPools === null || allPools === void 0 ? void 0 : allPools.isLoading, tokenA, tokenB]);
}

class Cache {
    constructor() {
        this.options = {
            // how long to live in ms
            ttl: 1000 * 60 * 5,
            max: 1000,
        };
        this.cache = new LRUCache(this.options);
    }
    get(key) {
        return this.cache.get(key);
    }
    set(key, value, ttl = 1000 * 60 * 5) {
        this.cache.set(key, value, ttl);
    }
    has(key) {
        return this.cache.has(key);
    }
}
const cache = new Cache();

class Near {
    constructor() {
        this.getAccountId = () => {
            var _a, _b, _c;
            return (_c = (_b = (_a = near === null || near === void 0 ? void 0 : near.wallet) === null || _a === void 0 ? void 0 : _a.account) === null || _b === void 0 ? void 0 : _b.call(_a)) === null || _c === void 0 ? void 0 : _c.accountId;
        };
        this.getTransaction = (hash) => __awaiter(this, void 0, void 0, function* () {
            try {
                const accountId = this.getAccountId();
                const provider = yield near.getProvider();
                return provider === null || provider === void 0 ? void 0 : provider.txStatus(hash, accountId);
            }
            catch (error) {
                console.log(error);
                return undefined;
            }
        });
        this.getTranctionSummary = (tx) => {
            var _a, _b, _c, _d;
            let summary = '';
            const methodName = (_d = (_c = (_b = (_a = tx.transaction) === null || _a === void 0 ? void 0 : _a.actions) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.FunctionCall) === null || _d === void 0 ? void 0 : _d.method_name;
            if (methodName === 'ft_transfer_call') {
                summary = 'Swap successful';
            }
            else if (methodName === 'add_liquidity') {
                summary = 'Add Liquidity successful';
            }
            else if (methodName === 'remove_liquidity') {
                summary = 'Remove Liquidity successful';
            }
            return summary;
        };
        this.getGas = (gas) => (gas ? new BN(gas) : new BN('100000000000000'));
        this.getAmount = (amount) => {
            if (amount) {
                const parseAmount = utils.format.parseNearAmount(amount);
                return parseAmount ? new BN(parseAmount) : new BN('0');
            }
            else {
                return new BN('0');
            }
        };
    }
    viewFunction(tokenId, { methodName, args, }) {
        return __awaiter(this, void 0, void 0, function* () {
            return near.wallet.account().viewFunction(tokenId, methodName, args);
        });
    }
    getMetadata(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (cache.has(`near:token_metadata:${tokenAddress}`)) {
                    return cache.get(`near:token_metadata:${tokenAddress}`);
                }
                const metadata = yield this.viewFunction(tokenAddress, {
                    methodName: 'ft_metadata',
                });
                const tokenMetadata = Object.assign({ id: tokenAddress }, metadata);
                cache.set(`near:token_metadata:${tokenAddress}`, tokenMetadata);
                return tokenMetadata;
            }
            catch (err) {
                return {
                    id: tokenAddress,
                    name: tokenAddress,
                    symbol: tokenAddress === null || tokenAddress === void 0 ? void 0 : tokenAddress.split('.')[0].slice(0, 8),
                    decimals: 6,
                    icon: '',
                };
            }
        });
    }
    getTokenBalance(tokenAddress, account) {
        return __awaiter(this, void 0, void 0, function* () {
            if (cache.has(`near:token_balance:${tokenAddress}`)) {
                return cache.get(`near:token_balance:${tokenAddress}`);
            }
            const tokenBalance = this.viewFunction(tokenAddress, {
                methodName: 'ft_balance_of',
                args: {
                    account_id: account,
                },
            });
            cache.set(`near:token_balance:${tokenAddress}`, tokenBalance, 1000 * 60);
            return tokenBalance;
        });
    }
    getTotalSupply(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (cache.has(`near:total_supply:${tokenAddress}`)) {
                return cache.get(`near:total_supply:${tokenAddress}`);
            }
            const totalSupply = this.viewFunction(tokenAddress, {
                methodName: 'ft_total_supply',
                args: {},
            });
            cache.set(`near:total_supply:${tokenAddress}`, totalSupply, 1000 * 60);
            return totalSupply;
        });
    }
    getExchangeContract(deployer, exchange) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = new Contract$1(deployer, exchange, {
                viewMethods: ['get_pools', 'get_number_of_pools'],
                changeMethods: [],
            });
            return contract;
        });
    }
    getAllPools(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (cache.has('near:pools')) {
                return cache.get('near:pools');
            }
            const deployer = yield near.wallet.account();
            const contract = yield this.getExchangeContract(deployer, NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId]);
            const numberOfPools = yield contract.get_number_of_pools();
            const pools = contract.get_pools({
                from_index: 0,
                limit: numberOfPools,
            });
            cache.set('near:pools', pools);
            return pools;
        });
    }
    getPoolId(chainId, tokenA, tokenB) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield this.getAllPools(chainId);
            return results.findIndex((element) => {
                if ((element === null || element === void 0 ? void 0 : element.pool_kind) !== PoolType$2.SIMPLE_POOL)
                    return false;
                const tokenIds = (element === null || element === void 0 ? void 0 : element.token_account_ids) || [];
                if (tokenIds.includes(tokenA === null || tokenA === void 0 ? void 0 : tokenA.address) && tokenIds.includes(tokenB === null || tokenB === void 0 ? void 0 : tokenB.address)) {
                    return true;
                }
                return false;
            });
        });
    }
    getPool(chainId, tokenA, tokenB) {
        return __awaiter(this, void 0, void 0, function* () {
            if (cache.has(`near:pool:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`)) {
                return cache.get(`near:pool:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`);
            }
            const poolId = yield this.getPoolId(chainId, tokenA, tokenB);
            const result = yield this.viewFunction(NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId], {
                methodName: 'get_pool',
                args: { pool_id: poolId },
            });
            const pool = Object.assign(Object.assign({}, result), { id: poolId });
            cache.set(`near:pool:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`, pool, 1000 * 60);
            return pool;
        });
    }
    getSharesInPool(chainId, tokenA, tokenB) {
        return __awaiter(this, void 0, void 0, function* () {
            if (cache.has(`near:pool_shares:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`)) {
                return cache.get(`near:pool_shares:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`);
            }
            const poolId = yield this.getPoolId(chainId, tokenA, tokenB);
            const poolShares = this.viewFunction(NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId], {
                methodName: 'get_pool_shares',
                args: { pool_id: poolId, account_id: this.getAccountId() },
            });
            cache.set(`near:pool_shares:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`, poolShares, 1000 * 60);
            return poolShares;
        });
    }
    getStorageBalance(contractId, account = this.getAccountId()) {
        return this.viewFunction(contractId, {
            methodName: 'storage_balance_of',
            args: { account_id: account },
        });
    }
    needDepositStorage(contractId, account = this.getAccountId()) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = yield this.viewFunction(contractId, {
                methodName: 'get_user_storage_state',
                args: { account_id: account },
            });
            return new BN(storage === null || storage === void 0 ? void 0 : storage.deposit).lte(new BN(storage === null || storage === void 0 ? void 0 : storage.usage));
        });
    }
    checkUserNeedsStorageDeposit(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            let storageNeeded = 0;
            const needDeposit = yield nearFn.needDepositStorage(NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId]);
            if (needDeposit) {
                storageNeeded = Number('0.01');
            }
            else {
                const balance = yield this.getStorageBalance(NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId]);
                if (!balance) {
                    storageNeeded = Number(storageNeeded) + Number(NEAR_ACCOUNT_MIN_STORAGE_AMOUNT);
                }
                if (new BN((balance === null || balance === void 0 ? void 0 : balance.available) || '0').lt(NEAR_MIN_DEPOSIT_PER_TOKEN)) {
                    storageNeeded = Number(storageNeeded) + Number(NEAR_STORAGE_PER_TOKEN);
                }
            }
            return storageNeeded ? storageNeeded.toString() : '';
        });
    }
    getWhitelistedTokens(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            let userWhitelist = [];
            const contractId = NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId];
            const accountId = this.getAccountId();
            const globalWhitelist = yield this.viewFunction(contractId, {
                methodName: 'get_whitelisted_tokens',
                args: {},
            });
            userWhitelist = yield this.viewFunction(contractId, {
                methodName: 'get_user_whitelisted_tokens',
                args: { account_id: accountId },
            });
            return [...new Set([...globalWhitelist, ...userWhitelist])];
        });
    }
    createNearTransaction({ receiverId, actions, nonceOffset = 1, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountId = yield near.wallet.getAccountId();
            const walletAccount = yield near.wallet.account();
            const localKey = yield walletAccount.connection.signer.getPublicKey(accountId, near.wallet._networkId);
            const accessKey = yield walletAccount.accessKeyForTransaction(receiverId, actions, localKey);
            if (!accessKey) {
                throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);
            }
            const block = yield walletAccount.connection.provider.block({ finality: 'final' });
            const blockHash = baseDecode(block.header.hash);
            const publicKey = utils.PublicKey.from(accessKey.public_key);
            const nonce = accessKey.access_key.nonce + nonceOffset;
            return transactions.createTransaction(accountId, publicKey, receiverId, nonce, actions, blockHash);
        });
    }
    executeMultipleTransactions(allTransactions, callbackUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTransactions = yield Promise.all(allTransactions.map((t, i) => {
                return this.createNearTransaction({
                    receiverId: t.receiverId,
                    nonceOffset: i + 1,
                    actions: t.functionCalls.map((fc) => transactions.functionCall(fc.methodName, (fc === null || fc === void 0 ? void 0 : fc.args) ? fc === null || fc === void 0 ? void 0 : fc.args : {}, this.getGas(fc.gas), this.getAmount(fc === null || fc === void 0 ? void 0 : fc.amount))),
                });
            }));
            return near.wallet.requestSignTransactions(currentTransactions, callbackUrl);
        });
    }
    storageDepositAction({ accountId = nearFn.getAccountId(), registrationOnly = false, amount, }) {
        return {
            methodName: 'storage_deposit',
            args: {
                account_id: accountId,
                registration_only: registrationOnly,
            },
            amount,
        };
    }
    nearDepositAction(amount) {
        return {
            methodName: 'near_deposit',
            args: {},
            amount,
        };
    }
    nearWithdrawAction(amount) {
        return {
            methodName: 'near_withdraw',
            args: { amount: amount },
            amount: ONE_YOCTO_NEAR,
        };
    }
    registerTokenAction(tokenId) {
        return {
            methodName: 'register_tokens',
            args: { token_ids: [tokenId] },
            amount: ONE_YOCTO_NEAR,
        };
    }
    withdrawAction({ tokenId, amount, unregister = false }) {
        return {
            methodName: 'withdraw',
            args: { token_id: tokenId, amount, unregister },
            amount: ONE_YOCTO_NEAR,
        };
    }
    getYourPools() {
        return __awaiter(this, void 0, void 0, function* () {
            return fetch(NEAR_API_BASE_URL + '/liquidity-pools/' + nearFn.getAccountId(), {
                method: 'GET',
                headers: { 'Content-type': 'application/json; charset=UTF-8' },
            })
                .then((res) => res.json())
                .then((pools) => {
                    return pools;
                });
        });
    }
}
const nearFn = new Near();
/* eslint-enable max-lines */

var ERC20_ABI = [
    {
        constant: true,
        inputs: [
        ],
        name: "name",
        outputs: [
            {
                name: "",
                type: "string"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: false,
        inputs: [
            {
                name: "_spender",
                type: "address"
            },
            {
                name: "_value",
                type: "uint256"
            }
        ],
        name: "approve",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "totalSupply",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address"
            },
            {
                name: "_to",
                type: "address"
            },
            {
                name: "_value",
                type: "uint256"
            }
        ],
        name: "transferFrom",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "decimals",
        outputs: [
            {
                name: "",
                type: "uint8"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address"
            }
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "balance",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "symbol",
        outputs: [
            {
                name: "",
                type: "string"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: false,
        inputs: [
            {
                name: "_to",
                type: "address"
            },
            {
                name: "_value",
                type: "uint256"
            }
        ],
        name: "transfer",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address"
            },
            {
                name: "_spender",
                type: "address"
            }
        ],
        name: "allowance",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        payable: true,
        stateMutability: "payable",
        type: "fallback"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "spender",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ],
        name: "Approval",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ],
        name: "Transfer",
        type: "event"
    }
];

var ERC20_BYTES32_ABI = [
    {
        constant: true,
        inputs: [
        ],
        name: "name",
        outputs: [
            {
                name: "",
                type: "bytes32"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "symbol",
        outputs: [
            {
                name: "",
                type: "bytes32"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    }
];

const ERC20_INTERFACE = new Interface(ERC20_ABI);
const ERC20_BYTES32_INTERFACE = new Interface(ERC20_BYTES32_ABI);

var _format = "hh-sol-artifact-1";
var contractName = "PangoChef";
var sourceName = "contracts/staking-positions/PangoChef.sol";
var abi = [
    {
        inputs: [
            {
                internalType: "address",
                name: "newRewardsToken",
                type: "address"
            },
            {
                internalType: "address",
                name: "newAdmin",
                type: "address"
            },
            {
                internalType: "contract IPangolinFactory",
                name: "newFactory",
                type: "address"
            },
            {
                internalType: "address",
                name: "newWrappedNativeToken",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
    },
    {
        inputs: [
        ],
        name: "FailedTransfer",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "HighSlippage",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "InsufficientBalance",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "InvalidAmount",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "InvalidToken",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "InvalidType",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "Locked",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "MismatchedArrayLengths",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "NoEffect",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "NonExistentToken",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "NullInput",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "OutOfBounds",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "Overflow",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "Reentrancy",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "TooEarly",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "TooLate",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "Underflow",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "UnprivilegedCaller",
        type: "error"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "newDuration",
                type: "uint256"
            }
        ],
        name: "PeriodDurationUpdated",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
        ],
        name: "PeriodEnded",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "address",
                name: "tokenOrRecipient",
                type: "address"
            }
        ],
        name: "PoolInitialized",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "reward",
                type: "uint256"
            }
        ],
        name: "RewardAdded",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "address",
                name: "rewarder",
                type: "address"
            }
        ],
        name: "RewarderSet",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "previousAdminRole",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "newAdminRole",
                type: "bytes32"
            }
        ],
        name: "RoleAdminChanged",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address"
            }
        ],
        name: "RoleGranted",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address"
            }
        ],
        name: "RoleRevoked",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "address",
                name: "userId",
                type: "address"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "reward",
                type: "uint256"
            }
        ],
        name: "Staked",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "newWeight",
                type: "uint256"
            }
        ],
        name: "WeightSet",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "address",
                name: "userId",
                type: "address"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "reward",
                type: "uint256"
            }
        ],
        name: "Withdrawn",
        type: "event"
    },
    {
        inputs: [
        ],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "addReward",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            }
        ],
        name: "claim",
        outputs: [
            {
                internalType: "uint256",
                name: "reward",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "minPairAmount",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxPairAmount",
                        type: "uint256"
                    }
                ],
                internalType: "struct PangoChef.Slippage",
                name: "slippage",
                type: "tuple"
            }
        ],
        name: "compound",
        outputs: [
        ],
        stateMutability: "payable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "minPairAmount",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxPairAmount",
                        type: "uint256"
                    }
                ],
                internalType: "struct PangoChef.Slippage",
                name: "slippage",
                type: "tuple"
            }
        ],
        name: "compoundToPoolZero",
        outputs: [
        ],
        stateMutability: "payable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            }
        ],
        name: "emergencyExitLevel1",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            }
        ],
        name: "emergencyExitLevel2",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "endPeriod",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "factory",
        outputs: [
            {
                internalType: "contract IPangolinFactory",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            }
        ],
        name: "getRoleAdmin",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "uint256",
                name: "index",
                type: "uint256"
            }
        ],
        name: "getRoleMember",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            }
        ],
        name: "getRoleMemberCount",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "userId",
                type: "address"
            }
        ],
        name: "getUser",
        outputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "uint104",
                                name: "balance",
                                type: "uint104"
                            },
                            {
                                internalType: "uint152",
                                name: "sumOfEntryTimes",
                                type: "uint152"
                            }
                        ],
                        internalType: "struct PangoChef.ValueVariables",
                        name: "valueVariables",
                        type: "tuple"
                    },
                    {
                        components: [
                            {
                                internalType: "uint256",
                                name: "idealPosition",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "rewardPerValue",
                                type: "uint256"
                            }
                        ],
                        internalType: "struct PangoChef.RewardSummations",
                        name: "rewardSummationsPaid",
                        type: "tuple"
                    },
                    {
                        internalType: "uint152",
                        name: "previousValues",
                        type: "uint152"
                    },
                    {
                        internalType: "uint48",
                        name: "lastUpdate",
                        type: "uint48"
                    },
                    {
                        internalType: "bool",
                        name: "isLockingPoolZero",
                        type: "bool"
                    },
                    {
                        internalType: "uint96",
                        name: "stashedRewards",
                        type: "uint96"
                    }
                ],
                internalType: "struct PangoChef.User",
                name: "",
                type: "tuple"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "grantRole",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            }
        ],
        name: "harvest",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "hasRole",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "tokenOrRecipient",
                type: "address"
            },
            {
                internalType: "enum PangoChef.PoolType",
                name: "poolType",
                type: "uint8"
            }
        ],
        name: "initializePool",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        name: "lastTimeRewarderCallFailed",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "lastUpdate",
        outputs: [
            {
                internalType: "uint48",
                name: "",
                type: "uint48"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "periodDuration",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "periodFinish",
        outputs: [
            {
                internalType: "uint48",
                name: "",
                type: "uint48"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        name: "poolRewardInfos",
        outputs: [
            {
                internalType: "uint32",
                name: "weight",
                type: "uint32"
            },
            {
                internalType: "uint96",
                name: "stashedRewards",
                type: "uint96"
            },
            {
                internalType: "uint128",
                name: "rewardPerWeightPaid",
                type: "uint128"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            }
        ],
        name: "poolRewardRate",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        name: "poolZeroLockCount",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        name: "pools",
        outputs: [
            {
                internalType: "address",
                name: "tokenOrRecipient",
                type: "address"
            },
            {
                internalType: "enum PangoChef.PoolType",
                name: "poolType",
                type: "uint8"
            },
            {
                internalType: "contract IRewarder",
                name: "rewarder",
                type: "address"
            },
            {
                internalType: "address",
                name: "rewardPair",
                type: "address"
            },
            {
                components: [
                    {
                        internalType: "uint104",
                        name: "balance",
                        type: "uint104"
                    },
                    {
                        internalType: "uint152",
                        name: "sumOfEntryTimes",
                        type: "uint152"
                    }
                ],
                internalType: "struct PangoChef.ValueVariables",
                name: "valueVariables",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "idealPosition",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "rewardPerValue",
                        type: "uint256"
                    }
                ],
                internalType: "struct PangoChef.RewardSummations",
                name: "rewardSummationsStored",
                type: "tuple"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "poolsLength",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "renounceRole",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "revokeRole",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "rewardPerWeightStored",
        outputs: [
            {
                internalType: "uint128",
                name: "",
                type: "uint128"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "rewardRate",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "rewardsToken",
        outputs: [
            {
                internalType: "contract ERC20",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "newDuration",
                type: "uint256"
            }
        ],
        name: "setPeriodDuration",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "rewarder",
                type: "address"
            }
        ],
        name: "setRewarder",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256[]",
                name: "poolIds",
                type: "uint256[]"
            },
            {
                internalType: "uint32[]",
                name: "weights",
                type: "uint32[]"
            }
        ],
        name: "setWeights",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "stake",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "userId",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "stakeTo",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "interfaceId",
                type: "bytes4"
            }
        ],
        name: "supportsInterface",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "totalRewardAdded",
        outputs: [
            {
                internalType: "uint96",
                name: "",
                type: "uint96"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "totalWeight",
        outputs: [
            {
                internalType: "uint32",
                name: "",
                type: "uint32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "userId",
                type: "address"
            }
        ],
        name: "userPendingRewards",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "userId",
                type: "address"
            }
        ],
        name: "userRewardRate",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "poolId",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "withdraw",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "wrappedNativeToken",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
];
var bytecode = "0x60e06040526201518060055560016006556000600a553480156200002257600080fd5b5060405162004b0238038062004b028339810160408190526200004591620004f0565b83836001600160a01b0381166200006f57604051632505ecc360e11b815260040160405180910390fd5b6001600160a01b038216608052620000896000826200023d565b620000b57f0914bb97ca83e85ef385857d9d418f187ff630589e0c9f44db92976d8e4519cb826200023d565b620000e17f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff826200023d565b5050600080805260026020527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b80546103e863ffffffff199091161790556004805463ffffffff60901b1916607d60931b17815560405163e6a4390560e01b81526001600160a01b038781169282019290925283821660248201529084169063e6a4390590604401602060405180830381865afa15801562000187573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001ad919062000558565b90506001600160a01b038116620001d757604051632505ecc360e11b815260040160405180910390fd5b620001e481600162000280565b506000805260076020527f6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6e180546001600160a01b0319166001600160a01b03928316908117909155911660a05260c05250620005bd9050565b620002548282620003c460201b6200186d1760201c565b60008281526001602090815260409091206200027b9183906200190b62000465821b17901c565b505050565b600a80546000918262000293836200057f565b9091555090506001600160a01b0383161580620002c457506000826002811115620002c257620002c2620005a7565b145b15620002e357604051632505ecc360e11b815260040160405180910390fd5b6001826002811115620002fa57620002fa620005a7565b1480156200031057506001600160a01b0383163b155b156200032f5760405163c1ab6dc160e01b815260040160405180910390fd5b600081815260076020526040902080546001600160a01b0385166001600160a01b0319821681178355849183916001600160a81b031990911617600160a01b836002811115620003835762000383620005a7565b02179055506040516001600160a01b0385169083907f3d82013e0d368d05bfb8b953d35bffd6eec15520773228de41146f306a241aec90600090a350505050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1662000461576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620004203390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45b5050565b60006200047c836001600160a01b03841662000485565b90505b92915050565b6000818152600183016020526040812054620004ce575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556200047f565b5060006200047f565b6001600160a01b0381168114620004ed57600080fd5b50565b600080600080608085870312156200050757600080fd5b84516200051481620004d7565b60208601519094506200052781620004d7565b60408601519093506200053a81620004d7565b60608601519092506200054d81620004d7565b939692955090935050565b6000602082840312156200056b57600080fd5b81516200057881620004d7565b9392505050565b600060018201620005a057634e487b7160e01b600052601160045260246000fd5b5060010190565b634e487b7160e01b600052602160045260246000fd5b60805160a05160c0516144d66200062c60003960008181610374015261313f0152600081816109b10152613456015260008181610a2501528181610dd3015281816112ed015281816114e30152818161243a01528181613059015281816134ea015261352b01526144d66000f3fe6080604052600436106102dc5760003560e01c80637b0a47ee11610184578063c45a0155116100d6578063d61f06801161008a578063ebe2b12b11610064578063ebe2b12b14610aba578063f2d1e1cd14610ad9578063f851844b14610af957600080fd5b8063d61f068014610a67578063d97f8ed614610a87578063ddc6326214610a9a57600080fd5b8063cea84402116100bb578063cea84402146109f3578063d1af0c7d14610a13578063d547741f14610a4757600080fd5b8063c45a01551461099f578063ca15c873146109d357600080fd5b806396c82e5711610138578063b470aade11610112578063b470aade1461091f578063c046371114610935578063c348dac11461097257600080fd5b806396c82e5714610801578063a217fddf1461083a578063ac4afa381461084f57600080fd5b806382f084d31161016957806382f084d31461077d5780639010d07c1461079d57806391d14854146107bd57600080fd5b80637b0a47ee146107485780637c2d6e011461075d57600080fd5b8063379607f51161023d57806359b02eb3116101f15780636bc9f703116101cb5780636bc9f7031461066257806374de4ec4146107085780637b0472f01461072857600080fd5b806359b02eb3146105f55780635faa65ff14610615578063677f93261461062a57600080fd5b806343de32071161022257806343de320714610595578063441a3e70146105b557806354f8c475146105d557600080fd5b8063379607f51461055557806343d5599e1461057557600080fd5b8063257664a4116102945780632f2ff15d116102795780632f2ff15d146104cb5780633228dd59146104eb57806336568abe1461053557600080fd5b8063257664a4146104015780632716ae66146104b657600080fd5b806317fcb39b116102c557806317fcb39b14610362578063190d8ef4146103ae578063248a9ca3146103c357600080fd5b806301ffc9a7146102e1578063098b885814610316575b600080fd5b3480156102ed57600080fd5b506103016102fc366004613d15565b610b19565b60405190151581526020015b60405180910390f35b34801561032257600080fd5b5060045461034590660100000000000090046bffffffffffffffffffffffff1681565b6040516bffffffffffffffffffffffff909116815260200161030d565b34801561036e57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161030d565b6103c16103bc366004613d57565b610b75565b005b3480156103cf57600080fd5b506103f36103de366004613d8f565b60009081526020819052604090206001015490565b60405190815260200161030d565b34801561040d57600080fd5b5061042161041c366004613dbd565b610bb6565b60405161030d9190815180516001600160681b031682526020908101516001600160981b031690820152610100810160208381015180516040850152908101516060840152506001600160981b03604084015116608083015265ffffffffffff60608401511660a08301526080830151151560c08301526bffffffffffffffffffffffff60a08401511660e083015292915050565b3480156104c257600080fd5b50600a546103f3565b3480156104d757600080fd5b506103c16104e6366004613dbd565b610c96565b3480156104f757600080fd5b50600354610514906fffffffffffffffffffffffffffffffff1681565b6040516fffffffffffffffffffffffffffffffff909116815260200161030d565b34801561054157600080fd5b506103c1610550366004613dbd565b610cc0565b34801561056157600080fd5b506103f3610570366004613d8f565b610d51565b34801561058157600080fd5b506103c1610590366004613ded565b610e46565b3480156105a157600080fd5b506103c16105b0366004613dbd565b610e72565b3480156105c157600080fd5b506103c16105d0366004613e25565b610f11565b3480156105e157600080fd5b506103c16105f0366004613e93565b610f23565b34801561060157600080fd5b506103f3610610366004613dbd565b6111c8565b34801561062157600080fd5b506103c1611212565b34801561063657600080fd5b506103f3610645366004613dbd565b600960209081526000928352604080842090915290825290205481565b34801561066e57600080fd5b506106c761067d366004613d8f565b60026020526000908152604090205463ffffffff81169064010000000081046bffffffffffffffffffffffff1690600160801b90046fffffffffffffffffffffffffffffffff1683565b6040805163ffffffff90941684526bffffffffffffffffffffffff90921660208401526fffffffffffffffffffffffffffffffff169082015260600161030d565b34801561071457600080fd5b506103c1610723366004613d8f565b611349565b34801561073457600080fd5b506103c1610743366004613e25565b61154c565b34801561075457600080fd5b506103f3611578565b34801561076957600080fd5b506103c1610778366004613d8f565b6115bd565b34801561078957600080fd5b506103f3610798366004613dbd565b611693565b3480156107a957600080fd5b506103966107b8366004613e25565b61170c565b3480156107c957600080fd5b506103016107d8366004613dbd565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b34801561080d57600080fd5b5060045461082590600160901b900463ffffffff1681565b60405163ffffffff909116815260200161030d565b34801561084657600080fd5b506103f3600081565b34801561085b57600080fd5b5061090d61086a366004613d8f565b6007602090815260009182526040918290208054600182015460028301548551808701875260038501546001600160681b03811682526d010000000000000000000000000090046001600160981b031681870152865180880190975260048501548752600590940154948601949094526001600160a01b03808316957401000000000000000000000000000000000000000090930460ff16949181169391169186565b60405161030d96959493929190613f15565b34801561092b57600080fd5b506103f360055481565b34801561094157600080fd5b5060035461095b90600160801b900465ffffffffffff1681565b60405165ffffffffffff909116815260200161030d565b34801561097e57600080fd5b506103f361098d366004613f98565b60086020526000908152604090205481565b3480156109ab57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b3480156109df57600080fd5b506103f36109ee366004613d8f565b61172b565b3480156109ff57600080fd5b506103c1610a0e366004613d8f565b611742565b348015610a1f57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b348015610a5357600080fd5b506103c1610a62366004613dbd565b611762565b348015610a7357600080fd5b506103c1610a82366004613fb5565b611787565b6103c1610a95366004613d57565b6117bb565b348015610aa657600080fd5b506103c1610ab5366004613d8f565b6117e9565b348015610ac657600080fd5b5060045461095b9065ffffffffffff1681565b348015610ae557600080fd5b506103f3610af4366004613d8f565b6117ff565b348015610b0557600080fd5b506103c1610b14366004613d8f565b611855565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5a05180f000000000000000000000000000000000000000000000000000000001480610b6f5750610b6f82611920565b92915050565b610b7d6119b7565b60026006556000610b8d836119f5565b9050610bac600033836002610ba736889003880188613ffd565b611c3f565b5050600160065550565b610bbe613cb2565b5060008281526007602090815260408083206001600160a01b038516845260060182529182902082516101008101845281546001600160681b03811660c083019081526d01000000000000000000000000009091046001600160981b0390811660e0840152908252845180860186526001840154815260028401548186015293820193909352600382015492831693810193909352600160981b820465ffffffffffff166060840152600160c81b90910460ff1615156080830152600401546bffffffffffffffffffffffff1660a082015292915050565b600082815260208190526040902060010154610cb1816120f1565b610cbb83836120fb565b505050565b6001600160a01b0381163314610d435760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c66000000000000000000000000000000000060648201526084015b60405180910390fd5b610d4d828261211d565b5050565b6000610d5b6119b7565b6000828152600760205260409020610d728161213f565b80546001600160a01b03163314610db5576040517f38c5856200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610dbe8361218e565b91508115610dfa57610dfa6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633846121dc565b6000336001600160a01b0316847f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace85604051610e3891815260200190565b60405180910390a450919050565b610e4e6119b7565b610cbb83838360006040518060400160405280600081526020016000815250611c3f565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff610e9c816120f1565b6000838152600760205260409020610eb381612281565b60018101805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03851690811790915560405185907f865fdcfd963a9e21f0dbb101fecee79dda3ecc602d0fe55e29268c843f2a3b7c90600090a350505050565b610f196119b7565b610d4d8282612288565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff610f4d816120f1565b610f55612552565b83828114610f8f576040517f568efce200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610f9a600a5490565b90506000805b8381101561111b576000898983818110610fbc57610fbc61405a565b9050602002013590506000888884818110610fd957610fd961405a565b9050602002016020810190610fee9190614082565b63ffffffff16905084821061101657604051632d0483c560e21b815260040160405180910390fd5b6000828152600260205260409020805463ffffffff1680830361104c576040516324d0659d60e11b815260040160405180910390fd5b61105681846140b5565b6110609087614129565b955061106b826125db565b82547fffffffffffffffffffffffffffffffff00000000000000000000000000000000166401000000006bffffffffffffffffffffffff92909216919091027fffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000161763ffffffff841617825560405183815284907f645b3dc30fbdcc9749f62868ae25c191ff0090b1c21905c2793ec7159856e4389060200160405180910390a284600101945050505050610fa0565b5060045460009061113a908390600160901b900463ffffffff16614129565b90506000811361115d57604051632d0483c560e21b815260040160405180910390fd5b63ffffffff81111561118257604051632d0483c560e21b815260040160405180910390fd5b6004805463ffffffff909216600160901b027fffffffffffffffffffff00000000ffffffffffffffffffffffffffffffffffff9092169190911790555050505050505050565b60008281526007602090815260408083206001600160a01b0385168452600681019092528220826111fc8684846001612615565b90506112088183612735565b9695505050505050565b600061121d816120f1565b60045465ffffffffffff164210611260576040517fecdd1c2900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600354600480547fffffffffffffffffffffffffffff0000000000000000000000000000000000008116600160b01b90930469ffffffffffffffffffff164265ffffffffffff808416829003929092026601000000000000938490046bffffffffffffffffffffffff9081168290031690930265ffffffffffff191694909417931692909217905561131c7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633836121dc565b6040517fac02d07d013ae7c7e3ee940f8df0877c2ab1103bf87ab258ce31665f7111f09290600090a15050565b7f0914bb97ca83e85ef385857d9d418f187ff630589e0c9f44db92976d8e4519cb611373816120f1565b61137b612552565b6005546bffffffffffffffffffffffff8311156113c4576040517f35278d1200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600460068282829054906101000a90046bffffffffffffffffffffffff166113ed919061419d565b82546bffffffffffffffffffffffff9182166101009390930a92830291909202199091161790555060045460009065ffffffffffff1642106114325750808304611463565b506003546004544265ffffffffffff9091160369ffffffffffffffffffff600160b01b909204919091160283018190045b80600003611484576040516324d0659d60e11b815260040160405180910390fd5b6003805475ffffffffffffffffffffffffffffffffffffffffffff16600160b01b69ffffffffffffffffffff8416021790556114c082426141cd565b6004805465ffffffffffff191665ffffffffffff929092169190911790556115137f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163330876127f7565b6040518481527fde88a922e0d3b88b24e9623efeb464919c6bf9f66857a65e2bfcf2ce87a9433d9060200160405180910390a150505050565b6115546119b7565b610d4d82338360006040518060400160405280600081526020016000815250611c3f565b6004546000904265ffffffffffff909116106115a957600354600160b01b900469ffffffffffffffffffff166115ac565b60005b69ffffffffffffffffffff16905090565b60006115c8816120f1565b6004544265ffffffffffff909116111561160e576040517f085de62500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6201000182101561163257604051632d0483c560e21b815260040160405180910390fd5b63ffffffff82111561165757604051632d0483c560e21b815260040160405180910390fd5b60058290556040518281527fbd6eb9cf4d6e2902587c57e3163aaafdb46e3b3f2086bdfa75c790228930a9d79060200160405180910390a15050565b6000828152600760205260408120816116ae600383016128a3565b6001600160a01b03851660009081526006840160205260408120919250906116d5906128a3565b905080156117005781816116e7611578565b6116f191906141e5565b6116fb9190614204565b611208565b50600095945050505050565b600082815260016020526040812061172490836128e0565b9392505050565b6000818152600160205260408120610b6f906128ec565b61174a6119b7565b600260065561175a8160006128f6565b506001600655565b60008281526020819052604090206001015461177d816120f1565b610cbb838361211d565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff6117b1816120f1565b610cbb8383612cef565b6117c36119b7565b60026006556117e0823360006001610ba736879003870187613ffd565b50506001600655565b6117f16119b7565b6117fc816000612288565b50565b60008181526002602052604081205463ffffffff16801561184c57600454600160901b900463ffffffff1681611833611578565b61183d91906141e5565b6118479190614204565b611724565b60009392505050565b61185d6119b7565b600260065561175a8160016128f6565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610d4d576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556118c73390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000611724836001600160a01b038416612e73565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b000000000000000000000000000000000000000000000000000000001480610b6f57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614610b6f565b6006546002036119f3576040517fab143c0600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6000818152600760209081526040808320338452600681019092528220611a1b82612281565b611a258483612ec2565b5083600003611a475760405163b968846160e01b815260040160405180910390fd5b611a5081612f28565b611a5b848383612f84565b6004820180546bffffffffffffffffffffffff1916905592506000839003611a96576040516324d0659d60e11b815260040160405180910390fd5b805460038201546001600160681b0390911690611ac290600160981b900465ffffffffffff1642614226565b611acc90826141e5565b600383018054600090611ae99084906001600160981b031661423d565b92506101000a8154816001600160981b0302191690836001600160981b03160217905550611b66838360038101805465ffffffffffff4216600160981b027fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffffff90911617905560048201546001820155600590910154600290910155565b6000336001600160a01b0316867f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace87604051611ba491815260200190565b60405180910390a460018301546001600160a01b03168015611c36576040516344af0fa760e01b8152600481018790523360248201819052604482015260648101869052608481018390526001600160a01b038216906344af0fa79060a401600060405180830381600087803b158015611c1d57600080fd5b505af1158015611c31573d6000803e3d6000fd5b505050505b50505050919050565b60008581526007602090815260408083206001600160a01b038816845260068101909252909120611c6f82612281565b6003820180546001600160681b03168015611c9057611c8e8985612ec2565b505b6000611c9d8a8686612f84565b9050600080886002811115611cb457611cb4613eff565b03611cee57506004840180546bffffffffffffffffffffffff19166bffffffffffffffffffffffff92909216919091179055600087611db6565b6002886002811115611d0257611d02613eff565b03611d58578a15611d1557611d1561425f565b611d20868a89612fa9565b6004860180546bffffffffffffffffffffffff19166bffffffffffffffffffffffff9490941693909317909255909750600090611db6565b6001886002811115611d6c57611d6c613eff565b14611d7957611d7961425f565b8815611d8757611d8761425f565b611d908661330b565b50611d9c868389612fa9565b6004860180546bffffffffffffffffffffffff1916905598505b88600003611dd7576040516324d0659d60e11b815260040160405180910390fd5b600080611de48b866141cd565b90506001600160681b03811115611e27576040517f35278d1200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008b420290508087600001600d8282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b03160217905550818760000160006101000a8154816001600160681b0302191690836001600160681b03160217905550600088600001905060008160000160009054906101000a90046001600160681b03166001600160681b031690508d81019450848260000160006101000a8154816001600160681b0302191690836001600160681b031602179055508282600001600d8282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b031602179055508960030160139054906101000a900465ffffffffffff1665ffffffffffff16420381028a60030160008282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b0316021790555050505050611ff4878760038101805465ffffffffffff4216600160981b027fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffffff90911617905560048201546001820155600590910154600290910155565b8115612011578654612011906001600160a01b03163330856127f7565b898b6001600160a01b03168d7f17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a328660405161204e91815260200190565b60405180910390a460018701546001600160a01b031680156120e2576040516344af0fa760e01b8152600481018e90526001600160a01b038d811660248301819052604483015260648201869052608482018490528216906344af0fa79060a401600060405180830381600087803b1580156120c957600080fd5b505af11580156120dd573d6000803e3d6000fd5b505050505b50505050505050505050505050565b6117fc81336135b6565b612105828261186d565b6000828152600160205260409020610cbb908261190b565b6121278282613634565b6000828152600160205260409020610cbb90826136b3565b60025b815474010000000000000000000000000000000000000000900460ff16600281111561217057612170613eff565b146117fc5760405163b968846160e01b815260040160405180910390fd5b6000612198612552565b60008281526002602052604090206121af816125db565b81547fffffffffffffffffffffffffffffffff000000000000000000000000ffffffff1690915592915050565b60006040517fa9059cbb000000000000000000000000000000000000000000000000000000008152836004820152826024820152602060006044836000895af13d15601f3d116001600051141617169150508061227b5760405162461bcd60e51b815260206004820152600f60248201527f5452414e534645525f4641494c454400000000000000000000000000000000006044820152606401610d3a565b50505050565b6001612142565b6000828152600760209081526040808320338452600681019092529091206122af82612281565b6122b98483612ec2565b506122c484826136c8565b805481906001600160681b03168085111561230b576040517ff4d678b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000612318878686612f84565b6004850180546bffffffffffffffffffffffff1916905590508515801561233d575080155b1561235b576040516324d0659d60e11b815260040160405180910390fd5b600385810180546001600160681b038082168a900381166cffffffffffffffffffffffffff19909216821780845587546001600160981b036d0100000000000000000000000000918290048116928290048116428e8b03818102928301959095038316840290961790965594909416909302908316178655918601805465ffffffffffff909316600160981b027fffffffffffffff000000000000000000000000000000000000000000000000009093169290921790915560048601546001860155600586015460028601558115612461576124616001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633846121dc565b861561247d57855461247d906001600160a01b031633896121dc565b86336001600160a01b0316897f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace856040516124ba91815260200190565b60405180910390a460018601546001600160a01b03168015612547576040516344af0fa760e01b8152600481018a90523360248201819052604482015260648101849052608481018390526001600160a01b038216906344af0fa79060a401600060405180830381600087803b15801561253357600080fd5b505af11580156120e2573d6000803e3d6000fd5b505050505050505050565b61255a61376e565b6003805460009061257e9084906fffffffffffffffffffffffffffffffff16614275565b92506101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff16021790555042600360106101000a81548165ffffffffffff021916908365ffffffffffff160217905550565b6000806125e983600061379a565b6003548454600160801b6fffffffffffffffffffffffffffffffff928316029116179093555090919050565b60408051808201909152600080825260208201526003830154600160981b900465ffffffffffff1660000361265e5750604080518082019091526000808252602082015261272d565b600183016004850183156126f4576000878152600260205260408120612684908661379a565b9050600080612693898461384a565b91509150604051806040016040528086600001548487600001546126b791906141cd565b6126c19190614226565b815260200186600101548387600101546126db91906141cd565b6126e59190614226565b8152509550505050505061272d565b6040805180820190915282548254829161270d91614226565b8152602001836001015483600101546127269190614226565b9052925050505b949350505050565b6003810154600090600160981b900465ffffffffffff16156127ee5760038201546020840151600160801b91612776916001600160981b03909116906141e5565b8354600385015460208701516001600160681b03909216916127a791600160981b900465ffffffffffff16906141e5565b86516127b39190614226565b6127bd91906141e5565b6127c791906141cd565b6127d19190614204565b600483015461184791906bffffffffffffffffffffffff166141cd565b50600092915050565b60006040517f23b872dd0000000000000000000000000000000000000000000000000000000081528460048201528360248201528260448201526020600060648360008a5af13d15601f3d116001600051141617169150508061289c5760405162461bcd60e51b815260206004820152601460248201527f5452414e534645525f46524f4d5f4641494c45440000000000000000000000006044820152606401610d3a565b5050505050565b80546000906001600160981b036d0100000000000000000000000000820416906128d6906001600160681b0316426141e5565b610b6f9190614226565b600061172483836138ad565b6000610b6f825490565b60008281526007602090815260408083203384526006810190925290912061291d82612281565b61292784826136c8565b8054600383019082906001600160681b0316600081900361295b576040516324d0659d60e11b815260040160405180910390fd5b82546001600160681b03808216839003166cffffffffffffffffffffffffff19909116811780855583546001600160981b036d01000000000000000000000000009182900481169282900481169290920390911602178355600087815260076020908152604080832033845260060190915281208181556001810182905560028101919091556003810180547fffffffffffff000000000000000000000000000000000000000000000000000016905560040180546bffffffffffffffffffffffff191690558515612a9a578454612a46906001600160a01b0316336001600160681b0384166121dc565b806001600160681b0316336001600160a01b0316887f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace6000604051612a8d91815260200190565b60405180910390a4612bf7565b8454604080513360248201526001600160681b03841660448083019190915282518083039091018152606490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb00000000000000000000000000000000000000000000000000000000179052905160009283926001600160a01b0390911691612b2f91906142cc565b6000604051808303816000865af19150503d8060008114612b6c576040519150601f19603f3d011682016040523d82523d6000602084013e612b71565b606091505b5091509150818015612b84575060008151115b8015612b9f575080806020019051810190612b9f91906142e8565b15612bf457826001600160681b0316336001600160a01b03168a7f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace6000604051612beb91815260200190565b60405180910390a45b50505b600185015460408051602481018a90523360448201819052606482015260006084820181905260a48083018290528351808403909101815260c490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166344af0fa760e01b179052915191926001600160a01b031691612c7d91906142cc565b6000604051808303816000865af19150503d8060008114612cba576040519150601f19603f3d011682016040523d82523d6000602084013e612cbf565b606091505b5050905080612ce557600088815260096020908152604080832033845290915290204290555b5050505050505050565b600a805460009182612d008361430a565b9091555090506001600160a01b0383161580612d2d57506000826002811115612d2b57612d2b613eff565b145b15612d64576040517f4a0bd98600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001826002811115612d7857612d78613eff565b148015612d8d57506001600160a01b0383163b155b15612dab5760405163c1ab6dc160e01b815260040160405180910390fd5b600081815260076020526040902080546001600160a01b03851673ffffffffffffffffffffffffffffffffffffffff19821681178355849183917fffffffffffffffffffffff0000000000000000000000000000000000000000009091161774010000000000000000000000000000000000000000836002811115612e3257612e32613eff565b02179055506040516001600160a01b0385169083907f3d82013e0d368d05bfb8b953d35bffd6eec15520773228de41146f306a241aec90600090a350505050565b6000818152600183016020526040812054612eba57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610b6f565b506000610b6f565b600080612ece8461218e565b9050600080612edd858461384a565b91509150600085600401905082816000016000828254612efd91906141cd565b9250508190555081816001016000828254612f1891906141cd565b9091555093979650505050505050565b6003810154600160c81b900460ff166117fc57336000908152600860205260409020805460010190556003810180547fffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffff16600160c81b17905550565b600080612f948585856000612615565b9050612fa08184612735565b95945050505050565b82546002840154604080517f0902f1ac00000000000000000000000000000000000000000000000000000000815290516000936001600160a01b03908116931691849182918591630902f1ac916004808201926060929091908290030181865afa15801561301b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061303f9190614342565b506dffffffffffffffffffffffffffff91821693501690507f000000000000000000000000000000000000000000000000000000000000000060006001600160a01b03808616908316106130a757826130988a866141e5565b6130a29190614204565b6130bc565b836130b28a856141e5565b6130bc9190614204565b905087602001518111156130fc576040517f4c9b2c5900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8751811015613137576040517f4c9b2c5900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3415613251577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316856001600160a01b03161461318f5760405163c1ab6dc160e01b815260040160405180910390fd5b876020015134146131cc576040517f2c5211c600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b846001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561320757600080fd5b505af115801561321b573d6000803e3d6000fd5b50613236935050506001600160a01b038716905087836121dc565b3481810390821461324b5761324b33826138d7565b50613266565b6132666001600160a01b0386163388846127f7565b61327a6001600160a01b038316878b6121dc565b6040517f6a6278420000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03871690636a627842906024016020604051808303816000875af11580156132d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132fd9190614389565b9a9950505050505050505050565b60028101546001600160a01b0316806135b1578154604080517f0dfe168100000000000000000000000000000000000000000000000000000000815290516001600160a01b03909216916000918391630dfe1681916004808201926020929091908290030181865afa158015613385573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133a991906143a2565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156133eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061340f91906143a2565b6040517fe6a439050000000000000000000000000000000000000000000000000000000081526001600160a01b0384811660048301528083166024830152919250818516917f0000000000000000000000000000000000000000000000000000000000000000169063e6a4390590604401602060405180830381865afa15801561349d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134c191906143a2565b6001600160a01b0316146134e85760405163c1ab6dc160e01b815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316826001600160a01b03160361352957809350613583565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b03160361356a57819350613583565b60405163b968846160e01b815260040160405180910390fd5b50505060028201805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383161790555b919050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610d4d576135f2816001600160a01b03166014613932565b6135fd836020613932565b60405160200161360e9291906143bf565b60408051601f198184030181529082905262461bcd60e51b8252610d3a91600401614440565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1615610d4d576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6000611724836001600160a01b038416613b5b565b81600003613717573360009081526008602052604090205415610d4d576040517f0f2e5b6c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6003810154600160c81b900460ff1615610d4d57336000908152600860205260409020805460001901905560030180547fffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffff16905550565b600080613779613c4e565b60045463ffffffff600160901b909104166401000000009091020492915050565b600080826137bc576003546fffffffffffffffffffffffffffffffff166137db565b6137c461376e565b6003546fffffffffffffffffffffffffffffffff16015b84546fffffffffffffffffffffffffffffffff9182169250600160801b81049091168203906401000000009063ffffffff16820286546bffffffffffffffffffffffff6401000000009091048116929091049190910193508311156138425761384261425f565b505092915050565b600080600061385b856003016128a3565b905080156138a55780600160801b61387342876141e5565b61387d91906141e5565b6138879190614204565b925080613898600160801b866141e5565b6138a29190614204565b91505b509250929050565b60008260000182815481106138c4576138c461405a565b9060005260206000200154905092915050565b600080600080600085875af1905080610cbb5760405162461bcd60e51b815260206004820152601360248201527f4554485f5452414e534645525f4641494c4544000000000000000000000000006044820152606401610d3a565b606060006139418360026141e5565b61394c9060026141cd565b67ffffffffffffffff81111561396457613964613fe7565b6040519080825280601f01601f19166020018201604052801561398e576020820181803683370190505b5090507f3000000000000000000000000000000000000000000000000000000000000000816000815181106139c5576139c561405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110613a2857613a2861405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506000613a648460026141e5565b613a6f9060016141cd565b90505b6001811115613b0c577f303132333435363738396162636465660000000000000000000000000000000085600f1660108110613ab057613ab061405a565b1a60f81b828281518110613ac657613ac661405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060049490941c93613b0581614473565b9050613a72565b5083156117245760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610d3a565b60008181526001830160205260408120548015613c44576000613b7f600183614226565b8554909150600090613b9390600190614226565b9050818114613bf8576000866000018281548110613bb357613bb361405a565b9060005260206000200154905080876000018481548110613bd657613bd661405a565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613c0957613c0961448a565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610b6f565b6000915050610b6f565b60045460009065ffffffffffff1681428210613c6a5742613c6c565b815b600354909150600160801b900465ffffffffffff1680821115613ca857600354600160b01b900469ffffffffffffffffffff1691030292915050565b6000935050505090565b604080516101008101909152600060c0820181815260e083019190915281908152602001613cf3604051806040016040528060008152602001600081525090565b8152600060208201819052604082018190526060820181905260809091015290565b600060208284031215613d2757600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461172457600080fd5b6000808284036060811215613d6b57600080fd5b833592506040601f1982011215613d8157600080fd5b506020830190509250929050565b600060208284031215613da157600080fd5b5035919050565b6001600160a01b03811681146117fc57600080fd5b60008060408385031215613dd057600080fd5b823591506020830135613de281613da8565b809150509250929050565b600080600060608486031215613e0257600080fd5b833592506020840135613e1481613da8565b929592945050506040919091013590565b60008060408385031215613e3857600080fd5b50508035926020909101359150565b60008083601f840112613e5957600080fd5b50813567ffffffffffffffff811115613e7157600080fd5b6020830191508360208260051b8501011115613e8c57600080fd5b9250929050565b60008060008060408587031215613ea957600080fd5b843567ffffffffffffffff80821115613ec157600080fd5b613ecd88838901613e47565b90965094506020870135915080821115613ee657600080fd5b50613ef387828801613e47565b95989497509550505050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b03878116825261010082019060038810613f4657634e487b7160e01b600052602160045260246000fd5b602083810198909852958616604083015293909416606085015281516001600160681b03166080850152908401516001600160981b031660a0840152805160c08401529092015160e090910152919050565b600060208284031215613faa57600080fd5b813561172481613da8565b60008060408385031215613fc857600080fd5b8235613fd381613da8565b9150602083013560038110613de257600080fd5b634e487b7160e01b600052604160045260246000fd5b60006040828403121561400f57600080fd5b6040516040810181811067ffffffffffffffff8211171561404057634e487b7160e01b600052604160045260246000fd5b604052823581526020928301359281019290925250919050565b634e487b7160e01b600052603260045260246000fd5b63ffffffff811681146117fc57600080fd5b60006020828403121561409457600080fd5b813561172481614070565b634e487b7160e01b600052601160045260246000fd5b6000808312837f8000000000000000000000000000000000000000000000000000000000000000018312811516156140ef576140ef61409f565b837f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0183138116156141235761412361409f565b50500390565b6000808212827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038413811516156141635761416361409f565b827f80000000000000000000000000000000000000000000000000000000000000000384128116156141975761419761409f565b50500190565b60006bffffffffffffffffffffffff8083168185168083038211156141c4576141c461409f565b01949350505050565b600082198211156141e0576141e061409f565b500190565b60008160001904831182151516156141ff576141ff61409f565b500290565b60008261422157634e487b7160e01b600052601260045260246000fd5b500490565b6000828210156142385761423861409f565b500390565b60006001600160981b038083168185168083038211156141c4576141c461409f565b634e487b7160e01b600052600160045260246000fd5b60006fffffffffffffffffffffffffffffffff8083168185168083038211156141c4576141c461409f565b60005b838110156142bb5781810151838201526020016142a3565b8381111561227b5750506000910152565b600082516142de8184602087016142a0565b9190910192915050565b6000602082840312156142fa57600080fd5b8151801515811461172457600080fd5b6000600019820361431d5761431d61409f565b5060010190565b80516dffffffffffffffffffffffffffff811681146135b157600080fd5b60008060006060848603121561435757600080fd5b61436084614324565b925061436e60208501614324565b9150604084015161437e81614070565b809150509250925092565b60006020828403121561439b57600080fd5b5051919050565b6000602082840312156143b457600080fd5b815161172481613da8565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516143f78160178501602088016142a0565b7f206973206d697373696e6720726f6c652000000000000000000000000000000060179184019182015283516144348160288401602088016142a0565b01602801949350505050565b602081526000825180602084015261445f8160408501602087016142a0565b601f01601f19169190910160400192915050565b6000816144825761448261409f565b506000190190565b634e487b7160e01b600052603160045260246000fdfea264697066735822122027f9d01da3d32717fd6b88a18cc73e225ef20368c4daca229be32bbe8a0d60d964736f6c634300080f0033";
var deployedBytecode = "0x6080604052600436106102dc5760003560e01c80637b0a47ee11610184578063c45a0155116100d6578063d61f06801161008a578063ebe2b12b11610064578063ebe2b12b14610aba578063f2d1e1cd14610ad9578063f851844b14610af957600080fd5b8063d61f068014610a67578063d97f8ed614610a87578063ddc6326214610a9a57600080fd5b8063cea84402116100bb578063cea84402146109f3578063d1af0c7d14610a13578063d547741f14610a4757600080fd5b8063c45a01551461099f578063ca15c873146109d357600080fd5b806396c82e5711610138578063b470aade11610112578063b470aade1461091f578063c046371114610935578063c348dac11461097257600080fd5b806396c82e5714610801578063a217fddf1461083a578063ac4afa381461084f57600080fd5b806382f084d31161016957806382f084d31461077d5780639010d07c1461079d57806391d14854146107bd57600080fd5b80637b0a47ee146107485780637c2d6e011461075d57600080fd5b8063379607f51161023d57806359b02eb3116101f15780636bc9f703116101cb5780636bc9f7031461066257806374de4ec4146107085780637b0472f01461072857600080fd5b806359b02eb3146105f55780635faa65ff14610615578063677f93261461062a57600080fd5b806343de32071161022257806343de320714610595578063441a3e70146105b557806354f8c475146105d557600080fd5b8063379607f51461055557806343d5599e1461057557600080fd5b8063257664a4116102945780632f2ff15d116102795780632f2ff15d146104cb5780633228dd59146104eb57806336568abe1461053557600080fd5b8063257664a4146104015780632716ae66146104b657600080fd5b806317fcb39b116102c557806317fcb39b14610362578063190d8ef4146103ae578063248a9ca3146103c357600080fd5b806301ffc9a7146102e1578063098b885814610316575b600080fd5b3480156102ed57600080fd5b506103016102fc366004613d15565b610b19565b60405190151581526020015b60405180910390f35b34801561032257600080fd5b5060045461034590660100000000000090046bffffffffffffffffffffffff1681565b6040516bffffffffffffffffffffffff909116815260200161030d565b34801561036e57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161030d565b6103c16103bc366004613d57565b610b75565b005b3480156103cf57600080fd5b506103f36103de366004613d8f565b60009081526020819052604090206001015490565b60405190815260200161030d565b34801561040d57600080fd5b5061042161041c366004613dbd565b610bb6565b60405161030d9190815180516001600160681b031682526020908101516001600160981b031690820152610100810160208381015180516040850152908101516060840152506001600160981b03604084015116608083015265ffffffffffff60608401511660a08301526080830151151560c08301526bffffffffffffffffffffffff60a08401511660e083015292915050565b3480156104c257600080fd5b50600a546103f3565b3480156104d757600080fd5b506103c16104e6366004613dbd565b610c96565b3480156104f757600080fd5b50600354610514906fffffffffffffffffffffffffffffffff1681565b6040516fffffffffffffffffffffffffffffffff909116815260200161030d565b34801561054157600080fd5b506103c1610550366004613dbd565b610cc0565b34801561056157600080fd5b506103f3610570366004613d8f565b610d51565b34801561058157600080fd5b506103c1610590366004613ded565b610e46565b3480156105a157600080fd5b506103c16105b0366004613dbd565b610e72565b3480156105c157600080fd5b506103c16105d0366004613e25565b610f11565b3480156105e157600080fd5b506103c16105f0366004613e93565b610f23565b34801561060157600080fd5b506103f3610610366004613dbd565b6111c8565b34801561062157600080fd5b506103c1611212565b34801561063657600080fd5b506103f3610645366004613dbd565b600960209081526000928352604080842090915290825290205481565b34801561066e57600080fd5b506106c761067d366004613d8f565b60026020526000908152604090205463ffffffff81169064010000000081046bffffffffffffffffffffffff1690600160801b90046fffffffffffffffffffffffffffffffff1683565b6040805163ffffffff90941684526bffffffffffffffffffffffff90921660208401526fffffffffffffffffffffffffffffffff169082015260600161030d565b34801561071457600080fd5b506103c1610723366004613d8f565b611349565b34801561073457600080fd5b506103c1610743366004613e25565b61154c565b34801561075457600080fd5b506103f3611578565b34801561076957600080fd5b506103c1610778366004613d8f565b6115bd565b34801561078957600080fd5b506103f3610798366004613dbd565b611693565b3480156107a957600080fd5b506103966107b8366004613e25565b61170c565b3480156107c957600080fd5b506103016107d8366004613dbd565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b34801561080d57600080fd5b5060045461082590600160901b900463ffffffff1681565b60405163ffffffff909116815260200161030d565b34801561084657600080fd5b506103f3600081565b34801561085b57600080fd5b5061090d61086a366004613d8f565b6007602090815260009182526040918290208054600182015460028301548551808701875260038501546001600160681b03811682526d010000000000000000000000000090046001600160981b031681870152865180880190975260048501548752600590940154948601949094526001600160a01b03808316957401000000000000000000000000000000000000000090930460ff16949181169391169186565b60405161030d96959493929190613f15565b34801561092b57600080fd5b506103f360055481565b34801561094157600080fd5b5060035461095b90600160801b900465ffffffffffff1681565b60405165ffffffffffff909116815260200161030d565b34801561097e57600080fd5b506103f361098d366004613f98565b60086020526000908152604090205481565b3480156109ab57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b3480156109df57600080fd5b506103f36109ee366004613d8f565b61172b565b3480156109ff57600080fd5b506103c1610a0e366004613d8f565b611742565b348015610a1f57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b348015610a5357600080fd5b506103c1610a62366004613dbd565b611762565b348015610a7357600080fd5b506103c1610a82366004613fb5565b611787565b6103c1610a95366004613d57565b6117bb565b348015610aa657600080fd5b506103c1610ab5366004613d8f565b6117e9565b348015610ac657600080fd5b5060045461095b9065ffffffffffff1681565b348015610ae557600080fd5b506103f3610af4366004613d8f565b6117ff565b348015610b0557600080fd5b506103c1610b14366004613d8f565b611855565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5a05180f000000000000000000000000000000000000000000000000000000001480610b6f5750610b6f82611920565b92915050565b610b7d6119b7565b60026006556000610b8d836119f5565b9050610bac600033836002610ba736889003880188613ffd565b611c3f565b5050600160065550565b610bbe613cb2565b5060008281526007602090815260408083206001600160a01b038516845260060182529182902082516101008101845281546001600160681b03811660c083019081526d01000000000000000000000000009091046001600160981b0390811660e0840152908252845180860186526001840154815260028401548186015293820193909352600382015492831693810193909352600160981b820465ffffffffffff166060840152600160c81b90910460ff1615156080830152600401546bffffffffffffffffffffffff1660a082015292915050565b600082815260208190526040902060010154610cb1816120f1565b610cbb83836120fb565b505050565b6001600160a01b0381163314610d435760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c66000000000000000000000000000000000060648201526084015b60405180910390fd5b610d4d828261211d565b5050565b6000610d5b6119b7565b6000828152600760205260409020610d728161213f565b80546001600160a01b03163314610db5576040517f38c5856200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610dbe8361218e565b91508115610dfa57610dfa6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633846121dc565b6000336001600160a01b0316847f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace85604051610e3891815260200190565b60405180910390a450919050565b610e4e6119b7565b610cbb83838360006040518060400160405280600081526020016000815250611c3f565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff610e9c816120f1565b6000838152600760205260409020610eb381612281565b60018101805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03851690811790915560405185907f865fdcfd963a9e21f0dbb101fecee79dda3ecc602d0fe55e29268c843f2a3b7c90600090a350505050565b610f196119b7565b610d4d8282612288565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff610f4d816120f1565b610f55612552565b83828114610f8f576040517f568efce200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610f9a600a5490565b90506000805b8381101561111b576000898983818110610fbc57610fbc61405a565b9050602002013590506000888884818110610fd957610fd961405a565b9050602002016020810190610fee9190614082565b63ffffffff16905084821061101657604051632d0483c560e21b815260040160405180910390fd5b6000828152600260205260409020805463ffffffff1680830361104c576040516324d0659d60e11b815260040160405180910390fd5b61105681846140b5565b6110609087614129565b955061106b826125db565b82547fffffffffffffffffffffffffffffffff00000000000000000000000000000000166401000000006bffffffffffffffffffffffff92909216919091027fffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000161763ffffffff841617825560405183815284907f645b3dc30fbdcc9749f62868ae25c191ff0090b1c21905c2793ec7159856e4389060200160405180910390a284600101945050505050610fa0565b5060045460009061113a908390600160901b900463ffffffff16614129565b90506000811361115d57604051632d0483c560e21b815260040160405180910390fd5b63ffffffff81111561118257604051632d0483c560e21b815260040160405180910390fd5b6004805463ffffffff909216600160901b027fffffffffffffffffffff00000000ffffffffffffffffffffffffffffffffffff9092169190911790555050505050505050565b60008281526007602090815260408083206001600160a01b0385168452600681019092528220826111fc8684846001612615565b90506112088183612735565b9695505050505050565b600061121d816120f1565b60045465ffffffffffff164210611260576040517fecdd1c2900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600354600480547fffffffffffffffffffffffffffff0000000000000000000000000000000000008116600160b01b90930469ffffffffffffffffffff164265ffffffffffff808416829003929092026601000000000000938490046bffffffffffffffffffffffff9081168290031690930265ffffffffffff191694909417931692909217905561131c7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633836121dc565b6040517fac02d07d013ae7c7e3ee940f8df0877c2ab1103bf87ab258ce31665f7111f09290600090a15050565b7f0914bb97ca83e85ef385857d9d418f187ff630589e0c9f44db92976d8e4519cb611373816120f1565b61137b612552565b6005546bffffffffffffffffffffffff8311156113c4576040517f35278d1200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600460068282829054906101000a90046bffffffffffffffffffffffff166113ed919061419d565b82546bffffffffffffffffffffffff9182166101009390930a92830291909202199091161790555060045460009065ffffffffffff1642106114325750808304611463565b506003546004544265ffffffffffff9091160369ffffffffffffffffffff600160b01b909204919091160283018190045b80600003611484576040516324d0659d60e11b815260040160405180910390fd5b6003805475ffffffffffffffffffffffffffffffffffffffffffff16600160b01b69ffffffffffffffffffff8416021790556114c082426141cd565b6004805465ffffffffffff191665ffffffffffff929092169190911790556115137f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163330876127f7565b6040518481527fde88a922e0d3b88b24e9623efeb464919c6bf9f66857a65e2bfcf2ce87a9433d9060200160405180910390a150505050565b6115546119b7565b610d4d82338360006040518060400160405280600081526020016000815250611c3f565b6004546000904265ffffffffffff909116106115a957600354600160b01b900469ffffffffffffffffffff166115ac565b60005b69ffffffffffffffffffff16905090565b60006115c8816120f1565b6004544265ffffffffffff909116111561160e576040517f085de62500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6201000182101561163257604051632d0483c560e21b815260040160405180910390fd5b63ffffffff82111561165757604051632d0483c560e21b815260040160405180910390fd5b60058290556040518281527fbd6eb9cf4d6e2902587c57e3163aaafdb46e3b3f2086bdfa75c790228930a9d79060200160405180910390a15050565b6000828152600760205260408120816116ae600383016128a3565b6001600160a01b03851660009081526006840160205260408120919250906116d5906128a3565b905080156117005781816116e7611578565b6116f191906141e5565b6116fb9190614204565b611208565b50600095945050505050565b600082815260016020526040812061172490836128e0565b9392505050565b6000818152600160205260408120610b6f906128ec565b61174a6119b7565b600260065561175a8160006128f6565b506001600655565b60008281526020819052604090206001015461177d816120f1565b610cbb838361211d565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff6117b1816120f1565b610cbb8383612cef565b6117c36119b7565b60026006556117e0823360006001610ba736879003870187613ffd565b50506001600655565b6117f16119b7565b6117fc816000612288565b50565b60008181526002602052604081205463ffffffff16801561184c57600454600160901b900463ffffffff1681611833611578565b61183d91906141e5565b6118479190614204565b611724565b60009392505050565b61185d6119b7565b600260065561175a8160016128f6565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610d4d576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556118c73390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000611724836001600160a01b038416612e73565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b000000000000000000000000000000000000000000000000000000001480610b6f57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614610b6f565b6006546002036119f3576040517fab143c0600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6000818152600760209081526040808320338452600681019092528220611a1b82612281565b611a258483612ec2565b5083600003611a475760405163b968846160e01b815260040160405180910390fd5b611a5081612f28565b611a5b848383612f84565b6004820180546bffffffffffffffffffffffff1916905592506000839003611a96576040516324d0659d60e11b815260040160405180910390fd5b805460038201546001600160681b0390911690611ac290600160981b900465ffffffffffff1642614226565b611acc90826141e5565b600383018054600090611ae99084906001600160981b031661423d565b92506101000a8154816001600160981b0302191690836001600160981b03160217905550611b66838360038101805465ffffffffffff4216600160981b027fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffffff90911617905560048201546001820155600590910154600290910155565b6000336001600160a01b0316867f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace87604051611ba491815260200190565b60405180910390a460018301546001600160a01b03168015611c36576040516344af0fa760e01b8152600481018790523360248201819052604482015260648101869052608481018390526001600160a01b038216906344af0fa79060a401600060405180830381600087803b158015611c1d57600080fd5b505af1158015611c31573d6000803e3d6000fd5b505050505b50505050919050565b60008581526007602090815260408083206001600160a01b038816845260068101909252909120611c6f82612281565b6003820180546001600160681b03168015611c9057611c8e8985612ec2565b505b6000611c9d8a8686612f84565b9050600080886002811115611cb457611cb4613eff565b03611cee57506004840180546bffffffffffffffffffffffff19166bffffffffffffffffffffffff92909216919091179055600087611db6565b6002886002811115611d0257611d02613eff565b03611d58578a15611d1557611d1561425f565b611d20868a89612fa9565b6004860180546bffffffffffffffffffffffff19166bffffffffffffffffffffffff9490941693909317909255909750600090611db6565b6001886002811115611d6c57611d6c613eff565b14611d7957611d7961425f565b8815611d8757611d8761425f565b611d908661330b565b50611d9c868389612fa9565b6004860180546bffffffffffffffffffffffff1916905598505b88600003611dd7576040516324d0659d60e11b815260040160405180910390fd5b600080611de48b866141cd565b90506001600160681b03811115611e27576040517f35278d1200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008b420290508087600001600d8282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b03160217905550818760000160006101000a8154816001600160681b0302191690836001600160681b03160217905550600088600001905060008160000160009054906101000a90046001600160681b03166001600160681b031690508d81019450848260000160006101000a8154816001600160681b0302191690836001600160681b031602179055508282600001600d8282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b031602179055508960030160139054906101000a900465ffffffffffff1665ffffffffffff16420381028a60030160008282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b0316021790555050505050611ff4878760038101805465ffffffffffff4216600160981b027fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffffff90911617905560048201546001820155600590910154600290910155565b8115612011578654612011906001600160a01b03163330856127f7565b898b6001600160a01b03168d7f17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a328660405161204e91815260200190565b60405180910390a460018701546001600160a01b031680156120e2576040516344af0fa760e01b8152600481018e90526001600160a01b038d811660248301819052604483015260648201869052608482018490528216906344af0fa79060a401600060405180830381600087803b1580156120c957600080fd5b505af11580156120dd573d6000803e3d6000fd5b505050505b50505050505050505050505050565b6117fc81336135b6565b612105828261186d565b6000828152600160205260409020610cbb908261190b565b6121278282613634565b6000828152600160205260409020610cbb90826136b3565b60025b815474010000000000000000000000000000000000000000900460ff16600281111561217057612170613eff565b146117fc5760405163b968846160e01b815260040160405180910390fd5b6000612198612552565b60008281526002602052604090206121af816125db565b81547fffffffffffffffffffffffffffffffff000000000000000000000000ffffffff1690915592915050565b60006040517fa9059cbb000000000000000000000000000000000000000000000000000000008152836004820152826024820152602060006044836000895af13d15601f3d116001600051141617169150508061227b5760405162461bcd60e51b815260206004820152600f60248201527f5452414e534645525f4641494c454400000000000000000000000000000000006044820152606401610d3a565b50505050565b6001612142565b6000828152600760209081526040808320338452600681019092529091206122af82612281565b6122b98483612ec2565b506122c484826136c8565b805481906001600160681b03168085111561230b576040517ff4d678b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000612318878686612f84565b6004850180546bffffffffffffffffffffffff1916905590508515801561233d575080155b1561235b576040516324d0659d60e11b815260040160405180910390fd5b600385810180546001600160681b038082168a900381166cffffffffffffffffffffffffff19909216821780845587546001600160981b036d0100000000000000000000000000918290048116928290048116428e8b03818102928301959095038316840290961790965594909416909302908316178655918601805465ffffffffffff909316600160981b027fffffffffffffff000000000000000000000000000000000000000000000000009093169290921790915560048601546001860155600586015460028601558115612461576124616001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633846121dc565b861561247d57855461247d906001600160a01b031633896121dc565b86336001600160a01b0316897f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace856040516124ba91815260200190565b60405180910390a460018601546001600160a01b03168015612547576040516344af0fa760e01b8152600481018a90523360248201819052604482015260648101849052608481018390526001600160a01b038216906344af0fa79060a401600060405180830381600087803b15801561253357600080fd5b505af11580156120e2573d6000803e3d6000fd5b505050505050505050565b61255a61376e565b6003805460009061257e9084906fffffffffffffffffffffffffffffffff16614275565b92506101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff16021790555042600360106101000a81548165ffffffffffff021916908365ffffffffffff160217905550565b6000806125e983600061379a565b6003548454600160801b6fffffffffffffffffffffffffffffffff928316029116179093555090919050565b60408051808201909152600080825260208201526003830154600160981b900465ffffffffffff1660000361265e5750604080518082019091526000808252602082015261272d565b600183016004850183156126f4576000878152600260205260408120612684908661379a565b9050600080612693898461384a565b91509150604051806040016040528086600001548487600001546126b791906141cd565b6126c19190614226565b815260200186600101548387600101546126db91906141cd565b6126e59190614226565b8152509550505050505061272d565b6040805180820190915282548254829161270d91614226565b8152602001836001015483600101546127269190614226565b9052925050505b949350505050565b6003810154600090600160981b900465ffffffffffff16156127ee5760038201546020840151600160801b91612776916001600160981b03909116906141e5565b8354600385015460208701516001600160681b03909216916127a791600160981b900465ffffffffffff16906141e5565b86516127b39190614226565b6127bd91906141e5565b6127c791906141cd565b6127d19190614204565b600483015461184791906bffffffffffffffffffffffff166141cd565b50600092915050565b60006040517f23b872dd0000000000000000000000000000000000000000000000000000000081528460048201528360248201528260448201526020600060648360008a5af13d15601f3d116001600051141617169150508061289c5760405162461bcd60e51b815260206004820152601460248201527f5452414e534645525f46524f4d5f4641494c45440000000000000000000000006044820152606401610d3a565b5050505050565b80546000906001600160981b036d0100000000000000000000000000820416906128d6906001600160681b0316426141e5565b610b6f9190614226565b600061172483836138ad565b6000610b6f825490565b60008281526007602090815260408083203384526006810190925290912061291d82612281565b61292784826136c8565b8054600383019082906001600160681b0316600081900361295b576040516324d0659d60e11b815260040160405180910390fd5b82546001600160681b03808216839003166cffffffffffffffffffffffffff19909116811780855583546001600160981b036d01000000000000000000000000009182900481169282900481169290920390911602178355600087815260076020908152604080832033845260060190915281208181556001810182905560028101919091556003810180547fffffffffffff000000000000000000000000000000000000000000000000000016905560040180546bffffffffffffffffffffffff191690558515612a9a578454612a46906001600160a01b0316336001600160681b0384166121dc565b806001600160681b0316336001600160a01b0316887f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace6000604051612a8d91815260200190565b60405180910390a4612bf7565b8454604080513360248201526001600160681b03841660448083019190915282518083039091018152606490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb00000000000000000000000000000000000000000000000000000000179052905160009283926001600160a01b0390911691612b2f91906142cc565b6000604051808303816000865af19150503d8060008114612b6c576040519150601f19603f3d011682016040523d82523d6000602084013e612b71565b606091505b5091509150818015612b84575060008151115b8015612b9f575080806020019051810190612b9f91906142e8565b15612bf457826001600160681b0316336001600160a01b03168a7f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace6000604051612beb91815260200190565b60405180910390a45b50505b600185015460408051602481018a90523360448201819052606482015260006084820181905260a48083018290528351808403909101815260c490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166344af0fa760e01b179052915191926001600160a01b031691612c7d91906142cc565b6000604051808303816000865af19150503d8060008114612cba576040519150601f19603f3d011682016040523d82523d6000602084013e612cbf565b606091505b5050905080612ce557600088815260096020908152604080832033845290915290204290555b5050505050505050565b600a805460009182612d008361430a565b9091555090506001600160a01b0383161580612d2d57506000826002811115612d2b57612d2b613eff565b145b15612d64576040517f4a0bd98600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001826002811115612d7857612d78613eff565b148015612d8d57506001600160a01b0383163b155b15612dab5760405163c1ab6dc160e01b815260040160405180910390fd5b600081815260076020526040902080546001600160a01b03851673ffffffffffffffffffffffffffffffffffffffff19821681178355849183917fffffffffffffffffffffff0000000000000000000000000000000000000000009091161774010000000000000000000000000000000000000000836002811115612e3257612e32613eff565b02179055506040516001600160a01b0385169083907f3d82013e0d368d05bfb8b953d35bffd6eec15520773228de41146f306a241aec90600090a350505050565b6000818152600183016020526040812054612eba57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610b6f565b506000610b6f565b600080612ece8461218e565b9050600080612edd858461384a565b91509150600085600401905082816000016000828254612efd91906141cd565b9250508190555081816001016000828254612f1891906141cd565b9091555093979650505050505050565b6003810154600160c81b900460ff166117fc57336000908152600860205260409020805460010190556003810180547fffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffff16600160c81b17905550565b600080612f948585856000612615565b9050612fa08184612735565b95945050505050565b82546002840154604080517f0902f1ac00000000000000000000000000000000000000000000000000000000815290516000936001600160a01b03908116931691849182918591630902f1ac916004808201926060929091908290030181865afa15801561301b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061303f9190614342565b506dffffffffffffffffffffffffffff91821693501690507f000000000000000000000000000000000000000000000000000000000000000060006001600160a01b03808616908316106130a757826130988a866141e5565b6130a29190614204565b6130bc565b836130b28a856141e5565b6130bc9190614204565b905087602001518111156130fc576040517f4c9b2c5900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8751811015613137576040517f4c9b2c5900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3415613251577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316856001600160a01b03161461318f5760405163c1ab6dc160e01b815260040160405180910390fd5b876020015134146131cc576040517f2c5211c600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b846001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561320757600080fd5b505af115801561321b573d6000803e3d6000fd5b50613236935050506001600160a01b038716905087836121dc565b3481810390821461324b5761324b33826138d7565b50613266565b6132666001600160a01b0386163388846127f7565b61327a6001600160a01b038316878b6121dc565b6040517f6a6278420000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03871690636a627842906024016020604051808303816000875af11580156132d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132fd9190614389565b9a9950505050505050505050565b60028101546001600160a01b0316806135b1578154604080517f0dfe168100000000000000000000000000000000000000000000000000000000815290516001600160a01b03909216916000918391630dfe1681916004808201926020929091908290030181865afa158015613385573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133a991906143a2565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156133eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061340f91906143a2565b6040517fe6a439050000000000000000000000000000000000000000000000000000000081526001600160a01b0384811660048301528083166024830152919250818516917f0000000000000000000000000000000000000000000000000000000000000000169063e6a4390590604401602060405180830381865afa15801561349d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134c191906143a2565b6001600160a01b0316146134e85760405163c1ab6dc160e01b815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316826001600160a01b03160361352957809350613583565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b03160361356a57819350613583565b60405163b968846160e01b815260040160405180910390fd5b50505060028201805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383161790555b919050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610d4d576135f2816001600160a01b03166014613932565b6135fd836020613932565b60405160200161360e9291906143bf565b60408051601f198184030181529082905262461bcd60e51b8252610d3a91600401614440565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1615610d4d576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6000611724836001600160a01b038416613b5b565b81600003613717573360009081526008602052604090205415610d4d576040517f0f2e5b6c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6003810154600160c81b900460ff1615610d4d57336000908152600860205260409020805460001901905560030180547fffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffff16905550565b600080613779613c4e565b60045463ffffffff600160901b909104166401000000009091020492915050565b600080826137bc576003546fffffffffffffffffffffffffffffffff166137db565b6137c461376e565b6003546fffffffffffffffffffffffffffffffff16015b84546fffffffffffffffffffffffffffffffff9182169250600160801b81049091168203906401000000009063ffffffff16820286546bffffffffffffffffffffffff6401000000009091048116929091049190910193508311156138425761384261425f565b505092915050565b600080600061385b856003016128a3565b905080156138a55780600160801b61387342876141e5565b61387d91906141e5565b6138879190614204565b925080613898600160801b866141e5565b6138a29190614204565b91505b509250929050565b60008260000182815481106138c4576138c461405a565b9060005260206000200154905092915050565b600080600080600085875af1905080610cbb5760405162461bcd60e51b815260206004820152601360248201527f4554485f5452414e534645525f4641494c4544000000000000000000000000006044820152606401610d3a565b606060006139418360026141e5565b61394c9060026141cd565b67ffffffffffffffff81111561396457613964613fe7565b6040519080825280601f01601f19166020018201604052801561398e576020820181803683370190505b5090507f3000000000000000000000000000000000000000000000000000000000000000816000815181106139c5576139c561405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110613a2857613a2861405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506000613a648460026141e5565b613a6f9060016141cd565b90505b6001811115613b0c577f303132333435363738396162636465660000000000000000000000000000000085600f1660108110613ab057613ab061405a565b1a60f81b828281518110613ac657613ac661405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060049490941c93613b0581614473565b9050613a72565b5083156117245760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610d3a565b60008181526001830160205260408120548015613c44576000613b7f600183614226565b8554909150600090613b9390600190614226565b9050818114613bf8576000866000018281548110613bb357613bb361405a565b9060005260206000200154905080876000018481548110613bd657613bd661405a565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613c0957613c0961448a565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610b6f565b6000915050610b6f565b60045460009065ffffffffffff1681428210613c6a5742613c6c565b815b600354909150600160801b900465ffffffffffff1680821115613ca857600354600160b01b900469ffffffffffffffffffff1691030292915050565b6000935050505090565b604080516101008101909152600060c0820181815260e083019190915281908152602001613cf3604051806040016040528060008152602001600081525090565b8152600060208201819052604082018190526060820181905260809091015290565b600060208284031215613d2757600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461172457600080fd5b6000808284036060811215613d6b57600080fd5b833592506040601f1982011215613d8157600080fd5b506020830190509250929050565b600060208284031215613da157600080fd5b5035919050565b6001600160a01b03811681146117fc57600080fd5b60008060408385031215613dd057600080fd5b823591506020830135613de281613da8565b809150509250929050565b600080600060608486031215613e0257600080fd5b833592506020840135613e1481613da8565b929592945050506040919091013590565b60008060408385031215613e3857600080fd5b50508035926020909101359150565b60008083601f840112613e5957600080fd5b50813567ffffffffffffffff811115613e7157600080fd5b6020830191508360208260051b8501011115613e8c57600080fd5b9250929050565b60008060008060408587031215613ea957600080fd5b843567ffffffffffffffff80821115613ec157600080fd5b613ecd88838901613e47565b90965094506020870135915080821115613ee657600080fd5b50613ef387828801613e47565b95989497509550505050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b03878116825261010082019060038810613f4657634e487b7160e01b600052602160045260246000fd5b602083810198909852958616604083015293909416606085015281516001600160681b03166080850152908401516001600160981b031660a0840152805160c08401529092015160e090910152919050565b600060208284031215613faa57600080fd5b813561172481613da8565b60008060408385031215613fc857600080fd5b8235613fd381613da8565b9150602083013560038110613de257600080fd5b634e487b7160e01b600052604160045260246000fd5b60006040828403121561400f57600080fd5b6040516040810181811067ffffffffffffffff8211171561404057634e487b7160e01b600052604160045260246000fd5b604052823581526020928301359281019290925250919050565b634e487b7160e01b600052603260045260246000fd5b63ffffffff811681146117fc57600080fd5b60006020828403121561409457600080fd5b813561172481614070565b634e487b7160e01b600052601160045260246000fd5b6000808312837f8000000000000000000000000000000000000000000000000000000000000000018312811516156140ef576140ef61409f565b837f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0183138116156141235761412361409f565b50500390565b6000808212827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038413811516156141635761416361409f565b827f80000000000000000000000000000000000000000000000000000000000000000384128116156141975761419761409f565b50500190565b60006bffffffffffffffffffffffff8083168185168083038211156141c4576141c461409f565b01949350505050565b600082198211156141e0576141e061409f565b500190565b60008160001904831182151516156141ff576141ff61409f565b500290565b60008261422157634e487b7160e01b600052601260045260246000fd5b500490565b6000828210156142385761423861409f565b500390565b60006001600160981b038083168185168083038211156141c4576141c461409f565b634e487b7160e01b600052600160045260246000fd5b60006fffffffffffffffffffffffffffffffff8083168185168083038211156141c4576141c461409f565b60005b838110156142bb5781810151838201526020016142a3565b8381111561227b5750506000910152565b600082516142de8184602087016142a0565b9190910192915050565b6000602082840312156142fa57600080fd5b8151801515811461172457600080fd5b6000600019820361431d5761431d61409f565b5060010190565b80516dffffffffffffffffffffffffffff811681146135b157600080fd5b60008060006060848603121561435757600080fd5b61436084614324565b925061436e60208501614324565b9150604084015161437e81614070565b809150509250925092565b60006020828403121561439b57600080fd5b5051919050565b6000602082840312156143b457600080fd5b815161172481613da8565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516143f78160178501602088016142a0565b7f206973206d697373696e6720726f6c652000000000000000000000000000000060179184019182015283516144348160288401602088016142a0565b01602801949350505050565b602081526000825180602084015261445f8160408501602087016142a0565b601f01601f19169190910160400192915050565b6000816144825761448261409f565b506000190190565b634e487b7160e01b600052603160045260246000fdfea264697066735822122027f9d01da3d32717fd6b88a18cc73e225ef20368c4daca229be32bbe8a0d60d964736f6c634300080f0033";
var linkReferences = {
};
var deployedLinkReferences = {
};
var PANGOCHEF_ABI = {
    _format: _format,
    contractName: contractName,
    sourceName: sourceName,
    abi: abi,
    bytecode: bytecode,
    deployedBytecode: deployedBytecode,
    linkReferences: linkReferences,
    deployedLinkReferences: deployedLinkReferences
};

var REWARDERVIAMULTIPLIER_ABI = [
    {
        inputs: [
            {
                internalType: "contract IERC20[]",
                name: "_rewardTokens",
                type: "address[]"
            },
            {
                internalType: "uint256[]",
                name: "_rewardMultipliers",
                type: "uint256[]"
            },
            {
                internalType: "uint256",
                name: "_baseRewardTokenDecimals",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "_chefV2",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
    },
    {
        inputs: [
        ],
        name: "getRewardMultipliers",
        outputs: [
            {
                internalType: "uint256[]",
                name: "",
                type: "uint256[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "getRewardTokens",
        outputs: [
            {
                internalType: "contract IERC20[]",
                name: "",
                type: "address[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "user",
                type: "address"
            },
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "rewardAmount",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        name: "onReward",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "user",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "rewardAmount",
                type: "uint256"
            }
        ],
        name: "pendingTokens",
        outputs: [
            {
                internalType: "contract IERC20[]",
                name: "tokens",
                type: "address[]"
            },
            {
                internalType: "uint256[]",
                name: "amounts",
                type: "uint256[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            },
            {
                internalType: "address",
                name: "user",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "rewardAmount",
                type: "uint256"
            }
        ],
        name: "pendingTokensDebt",
        outputs: [
            {
                internalType: "contract IERC20[]",
                name: "tokens",
                type: "address[]"
            },
            {
                internalType: "uint256[]",
                name: "amounts",
                type: "uint256[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        name: "rewardMultipliers",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        name: "rewardTokens",
        outputs: [
            {
                internalType: "contract IERC20",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
];

const REWARDER_VIA_MULTIPLIER_INTERFACE = new Interface(REWARDERVIAMULTIPLIER_ABI);

var SarStaking = [
    {
        inputs: [
            {
                internalType: "address",
                name: "newRewardsToken",
                type: "address"
            },
            {
                internalType: "address",
                name: "newAdmin",
                type: "address"
            },
            {
                internalType: "contract ITokenMetadata",
                name: "newTokenMetadata",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
    },
    {
        inputs: [
        ],
        name: "FailedTransfer",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "HighSlippage",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "InsufficientBalance",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "InvalidAmount",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "InvalidToken",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "InvalidType",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "Locked",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "MismatchedArrayLengths",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "NoEffect",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "NonExistentToken",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "NullInput",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "OutOfBounds",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "Overflow",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "TooEarly",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "TooLate",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "Underflow",
        type: "error"
    },
    {
        inputs: [
        ],
        name: "UnprivilegedCaller",
        type: "error"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "approved",
                type: "address"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "Approval",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "operator",
                type: "address"
            },
            {
                indexed: false,
                internalType: "bool",
                name: "approved",
                type: "bool"
            }
        ],
        name: "ApprovalForAll",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "newApprovalPauseDuration",
                type: "uint256"
            }
        ],
        name: "PauseDurationSet",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "newDuration",
                type: "uint256"
            }
        ],
        name: "PeriodDurationUpdated",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
        ],
        name: "PeriodEnded",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "reward",
                type: "uint256"
            }
        ],
        name: "RewardAdded",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "previousAdminRole",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "newAdminRole",
                type: "bytes32"
            }
        ],
        name: "RoleAdminChanged",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address"
            }
        ],
        name: "RoleGranted",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address"
            }
        ],
        name: "RoleRevoked",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "reward",
                type: "uint256"
            }
        ],
        name: "Staked",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "contract ITokenMetadata",
                name: "newTokenMetadata",
                type: "address"
            }
        ],
        name: "TokenMetadataSet",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "Transfer",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "reward",
                type: "uint256"
            }
        ],
        name: "Withdrawn",
        type: "event"
    },
    {
        inputs: [
        ],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "addReward",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "approvalPauseDuration",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "approve",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address"
            }
        ],
        name: "balanceOf",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            }
        ],
        name: "burn",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            }
        ],
        name: "compound",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            }
        ],
        name: "emergencyExit",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "endPeriod",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "getApproved",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            }
        ],
        name: "getRoleAdmin",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "uint256",
                name: "index",
                type: "uint256"
            }
        ],
        name: "getRoleMember",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            }
        ],
        name: "getRoleMemberCount",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "grantRole",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            }
        ],
        name: "harvest",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "hasRole",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address"
            },
            {
                internalType: "address",
                name: "operator",
                type: "address"
            }
        ],
        name: "isApprovedForAll",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "lastUpdate",
        outputs: [
            {
                internalType: "uint40",
                name: "",
                type: "uint40"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "mint",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256[]",
                name: "positionIds",
                type: "uint256[]"
            },
            {
                internalType: "uint256[]",
                name: "amounts",
                type: "uint256[]"
            }
        ],
        name: "multiStake",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256[]",
                name: "positionIds",
                type: "uint256[]"
            },
            {
                internalType: "uint256[]",
                name: "amounts",
                type: "uint256[]"
            }
        ],
        name: "multiWithdraw",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "name",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "ownerOf",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "periodDuration",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "periodFinish",
        outputs: [
            {
                internalType: "uint40",
                name: "",
                type: "uint40"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            }
        ],
        name: "positionPendingRewards",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            }
        ],
        name: "positionRewardRate",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        name: "positions",
        outputs: [
            {
                components: [
                    {
                        internalType: "uint96",
                        name: "balance",
                        type: "uint96"
                    },
                    {
                        internalType: "uint160",
                        name: "sumOfEntryTimes",
                        type: "uint160"
                    }
                ],
                internalType: "struct PangolinStakingPositions.ValueVariables",
                name: "valueVariables",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "idealPosition",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "rewardPerValue",
                        type: "uint256"
                    }
                ],
                internalType: "struct PangolinStakingPositions.RewardSummations",
                name: "rewardSummationsPaid",
                type: "tuple"
            },
            {
                internalType: "uint160",
                name: "previousValues",
                type: "uint160"
            },
            {
                internalType: "uint48",
                name: "lastUpdate",
                type: "uint48"
            },
            {
                internalType: "uint48",
                name: "lastDevaluation",
                type: "uint48"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "renounceRole",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32"
            },
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "revokeRole",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "rewardRate",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "rewardSummationsStored",
        outputs: [
            {
                internalType: "uint256",
                name: "idealPosition",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "rewardPerValue",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "rewardsToken",
        outputs: [
            {
                internalType: "contract IERC20",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "from",
                type: "address"
            },
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "safeTransferFrom",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "from",
                type: "address"
            },
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes"
            }
        ],
        name: "safeTransferFrom",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "operator",
                type: "address"
            },
            {
                internalType: "bool",
                name: "approved",
                type: "bool"
            }
        ],
        name: "setApprovalForAll",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "newApprovalPauseDuration",
                type: "uint256"
            }
        ],
        name: "setApprovalPauseDuration",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "newDuration",
                type: "uint256"
            }
        ],
        name: "setPeriodDuration",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "contract ITokenMetadata",
                name: "newTokenMetadata",
                type: "address"
            }
        ],
        name: "setTokenMetadata",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "stake",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "interfaceId",
                type: "bytes4"
            }
        ],
        name: "supportsInterface",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "symbol",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "index",
                type: "uint256"
            }
        ],
        name: "tokenByIndex",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "tokenMetadata",
        outputs: [
            {
                internalType: "contract ITokenMetadata",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "index",
                type: "uint256"
            }
        ],
        name: "tokenOfOwnerByIndex",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "tokenURI",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "from",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "to",
                type: "uint256"
            }
        ],
        name: "tokensOfOwnerByIndex",
        outputs: [
            {
                internalType: "uint256[]",
                name: "",
                type: "uint256[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "totalRewardAdded",
        outputs: [
            {
                internalType: "uint96",
                name: "",
                type: "uint96"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "totalSupply",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
        ],
        name: "totalValueVariables",
        outputs: [
            {
                internalType: "uint96",
                name: "balance",
                type: "uint96"
            },
            {
                internalType: "uint160",
                name: "sumOfEntryTimes",
                type: "uint160"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "from",
                type: "address"
            },
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "transferFrom",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "positionId",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "withdraw",
        outputs: [
        ],
        stateMutability: "nonpayable",
        type: "function"
    }
];

var WETH_ABI = [
    {
        constant: true,
        inputs: [
        ],
        name: "name",
        outputs: [
            {
                name: "",
                type: "string"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: false,
        inputs: [
            {
                name: "guy",
                type: "address"
            },
            {
                name: "wad",
                type: "uint256"
            }
        ],
        name: "approve",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "totalSupply",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: false,
        inputs: [
            {
                name: "src",
                type: "address"
            },
            {
                name: "dst",
                type: "address"
            },
            {
                name: "wad",
                type: "uint256"
            }
        ],
        name: "transferFrom",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        constant: false,
        inputs: [
            {
                name: "wad",
                type: "uint256"
            }
        ],
        name: "withdraw",
        outputs: [
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "decimals",
        outputs: [
            {
                name: "",
                type: "uint8"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                name: "",
                type: "address"
            }
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "symbol",
        outputs: [
            {
                name: "",
                type: "string"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: false,
        inputs: [
            {
                name: "dst",
                type: "address"
            },
            {
                name: "wad",
                type: "uint256"
            }
        ],
        name: "transfer",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        constant: false,
        inputs: [
        ],
        name: "deposit",
        outputs: [
        ],
        payable: true,
        stateMutability: "payable",
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                name: "",
                type: "address"
            },
            {
                name: "",
                type: "address"
            }
        ],
        name: "allowance",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        payable: true,
        stateMutability: "payable",
        type: "fallback"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "src",
                type: "address"
            },
            {
                indexed: true,
                name: "guy",
                type: "address"
            },
            {
                indexed: false,
                name: "wad",
                type: "uint256"
            }
        ],
        name: "Approval",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "src",
                type: "address"
            },
            {
                indexed: true,
                name: "dst",
                type: "address"
            },
            {
                indexed: false,
                name: "wad",
                type: "uint256"
            }
        ],
        name: "Transfer",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "dst",
                type: "address"
            },
            {
                indexed: false,
                name: "wad",
                type: "uint256"
            }
        ],
        name: "Deposit",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "src",
                type: "address"
            },
            {
                indexed: false,
                name: "wad",
                type: "uint256"
            }
        ],
        name: "Withdrawal",
        type: "event"
    }
];

var MULTICALL_ABI = [
    {
        constant: true,
        inputs: [
        ],
        name: "getCurrentBlockTimestamp",
        outputs: [
            {
                name: "timestamp",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                components: [
                    {
                        name: "target",
                        type: "address"
                    },
                    {
                        name: "callData",
                        type: "bytes"
                    }
                ],
                name: "calls",
                type: "tuple[]"
            }
        ],
        name: "aggregate",
        outputs: [
            {
                name: "blockNumber",
                type: "uint256"
            },
            {
                name: "returnData",
                type: "bytes[]"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "getLastBlockHash",
        outputs: [
            {
                name: "blockHash",
                type: "bytes32"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                name: "addr",
                type: "address"
            }
        ],
        name: "getEthBalance",
        outputs: [
            {
                name: "balance",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "getCurrentBlockDifficulty",
        outputs: [
            {
                name: "difficulty",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "getCurrentBlockGasLimit",
        outputs: [
            {
                name: "gaslimit",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
        ],
        name: "getCurrentBlockCoinbase",
        outputs: [
            {
                name: "coinbase",
                type: "address"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                name: "blockNumber",
                type: "uint256"
            }
        ],
        name: "getBlockHash",
        outputs: [
            {
                name: "blockHash",
                type: "bytes32"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    }
];

const MULTICALL_NETWORKS = {
    [ChainId.FUJI]: CHAINS[ChainId.FUJI].contracts.multicall,
    [ChainId.AVALANCHE]: CHAINS[ChainId.AVALANCHE].contracts.multicall,
    [ChainId.WAGMI]: CHAINS[ChainId.WAGMI].contracts.multicall,
    [ChainId.COSTON]: CHAINS[ChainId.COSTON].contracts.multicall,
    [ChainId.SONGBIRD]: CHAINS[ChainId.SONGBIRD].contracts.multicall,
    [ChainId.NEAR_MAINNET]: '',
    [ChainId.NEAR_TESTNET]: '',
};

// returns null on errors
function useContract(address, ABI, withSignerIfPossible = true) {
    const { account } = usePangolinWeb3();
    const { library } = useLibrary();
    return useMemo(() => {
        if (!address || address === ZERO_ADDRESS || !ABI || !library)
            return null;
        try {
            return getContract(address, ABI, library, withSignerIfPossible && account ? account : undefined);
        }
        catch (error) {
            console.error('Failed to get contract', error);
            return null;
        }
    }, [address, ABI, library, withSignerIfPossible, account]);
}
function useTokenContract(tokenAddress, withSignerIfPossible) {
    return useContract(tokenAddress, ERC20_ABI, withSignerIfPossible);
}
function useBytes32TokenContract(tokenAddress, withSignerIfPossible) {
    return useContract(tokenAddress, ERC20_BYTES32_ABI, withSignerIfPossible);
}
function useWETHContract(withSignerIfPossible) {
    var _a;
    const { chainId } = usePangolinWeb3();
    return useContract(chainId ? (_a = WAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.address : undefined, WETH_ABI, withSignerIfPossible);
}
function useMulticallContract() {
    const { chainId } = usePangolinWeb3();
    return useContract(chainId && MULTICALL_NETWORKS[chainId], MULTICALL_ABI, false);
}
function useStakingContract(stakingAddress, withSignerIfPossible) {
    const chainId = useChainId();
    return useContract(stakingAddress, stakingAddress === MINICHEF_ADDRESS[chainId] ? MiniChefV2.abi : StakingRewards.abi, withSignerIfPossible);
}
function useMiniChefContract() {
    const chainId = useChainId();
    return useContract(MINICHEF_ADDRESS[chainId], MiniChefV2.abi, true);
}
function useRewardViaMultiplierContract(address, withSignerIfPossible) {
    return useContract(address, REWARDER_VIA_MULTIPLIER_INTERFACE, withSignerIfPossible);
}
function usePairContract(pairAddress, withSignerIfPossible) {
    return useContract(pairAddress, IArcanumPair.abi, withSignerIfPossible);
}
function useSarStakingContract() {
    const chainId = useChainId();
    return useContract(SAR_STAKING_ADDRESS[chainId], SarStaking, true);
}
function usePangoChefContract() {
    const chainId = useChainId();
    return useContract(PANGOCHEF_ADDRESS[chainId], PANGOCHEF_ABI.abi, true);
}

function useAllTokens() {
    const chainId = useChainId();
    const userAddedTokens = useUserAddedTokens();
    const allTokens = useSelectedTokenList();
    return useMemo(() => {
        if (!chainId)
            return {};
        return (userAddedTokens
            // reduce into all ALL_TOKENS filtered by the current chain
            .reduce((tokenMap, token) => {
                tokenMap[token.address] = token;
                return tokenMap;
            }, Object.assign({}, allTokens[chainId])));
    }, [chainId, userAddedTokens, allTokens]);
}
// parse a name or symbol from a token response
const BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;
function parseStringOrBytes32(str, bytes32, defaultValue) {
    return str && str.length > 0
        ? str
        : bytes32 && BYTES32_REGEX.test(bytes32)
            ? parseBytes32String(bytes32)
            : defaultValue;
}
// undefined if invalid or does not exist
// null if loading
// otherwise returns the token
function useToken(tokenAddress) {
    const chainId = useChainId();
    const tokens = useAllTokens();
    const address = isAddress(tokenAddress);
    const tokenContract = useTokenContract(address ? address : undefined, false);
    const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);
    const token = address ? tokens[address] : undefined;
    const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);
    const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);
    const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);
    const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);
    const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);
    return useMemo(() => {
        var _a, _b, _c, _d;
        if (token)
            return token;
        if (!chainId || !address)
            return undefined;
        if (decimals.loading || symbol.loading || tokenName.loading)
            return null;
        if (decimals.result) {
            return new Token$1(chainId, address, decimals.result[0], parseStringOrBytes32((_a = symbol.result) === null || _a === void 0 ? void 0 : _a[0], (_b = symbolBytes32.result) === null || _b === void 0 ? void 0 : _b[0], 'UNKNOWN'), parseStringOrBytes32((_c = tokenName.result) === null || _c === void 0 ? void 0 : _c[0], (_d = tokenNameBytes32.result) === null || _d === void 0 ? void 0 : _d[0], 'Unknown Token'));
        }
        return undefined;
    }, [
        address,
        chainId,
        decimals.loading,
        decimals.result,
        symbol.loading,
        symbol.result,
        symbolBytes32.result,
        token,
        tokenName.loading,
        tokenName.result,
        tokenNameBytes32.result,
    ]);
}
function useNearToken(tokenAddress) {
    const [tokenData, setTokenData] = useState();
    const chainId = useChainId();
    const tokens = useAllTokens();
    const address = tokenAddress;
    const token = address ? tokens[address] : undefined;
    useEffect(() => {
        function getTokenData() {
            return __awaiter(this, void 0, void 0, function* () {
                if (address) {
                    const tokenMetaData = yield nearFn.getMetadata(address);
                    setTokenData(tokenMetaData);
                }
            });
        }
        getTokenData();
    }, [address]);
    return useMemo(() => {
        if (token)
            return token;
        if (!chainId || !address)
            return undefined;
        if (tokenData) {
            return new Token$1(chainId, address, tokenData === null || tokenData === void 0 ? void 0 : tokenData.decimals, tokenData === null || tokenData === void 0 ? void 0 : tokenData.symbol, tokenData === null || tokenData === void 0 ? void 0 : tokenData.name);
        }
        return undefined;
    }, [address, chainId, token, tokenData]);
}
function useTokens(tokensAddress = []) {
    const chainId = useChainId();
    const tokens = useAllTokens();
    const tokensName = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'name', undefined, NEVER_RELOAD);
    const tokensNameBytes32 = useMultipleContractSingleData(tokensAddress, ERC20_BYTES32_INTERFACE, 'name', undefined, NEVER_RELOAD);
    const symbols = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'symbol', undefined, NEVER_RELOAD);
    const symbolsBytes32 = useMultipleContractSingleData(tokensAddress, ERC20_BYTES32_INTERFACE, 'symbol', undefined, NEVER_RELOAD);
    const decimals = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'decimals', undefined, NEVER_RELOAD);
    return useMemo(() => {
        if (!tokensAddress || (tokensAddress === null || tokensAddress === void 0 ? void 0 : tokensAddress.length) === 0)
            return [];
        if (!chainId)
            return [];
        return tokensAddress.reduce((acc, tokenAddress, index) => {
            var _a, _b, _c, _d, _e;
            const tokenName = tokensName === null || tokensName === void 0 ? void 0 : tokensName[index];
            const tokenNameBytes32 = tokensNameBytes32 === null || tokensNameBytes32 === void 0 ? void 0 : tokensNameBytes32[index];
            const symbol = symbols === null || symbols === void 0 ? void 0 : symbols[index];
            const symbolBytes32 = symbolsBytes32 === null || symbolsBytes32 === void 0 ? void 0 : symbolsBytes32[index];
            const decimal = decimals === null || decimals === void 0 ? void 0 : decimals[index];
            const address = isAddress(tokenAddress);
            if (!!address && tokens[address]) {
                // if we have user tokens already
                acc.push(tokens[address]);
            }
            else if ((tokenName === null || tokenName === void 0 ? void 0 : tokenName.loading) === false &&
                (tokenNameBytes32 === null || tokenNameBytes32 === void 0 ? void 0 : tokenNameBytes32.loading) === false &&
                (symbol === null || symbol === void 0 ? void 0 : symbol.loading) === false &&
                (symbolBytes32 === null || symbolBytes32 === void 0 ? void 0 : symbolBytes32.loading) === false &&
                (decimal === null || decimal === void 0 ? void 0 : decimal.loading) === false &&
                address) {
                const token = new Token$1(chainId, tokenAddress, (_a = decimal === null || decimal === void 0 ? void 0 : decimal.result) === null || _a === void 0 ? void 0 : _a[0], parseStringOrBytes32((_b = symbol.result) === null || _b === void 0 ? void 0 : _b[0], (_c = symbolBytes32.result) === null || _c === void 0 ? void 0 : _c[0], 'UNKNOWN'), parseStringOrBytes32((_d = tokenName.result) === null || _d === void 0 ? void 0 : _d[0], (_e = tokenNameBytes32.result) === null || _e === void 0 ? void 0 : _e[0], 'Unknown Token'));
                acc.push(token);
            }
            return acc;
        }, []);
    }, [chainId, decimals, symbols, symbolsBytes32, tokensName, tokensNameBytes32, tokens, tokensAddress]);
}
const fetchNearTokenMetadata = (address) => () => {
    return nearFn.getMetadata(address);
};
function useNearTokens(tokensAddress = []) {
    const chainId = useChainId();
    const tokens = useAllTokens();
    const queryParameter = useMemo(() => {
        var _a;
        return ((_a = tokensAddress === null || tokensAddress === void 0 ? void 0 : tokensAddress.map((address) => {
            return { queryKey: ['token', address], queryFn: fetchNearTokenMetadata(address) };
        })) !== null && _a !== void 0 ? _a : []);
    }, [tokensAddress]);
    const results = useQueries(queryParameter);
    return useMemo(() => {
        if (!tokensAddress || (tokensAddress === null || tokensAddress === void 0 ? void 0 : tokensAddress.length) === 0)
            return [];
        if (!chainId)
            return [];
        return results.reduce((acc, result) => {
            const tokenData = result === null || result === void 0 ? void 0 : result.data;
            if (tokenData && (result === null || result === void 0 ? void 0 : result.isLoading) === false) {
                if (!!(tokenData === null || tokenData === void 0 ? void 0 : tokenData.id) && tokens[tokenData === null || tokenData === void 0 ? void 0 : tokenData.id]) {
                    // if we have user tokens already
                    acc.push(tokens[tokenData === null || tokenData === void 0 ? void 0 : tokenData.id]);
                }
                else {
                    const token = new Token$1(chainId, tokenData === null || tokenData === void 0 ? void 0 : tokenData.id, tokenData === null || tokenData === void 0 ? void 0 : tokenData.decimals, tokenData === null || tokenData === void 0 ? void 0 : tokenData.symbol, tokenData === null || tokenData === void 0 ? void 0 : tokenData.name);
                    acc.push(token);
                }
            }
            return acc;
        }, []);
    }, [results, tokens]);
}
function useCurrency(currencyId) {
    var _a;
    const chainId = useChainId();
    const isAVAX = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === ((_a = CAVAX[chainId].symbol) === null || _a === void 0 ? void 0 : _a.toUpperCase());
    const useToken_ = useTokenHook[chainId];
    const token = useToken_(isAVAX ? undefined : currencyId);
    return isAVAX ? chainId && CAVAX[chainId] : token;
}
function useCoinGeckoTokenPrice(coin) {
    const [result, setResult] = useState({});
    useEffect(() => {
        const getCoinPriceData = () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const chain = coin.chainId === 43113 ? CHAINS[ChainId.AVALANCHE] : CHAINS[coin.chainId];
                const url = `${COINGEKO_BASE_URL}/simple/token_price/${chain.coingecko_id}?contract_addresses=${coin.address.toLowerCase()}&vs_currencies=usd`;
                const response = yield fetch(url);
                const data = yield response.json();
                setResult({
                    tokenUsdPrice: (_a = data === null || data === void 0 ? void 0 : data[coin.address.toLowerCase()]) === null || _a === void 0 ? void 0 : _a.usd,
                });
            }
            catch (error) {
                console.error('coingecko api error', error);
            }
        });
        getCoinPriceData();
    }, [coin]);
    return result;
}
function useCoinGeckoTokenPriceChart(coin, days = '7') {
    const [result, setResult] = useState([]);
    useEffect(() => {
        const getCoinData = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            try {
                const chain = coin.chainId === 43113 ? CHAINS[ChainId.AVALANCHE] : CHAINS[coin.chainId];
                const url = `${COINGEKO_BASE_URL}/coins/${chain.coingecko_id}/contract/${coin.address.toLowerCase()}/market_chart/?vs_currency=usd&days=${days}`;
                const response = yield fetch(url);
                const data = yield response.json();
                const formattedHistory = [];
                const priceData = (data === null || data === void 0 ? void 0 : data.prices) || [];
                // for each hour, construct the open and close price
                for (let i = 0; i < priceData.length - 1; i++) {
                    formattedHistory.push({
                        timestamp: (((_a = priceData[i]) === null || _a === void 0 ? void 0 : _a[0]) / 1000).toFixed(0),
                        priceUSD: parseFloat((_b = priceData[i]) === null || _b === void 0 ? void 0 : _b[1]),
                    });
                }
                setResult(formattedHistory);
            }
            catch (error) {
                console.error('coingecko api error', error);
            }
        });
        getCoinData();
    }, [coin, days]);
    return result;
}
/**
 * Get the coingecko data for a token
 * @param coin - Token or Currency
 * @returns CoingeckoData of token if exist in coingecko else null
 * */
function useCoinGeckoTokenData(coin) {
    const chain = CHAINS[coin.chainId];
    return useQuery(['coingeckoToken', coin.address, chain.name], () => __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (!chain.coingecko_id) {
            return null;
        }
        const response = yield fetch(`${COINGECKO_API}/coins/${chain.coingecko_id}/contract/${coin.address.toLowerCase()}`);
        const data = yield response.json();
        return {
            coinId: data === null || data === void 0 ? void 0 : data.id,
            homePage: (_a = data === null || data === void 0 ? void 0 : data.links) === null || _a === void 0 ? void 0 : _a.homepage[0],
            description: (_b = data === null || data === void 0 ? void 0 : data.description) === null || _b === void 0 ? void 0 : _b.en,
        };
    }));
}
function useCoinGeckoCurrencyPrice(chainId) {
    const currencyId = COINGECKO_CURRENCY_ID[chainId];
    return useQuery(['coingeckoCurrencyPrice', chainId], () => __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (!currencyId) {
            return 0;
        }
        try {
            const response = yield axios.get(`${COINGECKO_API}/simple/price?ids=${currencyId}&vs_currencies=usd`);
            const data = response.data;
            if (!data)
                return 0;
            return (_b = (_a = data[currencyId]) === null || _a === void 0 ? void 0 : _a.usd) !== null && _b !== void 0 ? _b : 0;
        }
        catch (error) {
            return 0;
        }
    }));
}

function useTokenAllowance(token, owner, spender) {
    const contract = useTokenContract(token === null || token === void 0 ? void 0 : token.address, false);
    const inputs = useMemo(() => [owner, spender], [owner, spender]);
    const allowance = useSingleCallResult(contract, 'allowance', inputs).result;
    return useMemo(() => (token && allowance ? new TokenAmount(token, allowance.toString()) : undefined), [token, allowance]);
}

// helper that can take a ethers library transaction response and add it to the list of transactions
function useTransactionAdder() {
    const { chainId, account } = usePangolinWeb3();
    const dispatch = useDispatch();
    return useCallback((response, { summary, approval, claim, } = {}) => {
        if (!account)
            return;
        if (!chainId)
            return;
        const { hash } = response;
        if (!hash) {
            throw Error('No transaction hash found.');
        }
        dispatch(addTransaction({ hash, from: account, chainId, approval, summary, claim }));
    }, [dispatch, chainId, account]);
}
function useAllTransactionsClearer() {
    const chainId = useChainId();
    const dispatch = useDispatch();
    return useCallback(() => {
        dispatch(clearAllTransactions({ chainId }));
    }, [chainId, dispatch]);
}
// returns all the transactions for the current chain
function useAllTransactions() {
    var _a;
    const { chainId } = usePangolinWeb3();
    const state = useSelector((state) => state.ptransactions);
    return chainId ? (_a = state[chainId]) !== null && _a !== void 0 ? _a : {} : {};
}
/**
 * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)
 * @param tx to check for recency
 */
function isTransactionRecent(tx) {
    return new Date().getTime() - tx.addedTime < 86400000;
}
// returns whether a token has a pending approval transaction
function useHasPendingApproval(tokenAddress, spender) {
    const allTransactions = useAllTransactions();
    return useMemo(() => typeof tokenAddress === 'string' &&
        typeof spender === 'string' &&
        Object.keys(allTransactions).some((hash) => {
            const tx = allTransactions[hash];
            if (!tx)
                return false;
            if (tx.receipt) {
                return false;
            }
            else {
                const approval = tx.approval;
                if (!approval)
                    return false;
                return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx);
            }
        }), [allTransactions, spender, tokenAddress]);
}

const ONE_HUNDRED_PERCENT = new Percent$1(JSBI$1.BigInt(1000), JSBI$1.BigInt(1000));
// computes price breakdown for the trade
function computeTradePriceBreakdown(trade) {
    // for each hop in our trade, take away the x*y=k price impact from swap fees
    // the following example assumes swap fees of 0.3% but this is determined by the pair
    // e.g. for 3 tokens/2 hops: 1 - ((1 - .03) * (1-.03))
    const realizedLPFee = !trade
        ? undefined
        : ONE_HUNDRED_PERCENT.subtract(trade.route.pools.reduce((currentFee, pool) => currentFee.multiply(new Percent$1(pool.swapFeeCoefficient, pool.swapFeeDivisor)), ONE_HUNDRED_PERCENT));
    // remove lp fees from price impact
    const priceImpactWithoutFeeFraction = trade && realizedLPFee ? trade.priceImpact.subtract(realizedLPFee) : undefined;
    // the x*y=k impact
    const priceImpactWithoutFeePercent = priceImpactWithoutFeeFraction
        ? new Percent$1(priceImpactWithoutFeeFraction === null || priceImpactWithoutFeeFraction === void 0 ? void 0 : priceImpactWithoutFeeFraction.numerator, priceImpactWithoutFeeFraction === null || priceImpactWithoutFeeFraction === void 0 ? void 0 : priceImpactWithoutFeeFraction.denominator)
        : undefined;
    // the amount of the input that accrues to LPs
    const realizedLPFeeAmount = realizedLPFee &&
        trade &&
        (trade.inputAmount instanceof TokenAmount
            ? new TokenAmount(trade.inputAmount.token, realizedLPFee.multiply(trade.inputAmount.raw).quotient)
            : CurrencyAmount.ether(realizedLPFee.multiply(trade.inputAmount.raw).quotient));
    const feeAmount = !trade
        ? undefined
        : trade.outputAmount instanceof TokenAmount
            ? new TokenAmount(trade.outputAmount.token, trade.fee.multiply(trade.outputAmount.raw).quotient)
            : CurrencyAmount.ether(trade.fee.multiply(trade.outputAmount.raw).quotient);
    return {
        priceImpactWithoutFee: priceImpactWithoutFeePercent,
        realizedLPFee,
        realizedLPFeeAmount,
        daasFeeAmount: feeAmount,
    };
}
// computes the minimum amount out and maximum amount in for a trade given a user specified allowed slippage in bips
function computeSlippageAdjustedAmounts(trade, allowedSlippage) {
    const pct = basisPointsToPercent(allowedSlippage);
    return {
        [Field.INPUT]: trade === null || trade === void 0 ? void 0 : trade.maximumAmountIn(pct),
        [Field.OUTPUT]: trade === null || trade === void 0 ? void 0 : trade.minimumAmountOut(pct),
    };
}
function warningSeverity(priceImpact) {
    if (!(priceImpact === null || priceImpact === void 0 ? void 0 : priceImpact.lessThan(BLOCKED_PRICE_IMPACT_NON_EXPERT)))
        return 4;
    if (!(priceImpact === null || priceImpact === void 0 ? void 0 : priceImpact.lessThan(ALLOWED_PRICE_IMPACT_HIGH)))
        return 3;
    if (!(priceImpact === null || priceImpact === void 0 ? void 0 : priceImpact.lessThan(ALLOWED_PRICE_IMPACT_MEDIUM)))
        return 2;
    if (!(priceImpact === null || priceImpact === void 0 ? void 0 : priceImpact.lessThan(ALLOWED_PRICE_IMPACT_LOW)))
        return 1;
    return 0;
}

var ApprovalState;
(function (ApprovalState) {
    ApprovalState[ApprovalState["UNKNOWN"] = 0] = "UNKNOWN";
    ApprovalState[ApprovalState["NOT_APPROVED"] = 1] = "NOT_APPROVED";
    ApprovalState[ApprovalState["PENDING"] = 2] = "PENDING";
    ApprovalState[ApprovalState["APPROVED"] = 3] = "APPROVED";
})(ApprovalState || (ApprovalState = {}));
// returns a variable indicating the state of the approval and a function which approves if necessary or early returns
function useApproveCallback(chainId, amountToApprove, spender) {
    const { account } = usePangolinWeb3();
    const token = amountToApprove instanceof TokenAmount ? amountToApprove.token : undefined;
    const currentAllowance = useTokenAllowance(token, account !== null && account !== void 0 ? account : undefined, spender);
    const pendingApproval = useHasPendingApproval(token === null || token === void 0 ? void 0 : token.address, spender);
    // check the current approval status
    const approvalState = useMemo(() => {
        if (!amountToApprove || !spender)
            return ApprovalState.UNKNOWN;
        if (amountToApprove.currency === CAVAX[chainId])
            return ApprovalState.APPROVED;
        // we might not have enough data to know whether or not we need to approve
        if (!currentAllowance)
            return ApprovalState.UNKNOWN;
        // amountToApprove will be defined if currentAllowance is
        return currentAllowance.lessThan(amountToApprove)
            ? pendingApproval
                ? ApprovalState.PENDING
                : ApprovalState.NOT_APPROVED
            : ApprovalState.APPROVED;
    }, [amountToApprove, currentAllowance, pendingApproval, spender]);
    const tokenContract = useTokenContract(token === null || token === void 0 ? void 0 : token.address);
    const addTransaction = useTransactionAdder();
    const approve = useCallback(() => __awaiter(this, void 0, void 0, function* () {
        if (approvalState !== ApprovalState.NOT_APPROVED) {
            console.error('approve was called unnecessarily');
            return;
        }
        if (!token) {
            console.error('no token');
            return;
        }
        if (!tokenContract) {
            console.error('tokenContract is null');
            return;
        }
        if (!amountToApprove) {
            console.error('missing amount to approve');
            return;
        }
        if (!spender) {
            console.error('no spender');
            return;
        }
        let useExact = false;
        const estimatedGas = yield tokenContract.estimateGas.approve(spender, MaxUint256).catch(() => {
            // general fallback for tokens who restrict approval amounts
            useExact = true;
            return tokenContract.estimateGas.approve(spender, amountToApprove.raw.toString());
        });
        try {
            const response = yield tokenContract.approve(spender, useExact ? amountToApprove.raw.toString() : MaxUint256, {
                gasLimit: calculateGasMargin(estimatedGas),
            });
            yield waitForTransaction(response, 1);
            addTransaction(response, {
                summary: 'Approve ' + amountToApprove.currency.symbol,
                approval: { tokenAddress: token.address, spender: spender },
            });
        }
        catch (error) {
            console.debug('Failed to approve token', error);
            throw error;
        }
    }), [approvalState, token, tokenContract, amountToApprove, spender, addTransaction]);
    return [approvalState, approve];
}
function useNearApproveCallback() {
    const approve = useCallback(() => __awaiter(this, void 0, void 0, function* () {
        Promise.resolve(42);
    }), []);
    return [ApprovalState.APPROVED, approve];
}
// wraps useApproveCallback in the context of a swap
function useApproveCallbackFromTrade(chainId, trade, allowedSlippage = 0) {
    const [amountToApprove, routerAddress] = useMemo(() => {
        if (!chainId || !trade)
            return [undefined, undefined];
        return [
            computeSlippageAdjustedAmounts(trade, allowedSlippage)[Field.INPUT],
            trade.feeTo === ZERO_ADDRESS ? ROUTER_ADDRESS[chainId] : ROUTER_DAAS_ADDRESS[chainId],
        ];
    }, [trade, allowedSlippage]);
    return useApproveCallback(chainId, amountToApprove, routerAddress);
}
//TODO:  Near Swap Approve dummy hook
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function useApproveCallbackFromNearTrade(_chainId, _trade, _allowedSlippage = 0) {
    const approve = () => {
        return Promise.resolve();
    };
    return [ApprovalState.APPROVED, approve];
}
// wraps useApproveCallback in the context of a swap
function useApproveCallbackFromInputCurrencyAmount(currencyAmountIn) {
    var _a;
    const chainId = useChainId();
    const gelatoLibrary = useGelatoLimitOrdersLib();
    const newCurrencyAmountIn = currencyAmountIn
        ? new TokenAmount(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.numerator)
        : undefined;
    return useApproveCallback(chainId, newCurrencyAmountIn, (_a = gelatoLibrary === null || gelatoLibrary === void 0 ? void 0 : gelatoLibrary.erc20OrderRouter.address) !== null && _a !== void 0 ? _a : undefined);
}

/**
 * Returns true if the string value is zero in hex
 * @param hexNumberString
 */
function isZero(hexNumberString) {
    return /^0x0*$/.test(hexNumberString);
}

function useAllCommonPairs(currencyA, currencyB) {
    const chainId = useChainId();
    const usePairs = usePairsHook[chainId];
    const bases = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []; // eslint-disable-line react-hooks/exhaustive-deps
    const [tokenA, tokenB] = chainId
        ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]
        : [undefined, undefined];
    const basePairs = useMemo(() => flatMap(bases, (base) => bases.map((otherBase) => [base, otherBase])).filter(([t0, t1]) => t0.address !== t1.address), [bases]);
    const allPairCombinations = useMemo(() => tokenA && tokenB
        ? [
            // the direct pair
            [tokenA, tokenB],
            // token A against all bases
            ...bases.map((base) => [tokenA, base]),
            // token B against all bases
            ...bases.map((base) => [tokenB, base]),
            // each base against all bases
            ...basePairs,
        ]
            .filter((tokens) => Boolean(tokens[0] && tokens[1]))
            .filter(([t0, t1]) => t0.address !== t1.address)
            .filter(([tokenA, tokenB]) => {
                if (!chainId)
                    return true;
                const customBases = CUSTOM_BASES[chainId];
                if (!customBases)
                    return true;
                const customBasesA = customBases[tokenA.address];
                const customBasesB = customBases[tokenB.address];
                if (!customBasesA && !customBasesB)
                    return true;
                if (customBasesA && !customBasesA.find((base) => tokenB.equals(base)))
                    return false;
                if (customBasesB && !customBasesB.find((base) => tokenA.equals(base)))
                    return false;
                return true;
            })
        : [], [tokenA, tokenB, bases, basePairs, chainId]);
    const allPairs = usePairs(allPairCombinations);
    // only pass along valid pairs, non-duplicated pairs
    return useMemo(() => {
        const pairs = Object.values(allPairs
            // filter out invalid pairs
            .filter((result) => Boolean(result[0] === PairState.EXISTS && result[1]))
            // filter out duplicated pairs
            .reduce((memo, [, curr]) => {
                var _a;
                memo[curr.liquidityToken.address] = (_a = memo[curr.liquidityToken.address]) !== null && _a !== void 0 ? _a : curr;
                return memo;
            }, {}));
        const isLoading = allPairs.some((result) => result[0] === PairState.LOADING);
        return { pairs, isLoading };
    }, [allPairs]);
}
/**
 * Returns the best trade for the exact amount of tokens in to the given token out
 */
function useTradeExactIn(currencyAmountIn, currencyOut) {
    const { pairs: allowedPairs, isLoading } = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);
    const [feeTo] = useDaasFeeTo();
    const [feeInfo] = useDaasFeeInfo();
    return useMemo(() => {
        if (currencyAmountIn && currencyOut && feeTo && feeInfo && allowedPairs.length > 0 && !isLoading) {
            const trade = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 3, maxNumResults: 1 }, { fee: new Percent$1(feeInfo.feeTotal.toString(), BIPS_BASE), feeTo })[0];
            return { trade: trade !== null && trade !== void 0 ? trade : null, isLoading: false };
        }
        return { trade: null, isLoading: true };
    }, [allowedPairs, isLoading, currencyAmountIn, currencyOut, feeTo, feeInfo]);
}
/**
 * Returns the best trade for the token in to the exact amount of token out
 */
function useTradeExactOut(currencyIn, currencyAmountOut) {
    const { pairs: allowedPairs, isLoading } = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);
    const [feeTo] = useDaasFeeTo();
    const [feeInfo] = useDaasFeeInfo();
    return useMemo(() => {
        if (currencyIn && currencyAmountOut && feeTo && feeInfo && allowedPairs.length > 0 && !isLoading) {
            const trade = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 3, maxNumResults: 1 }, { fee: new Percent$1(feeInfo.feeTotal.toString(), BIPS_BASE), feeTo })[0];
            return { trade: trade !== null && trade !== void 0 ? trade : null, isLoading: false };
        }
        return { trade: null, isLoading: true };
    }, [allowedPairs, isLoading, currencyIn, currencyAmountOut, feeTo, feeInfo]);
}

function useParsedQueryString() {
    const { href } = window.location || {};
    const search = href === null || href === void 0 ? void 0 : href.substring((href === null || href === void 0 ? void 0 : href.indexOf('?')) + 1);
    return useMemo(() => (search && search.length > 1 ? parse$1(search, { parseArrays: false, ignoreQueryPrefix: true }) : {}), [search]);
}

// import useParsedQueryString from './useParsedQueryString'
var Version;
(function (Version) {
    Version["v1"] = "v1";
    Version["v2"] = "v2";
})(Version || (Version = {}));
const DEFAULT_VERSION = Version.v2;
function useToggledVersion() {
    //TODO
    // const { use } = useParsedQueryString()
    // if (!use || typeof use !== 'string') return Version.v2
    // if (use.toLowerCase() === 'v1') return Version.v1
    return DEFAULT_VERSION;
}

function useGetTransactionSignature() {
    const { provider } = useLibrary();
    const { account } = usePangolinWeb3();
    const getSignature = (data) => __awaiter(this, void 0, void 0, function* () {
        try {
            const rawSignature = yield provider.execute('eth_signTypedData_v4', [account, data]);
            return splitSignature(rawSignature);
        }
        catch (err) {
            if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                throw err;
            }
        }
    });
    return getSignature;
}

const useTokenBalancesHook = {
    [ChainId.FUJI]: useTokenBalances,
    [ChainId.AVALANCHE]: useTokenBalances,
    [ChainId.WAGMI]: useTokenBalances,
    [ChainId.COSTON]: useTokenBalances,
    [ChainId.SONGBIRD]: useTokenBalances,
    [ChainId.NEAR_MAINNET]: useNearTokenBalances,
    [ChainId.NEAR_TESTNET]: useNearTokenBalances,
};
const useTokenBalanceHook = {
    [ChainId.FUJI]: useTokenBalance,
    [ChainId.AVALANCHE]: useTokenBalance,
    [ChainId.WAGMI]: useTokenBalance,
    [ChainId.COSTON]: useTokenBalance,
    [ChainId.SONGBIRD]: useTokenBalance,
    [ChainId.NEAR_MAINNET]: useNearTokenBalance,
    [ChainId.NEAR_TESTNET]: useNearTokenBalance,
};
const useAccountBalanceHook = {
    [ChainId.FUJI]: useETHBalances,
    [ChainId.AVALANCHE]: useETHBalances,
    [ChainId.WAGMI]: useETHBalances,
    [ChainId.COSTON]: useETHBalances,
    [ChainId.SONGBIRD]: useETHBalances,
    [ChainId.NEAR_MAINNET]: useNearBalance,
    [ChainId.NEAR_TESTNET]: useNearBalance,
};
const useAddLiquidityHook = {
    [ChainId.FUJI]: useAddLiquidity,
    [ChainId.AVALANCHE]: useAddLiquidity,
    [ChainId.WAGMI]: useAddLiquidity,
    [ChainId.COSTON]: useAddLiquidity,
    [ChainId.SONGBIRD]: useAddLiquidity,
    [ChainId.NEAR_MAINNET]: useNearAddLiquidity,
    [ChainId.NEAR_TESTNET]: useNearAddLiquidity,
};
const useRemoveLiquidityHook = {
    [ChainId.FUJI]: useRemoveLiquidity,
    [ChainId.AVALANCHE]: useRemoveLiquidity,
    [ChainId.WAGMI]: useRemoveLiquidity,
    [ChainId.COSTON]: useRemoveLiquidity,
    [ChainId.SONGBIRD]: useRemoveLiquidity,
    [ChainId.NEAR_MAINNET]: useNearRemoveLiquidity,
    [ChainId.NEAR_TESTNET]: useNearRemoveLiquidity,
};
const useGetUserLPHook = {
    [ChainId.FUJI]: useGetUserLP,
    [ChainId.AVALANCHE]: useGetUserLP,
    [ChainId.WAGMI]: useGetUserLP,
    [ChainId.COSTON]: useGetUserLP,
    [ChainId.SONGBIRD]: useGetUserLP,
    [ChainId.NEAR_MAINNET]: useGetNearUserLP,
    [ChainId.NEAR_TESTNET]: useGetNearUserLP,
};

/**
 * Returns a map of the given addresses to their eventually consistent ETH balances.
 */
function useETHBalances(chainId, uncheckedAddresses) {
    const multicallContract = useMulticallContract();
    const addresses = useMemo(() => uncheckedAddresses
        ? uncheckedAddresses
            .map(isAddress)
            .filter((a) => a !== false)
            .sort()
        : [], [uncheckedAddresses]);
    const results = useSingleContractMultipleData(multicallContract, 'getEthBalance', addresses.map((address) => [address]));
    return useMemo(() => addresses.reduce((memo, address, i) => {
        var _a, _b;
        const value = (_b = (_a = results === null || results === void 0 ? void 0 : results[i]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b[0];
        if (value)
            memo[address] = CurrencyAmount.ether(JSBI$1.BigInt(value.toString()), chainId);
        return memo;
    }, {}), [chainId, addresses, results]);
}
/**
 * Returns a Near Wallet balance.
 */
function useNearBalance(chainId, accounts) {
    const [nearBalance, setNearBalance] = useState();
    const nearToken = WAVAX[chainId];
    useEffect(() => {
        function checkNearBalance() {
            return __awaiter(this, void 0, void 0, function* () {
                const balance = yield near.getAccountBalance();
                if (balance && (accounts === null || accounts === void 0 ? void 0 : accounts[0])) {
                    const nearTokenBalance = new TokenAmount(nearToken, balance.available);
                    const container = {};
                    container[accounts === null || accounts === void 0 ? void 0 : accounts[0]] = nearTokenBalance;
                    setNearBalance(container);
                }
            });
        }
        checkNearBalance();
    }, [accounts, chainId]);
    return useMemo(() => nearBalance, [nearBalance]);
}
const fetchNearTokenBalance = (token, account) => () => __awaiter(void 0, void 0, void 0, function* () {
    if (token) {
        const balance = yield nearFn.getTokenBalance(token === null || token === void 0 ? void 0 : token.address, account);
        return new TokenAmount(token, balance);
    }
    return undefined;
});
const fetchNearPoolShare = (chainId, pair) => () => __awaiter(void 0, void 0, void 0, function* () {
    if (pair) {
        const share = yield nearFn.getSharesInPool(chainId, pair === null || pair === void 0 ? void 0 : pair.token0, pair === null || pair === void 0 ? void 0 : pair.token1);
        return new TokenAmount(pair === null || pair === void 0 ? void 0 : pair.liquidityToken, share);
    }
    return undefined;
});
/**
 * Returns a map of token addresses to their eventually consistent token balances for a single account.
 */
function useTokenBalancesWithLoadingIndicator(address, tokens) {
    const validatedTokens = useMemo(() => { var _a; return (_a = tokens === null || tokens === void 0 ? void 0 : tokens.filter((t) => isAddress(t === null || t === void 0 ? void 0 : t.address) !== false)) !== null && _a !== void 0 ? _a : []; }, [tokens]);
    const validatedTokenAddresses = useMemo(() => validatedTokens.map((vt) => vt.address), [validatedTokens]);
    const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address]);
    const anyLoading = useMemo(() => balances.some((callState) => callState.loading), [balances]);
    return [
        useMemo(() => address && validatedTokens.length > 0
            ? validatedTokens.reduce((memo, token, i) => {
                var _a, _b;
                const value = (_b = (_a = balances === null || balances === void 0 ? void 0 : balances[i]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b[0];
                const amount = value ? JSBI$1.BigInt(value.toString()) : undefined;
                if (amount) {
                    memo[token.address] = new TokenAmount(token, amount);
                }
                return memo;
            }, {})
            : {}, [address, validatedTokens, balances]),
        anyLoading,
    ];
}
function useTokenBalances(address, tokens) {
    return useTokenBalancesWithLoadingIndicator(address, tokens)[0];
}
function useNearTokenBalances(address, tokensOrPairs) {
    const chainId = useChainId();
    const queryParameter = useMemo(() => {
        var _a;
        return ((_a = tokensOrPairs === null || tokensOrPairs === void 0 ? void 0 : tokensOrPairs.map((item) => {
            var _a;
            if (item instanceof Pair) {
                return {
                    queryKey: ['pair-balance', (_a = item === null || item === void 0 ? void 0 : item.liquidityToken) === null || _a === void 0 ? void 0 : _a.address, address],
                    queryFn: fetchNearPoolShare(chainId, item),
                };
            }
            return {
                queryKey: ['token-balance', item === null || item === void 0 ? void 0 : item.address, address],
                queryFn: fetchNearTokenBalance(item, address),
            };
        })) !== null && _a !== void 0 ? _a : []);
    }, [tokensOrPairs]);
    const results = useQueries(queryParameter);
    return useMemo(() => results.reduce((memo, result, i) => {
        var _a;
        const value = result === null || result === void 0 ? void 0 : result.data;
        const token = tokensOrPairs === null || tokensOrPairs === void 0 ? void 0 : tokensOrPairs[i];
        if (token && token instanceof Token$1) {
            memo[token === null || token === void 0 ? void 0 : token.address] = value;
        }
        else if (token && token instanceof Pair) {
            memo[(_a = token === null || token === void 0 ? void 0 : token.liquidityToken) === null || _a === void 0 ? void 0 : _a.address] = value;
        }
        return memo;
    }, {}), [tokensOrPairs, address, results]);
}
// get the balance for a single token/account combo
function useTokenBalance(account, token) {
    const tokenBalances = useTokenBalances(account, [token]);
    if (!token)
        return undefined;
    return tokenBalances[token.address];
}
// get the balance for a single token/account combo
function useNearTokenBalance(account, tokenOrPair) {
    var _a;
    const tokensOrPairs = useMemo(() => [tokenOrPair], [tokenOrPair]);
    const tokenBalances = useNearTokenBalances(account, tokensOrPairs);
    if (!tokenOrPair)
        return undefined;
    if (tokenOrPair && tokenOrPair instanceof Token$1) {
        return tokenBalances[tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.address];
    }
    else if (tokenOrPair && tokenOrPair instanceof Pair) {
        return tokenBalances[(_a = tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address];
    }
}
function useCurrencyBalances(chainId, account, currencies) {
    const tokens = useMemo(() => { var _a; return (_a = currencies === null || currencies === void 0 ? void 0 : currencies.filter((currency) => currency instanceof Token$1)) !== null && _a !== void 0 ? _a : []; }, [currencies]);
    const useTokenBalances_ = useTokenBalancesHook[chainId];
    const useETHBalances_ = useAccountBalanceHook[chainId];
    const tokenBalances = useTokenBalances_(account, tokens);
    const containsETH = useMemo(() => { var _a; return (_a = currencies === null || currencies === void 0 ? void 0 : currencies.some((currency) => chainId && currency === CAVAX[chainId])) !== null && _a !== void 0 ? _a : false; }, [chainId, currencies]);
    const accountArr = useMemo(() => [account], [account]);
    const memoArr = useMemo(() => [], []);
    const ethBalance = useETHBalances_(chainId, containsETH ? accountArr : memoArr);
    return useMemo(() => {
        var _a;
        return (_a = currencies === null || currencies === void 0 ? void 0 : currencies.map((currency) => {
            if (!account || !currency)
                return undefined;
            if (currency instanceof Token$1)
                return tokenBalances[currency.address];
            if (currency === CAVAX[chainId])
                return ethBalance === null || ethBalance === void 0 ? void 0 : ethBalance[account];
            return undefined;
        })) !== null && _a !== void 0 ? _a : [];
    }, [chainId, account, currencies, ethBalance, tokenBalances]);
}
function useCurrencyBalance(chainId, account, currency) {
    const currencyArr = useMemo(() => [currency], [currency]);
    return useCurrencyBalances(chainId, account, currencyArr)[0];
}
// mimics useAllBalances
function useAllTokenBalances() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useTokenBalances_ = useTokenBalancesHook[chainId];
    const allTokens = useAllTokens();
    const allTokensArray = useMemo(() => Object.values(allTokens !== null && allTokens !== void 0 ? allTokens : {}), [allTokens]);
    const balances = useTokenBalances_(account !== null && account !== void 0 ? account : undefined, allTokensArray);
    return balances !== null && balances !== void 0 ? balances : {};
}
function useAddLiquidity() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const addTransaction = useTransactionAdder();
    const refetchMinichefSubgraph = useRefetchMinichefSubgraph();
    return (data) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (!chainId || !library || !account)
            return;
        const { parsedAmounts, deadline, noLiquidity, allowedSlippage, currencies } = data;
        const { CURRENCY_A: currencyA, CURRENCY_B: currencyB } = currencies;
        const router = getRouterContract(chainId, library, account);
        const { [Field$1.CURRENCY_A]: parsedAmountA, [Field$1.CURRENCY_B]: parsedAmountB } = parsedAmounts;
        if (!parsedAmountA || !parsedAmountB || !currencyA || !currencyB || !deadline || !router) {
            return;
        }
        const amountsMin = {
            [Field$1.CURRENCY_A]: calculateSlippageAmount(parsedAmountA, noLiquidity ? 0 : allowedSlippage)[0],
            [Field$1.CURRENCY_B]: calculateSlippageAmount(parsedAmountB, noLiquidity ? 0 : allowedSlippage)[0],
        };
        let estimate, method, args, value;
        if (currencyA === CAVAX[chainId] || currencyB === CAVAX[chainId]) {
            const tokenBIsETH = currencyB === CAVAX[chainId];
            estimate = router.estimateGas.addLiquidityAVAX;
            method = router.addLiquidityAVAX;
            args = [
                (_b = (_a = wrappedCurrency(tokenBIsETH ? currencyA : currencyB, chainId)) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : '',
                (tokenBIsETH ? parsedAmountA : parsedAmountB).raw.toString(),
                amountsMin[tokenBIsETH ? Field$1.CURRENCY_A : Field$1.CURRENCY_B].toString(),
                amountsMin[tokenBIsETH ? Field$1.CURRENCY_B : Field$1.CURRENCY_A].toString(),
                account,
                deadline.toHexString(),
            ];
            value = BigNumber.from((tokenBIsETH ? parsedAmountB : parsedAmountA).raw.toString());
        }
        else {
            estimate = router.estimateGas.addLiquidity;
            method = router.addLiquidity;
            args = [
                (_d = (_c = wrappedCurrency(currencyA, chainId)) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : '',
                (_f = (_e = wrappedCurrency(currencyB, chainId)) === null || _e === void 0 ? void 0 : _e.address) !== null && _f !== void 0 ? _f : '',
                parsedAmountA.raw.toString(),
                parsedAmountB.raw.toString(),
                amountsMin[Field$1.CURRENCY_A].toString(),
                amountsMin[Field$1.CURRENCY_B].toString(),
                account,
                deadline.toHexString(),
            ];
            value = null;
        }
        try {
            const estimatedGasLimit = yield estimate(...args, value ? { value } : {});
            const response = yield method(...args, Object.assign(Object.assign({}, (value ? { value } : {})), { gasLimit: calculateGasMargin(estimatedGasLimit) }));
            yield waitForTransaction(response, 5);
            addTransaction(response, {
                summary: 'Add ' +
                    ((_g = parsedAmounts[Field$1.CURRENCY_A]) === null || _g === void 0 ? void 0 : _g.toSignificant(3)) +
                    ' ' +
                    ((_h = currencies[Field$1.CURRENCY_A]) === null || _h === void 0 ? void 0 : _h.symbol) +
                    ' and ' +
                    ((_j = parsedAmounts[Field$1.CURRENCY_B]) === null || _j === void 0 ? void 0 : _j.toSignificant(3)) +
                    ' ' +
                    ((_k = currencies[Field$1.CURRENCY_B]) === null || _k === void 0 ? void 0 : _k.symbol),
            });
            yield refetchMinichefSubgraph();
            return response;
        }
        catch (err) {
            const _err = err;
            // we only care if the error is something _other_ than the user rejected the tx
            if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                console.error(_err);
            }
        }
        finally {
            // This is intentional
        }
    });
}
function useNearAddLiquidity() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    return (data) => __awaiter(this, void 0, void 0, function* () {
        if (!chainId || !library || !account)
            return;
        const depositTransactions = [];
        const { parsedAmounts, deadline, currencies } = data;
        const { CURRENCY_A: currencyA, CURRENCY_B: currencyB } = currencies;
        const { [Field$1.CURRENCY_A]: parsedAmountA, [Field$1.CURRENCY_B]: parsedAmountB } = parsedAmounts;
        const tokenA = currencyA ? wrappedCurrency(currencyA, chainId) : undefined;
        const tokenB = currencyB ? wrappedCurrency(currencyB, chainId) : undefined;
        if (!parsedAmountA || !parsedAmountB || !deadline || !tokenA || !tokenB) {
            throw new Error(`Missing dependency`);
        }
        const poolId = yield nearFn.getPoolId(chainId, tokenA, tokenB);
        const tokens = [tokenA, tokenB];
        const mainAmounts = [parsedAmountA.toFixed(), parsedAmountB.toFixed()];
        const amounts = [
            parseUnits(parsedAmountA.toFixed(), tokenA === null || tokenA === void 0 ? void 0 : tokenA.decimals).toString(),
            parseUnits(parsedAmountB.toFixed(), tokenB === null || tokenB === void 0 ? void 0 : tokenB.decimals).toString(),
        ];
        const exchangeContractId = NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId];
        const wNearContractId = WAVAX[chainId].address;
        const whitelist = yield nearFn.getWhitelistedTokens(chainId);
        for (let i = 0; i < tokens.length; i++) {
            const currencyId = tokens[i].address;
            depositTransactions.unshift({
                receiverId: currencyId,
                functionCalls: [
                    {
                        methodName: 'ft_transfer_call',
                        args: {
                            receiver_id: exchangeContractId,
                            amount: amounts[i],
                            msg: '',
                        },
                        amount: ONE_YOCTO_NEAR,
                    },
                ],
            });
            const tokenRegistered = yield nearFn.getStorageBalance(currencyId, exchangeContractId);
            if (tokenRegistered === null) {
                depositTransactions.unshift({
                    receiverId: currencyId,
                    functionCalls: [
                        nearFn.storageDepositAction({
                            accountId: exchangeContractId,
                            registrationOnly: true,
                            amount: NEAR_STORAGE_TO_REGISTER_WITH_FT,
                        }),
                    ],
                });
            }
            if (!whitelist.includes(currencyId)) {
                depositTransactions.unshift({
                    receiverId: exchangeContractId,
                    functionCalls: [nearFn.registerTokenAction(currencyId)],
                });
            }
        }
        const neededStorage = yield nearFn.checkUserNeedsStorageDeposit(chainId);
        if (neededStorage) {
            depositTransactions.unshift({
                receiverId: exchangeContractId,
                functionCalls: [nearFn.storageDepositAction({ amount: neededStorage })],
            });
        }
        const actions = [
            {
                methodName: 'add_liquidity',
                args: { pool_id: poolId, amounts },
                amount: NEAR_LP_STORAGE_AMOUNT,
            },
        ];
        const transactions = [
            ...depositTransactions,
            {
                receiverId: exchangeContractId,
                functionCalls: [...actions],
            },
        ];
        if (transactions.length > 0) {
            const wNearTokenIndex = tokens.findIndex((token) => (token === null || token === void 0 ? void 0 : token.address) === wNearContractId);
            if (wNearTokenIndex > -1 && !ONLY_ZEROS.test(mainAmounts[wNearTokenIndex])) {
                transactions.unshift({
                    receiverId: wNearContractId,
                    functionCalls: [nearFn.nearDepositAction(mainAmounts[wNearTokenIndex])],
                });
            }
            if (wNearTokenIndex > -1) {
                const registered = yield nearFn.getStorageBalance(wNearContractId);
                if (registered === null) {
                    transactions.unshift({
                        receiverId: wNearContractId,
                        functionCalls: [
                            nearFn.storageDepositAction({
                                registrationOnly: true,
                                amount: NEAR_STORAGE_TO_REGISTER_WITH_FT,
                            }),
                        ],
                    });
                }
            }
        }
        return nearFn.executeMultipleTransactions(transactions);
    });
}
function useRemoveLiquidity(pair) {
    var _a;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const addTransaction = useTransactionAdder();
    const { t } = useTranslation();
    const [signatureData, setSignatureData] = useState(null);
    const getSignature = useGetTransactionSignature();
    const pairContract = usePairContract((_a = pair === null || pair === void 0 ? void 0 : pair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address);
    const refetchMinichefSubgraph = useRefetchMinichefSubgraph();
    const removeLiquidity = (data) => __awaiter(this, void 0, void 0, function* () {
        var _b, _c;
        if (!chainId || !library || !account || !pair)
            return;
        const { parsedAmounts, deadline, allowedSlippage, approval } = data;
        const router = getRouterContract(chainId, library, account);
        if (!chainId || !library || !account || !deadline || !router)
            throw new Error(t('error.missingDependencies'));
        const { [Field$1.CURRENCY_A]: currencyAmountA, [Field$2.CURRENCY_B]: currencyAmountB } = parsedAmounts;
        const tokenA = pair === null || pair === void 0 ? void 0 : pair.token0;
        const tokenB = pair === null || pair === void 0 ? void 0 : pair.token1;
        const currencyA = tokenA ? unwrappedToken(tokenA, chainId) : undefined;
        const currencyB = tokenB ? unwrappedToken(tokenB, chainId) : undefined;
        if (!currencyAmountA || !currencyAmountB) {
            throw new Error(t('error.missingCurrencyAmounts'));
        }
        const amountsMin = {
            [Field$2.CURRENCY_A]: calculateSlippageAmount(currencyAmountA, allowedSlippage)[0],
            [Field$2.CURRENCY_B]: calculateSlippageAmount(currencyAmountB, allowedSlippage)[0],
        };
        if (!currencyA || !currencyB)
            throw new Error(t('error.missingTokens'));
        const liquidityAmount = parsedAmounts[Field$2.LIQUIDITY];
        if (!liquidityAmount)
            throw new Error(t('error.missingLiquidityAmount'));
        const currencyBIsAVAX = currencyB === CAVAX[chainId];
        const oneCurrencyIsAVAX = currencyA === CAVAX[chainId] || currencyBIsAVAX;
        if (!tokenA || !tokenB)
            throw new Error(t('error.couldNotWrap'));
        let methodNames, args;
        // we have approval, use normal remove liquidity
        if (approval === ApprovalState.APPROVED) {
            // removeLiquidityAVAX
            if (oneCurrencyIsAVAX) {
                methodNames = ['removeLiquidityAVAX', 'removeLiquidityAVAXSupportingFeeOnTransferTokens'];
                args = [
                    currencyBIsAVAX ? tokenA.address : tokenB.address,
                    liquidityAmount.raw.toString(),
                    amountsMin[currencyBIsAVAX ? Field$2.CURRENCY_A : Field$2.CURRENCY_B].toString(),
                    amountsMin[currencyBIsAVAX ? Field$2.CURRENCY_B : Field$2.CURRENCY_A].toString(),
                    account,
                    deadline.toHexString(),
                ];
            }
            // removeLiquidity
            else {
                methodNames = ['removeLiquidity'];
                args = [
                    tokenA.address,
                    tokenB.address,
                    liquidityAmount.raw.toString(),
                    amountsMin[Field$2.CURRENCY_A].toString(),
                    amountsMin[Field$2.CURRENCY_B].toString(),
                    account,
                    deadline.toHexString(),
                ];
            }
        }
        // we have a signature, use permit versions of remove liquidity
        else if (signatureData !== null) {
            // removeLiquidityAVAXWithPermit
            if (oneCurrencyIsAVAX) {
                methodNames = ['removeLiquidityAVAXWithPermit', 'removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens'];
                args = [
                    currencyBIsAVAX ? tokenA.address : tokenB.address,
                    liquidityAmount.raw.toString(),
                    amountsMin[currencyBIsAVAX ? Field$2.CURRENCY_A : Field$2.CURRENCY_B].toString(),
                    amountsMin[currencyBIsAVAX ? Field$2.CURRENCY_B : Field$2.CURRENCY_A].toString(),
                    account,
                    signatureData.deadline,
                    false,
                    signatureData.v,
                    signatureData.r,
                    signatureData.s,
                ];
            }
            // removeLiquidityAVAXWithPermit
            else {
                methodNames = ['removeLiquidityWithPermit'];
                args = [
                    tokenA.address,
                    tokenB.address,
                    liquidityAmount.raw.toString(),
                    amountsMin[Field$2.CURRENCY_A].toString(),
                    amountsMin[Field$2.CURRENCY_B].toString(),
                    account,
                    signatureData.deadline,
                    false,
                    signatureData.v,
                    signatureData.r,
                    signatureData.s,
                ];
            }
        }
        else {
            throw new Error(t('error.attemptingToConfirmApproval'));
        }
        const safeGasEstimates = yield Promise.all(methodNames.map((methodName) => router.estimateGas[methodName](...args)
            .then(calculateGasMargin)
            .catch((err) => {
                console.error(`estimateGas failed`, methodName, args, err);
                return undefined;
            })));
        const indexOfSuccessfulEstimation = safeGasEstimates.findIndex((safeGasEstimate) => BigNumber.isBigNumber(safeGasEstimate));
        // all estimations failed...
        if (indexOfSuccessfulEstimation === -1) {
            console.error('This transaction would fail. Please contact support.');
        }
        else {
            const methodName = methodNames[indexOfSuccessfulEstimation];
            const safeGasEstimate = safeGasEstimates[indexOfSuccessfulEstimation];
            try {
                const response = yield router[methodName](...args, {
                    gasLimit: safeGasEstimate,
                });
                yield waitForTransaction(response, 5);
                addTransaction(response, {
                    summary: t('removeLiquidity.remove') +
                        ' ' +
                        ((_b = parsedAmounts[Field$2.CURRENCY_A]) === null || _b === void 0 ? void 0 : _b.toSignificant(3)) +
                        ' ' +
                        (currencyA === null || currencyA === void 0 ? void 0 : currencyA.symbol) +
                        ' and ' +
                        ((_c = parsedAmounts[Field$2.CURRENCY_B]) === null || _c === void 0 ? void 0 : _c.toSignificant(3)) +
                        ' ' +
                        (currencyB === null || currencyB === void 0 ? void 0 : currencyB.symbol),
                });
                yield refetchMinichefSubgraph();
                return response;
            }
            catch (err) {
                const _err = err;
                // we only care if the error is something _other_ than the user rejected the tx
                if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                    console.error(_err);
                }
            }
        }
    });
    const onAttemptToApprove = (data1) => __awaiter(this, void 0, void 0, function* () {
        const { parsedAmounts, deadline, approveCallback } = data1;
        if (!pairContract || !pair || !library || !deadline || !chainId || !account)
            throw new Error(t('earn.missingDependencies'));
        const liquidityAmount = parsedAmounts[Field$2.LIQUIDITY];
        if (!liquidityAmount)
            throw new Error(t('earn.missingLiquidityAmount'));
        // try to gather a signature for permission
        const nonce = yield pairContract.nonces(account);
        const EIP712Domain = [
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
            { name: 'chainId', type: 'uint256' },
            { name: 'verifyingContract', type: 'address' },
        ];
        const domain = {
            name: 'Arcanum Liquidity',
            version: '1',
            chainId: chainId,
            verifyingContract: pair.liquidityToken.address,
        };
        const Permit = [
            { name: 'owner', type: 'address' },
            { name: 'spender', type: 'address' },
            { name: 'value', type: 'uint256' },
            { name: 'nonce', type: 'uint256' },
            { name: 'deadline', type: 'uint256' },
        ];
        const message = {
            owner: account,
            spender: ROUTER_ADDRESS[chainId],
            value: liquidityAmount.raw.toString(),
            nonce: nonce.toHexString(),
            deadline: deadline.toNumber(),
        };
        const data = JSON.stringify({
            types: {
                EIP712Domain,
                Permit,
            },
            domain,
            primaryType: 'Permit',
            message,
        });
        try {
            const signature = yield getSignature(data);
            setSignatureData({
                v: signature.v,
                r: signature.r,
                s: signature.s,
                deadline: deadline.toNumber(),
            });
        }
        catch (err) {
            approveCallback();
        }
    });
    return { removeLiquidity, onAttemptToApprove, signatureData, setSignatureData };
}
function useNearRemoveLiquidity(pair) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const { t } = useTranslation();
    const removeLiquidity = (data) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (!chainId || !library || !account)
            return;
        let transactions = [];
        const withDrawTransactions = [];
        const { parsedAmounts, deadline, allowedSlippage } = data;
        if (!chainId || !library || !account || !deadline)
            throw new Error(t('error.missingDependencies'));
        const { [Field$1.CURRENCY_A]: currencyAmountA, [Field$2.CURRENCY_B]: currencyAmountB } = parsedAmounts;
        const tokenA = pair === null || pair === void 0 ? void 0 : pair.token0;
        const tokenB = pair === null || pair === void 0 ? void 0 : pair.token1;
        if (!currencyAmountA || !currencyAmountB) {
            throw new Error(t('error.missingCurrencyAmounts'));
        }
        const liquidityAmount = parsedAmounts[Field$2.LIQUIDITY];
        if (!liquidityAmount)
            throw new Error(t('error.missingLiquidityAmount'));
        if (!tokenA || !tokenB)
            throw new Error(t('error.missingTokens'));
        const poolId = yield nearFn.getPoolId(chainId, tokenA, tokenB);
        const tokens = [tokenA, tokenB];
        const amountsMin = [
            (_a = calculateSlippageAmount(currencyAmountA, allowedSlippage)[0]) === null || _a === void 0 ? void 0 : _a.toString(),
            (_b = calculateSlippageAmount(currencyAmountB, allowedSlippage)[0]) === null || _b === void 0 ? void 0 : _b.toString(),
        ];
        const exchangeContractId = NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId];
        for (const token of tokens) {
            const currencyId = token.address;
            const tokenRegistered = yield nearFn.getStorageBalance(currencyId, exchangeContractId);
            if (tokenRegistered === null) {
                withDrawTransactions.unshift({
                    receiverId: currencyId,
                    functionCalls: [
                        nearFn.storageDepositAction({
                            accountId: exchangeContractId,
                            registrationOnly: true,
                            amount: NEAR_STORAGE_TO_REGISTER_WITH_FT,
                        }),
                    ],
                });
            }
        }
        const neededStorage = yield nearFn.checkUserNeedsStorageDeposit(chainId);
        if (neededStorage) {
            withDrawTransactions.unshift({
                receiverId: exchangeContractId,
                functionCalls: [nearFn.storageDepositAction({ amount: neededStorage })],
            });
        }
        const withdrawActions = tokens.map((token) => nearFn.withdrawAction({ tokenId: token === null || token === void 0 ? void 0 : token.address, amount: '0' }));
        const actions = [
            {
                methodName: 'remove_liquidity',
                args: { pool_id: poolId, shares: liquidityAmount === null || liquidityAmount === void 0 ? void 0 : liquidityAmount.raw.toString(), min_amounts: amountsMin },
                amount: ONE_YOCTO_NEAR,
            },
        ];
        withdrawActions.forEach((item) => {
            actions.push(item);
        });
        transactions = [
            ...withDrawTransactions,
            {
                receiverId: exchangeContractId,
                functionCalls: [...actions],
            },
        ];
        return nearFn.executeMultipleTransactions(transactions);
    });
    const onAttemptToApprove = () => {
        // This is intentional
    };
    return { removeLiquidity, onAttemptToApprove, signatureData: undefined, setSignatureData: () => { } };
}
function useGetUserLP() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    // fetch the user's balances of all tracked V2 LP tokens
    const trackedTokenPairs = useTrackedTokenPairs();
    const tokenPairsWithLiquidityTokens = useMemo(() => trackedTokenPairs.map((tokens) => ({
        liquidityToken: toV2LiquidityToken(tokens, chainId),
        tokens,
    })), [trackedTokenPairs, chainId]);
    const liquidityTokens = useMemo(() => tokenPairsWithLiquidityTokens.map((tpwlt) => tpwlt.liquidityToken), [tokenPairsWithLiquidityTokens]);
    const [v2PairsBalances, fetchingV2PairBalances] = useTokenBalancesWithLoadingIndicator(account !== null && account !== void 0 ? account : undefined, liquidityTokens);
    //fetch the reserves for all V2 pools in which the user has a balance
    const liquidityTokensWithBalances = useMemo(() => tokenPairsWithLiquidityTokens.filter(({ liquidityToken }) => { var _a; return (_a = v2PairsBalances[liquidityToken.address]) === null || _a === void 0 ? void 0 : _a.greaterThan('0'); }), [tokenPairsWithLiquidityTokens, v2PairsBalances]);
    const lpTokensWithBalances = useMemo(() => liquidityTokensWithBalances.map(({ tokens }) => tokens), [liquidityTokensWithBalances]);
    const v2Pairs = usePairs(lpTokensWithBalances);
    const v2IsLoading = fetchingV2PairBalances ||
        (v2Pairs === null || v2Pairs === void 0 ? void 0 : v2Pairs.length) < liquidityTokensWithBalances.length ||
        (v2Pairs === null || v2Pairs === void 0 ? void 0 : v2Pairs.some((V2Pair) => !V2Pair));
    const allV2PairsWithLiquidity = useMemo(() => v2Pairs.map(([, pair]) => pair).filter((v2Pair) => Boolean(v2Pair)), [v2Pairs]);
    const pairWithLpTokens = useMemo(() => tokenPairsWithLiquidityTokens.map(({ tokens }) => tokens), [tokenPairsWithLiquidityTokens]);
    const v2AllPairs = usePairs(pairWithLpTokens);
    const allV2AllPairsWithLiquidity = useMemo(() => v2AllPairs.map(([, pair]) => pair).filter((_v2AllPairs) => Boolean(_v2AllPairs)), [v2AllPairs]);
    return useMemo(() => ({ v2IsLoading, allV2PairsWithLiquidity, allPairs: allV2AllPairsWithLiquidity }), [v2IsLoading, allV2PairsWithLiquidity, allV2AllPairsWithLiquidity]);
}
function useGetNearUserLP() {
    const { account } = usePangolinWeb3();
    const { isLoading: v2IsLoading, data: pools = [] } = useGetNearAllPool();
    const allTokenAddress = useMemo(() => {
        var _a;
        let tokenAddresses = [];
        for (let i = 0; i < (pools === null || pools === void 0 ? void 0 : pools.length); i++) {
            tokenAddresses = [...tokenAddresses, ...(_a = pools === null || pools === void 0 ? void 0 : pools[i]) === null || _a === void 0 ? void 0 : _a.token_account_ids];
        }
        return [...new Set(tokenAddresses)];
    }, [pools]);
    const allTokens = useNearTokens(allTokenAddress);
    const tokensMapping = useMemo(() => {
        var _a;
        if (allTokens && allTokens.length > 0 && allTokenAddress.length === allTokens.length) {
            const tokensObj = {};
            for (let i = 0; i < (allTokens === null || allTokens === void 0 ? void 0 : allTokens.length); i++) {
                tokensObj[(_a = allTokens === null || allTokens === void 0 ? void 0 : allTokens[i]) === null || _a === void 0 ? void 0 : _a.address] = allTokens[i];
            }
            return tokensObj;
        }
        return undefined;
    }, [allTokens, allTokenAddress]);
    const liquidityTokens = useMemo(() => {
        if (allTokens && allTokens.length > 0 && tokensMapping && Object.keys(tokensMapping).length === allTokens.length) {
            const allLPTokens = (pools || []).map((pool) => {
                const tokens = pool === null || pool === void 0 ? void 0 : pool.token_account_ids.map((address) => {
                    const token = tokensMapping[address];
                    return token;
                });
                return [tokens === null || tokens === void 0 ? void 0 : tokens[0], tokens === null || tokens === void 0 ? void 0 : tokens[1]];
            });
            return allLPTokens;
        }
        return undefined;
    }, [allTokens, pools, tokensMapping]);
    const memoArray = useMemo(() => [], []);
    const v2AllPairs = useNearPairs(liquidityTokens || memoArray);
    const allV2Pairs = useMemo(() => v2AllPairs.map(([, pair]) => pair).filter((_v2AllPairs) => Boolean(_v2AllPairs)), [v2AllPairs]);
    const v2PairsBalances = useNearTokenBalances(account !== null && account !== void 0 ? account : undefined, allV2Pairs);
    //fetch the reserves for all V2 pools in which the user has a balance
    const allV2PairsWithLiquidity = useMemo(() => allV2Pairs.filter(({ liquidityToken }) => { var _a; return (_a = v2PairsBalances[liquidityToken.address]) === null || _a === void 0 ? void 0 : _a.greaterThan('0'); }), [allV2Pairs, v2PairsBalances]);
    const pairs = (liquidityTokens || memoArray).length > 0 ? allV2PairsWithLiquidity : [];
    return useMemo(() => ({ v2IsLoading, allV2PairsWithLiquidity: pairs }), [v2IsLoading, pairs]);
}
function useNearCreatePool() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    return (data) => __awaiter(this, void 0, void 0, function* () {
        if (!chainId || !library || !account)
            return;
        let transactions = [];
        const { tokenA, tokenB } = data;
        if (!tokenA || !tokenB) {
            throw new Error(`Missing dependency`);
        }
        // const poolId = await nearFn.getPoolId(chainId, tokenA, tokenB);
        // if (poolId) {
        //   throw new Error(`Pool is already exits`);
        // }
        const tokens = [tokenA, tokenB];
        const exchangeContractId = NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId];
        const tokenIds = tokens.map((token) => token === null || token === void 0 ? void 0 : token.address);
        const storageBalances = yield Promise.all(tokenIds.map((id) => nearFn.getStorageBalance(id, exchangeContractId)));
        transactions = storageBalances
            .reduce((acc, sb, i) => {
                if (!sb || sb.total === '0')
                    acc.push(tokenIds[i]);
                return acc;
            }, [])
            .map((id) => ({
                receiverId: id,
                functionCalls: [
                    nearFn.storageDepositAction({
                        accountId: exchangeContractId,
                        registrationOnly: true,
                        amount: NEAR_STORAGE_TO_REGISTER_WITH_FT,
                    }),
                ],
            }));
        transactions.push({
            receiverId: exchangeContractId,
            functionCalls: [
                {
                    methodName: 'add_simple_pool',
                    args: { tokens: tokenIds, fee: 0.5 },
                    amount: '0.05',
                },
            ],
        });
        const query = qs.stringify({
            currency0: tokenA === null || tokenA === void 0 ? void 0 : tokenA.address,
            currency1: tokenB === null || tokenB === void 0 ? void 0 : tokenB.address,
        });
        return nearFn.executeMultipleTransactions(transactions, `${window.location.origin}/${window.location.hash}?${query}`);
    });
}
/* eslint-enable max-lines */

/* eslint-disable max-lines */
function useSwapState() {
    return useSelector((state) => state.pswap);
}
function useSwapActionHandlers(chainId) {
    const dispatch = useDispatch();
    const onCurrencySelection = useCallback((field, currency) => {
        var _a, _b;
        dispatch(selectCurrency({
            field,
            currencyId: currency instanceof Token$1
                ? currency.address
                : currency === CAVAX[chainId] && ((_a = CAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.symbol)
                    ? (_b = CAVAX[chainId]) === null || _b === void 0 ? void 0 : _b.symbol
                    : '',
        }));
    }, [dispatch]);
    const onSwitchTokens = useCallback(() => {
        dispatch(switchCurrencies());
    }, [dispatch]);
    const onUserInput = useCallback((field, typedValue) => {
        dispatch(typeInput({ field, typedValue }));
    }, [dispatch]);
    const onChangeRecipient = useCallback((recipient) => {
        dispatch(setRecipient({ recipient }));
    }, [dispatch]);
    return {
        onSwitchTokens,
        onCurrencySelection,
        onUserInput,
        onChangeRecipient,
    };
}
// try to parse a user entered amount for a given token
function tryParseAmount(value, currency, chainId = ChainId.AVALANCHE) {
    if (!value || !currency) {
        return undefined;
    }
    try {
        const typedValueParsed = parseUnits$1(value, currency.decimals).toString();
        if (typedValueParsed !== '0') {
            return currency instanceof Token$1
                ? new TokenAmount(currency, JSBI$1.BigInt(typedValueParsed))
                : CurrencyAmount.ether(JSBI$1.BigInt(typedValueParsed), chainId);
        }
    }
    catch (error) {
        // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)
        console.debug(`Failed to parse input amount: "${value}"`, error);
    }
    // necessary for all paths to return a value
    return undefined;
}
const BAD_RECIPIENT_ADDRESSES = [
    FACTORY_ADDRESS[ChainId.AVALANCHE],
    ROUTER_ADDRESS[ChainId.AVALANCHE],
    ROUTER_DAAS_ADDRESS[ChainId.AVALANCHE], // DaaS router
];
/**
 * Returns true if any of the pairs or tokens in a trade have the given checksummed address
 * @param trade to check for the given address
 * @param checksummedAddress address to check in the pairs and tokens
 */
function involvesAddress(trade, checksummedAddress) {
    return (trade.route.path.some((token) => token.address === checksummedAddress) ||
        trade.route.pools.some((pool) => pool.liquidityToken.address === checksummedAddress));
}
// from the current swap inputs, compute the best trade and return it.
function useDerivedSwapInfo() {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const toggledVersion = useToggledVersion();
    const { independentField, typedValue, [Field.INPUT]: { currencyId: inputCurrencyId }, [Field.OUTPUT]: { currencyId: outputCurrencyId }, recipient, } = useSwapState();
    const inputCurrency = useCurrency(inputCurrencyId);
    const outputCurrency = useCurrency(outputCurrencyId);
    const recipientAddress = isEvmChain(chainId) ? isAddress(recipient) : recipient;
    const to = (_a = (recipientAddress ? recipientAddress : account)) !== null && _a !== void 0 ? _a : null;
    const relevantTokenBalances = useCurrencyBalances(chainId, account !== null && account !== void 0 ? account : undefined, [
        inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined,
        outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined,
    ]);
    const isExactIn = independentField === Field.INPUT;
    const parsedAmount = tryParseAmount(typedValue, (_b = (isExactIn ? inputCurrency : outputCurrency)) !== null && _b !== void 0 ? _b : undefined, chainId);
    const { trade: bestTradeExactIn, isLoading: isLoadingIn } = useTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined);
    const { trade: bestTradeExactOut, isLoading: isLoadingOut } = useTradeExactOut(inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, !isExactIn ? parsedAmount : undefined);
    const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut;
    const currencyBalances = {
        [Field.INPUT]: relevantTokenBalances[0],
        [Field.OUTPUT]: relevantTokenBalances[1],
    };
    const currencies = {
        [Field.INPUT]: inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined,
        [Field.OUTPUT]: outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined,
    };
    // get link to trade on v1, if a better rate exists
    const v1Trade = undefined;
    let inputError;
    if (!account) {
        inputError = 'Connect Wallet';
    }
    if (!parsedAmount) {
        inputError = inputError !== null && inputError !== void 0 ? inputError : 'Enter an amount';
    }
    if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {
        inputError = inputError !== null && inputError !== void 0 ? inputError : 'Select a token';
    }
    const formattedTo = isEvmChain(chainId) ? isAddress(to) : to;
    if (!to || !formattedTo) {
        inputError = inputError !== null && inputError !== void 0 ? inputError : 'Enter a recipient';
    }
    else {
        if (BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 ||
            (bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo)) ||
            (bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo))) {
            inputError = inputError !== null && inputError !== void 0 ? inputError : 'Invalid recipient';
        }
    }
    const [allowedSlippage] = useUserSlippageTolerance();
    const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage);
    // compare input balance to max input based on version
    const [balanceIn, amountIn] = [
        currencyBalances[Field.INPUT],
        toggledVersion === Version.v1
            ? null
            : slippageAdjustedAmounts
                ? slippageAdjustedAmounts[Field.INPUT]
                : null,
    ];
    if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {
        inputError = 'Insufficient ' + amountIn.currency.symbol + ' balance';
    }
    const isLoading = isExactIn ? isLoadingIn : isLoadingOut;
    return {
        currencies,
        currencyBalances,
        parsedAmount,
        v2Trade: v2Trade !== null && v2Trade !== void 0 ? v2Trade : undefined,
        inputError,
        v1Trade,
        isLoading,
    };
}
function parseCurrencyFromURLParameter(urlParam, chainId) {
    var _a, _b, _c, _d;
    if (typeof urlParam === 'string') {
        const valid = isAddress(urlParam);
        if (valid)
            return valid;
        if (urlParam.toUpperCase() === ((_b = (_a = CAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.toUpperCase()))
            return (_c = CAVAX[chainId]) === null || _c === void 0 ? void 0 : _c.symbol;
        if (valid === false)
            return (_d = CAVAX[chainId]) === null || _d === void 0 ? void 0 : _d.symbol;
    }
    //return 'AVAX' ?? '';
    return '';
}
function parseTokenAmountURLParameter(urlParam) {
    return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';
}
function parseIndependentFieldURLParameter(urlParam) {
    return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;
}
const ENS_NAME_REGEX$1 = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;
const ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;
function validatedRecipient(recipient) {
    if (typeof recipient !== 'string')
        return null;
    const address = isAddress(recipient);
    if (address)
        return address;
    if (ENS_NAME_REGEX$1.test(recipient))
        return recipient;
    if (ADDRESS_REGEX.test(recipient))
        return recipient;
    return null;
}
function queryParametersToSwapState(parsedQs, chainId) {
    let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency, chainId);
    let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency, chainId);
    if (inputCurrency === outputCurrency) {
        if (typeof parsedQs.outputCurrency === 'string') {
            inputCurrency = '';
        }
        else {
            outputCurrency = '';
        }
    }
    const recipient = validatedRecipient(parsedQs.recipient);
    return {
        [Field.INPUT]: {
            currencyId: inputCurrency,
        },
        [Field.OUTPUT]: {
            currencyId: outputCurrency,
        },
        typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),
        independentField: parseIndependentFieldURLParameter(parsedQs.exactField),
        recipient,
    };
}
// updates the swap state to use the defaults for a given network
function useDefaultsFromURLSearch() {
    const { chainId } = usePangolinWeb3();
    const dispatch = useDispatch();
    const parsedQs = useParsedQueryString();
    const [result, setResult] = useState();
    const { [Field.INPUT]: { currencyId: inputCurrencyId }, [Field.OUTPUT]: { currencyId: outputCurrencyId }, } = useSwapState();
    useEffect(() => {
        var _a, _b;
        if (!chainId)
            return;
        const parsed = queryParametersToSwapState(parsedQs, chainId);
        dispatch(replaceSwapState({
            typedValue: parsed.typedValue,
            field: parsed.independentField,
            inputCurrencyId: parsed[Field.INPUT].currencyId
                ? parsed[Field.INPUT].currencyId
                : inputCurrencyId
                    ? inputCurrencyId
                    : (_a = SWAP_DEFAULT_CURRENCY[chainId]) === null || _a === void 0 ? void 0 : _a.inputCurrency,
            outputCurrencyId: parsed[Field.OUTPUT].currencyId
                ? parsed[Field.OUTPUT].currencyId
                : outputCurrencyId
                    ? outputCurrencyId
                    : (_b = SWAP_DEFAULT_CURRENCY[chainId]) === null || _b === void 0 ? void 0 : _b.outputCurrency,
            recipient: parsed.recipient,
        }));
        setResult({ inputCurrencyId: parsed[Field.INPUT].currencyId, outputCurrencyId: parsed[Field.OUTPUT].currencyId });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [dispatch, chainId]);
    return result;
}
function useGelatoLimitOrderDetail(order) {
    const { chainId } = usePangolinWeb3();
    const gelatoLibrary = useGelatoLimitOrdersLib();
    const inputCurrency = order.inputToken === NATIVE && chainId ? 'AVAX' : order.inputToken;
    const outputCurrency = order.outputToken === NATIVE && chainId ? 'AVAX' : order.outputToken;
    const currency0 = useCurrency(inputCurrency);
    const currency1 = useCurrency(outputCurrency);
    const inputToken = currency0 ? wrappedCurrency(currency0, chainId) : undefined;
    const outputToken = currency1 ? wrappedCurrency(currency1, chainId) : undefined;
    const inputAmount = useMemo(() => (inputToken && order.inputAmount ? new TokenAmount(inputToken, order.inputAmount) : undefined), [inputToken, order.inputAmount]);
    const rawMinReturn = useMemo(() => order.adjustedMinReturn
        ? order.adjustedMinReturn
        : gelatoLibrary && chainId && order.minReturn
            ? gelatoLibrary.getAdjustedMinReturn(order.minReturn)
            : undefined, [chainId, gelatoLibrary, order.adjustedMinReturn, order.minReturn]);
    const outputAmount = useMemo(() => (outputToken && rawMinReturn ? new TokenAmount(outputToken, rawMinReturn) : undefined), [outputToken, rawMinReturn]);
    const executionPrice = useMemo(() => outputAmount && outputAmount.greaterThan('0') && inputAmount && currency0 && currency1
        ? new Price(currency0, currency1, inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.raw, outputAmount === null || outputAmount === void 0 ? void 0 : outputAmount.raw)
        : undefined, [currency0, currency1, inputAmount, outputAmount]);
    return useMemo(() => ({
        currency0,
        currency1,
        inputAmount,
        outputAmount,
        executionPrice,
    }), [currency0, currency1, inputAmount, outputAmount, executionPrice]);
}
function useGelatoLimitOrderList() {
    const { open, executed, cancelled } = useGelatoLimitOrdersHistory();
    const openPending = useMemo(() => (open.pending || []).map((item) => {
        const container = Object.assign({}, item);
        container['pending'] = true;
        return container;
    }), [open.pending]);
    const cancelledPending = useMemo(() => (cancelled.pending || []).map((item) => {
        const container = Object.assign({}, item);
        container['pending'] = true;
        return container;
    }), [cancelled.pending]);
    const allOrders = useMemo(() => [...cancelledPending, ...openPending, ...open.confirmed, ...cancelled.confirmed, ...executed], [openPending, cancelledPending, open.confirmed, cancelled.confirmed, executed]);
    const allOpenOrders = useMemo(() => [...cancelledPending, ...openPending, ...open.confirmed], [openPending, cancelledPending, open.confirmed]);
    const allCancelledOrders = useMemo(() => cancelled.confirmed, [cancelled.confirmed]);
    return useMemo(() => ({
        allOrders,
        allOpenOrders,
        allCancelledOrders,
        executed,
    }), [allOrders, allOpenOrders, allCancelledOrders, executed]);
}
function useDaasFeeTo() {
    const dispatch = useDispatch();
    const feeTo = useSelector((state) => {
        return state.pswap.feeTo;
    });
    const setFeeTo = useCallback((newFeeTo) => {
        dispatch(updateFeeTo({ feeTo: newFeeTo }));
    }, [dispatch]);
    return [feeTo, setFeeTo];
}
function useDaasFeeInfo() {
    const dispatch = useDispatch();
    const feeInfo = useSelector((state) => {
        return state.pswap.feeInfo;
    });
    const setFeeInfo = useCallback((newFeeInfo) => {
        dispatch(updateFeeInfo({ feeInfo: newFeeInfo }));
    }, [dispatch]);
    return [feeInfo, setFeeInfo];
}
/* eslint-enable max-lines */

/**
 * Given a name or address, does a lookup to resolve to an address and name
 * @param nameOrAddress ENS name or address
 */
function useENS(nameOrAddress) {
    const validated = isAddress(nameOrAddress);
    return {
        loading: false,
        address: validated ? validated : null,
        name: null,
    };
}

// combines the current timestamp with the user setting to give the deadline that should be used for any submitted transaction
function useTransactionDeadline() {
    const ttl = useSelector((state) => state.puser.userDeadline);
    const currentTimestampSeconds = BigNumber$1.from(Math.ceil(Date.now() / 1000));
    return ttl ? currentTimestampSeconds.add(ttl) : undefined;
}

var SwapCallbackState;
(function (SwapCallbackState) {
    SwapCallbackState[SwapCallbackState["INVALID"] = 0] = "INVALID";
    SwapCallbackState[SwapCallbackState["LOADING"] = 1] = "LOADING";
    SwapCallbackState[SwapCallbackState["VALID"] = 2] = "VALID";
})(SwapCallbackState || (SwapCallbackState = {}));
/**
 * Returns the swap calls that can be used to make the trade
 * @param trade trade to execute
 * @param allowedSlippage user allowed slippage
 * @param recipientAddressOrName
 */
function useSwapCallArguments(trade, // trade to execute, required
    allowedSlippage = INITIAL_ALLOWED_SLIPPAGE, // in bips
    recipientAddressOrName) {
    const { account, chainId } = usePangolinWeb3();
    const { library } = useLibrary();
    const [partnerDaaS] = useDaasFeeTo();
    const { address: recipientAddress } = useENS(recipientAddressOrName);
    const recipient = recipientAddressOrName === null ? account : recipientAddress;
    let deadline = useTransactionDeadline();
    const currentTime = BigNumber.from(new Date().getTime());
    if (deadline && deadline < currentTime.add(10)) {
        deadline = currentTime.add(10);
    }
    const contract = useMemo(() => {
        if (!chainId || !library || !account || !partnerDaaS)
            return null;
        return partnerDaaS === ZERO_ADDRESS
            ? getRouterContract(chainId, library, account)
            : getRouterContractDaaS(chainId, library, account);
    }, [chainId, library, account, partnerDaaS]);
    return useMemo(() => {
        if (!trade || !contract || !recipient || !deadline) {
            return [];
        }
        const swapMethods = [];
        swapMethods.push(Router.swapCallParameters(trade, {
            feeOnTransfer: false,
            allowedSlippage: new Percent$1(JSBI$1.BigInt(allowedSlippage), BIPS_BASE),
            recipient,
            deadline: deadline.toNumber(),
        }));
        if (trade.tradeType === TradeType$2.EXACT_INPUT) {
            swapMethods.push(Router.swapCallParameters(trade, {
                feeOnTransfer: true,
                allowedSlippage: new Percent$1(JSBI$1.BigInt(allowedSlippage), BIPS_BASE),
                recipient,
                deadline: deadline.toNumber(),
            }));
        }
        return swapMethods.map((parameters) => ({ parameters, contract }));
    }, [trade, contract, allowedSlippage, recipient, deadline]);
}
// returns a function that will execute a swap, if the parameters are all valid
// and the user has approved the slippage adjusted input amount for the trade
function useSwapCallback(trade, // trade to execute, required
    allowedSlippage = INITIAL_ALLOWED_SLIPPAGE, // in bips
    recipientAddressOrName) {
    const { account, chainId } = usePangolinWeb3();
    const { library } = useLibrary();
    const swapCalls = useSwapCallArguments(trade, allowedSlippage, recipientAddressOrName);
    const addTransaction = useTransactionAdder();
    const { address: recipientAddress } = useENS(recipientAddressOrName);
    const recipient = recipientAddressOrName === null ? account : recipientAddress;
    return useMemo(() => {
        if (!trade || !library || !account || !chainId) {
            return { state: SwapCallbackState.INVALID, callback: null, error: 'Missing dependencies' };
        }
        if (!recipient) {
            if (recipientAddressOrName !== null) {
                return { state: SwapCallbackState.INVALID, callback: null, error: 'Invalid recipient' };
            }
            else {
                return { state: SwapCallbackState.LOADING, callback: null, error: null };
            }
        }
        const tradeVersion = Version.v2;
        return {
            state: SwapCallbackState.VALID,
            callback: function onSwap() {
                return __awaiter(this, void 0, void 0, function* () {
                    const estimatedCalls = yield Promise.all(swapCalls.map((call) => {
                        const { parameters: { methodName, args, value }, contract, } = call;
                        const options = !value || isZero(value) ? {} : { value };
                        return contract.estimateGas[methodName](...args, options)
                            .then((gasEstimate) => {
                                return {
                                    call,
                                    gasEstimate,
                                };
                            })
                            .catch((gasError) => {
                                console.debug('Gas estimate failed, trying eth_call to extract error', call);
                                return contract.callStatic[methodName](...args, options)
                                    .then((result) => {
                                        console.debug('Unexpected successful call after failed estimate gas', call, gasError, result);
                                        return { call, error: new Error('Unexpected issue with estimating the gas. Please try again.') };
                                    })
                                    .catch((callError) => {
                                        console.debug('Call threw error', call, callError);
                                        let errorMessage;
                                        switch (callError.reason) {
                                            case 'PangolinRouter: INSUFFICIENT_OUTPUT_AMOUNT':
                                            case 'PangolinRouter: EXCESSIVE_INPUT_AMOUNT':
                                                errorMessage =
                                                    'This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.';
                                                break;
                                            default:
                                                errorMessage = `The transaction cannot succeed due to error: ${callError.reason}. This is probably an issue with one of the tokens you are swapping.`;
                                        }
                                        return { call, error: new Error(errorMessage) };
                                    });
                            });
                    }));
                    // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate
                    const successfulEstimation = estimatedCalls.find((el, ix, list) => 'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1]));
                    if (!successfulEstimation) {
                        const errorCalls = estimatedCalls.filter((call) => 'error' in call);
                        if (errorCalls.length > 0)
                            throw errorCalls[errorCalls.length - 1].error;
                        throw new Error('Unexpected error. Please contact support: none of the calls threw an error');
                    }
                    const { call: { contract, parameters: { methodName, args, value }, }, gasEstimate, } = successfulEstimation;
                    return contract[methodName](...args, Object.assign({ gasLimit: calculateGasMargin(gasEstimate) }, (value && !isZero(value) ? { value, from: account } : { from: account })))
                        .then((response) => {
                            const inputSymbol = trade.inputAmount.currency.symbol;
                            const outputSymbol = trade.outputAmount.currency.symbol;
                            const inputAmount = trade.inputAmount.toSignificant(3);
                            const outputAmount = trade.outputAmount.toSignificant(3);
                            const base = `Swap ${inputAmount} ${inputSymbol} for ${outputAmount} ${outputSymbol}`;
                            const withRecipient = recipient === account
                                ? base
                                : `${base} to ${recipientAddressOrName && isAddress(recipientAddressOrName)
                                    ? shortenAddress(recipientAddressOrName, chainId)
                                    : recipientAddressOrName}`;
                            const withVersion = tradeVersion === Version.v2
                                ? withRecipient
                                : `${withRecipient} on ${tradeVersion.toUpperCase()}`;
                            addTransaction(response, {
                                summary: withVersion,
                            });
                            return response.hash;
                        })
                        .catch((error) => {
                            // if the user rejected the tx, pass this along
                            if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {
                                throw new Error('Transaction rejected.');
                            }
                            else {
                                // otherwise, the error was unexpected and we need to convey that
                                console.error(`Swap failed`, error, methodName, args, value);
                                throw new Error(`Swap failed: ${error.message}`);
                            }
                        });
                });
            },
            error: null,
        };
    }, [trade, library, account, chainId, recipient, recipientAddressOrName, swapCalls, addTransaction]);
}
function useNearSwapCallback(trade, // trade to execute, required
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _allowedSlippage = INITIAL_ALLOWED_SLIPPAGE, // in bips
    recipientAddressOrName) {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const addTransaction = useTransactionAdder();
    const poolId = useGetNearPoolId((_a = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _a === void 0 ? void 0 : _a.currency, (_b = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _b === void 0 ? void 0 : _b.currency);
    return useMemo(() => {
        if (!trade || !library || !account || !chainId) {
            return { state: SwapCallbackState.INVALID, callback: null, error: 'Missing dependencies' };
        }
        return {
            state: SwapCallbackState.VALID,
            callback: function onSwap() {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    const transactions = [];
                    const tokenInActions = [];
                    const inputToken = (_a = trade.inputAmount) === null || _a === void 0 ? void 0 : _a.currency;
                    const outPutToken = (_b = trade.outputAmount) === null || _b === void 0 ? void 0 : _b.currency;
                    const inputCurrencyId = inputToken instanceof Token$1 ? inputToken === null || inputToken === void 0 ? void 0 : inputToken.address : undefined;
                    const outputCurrencyId = outPutToken instanceof Token$1 ? outPutToken === null || outPutToken === void 0 ? void 0 : outPutToken.address : undefined;
                    const inputAmount = trade.inputAmount.toExact();
                    if (!inputCurrencyId || !outputCurrencyId) {
                        throw new Error(`Missing Currency`);
                    }
                    const tokenRegistered = yield nearFn.getStorageBalance(outputCurrencyId).catch(() => {
                        throw new Error(`${outPutToken === null || outPutToken === void 0 ? void 0 : outPutToken.symbol} doesn't exist.`);
                    });
                    if (tokenRegistered === null) {
                        transactions.push({
                            receiverId: outputCurrencyId,
                            functionCalls: [
                                nearFn.storageDepositAction({
                                    accountId: account,
                                    registrationOnly: true,
                                    amount: '0.00125',
                                }),
                            ],
                        });
                    }
                    const swapActions = {
                        pool_id: poolId,
                        token_in: inputCurrencyId,
                        token_out: outputCurrencyId,
                        amount_in: parseUnits$1(inputAmount, inputToken === null || inputToken === void 0 ? void 0 : inputToken.decimals).toString(),
                        min_amount_out: '0',
                    };
                    tokenInActions.push({
                        methodName: 'ft_transfer_call',
                        args: {
                            receiver_id: NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId],
                            amount: parseUnits$1(inputAmount, inputToken === null || inputToken === void 0 ? void 0 : inputToken.decimals).toString(),
                            msg: JSON.stringify({
                                force: 0,
                                actions: [swapActions],
                            }),
                        },
                        amount: ONE_YOCTO_NEAR,
                    });
                    transactions.push({
                        receiverId: inputCurrencyId,
                        functionCalls: tokenInActions,
                    });
                    return nearFn.executeMultipleTransactions(transactions);
                });
            },
            error: null,
        };
    }, [trade, poolId, library, account, chainId, recipientAddressOrName, addTransaction]);
}

/**
 * Returns the tokens price in relation to gas coin (avax, wagmi, flare, etc)
 *
 * @param tokens array of tokens to get the price in wrapped gas coin
 * @returns object where the key is the address of the token and the value is the Price
 */
function useTokensCurrencyPrice(tokens) {
    const chainId = useChainId();
    const currency = WAVAX[chainId];
    // remove currency if exist e remove undefined
    const filteredTokens = tokens.filter((token) => !!token && !token.equals(currency));
    const _pairs = filteredTokens.map((token) => [token, currency]);
    const pairs = usePairs(_pairs);
    const prices = {};
    // if exist currency, add to object with price 1
    const existCurrency = Boolean(tokens.find((token) => !!token && token.equals(currency)));
    if (existCurrency) {
        prices[currency.address] = new Price(currency, currency, '1', '1');
    }
    return useMemo(() => {
        pairs.forEach(([pairState, pair], index) => {
            const token = filteredTokens[index];
            // if not exist pair, return 0 for price of this token
            if (pairState !== PairState.EXISTS || !pair) {
                prices[token.address] = new Price(token, currency, '1', '0'); // 0
            }
            else {
                const tokenCurrencyPrice = pair.priceOf(token, currency);
                prices[token.address] = tokenCurrencyPrice;
            }
        });
        return prices;
    }, [pairs, prices, filteredTokens]);
}
/**
 * Returns the token price in relation to gas coin (avax, wagmi, flare, etc)
 *
 * @param token token to get the price
 * @returns the price of token in relation to gas coin
 */
function useTokenCurrencyPrice(token) {
    const chainId = useChainId();
    const currency = WAVAX[chainId];
    const [pairState, pair] = usePair(token, currency);
    return useMemo(() => {
        if (!token)
            return new Price(currency, currency, '1', '0');
        if (token.equals(currency)) {
            return new Price(currency, currency, '1', '1');
        }
        if (pairState !== PairState.EXISTS || !pair) {
            return new Price(token, currency, '1', '0'); // 0
        }
        else {
            return pair.priceOf(token, currency);
        }
    }, [pairState, pair, token]);
}
/**
 * Returns the price of pairs in relation to gas coin
 *
 * @param pairs array of pair and total supply of pair
 * @returns object where the key is the address of the pair and the value is the Price
 */
function usePairsCurrencyPrice(pairs) {
    const chainId = useChainId();
    const currency = WAVAX[chainId];
    // Have the same size
    const tokens0 = pairs.map(({ pair }) => pair.token0);
    const tokens1 = pairs.map(({ pair }) => pair.token1);
    const uniqueTokens = [];
    const map = new Map();
    for (let index = 0; index < tokens0.length; index++) {
        const token0 = tokens0[index];
        const token1 = tokens1[index];
        if (!map.has(token0.address)) {
            map.set(token0.address, true);
            uniqueTokens.push(token0);
        }
        if (!map.has(token1.address)) {
            map.set(token1.address, true);
            uniqueTokens.push(token1);
        }
    }
    const tokensPrices = useTokensCurrencyPrice(uniqueTokens);
    return useMemo(() => {
        const pairsPrices = {};
        pairs.forEach(({ pair, totalSupply }) => {
            var _a, _b;
            const token0 = pair.token0;
            const token1 = pair.token1;
            const token0Price = (_a = tokensPrices[token0.address]) !== null && _a !== void 0 ? _a : new Price(token0, currency, '1', '0');
            const token1Price = (_b = tokensPrices[token1.address]) !== null && _b !== void 0 ? _b : new Price(token1, currency, '1', '0');
            let token0Amount = new TokenAmount(token0, '0');
            let token1Amount = new TokenAmount(token1, '0');
            if (JSBI$1.greaterThan(totalSupply.raw, ONE_TOKEN) || JSBI$1.equal(totalSupply.raw, ONE_TOKEN)) {
                [token0Amount, token1Amount] = pair.getLiquidityValues(totalSupply, new TokenAmount(pair.liquidityToken, ONE_TOKEN));
            }
            const token0PairPrice = token0Amount.multiply(token0Price);
            const token1PairPrice = token1Amount.multiply(token1Price);
            const _pairPrice = token0PairPrice.add(token1PairPrice);
            const pairPrice = new Price(pair.liquidityToken, currency, _pairPrice.denominator, _pairPrice.numerator);
            pairsPrices[pair.liquidityToken.address] = pairPrice;
        });
        return pairsPrices;
    }, [pairs, tokensPrices]);
}

/**
 * Returns the price in USDC of the input currency
 * @param currency currency to compute the USDC price of
 */
function useUSDCPrice(currency) {
    const chainId = useChainId();
    const wrapped = wrappedCurrency(currency, chainId);
    const USDC = USDCe[chainId];
    const tokenPairs = useMemo(() => [
        [
            chainId && wrapped && currencyEquals(WAVAX[chainId], wrapped) ? undefined : currency,
            chainId ? WAVAX[chainId] : undefined,
        ],
        [(wrapped === null || wrapped === void 0 ? void 0 : wrapped.equals(USDC)) ? undefined : wrapped, chainId === ChainId.AVALANCHE ? USDC : undefined],
        [chainId ? WAVAX[chainId] : undefined, chainId === ChainId.AVALANCHE ? USDC : undefined],
    ], [chainId, currency, wrapped, USDC]);
    const [[avaxPairState, avaxPair], [usdcPairState, usdcPair], [usdcAvaxPairState, usdcAvaxPair]] = usePairs(tokenPairs);
    return useMemo(() => {
        if (!currency || !wrapped || !chainId) {
            return undefined;
        }
        // handle wavax/avax
        if (wrapped.equals(WAVAX[chainId])) {
            if (usdcPair) {
                const price = usdcPair.priceOf(WAVAX[chainId], USDC);
                return new Price(currency, USDC, price.denominator, price.numerator);
            }
            else {
                return undefined;
            }
        }
        // handle usdc
        if (wrapped.equals(USDC)) {
            return new Price(USDC, USDC, '1', '1');
        }
        const avaxPairAVAXAmount = avaxPair === null || avaxPair === void 0 ? void 0 : avaxPair.reserveOfToken(WAVAX[chainId]);
        const avaxPairAVAXUSDCValue = avaxPairAVAXAmount && usdcAvaxPair
            ? usdcAvaxPair.priceOf(WAVAX[chainId], USDC).quote(avaxPairAVAXAmount, chainId).raw
            : JSBI$1.BigInt(0);
        // all other tokens
        // first try the usdc pair
        if (usdcPairState === PairState.EXISTS &&
            usdcPair &&
            usdcPair.reserveOfToken(USDC).greaterThan(avaxPairAVAXUSDCValue)) {
            const price = usdcPair.priceOf(wrapped, USDC);
            return new Price(currency, USDC, price.denominator, price.numerator);
        }
        if (avaxPairState === PairState.EXISTS && avaxPair && usdcAvaxPairState === PairState.EXISTS && usdcAvaxPair) {
            if (usdcAvaxPair.reserveOfToken(USDC).greaterThan('0') &&
                avaxPair.reserveOfToken(WAVAX[chainId]).greaterThan('0')) {
                const avaxUsdcPrice = usdcAvaxPair.priceOf(USDC, WAVAX[chainId]);
                const currencyAvaxPrice = avaxPair.priceOf(WAVAX[chainId], wrapped);
                const usdcPrice = avaxUsdcPrice.multiply(currencyAvaxPrice).invert();
                return new Price(currency, USDC, usdcPrice.denominator, usdcPrice.numerator);
            }
        }
        return undefined;
    }, [
        chainId,
        currency,
        avaxPair,
        avaxPairState,
        usdcAvaxPair,
        usdcAvaxPairState,
        usdcPair,
        usdcPairState,
        wrapped,
        USDC,
    ]);
}
function useNearUSDCPrice(currency) {
    const [result, setResult] = useState('');
    const chainId = useChainId();
    const token = wrappedCurrency(currency, chainId);
    useEffect(() => {
        const fetchPrice = () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const url = `${NEAR_API_BASE_URL}/list-token-price`;
                const response = yield fetch(url);
                const data = yield response.json();
                if (token) {
                    setResult((_a = data === null || data === void 0 ? void 0 : data[token === null || token === void 0 ? void 0 : token.address]) === null || _a === void 0 ? void 0 : _a.price);
                }
            }
            catch (error) {
                console.error('near token api error', error);
            }
        });
        fetchPrice();
    }, [token]);
    const USDC = USDCe[chainId];
    return useMemo(() => {
        if (!currency || !token || !chainId || !result) {
            return undefined;
        }
        const tokenAmount1 = new TokenAmount(token, parseUnits$1(result || '1', token === null || token === void 0 ? void 0 : token.decimals).toString());
        const tokenAmount2 = new TokenAmount(USDC, parseUnits$1('1', USDC === null || USDC === void 0 ? void 0 : USDC.decimals).toString());
        return new Price(USDC, currency, tokenAmount2.raw, tokenAmount1.raw);
    }, [chainId, currency, token, USDC, result]);
}
function useSongBirdUSDPrice(currency) {
    const chainId = ChainId.SONGBIRD;
    const wrapped = wrappedCurrency(currency, chainId);
    const tokenPrice = useTokenCurrencyPrice(wrapped); // token price in sgb
    const usd = USDC[chainId];
    const { data: currencyPrice, isLoading } = useCoinGeckoCurrencyPrice(chainId); // sbg price in usd
    return useMemo(() => {
        if (!wrapped || !currencyPrice || !tokenPrice || isLoading || !currency)
            return undefined;
        const tokenUSDPrice = tokenPrice.raw.multiply(decimalToFraction(currencyPrice));
        return new Price(currency, usd, tokenUSDPrice.denominator, tokenUSDPrice.numerator);
    }, [wrapped, currencyPrice, tokenPrice]);
}

var WrapType;
(function (WrapType) {
    WrapType[WrapType["NOT_APPLICABLE"] = 0] = "NOT_APPLICABLE";
    WrapType[WrapType["WRAP"] = 1] = "WRAP";
    WrapType[WrapType["UNWRAP"] = 2] = "UNWRAP";
})(WrapType || (WrapType = {}));
const NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE };
/**
 * Given the selected input and output currency, return a wrap callback
 * @param inputCurrency the selected input currency
 * @param outputCurrency the selected output currency
 * @param typedValue the user input value
 */
function useWrapCallback(inputCurrency, outputCurrency, typedValue) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const wethContract = useWETHContract();
    const balance = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, inputCurrency);
    // we can always parse the amount typed as the input currency, since wrapping is 1:1
    const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue]);
    const addTransaction = useTransactionAdder();
    return useMemo(() => {
        if (!wethContract || !chainId || !inputCurrency || !outputCurrency)
            return NOT_APPLICABLE;
        const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);
        if (inputCurrency === CAVAX[chainId] && currencyEquals(WAVAX[chainId], outputCurrency)) {
            return {
                wrapType: WrapType.WRAP,
                execute: sufficientBalance && inputAmount
                    ? () => __awaiter(this, void 0, void 0, function* () {
                        try {
                            const txReceipt = yield wethContract.deposit({ value: `0x${inputAmount.raw.toString(16)}` });
                            addTransaction(txReceipt, { summary: `Wrap ${inputAmount.toSignificant(6)} AVAX to WAVAX` });
                        }
                        catch (error) {
                            console.error('Could not deposit', error);
                        }
                    })
                    : undefined,
                inputError: sufficientBalance ? undefined : 'Insufficient AVAX balance',
            };
        }
        else if (currencyEquals(WAVAX[chainId], inputCurrency) && outputCurrency === CAVAX[chainId]) {
            return {
                wrapType: WrapType.UNWRAP,
                execute: sufficientBalance && inputAmount
                    ? () => __awaiter(this, void 0, void 0, function* () {
                        try {
                            const txReceipt = yield wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`);
                            addTransaction(txReceipt, { summary: `Unwrap ${inputAmount.toSignificant(6)} WAVAX to AVAX` });
                        }
                        catch (error) {
                            console.error('Could not withdraw', error);
                        }
                    })
                    : undefined,
                inputError: sufficientBalance ? undefined : 'Insufficient WAVAX balance',
            };
        }
        else {
            return NOT_APPLICABLE;
        }
    }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);
}
/**
 * Given the selected input and output currency, return a wrap callback
 * @param inputCurrency the selected input currency
 * @param outputCurrency the selected output currency
 * @param typedValue the user input value
 */
function useWrapNearCallback(inputCurrency, outputCurrency, typedValue) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const balance = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, inputCurrency);
    // we can always parse the amount typed as the input currency, since wrapping is 1:1
    const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency, chainId), [inputCurrency, typedValue, chainId]);
    const addTransaction = useTransactionAdder();
    return useMemo(() => {
        if (!chainId || !inputCurrency || !outputCurrency)
            return NOT_APPLICABLE;
        const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);
        const unWrapFunction = () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (sufficientBalance && inputAmount) {
                try {
                    //addTransaction({} as any, { summary: `Unwrap ${inputAmount.toSignificant(6)} WNear to Near` });
                    const transactions = [
                        {
                            receiverId: WAVAX[chainId].address,
                            functionCalls: [
                                nearFn.nearDepositAction(parseUnits(inputAmount.toFixed(), (_a = WAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.decimals).toString()),
                            ],
                        },
                    ];
                    nearFn.executeMultipleTransactions(transactions);
                }
                catch (error) {
                    console.error('Could not withdraw', error);
                }
            }
        });
        const wrapFunction = () => __awaiter(this, void 0, void 0, function* () {
            if (sufficientBalance && inputAmount) {
                try {
                    //addTransaction({} as any, { summary: `Wrap ${inputAmount.toSignificant(6)} NEAR to wNear` });
                    const transaction = [
                        {
                            receiverId: WAVAX[chainId].address,
                            functionCalls: [nearFn.nearWithdrawAction(inputAmount.toSignificant(6))],
                        },
                    ];
                    nearFn.executeMultipleTransactions(transaction);
                }
                catch (error) {
                    console.error('Could not withdraw', error);
                }
            }
        });
        if (inputCurrency === CAVAX[chainId] && currencyEquals(WAVAX[chainId], outputCurrency)) {
            return {
                wrapType: WrapType.WRAP,
                execute: wrapFunction,
                inputError: sufficientBalance ? undefined : 'Insufficient NEAR balance',
            };
        }
        else if (currencyEquals(WAVAX[chainId], inputCurrency) && outputCurrency === CAVAX[chainId]) {
            return {
                wrapType: WrapType.UNWRAP,
                execute: unWrapFunction,
                inputError: sufficientBalance ? undefined : 'Insufficient wNear balance',
            };
        }
        else {
            return NOT_APPLICABLE;
        }
    }, [chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);
}

const useWrapCallbackHook = {
    [ChainId.FUJI]: useWrapCallback,
    [ChainId.AVALANCHE]: useWrapCallback,
    [ChainId.WAGMI]: useWrapCallback,
    [ChainId.COSTON]: useWrapCallback,
    [ChainId.SONGBIRD]: useWrapCallback,
    [ChainId.NEAR_MAINNET]: useWrapNearCallback,
    [ChainId.NEAR_TESTNET]: useWrapNearCallback,
};
const useTokenHook = {
    [ChainId.FUJI]: useToken,
    [ChainId.AVALANCHE]: useToken,
    [ChainId.WAGMI]: useToken,
    [ChainId.COSTON]: useToken,
    [ChainId.SONGBIRD]: useToken,
    [ChainId.NEAR_MAINNET]: useNearToken,
    [ChainId.NEAR_TESTNET]: useNearToken,
};
const useApproveCallbackFromTradeHook = {
    [ChainId.FUJI]: useApproveCallbackFromTrade,
    [ChainId.AVALANCHE]: useApproveCallbackFromTrade,
    [ChainId.WAGMI]: useApproveCallbackFromTrade,
    [ChainId.COSTON]: useApproveCallbackFromTrade,
    [ChainId.SONGBIRD]: useApproveCallbackFromTrade,
    [ChainId.NEAR_MAINNET]: useApproveCallbackFromNearTrade,
    [ChainId.NEAR_TESTNET]: useApproveCallbackFromNearTrade,
};
const useSwapCallbackHook = {
    [ChainId.FUJI]: useSwapCallback,
    [ChainId.AVALANCHE]: useSwapCallback,
    [ChainId.WAGMI]: useSwapCallback,
    [ChainId.COSTON]: useSwapCallback,
    [ChainId.SONGBIRD]: useSwapCallback,
    [ChainId.NEAR_MAINNET]: useNearSwapCallback,
    [ChainId.NEAR_TESTNET]: useNearSwapCallback,
};
const useApproveCallbackHook = {
    [ChainId.FUJI]: useApproveCallback,
    [ChainId.AVALANCHE]: useApproveCallback,
    [ChainId.WAGMI]: useApproveCallback,
    [ChainId.COSTON]: useApproveCallback,
    [ChainId.SONGBIRD]: useApproveCallback,
    [ChainId.NEAR_MAINNET]: useNearApproveCallback,
    [ChainId.NEAR_TESTNET]: useNearApproveCallback,
};
const useUSDCPriceHook = {
    [ChainId.FUJI]: useUSDCPrice,
    [ChainId.AVALANCHE]: useUSDCPrice,
    [ChainId.WAGMI]: useUSDCPrice,
    [ChainId.COSTON]: useUSDCPrice,
    [ChainId.SONGBIRD]: useSongBirdUSDPrice,
    [ChainId.NEAR_MAINNET]: useNearUSDCPrice,
    [ChainId.NEAR_TESTNET]: useNearUSDCPrice,
};
({
    [ChainId.FUJI]: useTokens,
    [ChainId.AVALANCHE]: useTokens,
    [ChainId.WAGMI]: useTokens,
    [ChainId.COSTON]: useTokens,
    [ChainId.SONGBIRD]: useTokens,
    [ChainId.NEAR_MAINNET]: useNearTokens,
    [ChainId.NEAR_TESTNET]: useNearTokens,
});

/**
 * Given some token amount, return the max that can be spent of it
 * @param currencyAmount to return max of
 */
function maxAmountSpend(chainId, currencyAmount) {
    if (!currencyAmount)
        return undefined;
    if (chainId && currencyAmount.currency === CAVAX[chainId]) {
        if (JSBI$1.greaterThan(currencyAmount.raw, MIN_ETH)) {
            return CurrencyAmount.ether(JSBI$1.subtract(currencyAmount.raw, MIN_ETH), chainId);
        }
        else {
            return CurrencyAmount.ether(JSBI$1.BigInt(0), chainId);
        }
    }
    return currencyAmount;
}
function galetoMaxAmountSpend(chainId, currencyAmount) {
    if (!currencyAmount)
        return undefined;
    if (chainId && currencyAmount.currency === CAVAX[chainId]) {
        if (JSBI$1.greaterThan(currencyAmount.numerator, MIN_ETH)) {
            return CurrencyAmount.ether(JSBI$1.subtract(currencyAmount.numerator, MIN_ETH), chainId);
        }
        else {
            return CurrencyAmount.ether(JSBI$1.BigInt(0), chainId);
        }
    }
    return currencyAmount;
}

class JSBI extends Array { constructor(i, _) { if (super(i), this.sign = _, i > JSBI.__kMaxLength) throw new RangeError("Maximum BigInt size exceeded") } static BigInt(i) { var _ = Math.floor, t = Number.isFinite; if ("number" == typeof i) { if (0 === i) return JSBI.__zero(); if (JSBI.__isOneDigitInt(i)) return 0 > i ? JSBI.__oneDigit(-i, !0) : JSBI.__oneDigit(i, !1); if (!t(i) || _(i) !== i) throw new RangeError("The number " + i + " cannot be converted to BigInt because it is not an integer"); return JSBI.__fromDouble(i) } if ("string" == typeof i) { const _ = JSBI.__fromString(i); if (null === _) throw new SyntaxError("Cannot convert " + i + " to a BigInt"); return _ } if ("boolean" == typeof i) return !0 === i ? JSBI.__oneDigit(1, !1) : JSBI.__zero(); if ("object" == typeof i) { if (i.constructor === JSBI) return i; const _ = JSBI.__toPrimitive(i); return JSBI.BigInt(_) } throw new TypeError("Cannot convert " + i + " to a BigInt") } toDebugString() { const i = ["BigInt["]; for (const _ of this) i.push((_ ? (_ >>> 0).toString(16) : _) + ", "); return i.push("]"), i.join("") } toString(i = 10) { if (2 > i || 36 < i) throw new RangeError("toString() radix argument must be between 2 and 36"); return 0 === this.length ? "0" : 0 == (i & i - 1) ? JSBI.__toStringBasePowerOfTwo(this, i) : JSBI.__toStringGeneric(this, i, !1) } static toNumber(i) { const _ = i.length; if (0 === _) return 0; if (1 === _) { const _ = i.__unsignedDigit(0); return i.sign ? -_ : _ } const t = i.__digit(_ - 1), e = JSBI.__clz30(t), n = 30 * _ - e; if (1024 < n) return i.sign ? -Infinity : 1 / 0; let g = n - 1, o = t, s = _ - 1; const l = e + 3; let r = 32 === l ? 0 : o << l; r >>>= 12; const a = l - 12; let u = 12 <= l ? 0 : o << 20 + l, d = 20 + l; for (0 < a && 0 < s && (s--, o = i.__digit(s), r |= o >>> 30 - a, u = o << a + 2, d = a + 2); 0 < d && 0 < s;)s--, o = i.__digit(s), u |= 30 <= d ? o << d - 30 : o >>> 30 - d, d -= 30; const h = JSBI.__decideRounding(i, d, s, o); if ((1 === h || 0 === h && 1 == (1 & u)) && (u = u + 1 >>> 0, 0 === u && (r++, 0 != r >>> 20 && (r = 0, g++, 1023 < g)))) return i.sign ? -Infinity : 1 / 0; const m = i.sign ? -2147483648 : 0; return g = g + 1023 << 20, JSBI.__kBitConversionInts[1] = m | g | r, JSBI.__kBitConversionInts[0] = u, JSBI.__kBitConversionDouble[0] } static unaryMinus(i) { if (0 === i.length) return i; const _ = i.__copy(); return _.sign = !i.sign, _ } static bitwiseNot(i) { return i.sign ? JSBI.__absoluteSubOne(i).__trim() : JSBI.__absoluteAddOne(i, !0) } static exponentiate(i, _) { if (_.sign) throw new RangeError("Exponent must be positive"); if (0 === _.length) return JSBI.__oneDigit(1, !1); if (0 === i.length) return i; if (1 === i.length && 1 === i.__digit(0)) return i.sign && 0 == (1 & _.__digit(0)) ? JSBI.unaryMinus(i) : i; if (1 < _.length) throw new RangeError("BigInt too big"); let t = _.__unsignedDigit(0); if (1 === t) return i; if (t >= JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big"); if (1 === i.length && 2 === i.__digit(0)) { const _ = 1 + (0 | t / 30), e = i.sign && 0 != (1 & t), n = new JSBI(_, e); n.__initializeDigits(); const g = 1 << t % 30; return n.__setDigit(_ - 1, g), n } let e = null, n = i; for (0 != (1 & t) && (e = i), t >>= 1; 0 !== t; t >>= 1)n = JSBI.multiply(n, n), 0 != (1 & t) && (null === e ? e = n : e = JSBI.multiply(e, n)); return e } static multiply(_, t) { if (0 === _.length) return _; if (0 === t.length) return t; let i = _.length + t.length; 30 <= _.__clzmsd() + t.__clzmsd() && i--; const e = new JSBI(i, _.sign !== t.sign); e.__initializeDigits(); for (let n = 0; n < _.length; n++)JSBI.__multiplyAccumulate(t, _.__digit(n), e, n); return e.__trim() } static divide(i, _) { if (0 === _.length) throw new RangeError("Division by zero"); if (0 > JSBI.__absoluteCompare(i, _)) return JSBI.__zero(); const t = i.sign !== _.sign, e = _.__unsignedDigit(0); let n; if (1 === _.length && 32767 >= e) { if (1 === e) return t === i.sign ? i : JSBI.unaryMinus(i); n = JSBI.__absoluteDivSmall(i, e, null); } else n = JSBI.__absoluteDivLarge(i, _, !0, !1); return n.sign = t, n.__trim() } static remainder(i, _) { if (0 === _.length) throw new RangeError("Division by zero"); if (0 > JSBI.__absoluteCompare(i, _)) return i; const t = _.__unsignedDigit(0); if (1 === _.length && 32767 >= t) { if (1 === t) return JSBI.__zero(); const _ = JSBI.__absoluteModSmall(i, t); return 0 === _ ? JSBI.__zero() : JSBI.__oneDigit(_, i.sign) } const e = JSBI.__absoluteDivLarge(i, _, !1, !0); return e.sign = i.sign, e.__trim() } static add(i, _) { const t = i.sign; return t === _.sign ? JSBI.__absoluteAdd(i, _, t) : 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t) : JSBI.__absoluteSub(_, i, !t) } static subtract(i, _) { const t = i.sign; return t === _.sign ? 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t) : JSBI.__absoluteSub(_, i, !t) : JSBI.__absoluteAdd(i, _, t) } static leftShift(i, _) { return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__rightShiftByAbsolute(i, _) : JSBI.__leftShiftByAbsolute(i, _) } static signedRightShift(i, _) { return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__leftShiftByAbsolute(i, _) : JSBI.__rightShiftByAbsolute(i, _) } static unsignedRightShift() { throw new TypeError("BigInts have no unsigned right shift; use >> instead") } static lessThan(i, _) { return 0 > JSBI.__compareToBigInt(i, _) } static lessThanOrEqual(i, _) { return 0 >= JSBI.__compareToBigInt(i, _) } static greaterThan(i, _) { return 0 < JSBI.__compareToBigInt(i, _) } static greaterThanOrEqual(i, _) { return 0 <= JSBI.__compareToBigInt(i, _) } static equal(_, t) { if (_.sign !== t.sign) return !1; if (_.length !== t.length) return !1; for (let e = 0; e < _.length; e++)if (_.__digit(e) !== t.__digit(e)) return !1; return !0 } static notEqual(i, _) { return !JSBI.equal(i, _) } static bitwiseAnd(i, _) { var t = Math.max; if (!i.sign && !_.sign) return JSBI.__absoluteAnd(i, _).__trim(); if (i.sign && _.sign) { const e = t(i.length, _.length) + 1; let n = JSBI.__absoluteSubOne(i, e); const g = JSBI.__absoluteSubOne(_); return n = JSBI.__absoluteOr(n, g, n), JSBI.__absoluteAddOne(n, !0, n).__trim() } return i.sign && ([i, _] = [_, i]), JSBI.__absoluteAndNot(i, JSBI.__absoluteSubOne(_)).__trim() } static bitwiseXor(i, _) { var t = Math.max; if (!i.sign && !_.sign) return JSBI.__absoluteXor(i, _).__trim(); if (i.sign && _.sign) { const e = t(i.length, _.length), n = JSBI.__absoluteSubOne(i, e), g = JSBI.__absoluteSubOne(_); return JSBI.__absoluteXor(n, g, n).__trim() } const e = t(i.length, _.length) + 1; i.sign && ([i, _] = [_, i]); let n = JSBI.__absoluteSubOne(_, e); return n = JSBI.__absoluteXor(n, i, n), JSBI.__absoluteAddOne(n, !0, n).__trim() } static bitwiseOr(i, _) { var t = Math.max; const e = t(i.length, _.length); if (!i.sign && !_.sign) return JSBI.__absoluteOr(i, _).__trim(); if (i.sign && _.sign) { let t = JSBI.__absoluteSubOne(i, e); const n = JSBI.__absoluteSubOne(_); return t = JSBI.__absoluteAnd(t, n, t), JSBI.__absoluteAddOne(t, !0, t).__trim() } i.sign && ([i, _] = [_, i]); let n = JSBI.__absoluteSubOne(_, e); return n = JSBI.__absoluteAndNot(n, i, n), JSBI.__absoluteAddOne(n, !0, n).__trim() } static asIntN(_, t) { var i = Math.floor; if (0 === t.length) return t; if (_ = i(_), 0 > _) throw new RangeError("Invalid value: not (convertible to) a safe integer"); if (0 === _) return JSBI.__zero(); if (_ >= JSBI.__kMaxLengthBits) return t; const e = 0 | (_ + 29) / 30; if (t.length < e) return t; const g = t.__unsignedDigit(e - 1), o = 1 << (_ - 1) % 30; if (t.length === e && g < o) return t; if (!((g & o) === o)) return JSBI.__truncateToNBits(_, t); if (!t.sign) return JSBI.__truncateAndSubFromPowerOfTwo(_, t, !0); if (0 == (g & o - 1)) { for (let n = e - 2; 0 <= n; n--)if (0 !== t.__digit(n)) return JSBI.__truncateAndSubFromPowerOfTwo(_, t, !1); return t.length === e && g === o ? t : JSBI.__truncateToNBits(_, t) } return JSBI.__truncateAndSubFromPowerOfTwo(_, t, !1) } static asUintN(i, _) { var t = Math.floor; if (0 === _.length) return _; if (i = t(i), 0 > i) throw new RangeError("Invalid value: not (convertible to) a safe integer"); if (0 === i) return JSBI.__zero(); if (_.sign) { if (i > JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big"); return JSBI.__truncateAndSubFromPowerOfTwo(i, _, !1) } if (i >= JSBI.__kMaxLengthBits) return _; const e = 0 | (i + 29) / 30; if (_.length < e) return _; const g = i % 30; if (_.length == e) { if (0 === g) return _; const i = _.__digit(e - 1); if (0 == i >>> g) return _ } return JSBI.__truncateToNBits(i, _) } static ADD(i, _) { if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i) return "string" != typeof _ && (_ = _.toString()), i + _; if ("string" == typeof _) return i.toString() + _; if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i) && JSBI.__isBigInt(_)) return JSBI.add(i, _); if ("number" == typeof i && "number" == typeof _) return i + _; throw new TypeError("Cannot mix BigInt and other types, use explicit conversions") } static LT(i, _) { return JSBI.__compare(i, _, 0) } static LE(i, _) { return JSBI.__compare(i, _, 1) } static GT(i, _) { return JSBI.__compare(i, _, 2) } static GE(i, _) { return JSBI.__compare(i, _, 3) } static EQ(i, _) { for (; ;) { if (JSBI.__isBigInt(i)) return JSBI.__isBigInt(_) ? JSBI.equal(i, _) : JSBI.EQ(_, i); if ("number" == typeof i) { if (JSBI.__isBigInt(_)) return JSBI.__equalToNumber(_, i); if ("object" != typeof _) return i == _; _ = JSBI.__toPrimitive(_); } else if ("string" == typeof i) { if (JSBI.__isBigInt(_)) return i = JSBI.__fromString(i), null !== i && JSBI.equal(i, _); if ("object" != typeof _) return i == _; _ = JSBI.__toPrimitive(_); } else if ("boolean" == typeof i) { if (JSBI.__isBigInt(_)) return JSBI.__equalToNumber(_, +i); if ("object" != typeof _) return i == _; _ = JSBI.__toPrimitive(_); } else if ("symbol" == typeof i) { if (JSBI.__isBigInt(_)) return !1; if ("object" != typeof _) return i == _; _ = JSBI.__toPrimitive(_); } else if ("object" == typeof i) { if ("object" == typeof _ && _.constructor !== JSBI) return i == _; i = JSBI.__toPrimitive(i); } else return i == _ } } static NE(i, _) { return !JSBI.EQ(i, _) } static __zero() { return new JSBI(0, !1) } static __oneDigit(i, _) { const t = new JSBI(1, _); return t.__setDigit(0, i), t } __copy() { const _ = new JSBI(this.length, this.sign); for (let t = 0; t < this.length; t++)_[t] = this[t]; return _ } __trim() { let i = this.length, _ = this[i - 1]; for (; 0 === _;)i--, _ = this[i - 1], this.pop(); return 0 === i && (this.sign = !1), this } __initializeDigits() { for (let _ = 0; _ < this.length; _++)this[_] = 0; } static __decideRounding(i, _, t, e) { if (0 < _) return -1; let n; if (0 > _) n = -_ - 1; else { if (0 === t) return -1; t--, e = i.__digit(t), n = 29; } let g = 1 << n; if (0 == (e & g)) return -1; if (g -= 1, 0 != (e & g)) return 1; for (; 0 < t;)if (t--, 0 !== i.__digit(t)) return 1; return 0 } static __fromDouble(i) { JSBI.__kBitConversionDouble[0] = i; const _ = 2047 & JSBI.__kBitConversionInts[1] >>> 20, t = _ - 1023, e = (0 | t / 30) + 1, n = new JSBI(e, 0 > i); let g = 1048575 & JSBI.__kBitConversionInts[1] | 1048576, o = JSBI.__kBitConversionInts[0]; const s = 20, l = t % 30; let r, a = 0; if (l < 20) { const i = s - l; a = i + 32, r = g >>> i, g = g << 32 - i | o >>> i, o <<= 32 - i; } else if (l === 20) a = 32, r = g, g = o, o = 0; else { const i = l - s; a = 32 - i, r = g << i | o >>> 32 - i, g = o << i, o = 0; } n.__setDigit(e - 1, r); for (let _ = e - 2; 0 <= _; _--)0 < a ? (a -= 30, r = g >>> 2, g = g << 30 | o >>> 2, o <<= 30) : r = 0, n.__setDigit(_, r); return n.__trim() } static __isWhitespace(i) { return !!(13 >= i && 9 <= i) || (159 >= i ? 32 == i : 131071 >= i ? 160 == i || 5760 == i : 196607 >= i ? (i &= 131071, 10 >= i || 40 == i || 41 == i || 47 == i || 95 == i || 4096 == i) : 65279 == i) } static __fromString(i, _ = 0) { let t = 0; const e = i.length; let n = 0; if (n === e) return JSBI.__zero(); let g = i.charCodeAt(n); for (; JSBI.__isWhitespace(g);) { if (++n === e) return JSBI.__zero(); g = i.charCodeAt(n); } if (43 === g) { if (++n === e) return null; g = i.charCodeAt(n), t = 1; } else if (45 === g) { if (++n === e) return null; g = i.charCodeAt(n), t = -1; } if (0 === _) { if (_ = 10, 48 === g) { if (++n === e) return JSBI.__zero(); if (g = i.charCodeAt(n), 88 === g || 120 === g) { if (_ = 16, ++n === e) return null; g = i.charCodeAt(n); } else if (79 === g || 111 === g) { if (_ = 8, ++n === e) return null; g = i.charCodeAt(n); } else if (66 === g || 98 === g) { if (_ = 2, ++n === e) return null; g = i.charCodeAt(n); } } } else if (16 === _ && 48 === g) { if (++n === e) return JSBI.__zero(); if (g = i.charCodeAt(n), 88 === g || 120 === g) { if (++n === e) return null; g = i.charCodeAt(n); } } if (0 != t && 10 !== _) return null; for (; 48 === g;) { if (++n === e) return JSBI.__zero(); g = i.charCodeAt(n); } const o = e - n; let s = JSBI.__kMaxBitsPerChar[_], l = JSBI.__kBitsPerCharTableMultiplier - 1; if (o > 1073741824 / s) return null; const r = s * o + l >>> JSBI.__kBitsPerCharTableShift, a = new JSBI(0 | (r + 29) / 30, !1), u = 10 > _ ? _ : 10, h = 10 < _ ? _ - 10 : 0; if (0 == (_ & _ - 1)) { s >>= JSBI.__kBitsPerCharTableShift; const _ = [], t = []; let o = !1; do { let l = 0, r = 0; for (; ;) { let _; if (g - 48 >>> 0 < u) _ = g - 48; else if ((32 | g) - 97 >>> 0 < h) _ = (32 | g) - 87; else { o = !0; break } if (r += s, l = l << s | _, ++n === e) { o = !0; break } if (g = i.charCodeAt(n), 30 < r + s) break } _.push(l), t.push(r); } while (!o); JSBI.__fillFromParts(a, _, t); } else { a.__initializeDigits(); let t = !1, o = 0; do { let r = 0, b = 1; for (; ;) { let s; if (g - 48 >>> 0 < u) s = g - 48; else if ((32 | g) - 97 >>> 0 < h) s = (32 | g) - 87; else { t = !0; break } const l = b * _; if (1073741823 < l) break; if (b = l, r = r * _ + s, o++, ++n === e) { t = !0; break } g = i.charCodeAt(n); } l = 30 * JSBI.__kBitsPerCharTableMultiplier - 1; const D = 0 | (s * o + l >>> JSBI.__kBitsPerCharTableShift) / 30; a.__inplaceMultiplyAdd(b, r, D); } while (!t) } if (n !== e) { if (!JSBI.__isWhitespace(g)) return null; for (n++; n < e; n++)if (g = i.charCodeAt(n), !JSBI.__isWhitespace(g)) return null } return a.sign = -1 == t, a.__trim() } static __fillFromParts(_, t, e) { let n = 0, g = 0, o = 0; for (let s = t.length - 1; 0 <= s; s--) { const i = t[s], l = e[s]; g |= i << o, o += l, 30 === o ? (_.__setDigit(n++, g), o = 0, g = 0) : 30 < o && (_.__setDigit(n++, 1073741823 & g), o -= 30, g = i >>> l - o); } if (0 !== g) { if (n >= _.length) throw new Error("implementation bug"); _.__setDigit(n++, g); } for (; n < _.length; n++)_.__setDigit(n, 0); } static __toStringBasePowerOfTwo(_, i) { const t = _.length; let e = i - 1; e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e); const n = e, g = i - 1, o = _.__digit(t - 1), s = JSBI.__clz30(o); let l = 0 | (30 * t - s + n - 1) / n; if (_.sign && l++, 268435456 < l) throw new Error("string too long"); const r = Array(l); let a = l - 1, u = 0, d = 0; for (let e = 0; e < t - 1; e++) { const i = _.__digit(e), t = (u | i << d) & g; r[a--] = JSBI.__kConversionChars[t]; const o = n - d; for (u = i >>> o, d = 30 - o; d >= n;)r[a--] = JSBI.__kConversionChars[u & g], u >>>= n, d -= n; } const h = (u | o << d) & g; for (r[a--] = JSBI.__kConversionChars[h], u = o >>> n - d; 0 !== u;)r[a--] = JSBI.__kConversionChars[u & g], u >>>= n; if (_.sign && (r[a--] = "-"), -1 != a) throw new Error("implementation bug"); return r.join("") } static __toStringGeneric(_, i, t) { const e = _.length; if (0 === e) return ""; if (1 === e) { let e = _.__unsignedDigit(0).toString(i); return !1 === t && _.sign && (e = "-" + e), e } const n = 30 * e - JSBI.__clz30(_.__digit(e - 1)), g = JSBI.__kMaxBitsPerChar[i], o = g - 1; let s = n * JSBI.__kBitsPerCharTableMultiplier; s += o - 1, s = 0 | s / o; const l = s + 1 >> 1, r = JSBI.exponentiate(JSBI.__oneDigit(i, !1), JSBI.__oneDigit(l, !1)); let a, u; const d = r.__unsignedDigit(0); if (1 === r.length && 32767 >= d) { a = new JSBI(_.length, !1), a.__initializeDigits(); let t = 0; for (let e = 2 * _.length - 1; 0 <= e; e--) { const i = t << 15 | _.__halfDigit(e); a.__setHalfDigit(e, 0 | i / d), t = 0 | i % d; } u = t.toString(i); } else { const t = JSBI.__absoluteDivLarge(_, r, !0, !0); a = t.quotient; const e = t.remainder.__trim(); u = JSBI.__toStringGeneric(e, i, !0); } a.__trim(); let h = JSBI.__toStringGeneric(a, i, !0); for (; u.length < l;)u = "0" + u; return !1 === t && _.sign && (h = "-" + h), h + u } static __unequalSign(i) { return i ? -1 : 1 } static __absoluteGreater(i) { return i ? -1 : 1 } static __absoluteLess(i) { return i ? 1 : -1 } static __compareToBigInt(i, _) { const t = i.sign; if (t !== _.sign) return JSBI.__unequalSign(t); const e = JSBI.__absoluteCompare(i, _); return 0 < e ? JSBI.__absoluteGreater(t) : 0 > e ? JSBI.__absoluteLess(t) : 0 } static __compareToNumber(i, _) { if (JSBI.__isOneDigitInt(_)) { const t = i.sign, e = 0 > _; if (t !== e) return JSBI.__unequalSign(t); if (0 === i.length) { if (e) throw new Error("implementation bug"); return 0 === _ ? 0 : -1 } if (1 < i.length) return JSBI.__absoluteGreater(t); const n = Math.abs(_), g = i.__unsignedDigit(0); return g > n ? JSBI.__absoluteGreater(t) : g < n ? JSBI.__absoluteLess(t) : 0 } return JSBI.__compareToDouble(i, _) } static __compareToDouble(i, _) { if (_ !== _) return _; if (_ === 1 / 0) return -1; if (_ === -Infinity) return 1; const t = i.sign; if (t !== 0 > _) return JSBI.__unequalSign(t); if (0 === _) throw new Error("implementation bug: should be handled elsewhere"); if (0 === i.length) return -1; JSBI.__kBitConversionDouble[0] = _; const e = 2047 & JSBI.__kBitConversionInts[1] >>> 20; if (2047 == e) throw new Error("implementation bug: handled elsewhere"); const n = e - 1023; if (0 > n) return JSBI.__absoluteGreater(t); const g = i.length; let o = i.__digit(g - 1); const s = JSBI.__clz30(o), l = 30 * g - s, r = n + 1; if (l < r) return JSBI.__absoluteLess(t); if (l > r) return JSBI.__absoluteGreater(t); let a = 1048576 | 1048575 & JSBI.__kBitConversionInts[1], u = JSBI.__kBitConversionInts[0]; const d = 20, h = 29 - s; if (h !== (0 | (l - 1) % 30)) throw new Error("implementation bug"); let m, b = 0; if (20 > h) { const i = d - h; b = i + 32, m = a >>> i, a = a << 32 - i | u >>> i, u <<= 32 - i; } else if (20 === h) b = 32, m = a, a = u, u = 0; else { const i = h - d; b = 32 - i, m = a << i | u >>> 32 - i, a = u << i, u = 0; } if (o >>>= 0, m >>>= 0, o > m) return JSBI.__absoluteGreater(t); if (o < m) return JSBI.__absoluteLess(t); for (let e = g - 2; 0 <= e; e--) { 0 < b ? (b -= 30, m = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m = 0; const _ = i.__unsignedDigit(e); if (_ > m) return JSBI.__absoluteGreater(t); if (_ < m) return JSBI.__absoluteLess(t) } if (0 !== a || 0 !== u) { if (0 === b) throw new Error("implementation bug"); return JSBI.__absoluteLess(t) } return 0 } static __equalToNumber(i, _) { var t = Math.abs; return JSBI.__isOneDigitInt(_) ? 0 === _ ? 0 === i.length : 1 === i.length && i.sign === 0 > _ && i.__unsignedDigit(0) === t(_) : 0 === JSBI.__compareToDouble(i, _) } static __comparisonResultToBool(i, _) { return 0 === _ ? 0 > i : 1 === _ ? 0 >= i : 2 === _ ? 0 < i : 3 === _ ? 0 <= i : void 0 } static __compare(i, _, t) { if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i && "string" == typeof _) switch (t) { case 0: return i < _; case 1: return i <= _; case 2: return i > _; case 3: return i >= _; }if (JSBI.__isBigInt(i) && "string" == typeof _) return _ = JSBI.__fromString(_), null !== _ && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t); if ("string" == typeof i && JSBI.__isBigInt(_)) return i = JSBI.__fromString(i), null !== i && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t); if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i)) { if (JSBI.__isBigInt(_)) return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t); if ("number" != typeof _) throw new Error("implementation bug"); return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i, _), t) } if ("number" != typeof i) throw new Error("implementation bug"); if (JSBI.__isBigInt(_)) return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_, i), 2 ^ t); if ("number" != typeof _) throw new Error("implementation bug"); return 0 === t ? i < _ : 1 === t ? i <= _ : 2 === t ? i > _ : 3 === t ? i >= _ : void 0 } __clzmsd() { return JSBI.__clz30(this.__digit(this.length - 1)) } static __absoluteAdd(_, t, e) { if (_.length < t.length) return JSBI.__absoluteAdd(t, _, e); if (0 === _.length) return _; if (0 === t.length) return _.sign === e ? _ : JSBI.unaryMinus(_); let n = _.length; (0 === _.__clzmsd() || t.length === _.length && 0 === t.__clzmsd()) && n++; const g = new JSBI(n, e); let o = 0, s = 0; for (; s < t.length; s++) { const i = _.__digit(s) + t.__digit(s) + o; o = i >>> 30, g.__setDigit(s, 1073741823 & i); } for (; s < _.length; s++) { const i = _.__digit(s) + o; o = i >>> 30, g.__setDigit(s, 1073741823 & i); } return s < g.length && g.__setDigit(s, o), g.__trim() } static __absoluteSub(_, t, e) { if (0 === _.length) return _; if (0 === t.length) return _.sign === e ? _ : JSBI.unaryMinus(_); const n = new JSBI(_.length, e); let g = 0, o = 0; for (; o < t.length; o++) { const i = _.__digit(o) - t.__digit(o) - g; g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i); } for (; o < _.length; o++) { const i = _.__digit(o) - g; g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i); } return n.__trim() } static __absoluteAddOne(_, i, t = null) { const e = _.length; null === t ? t = new JSBI(e, i) : t.sign = i; let n = 1; for (let g = 0; g < e; g++) { const i = _.__digit(g) + n; n = i >>> 30, t.__setDigit(g, 1073741823 & i); } return 0 != n && t.__setDigitGrow(e, 1), t } static __absoluteSubOne(_, t) { const e = _.length; t = t || e; const n = new JSBI(t, !1); let g = 1; for (let o = 0; o < e; o++) { const i = _.__digit(o) - g; g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i); } if (0 != g) throw new Error("implementation bug"); for (let g = e; g < t; g++)n.__setDigit(g, 0); return n } static __absoluteAnd(_, t, e = null) { let n = _.length, g = t.length, o = g; if (n < g) { o = n; const i = _, e = n; _ = t, n = g, t = i, g = e; } let s = o; null === e ? e = new JSBI(s, !1) : s = e.length; let l = 0; for (; l < o; l++)e.__setDigit(l, _.__digit(l) & t.__digit(l)); for (; l < s; l++)e.__setDigit(l, 0); return e } static __absoluteAndNot(_, t, e = null) { const n = _.length, g = t.length; let o = g; n < g && (o = n); let s = n; null === e ? e = new JSBI(s, !1) : s = e.length; let l = 0; for (; l < o; l++)e.__setDigit(l, _.__digit(l) & ~t.__digit(l)); for (; l < n; l++)e.__setDigit(l, _.__digit(l)); for (; l < s; l++)e.__setDigit(l, 0); return e } static __absoluteOr(_, t, e = null) { let n = _.length, g = t.length, o = g; if (n < g) { o = n; const i = _, e = n; _ = t, n = g, t = i, g = e; } let s = n; null === e ? e = new JSBI(s, !1) : s = e.length; let l = 0; for (; l < o; l++)e.__setDigit(l, _.__digit(l) | t.__digit(l)); for (; l < n; l++)e.__setDigit(l, _.__digit(l)); for (; l < s; l++)e.__setDigit(l, 0); return e } static __absoluteXor(_, t, e = null) { let n = _.length, g = t.length, o = g; if (n < g) { o = n; const i = _, e = n; _ = t, n = g, t = i, g = e; } let s = n; null === e ? e = new JSBI(s, !1) : s = e.length; let l = 0; for (; l < o; l++)e.__setDigit(l, _.__digit(l) ^ t.__digit(l)); for (; l < n; l++)e.__setDigit(l, _.__digit(l)); for (; l < s; l++)e.__setDigit(l, 0); return e } static __absoluteCompare(_, t) { const e = _.length - t.length; if (0 != e) return e; let n = _.length - 1; for (; 0 <= n && _.__digit(n) === t.__digit(n);)n--; return 0 > n ? 0 : _.__unsignedDigit(n) > t.__unsignedDigit(n) ? 1 : -1 } static __multiplyAccumulate(_, t, e, n) { if (0 === t) return; const g = 32767 & t, o = t >>> 15; let s = 0, l = 0; for (let r, a = 0; a < _.length; a++, n++) { r = e.__digit(n); const i = _.__digit(a), t = 32767 & i, u = i >>> 15, d = JSBI.__imul(t, g), h = JSBI.__imul(t, o), m = JSBI.__imul(u, g), b = JSBI.__imul(u, o); r += l + d + s, s = r >>> 30, r &= 1073741823, r += ((32767 & h) << 15) + ((32767 & m) << 15), s += r >>> 30, l = b + (h >>> 15) + (m >>> 15), e.__setDigit(n, 1073741823 & r); } for (; 0 != s || 0 !== l; n++) { let i = e.__digit(n); i += s + l, l = 0, s = i >>> 30, e.__setDigit(n, 1073741823 & i); } } static __internalMultiplyAdd(_, t, e, g, o) { let s = e, l = 0; for (let n = 0; n < g; n++) { const i = _.__digit(n), e = JSBI.__imul(32767 & i, t), g = JSBI.__imul(i >>> 15, t), a = e + ((32767 & g) << 15) + l + s; s = a >>> 30, l = g >>> 15, o.__setDigit(n, 1073741823 & a); } if (o.length > g) for (o.__setDigit(g++, s + l); g < o.length;)o.__setDigit(g++, 0); else if (0 !== s + l) throw new Error("implementation bug") } __inplaceMultiplyAdd(i, _, t) { t > this.length && (t = this.length); const e = 32767 & i, n = i >>> 15; let g = 0, o = _; for (let s = 0; s < t; s++) { const i = this.__digit(s), _ = 32767 & i, t = i >>> 15, l = JSBI.__imul(_, e), r = JSBI.__imul(_, n), a = JSBI.__imul(t, e), u = JSBI.__imul(t, n); let d = o + l + g; g = d >>> 30, d &= 1073741823, d += ((32767 & r) << 15) + ((32767 & a) << 15), g += d >>> 30, o = u + (r >>> 15) + (a >>> 15), this.__setDigit(s, 1073741823 & d); } if (0 != g || 0 !== o) throw new Error("implementation bug") } static __absoluteDivSmall(_, t, e = null) { null === e && (e = new JSBI(_.length, !1)); let n = 0; for (let g, o = 2 * _.length - 1; 0 <= o; o -= 2) { g = (n << 15 | _.__halfDigit(o)) >>> 0; const i = 0 | g / t; n = 0 | g % t, g = (n << 15 | _.__halfDigit(o - 1)) >>> 0; const s = 0 | g / t; n = 0 | g % t, e.__setDigit(o >>> 1, i << 15 | s); } return e } static __absoluteModSmall(_, t) { let e = 0; for (let n = 2 * _.length - 1; 0 <= n; n--) { const i = (e << 15 | _.__halfDigit(n)) >>> 0; e = 0 | i % t; } return e } static __absoluteDivLarge(i, _, t, e) { const g = _.__halfDigitLength(), n = _.length, o = i.__halfDigitLength() - g; let s = null; t && (s = new JSBI(o + 2 >>> 1, !1), s.__initializeDigits()); const l = new JSBI(g + 2 >>> 1, !1); l.__initializeDigits(); const r = JSBI.__clz15(_.__halfDigit(g - 1)); 0 < r && (_ = JSBI.__specialLeftShift(_, r, 0)); const a = JSBI.__specialLeftShift(i, r, 1), u = _.__halfDigit(g - 1); let d = 0; for (let r, h = o; 0 <= h; h--) { r = 32767; const i = a.__halfDigit(h + g); if (i !== u) { const t = (i << 15 | a.__halfDigit(h + g - 1)) >>> 0; r = 0 | t / u; let e = 0 | t % u; const n = _.__halfDigit(g - 2), o = a.__halfDigit(h + g - 2); for (; JSBI.__imul(r, n) >>> 0 > (e << 16 | o) >>> 0 && (r--, e += u, !(32767 < e));); } JSBI.__internalMultiplyAdd(_, r, 0, n, l); let e = a.__inplaceSub(l, h, g + 1); 0 !== e && (e = a.__inplaceAdd(_, h, g), a.__setHalfDigit(h + g, 32767 & a.__halfDigit(h + g) + e), r--), t && (1 & h ? d = r << 15 : s.__setDigit(h >>> 1, d | r)); } if (e) return a.__inplaceRightShift(r), t ? { quotient: s, remainder: a } : a; if (t) return s; throw new Error("unreachable") } static __clz15(i) { return JSBI.__clz30(i) - 15 } __inplaceAdd(_, t, e) { let n = 0; for (let g = 0; g < e; g++) { const i = this.__halfDigit(t + g) + _.__halfDigit(g) + n; n = i >>> 15, this.__setHalfDigit(t + g, 32767 & i); } return n } __inplaceSub(_, t, e) { let n = 0; if (1 & t) { t >>= 1; let g = this.__digit(t), o = 32767 & g, s = 0; for (; s < e - 1 >>> 1; s++) { const i = _.__digit(s), e = (g >>> 15) - (32767 & i) - n; n = 1 & e >>> 15, this.__setDigit(t + s, (32767 & e) << 15 | 32767 & o), g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15; } const i = _.__digit(s), l = (g >>> 15) - (32767 & i) - n; n = 1 & l >>> 15, this.__setDigit(t + s, (32767 & l) << 15 | 32767 & o); if (t + s + 1 >= this.length) throw new RangeError("out of bounds"); 0 == (1 & e) && (g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15, this.__setDigit(t + _.length, 1073709056 & g | 32767 & o)); } else { t >>= 1; let g = 0; for (; g < _.length - 1; g++) { const i = this.__digit(t + g), e = _.__digit(g), o = (32767 & i) - (32767 & e) - n; n = 1 & o >>> 15; const s = (i >>> 15) - (e >>> 15) - n; n = 1 & s >>> 15, this.__setDigit(t + g, (32767 & s) << 15 | 32767 & o); } const i = this.__digit(t + g), o = _.__digit(g), s = (32767 & i) - (32767 & o) - n; n = 1 & s >>> 15; let l = 0; 0 == (1 & e) && (l = (i >>> 15) - (o >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t + g, (32767 & l) << 15 | 32767 & s); } return n } __inplaceRightShift(_) { if (0 === _) return; let t = this.__digit(0) >>> _; const e = this.length - 1; for (let n = 0; n < e; n++) { const i = this.__digit(n + 1); this.__setDigit(n, 1073741823 & i << 30 - _ | t), t = i >>> _; } this.__setDigit(e, t); } static __specialLeftShift(_, t, e) { const g = _.length, n = new JSBI(g + e, !1); if (0 === t) { for (let t = 0; t < g; t++)n.__setDigit(t, _.__digit(t)); return 0 < e && n.__setDigit(g, 0), n } let o = 0; for (let s = 0; s < g; s++) { const i = _.__digit(s); n.__setDigit(s, 1073741823 & i << t | o), o = i >>> 30 - t; } return 0 < e && n.__setDigit(g, o), n } static __leftShiftByAbsolute(_, i) { const t = JSBI.__toShiftAmount(i); if (0 > t) throw new RangeError("BigInt too big"); const e = 0 | t / 30, n = t % 30, g = _.length, o = 0 !== n && 0 != _.__digit(g - 1) >>> 30 - n, s = g + e + (o ? 1 : 0), l = new JSBI(s, _.sign); if (0 === n) { let t = 0; for (; t < e; t++)l.__setDigit(t, 0); for (; t < s; t++)l.__setDigit(t, _.__digit(t - e)); } else { let t = 0; for (let _ = 0; _ < e; _++)l.__setDigit(_, 0); for (let o = 0; o < g; o++) { const i = _.__digit(o); l.__setDigit(o + e, 1073741823 & i << n | t), t = i >>> 30 - n; } if (o) l.__setDigit(g + e, t); else if (0 !== t) throw new Error("implementation bug") } return l.__trim() } static __rightShiftByAbsolute(_, i) { const t = _.length, e = _.sign, n = JSBI.__toShiftAmount(i); if (0 > n) return JSBI.__rightShiftByMaximum(e); const g = 0 | n / 30, o = n % 30; let s = t - g; if (0 >= s) return JSBI.__rightShiftByMaximum(e); let l = !1; if (e) { if (0 != (_.__digit(g) & (1 << o) - 1)) l = !0; else for (let t = 0; t < g; t++)if (0 !== _.__digit(t)) { l = !0; break } } if (l && 0 === o) { const i = _.__digit(t - 1); 0 == ~i && s++; } let r = new JSBI(s, e); if (0 === o) { r.__setDigit(s - 1, 0); for (let e = g; e < t; e++)r.__setDigit(e - g, _.__digit(e)); } else { let e = _.__digit(g) >>> o; const n = t - g - 1; for (let t = 0; t < n; t++) { const i = _.__digit(t + g + 1); r.__setDigit(t, 1073741823 & i << 30 - o | e), e = i >>> o; } r.__setDigit(n, e); } return l && (r = JSBI.__absoluteAddOne(r, !0, r)), r.__trim() } static __rightShiftByMaximum(i) { return i ? JSBI.__oneDigit(1, !0) : JSBI.__zero() } static __toShiftAmount(i) { if (1 < i.length) return -1; const _ = i.__unsignedDigit(0); return _ > JSBI.__kMaxLengthBits ? -1 : _ } static __toPrimitive(i, _ = "default") { if ("object" != typeof i) return i; if (i.constructor === JSBI) return i; if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive) { const t = i[Symbol.toPrimitive]; if (t) { const i = t(_); if ("object" != typeof i) return i; throw new TypeError("Cannot convert object to primitive value") } } const t = i.valueOf; if (t) { const _ = t.call(i); if ("object" != typeof _) return _ } const e = i.toString; if (e) { const _ = e.call(i); if ("object" != typeof _) return _ } throw new TypeError("Cannot convert object to primitive value") } static __toNumeric(i) { return JSBI.__isBigInt(i) ? i : +i } static __isBigInt(i) { return "object" == typeof i && null !== i && i.constructor === JSBI } static __truncateToNBits(i, _) { const t = 0 | (i + 29) / 30, e = new JSBI(t, _.sign), n = t - 1; for (let t = 0; t < n; t++)e.__setDigit(t, _.__digit(t)); let g = _.__digit(n); if (0 != i % 30) { const _ = 32 - i % 30; g = g << _ >>> _; } return e.__setDigit(n, g), e.__trim() } static __truncateAndSubFromPowerOfTwo(_, t, e) { var n = Math.min; const g = 0 | (_ + 29) / 30, o = new JSBI(g, e); let s = 0; const l = g - 1; let a = 0; for (const i = n(l, t.length); s < i; s++) { const i = 0 - t.__digit(s) - a; a = 1 & i >>> 30, o.__setDigit(s, 1073741823 & i); } for (; s < l; s++)o.__setDigit(s, 0 | 1073741823 & -a); let u = l < t.length ? t.__digit(l) : 0; const d = _ % 30; let h; if (0 == d) h = 0 - u - a, h &= 1073741823; else { const i = 32 - d; u = u << i >>> i; const _ = 1 << 32 - i; h = _ - u - a, h &= _ - 1; } return o.__setDigit(l, h), o.__trim() } __digit(_) { return this[_] } __unsignedDigit(_) { return this[_] >>> 0 } __setDigit(_, i) { this[_] = 0 | i; } __setDigitGrow(_, i) { this[_] = 0 | i; } __halfDigitLength() { const i = this.length; return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i } __halfDigit(_) { return 32767 & this[_ >>> 1] >>> 15 * (1 & _) } __setHalfDigit(_, i) { const t = _ >>> 1, e = this.__digit(t), n = 1 & _ ? 32767 & e | i << 15 : 1073709056 & e | 32767 & i; this.__setDigit(t, n); } static __digitPow(i, _) { let t = 1; for (; 0 < _;)1 & _ && (t *= i), _ >>>= 1, i *= i; return t } static __isOneDigitInt(i) { return (1073741823 & i) === i } } JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function (i) { return Math.clz32(i) - 2 } : function (i) { return 0 === i ? 30 : 0 | 29 - (0 | Math.log(i >>> 0) / Math.LN2) }, JSBI.__imul = Math.imul || function (i, _) { return 0 | i * _ };

/*
 *  decimal.js-light v2.5.1
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js-light
 *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Expat Licence
 */


// ------------------------------------  EDITABLE DEFAULTS  ------------------------------------- //


// The limit on the value of `precision`, and on the value of the first argument to
// `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
var MAX_DIGITS = 1e9,                        // 0 to 1e9


    // The initial configuration properties of the Decimal constructor.
    defaults = {

        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed during run-time using `Decimal.config`.

        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,                         // 1 to MAX_DIGITS

        // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
        // `toFixed`, `toPrecision` and `toSignificantDigits`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,                           // 0 to 8

        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,                          // 0 to -MAX_E

        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,                         // 0 to MAX_E

        // The natural logarithm of 10.
        // 115 digits
        LN10: '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286'
    },


    // ------------------------------------ END OF EDITABLE DEFAULTS -------------------------------- //


    Decimal$1,
    external = true,

    decimalError = '[DecimalError] ',
    invalidArgument = decimalError + 'Invalid argument: ',
    exponentOutOfRange = decimalError + 'Exponent out of range: ',

    mathfloor = Math.floor,
    mathpow = Math.pow,

    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

    ONE,
    BASE = 1e7,
    LOG_BASE = 7,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE),    // 1286742750677284

    // Decimal.prototype object
    P$1 = {};


// Decimal prototype methods


/*
 *  absoluteValue                       abs
 *  comparedTo                          cmp
 *  decimalPlaces                       dp
 *  dividedBy                           div
 *  dividedToIntegerBy                  idiv
 *  equals                              eq
 *  exponent
 *  greaterThan                         gt
 *  greaterThanOrEqualTo                gte
 *  isInteger                           isint
 *  isNegative                          isneg
 *  isPositive                          ispos
 *  isZero
 *  lessThan                            lt
 *  lessThanOrEqualTo                   lte
 *  logarithm                           log
 *  minus                               sub
 *  modulo                              mod
 *  naturalExponential                  exp
 *  naturalLogarithm                    ln
 *  negated                             neg
 *  plus                                add
 *  precision                           sd
 *  squareRoot                          sqrt
 *  times                               mul
 *  toDecimalPlaces                     todp
 *  toExponential
 *  toFixed
 *  toInteger                           toint
 *  toNumber
 *  toPower                             pow
 *  toPrecision
 *  toSignificantDigits                 tosd
 *  toString
 *  valueOf                             val
 */


/*
 * Return a new Decimal whose value is the absolute value of this Decimal.
 *
 */
P$1.absoluteValue = P$1.abs = function () {
    var x = new this.constructor(this);
    if (x.s) x.s = 1;
    return x;
};


/*
 * Return
 *   1    if the value of this Decimal is greater than the value of `y`,
 *  -1    if the value of this Decimal is less than the value of `y`,
 *   0    if they have the same value
 *
 */
P$1.comparedTo = P$1.cmp = function (y) {
    var i, j, xdL, ydL,
        x = this;

    y = new x.constructor(y);

    // Signs differ?
    if (x.s !== y.s) return x.s || -y.s;

    // Compare exponents.
    if (x.e !== y.e) return x.e > y.e ^ x.s < 0 ? 1 : -1;

    xdL = x.d.length;
    ydL = y.d.length;

    // Compare digit by digit.
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (x.d[i] !== y.d[i]) return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
    }

    // Compare lengths.
    return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
};


/*
 * Return the number of decimal places of the value of this Decimal.
 *
 */
P$1.decimalPlaces = P$1.dp = function () {
    var x = this,
        w = x.d.length - 1,
        dp = (w - x.e) * LOG_BASE;

    // Subtract the number of trailing zeros of the last word.
    w = x.d[w];
    if (w) for (; w % 10 == 0; w /= 10) dp--;

    return dp < 0 ? 0 : dp;
};


/*
 * Return a new Decimal whose value is the value of this Decimal divided by `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.dividedBy = P$1.div = function (y) {
    return divide(this, new this.constructor(y));
};


/*
 * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
 * by the value of `y`, truncated to `precision` significant digits.
 *
 */
P$1.dividedToIntegerBy = P$1.idiv = function (y) {
    var x = this,
        Ctor = x.constructor;
    return round$1(divide(x, new Ctor(y), 0, 1), Ctor.precision);
};


/*
 * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
 *
 */
P$1.equals = P$1.eq = function (y) {
    return !this.cmp(y);
};


/*
 * Return the (base 10) exponent value of this Decimal (this.e is the base 10000000 exponent).
 *
 */
P$1.exponent = function () {
    return getBase10Exponent(this);
};


/*
 * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
 * false.
 *
 */
P$1.greaterThan = P$1.gt = function (y) {
    return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Decimal is greater than or equal to the value of `y`,
 * otherwise return false.
 *
 */
P$1.greaterThanOrEqualTo = P$1.gte = function (y) {
    return this.cmp(y) >= 0;
};


/*
 * Return true if the value of this Decimal is an integer, otherwise return false.
 *
 */
P$1.isInteger = P$1.isint = function () {
    return this.e > this.d.length - 2;
};


/*
 * Return true if the value of this Decimal is negative, otherwise return false.
 *
 */
P$1.isNegative = P$1.isneg = function () {
    return this.s < 0;
};


/*
 * Return true if the value of this Decimal is positive, otherwise return false.
 *
 */
P$1.isPositive = P$1.ispos = function () {
    return this.s > 0;
};


/*
 * Return true if the value of this Decimal is 0, otherwise return false.
 *
 */
P$1.isZero = function () {
    return this.s === 0;
};


/*
 * Return true if the value of this Decimal is less than `y`, otherwise return false.
 *
 */
P$1.lessThan = P$1.lt = function (y) {
    return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
 *
 */
P$1.lessThanOrEqualTo = P$1.lte = function (y) {
    return this.cmp(y) < 1;
};


/*
 * Return the logarithm of the value of this Decimal to the specified base, truncated to
 * `precision` significant digits.
 *
 * If no base is specified, return log[10](x).
 *
 * log[base](x) = ln(x) / ln(base)
 *
 * The maximum error of the result is 1 ulp (unit in the last place).
 *
 * [base] {number|string|Decimal} The base of the logarithm.
 *
 */
P$1.logarithm = P$1.log = function (base) {
    var r,
        x = this,
        Ctor = x.constructor,
        pr = Ctor.precision,
        wpr = pr + 5;

    // Default base is 10.
    if (base === void 0) {
        base = new Ctor(10);
    } else {
        base = new Ctor(base);

        // log[-b](x) = NaN
        // log[0](x)  = NaN
        // log[1](x)  = NaN
        if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + 'NaN');
    }

    // log[b](-x) = NaN
    // log[b](0) = -Infinity
    if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));

    // log[b](1) = 0
    if (x.eq(ONE)) return new Ctor(0);

    external = false;
    r = divide(ln(x, wpr), ln(base, wpr), wpr);
    external = true;

    return round$1(r, pr);
};


/*
 * Return a new Decimal whose value is the value of this Decimal minus `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.minus = P$1.sub = function (y) {
    var x = this;
    y = new x.constructor(y);
    return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
};


/*
 * Return a new Decimal whose value is the value of this Decimal modulo `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.modulo = P$1.mod = function (y) {
    var q,
        x = this,
        Ctor = x.constructor,
        pr = Ctor.precision;

    y = new Ctor(y);

    // x % 0 = NaN
    if (!y.s) throw Error(decimalError + 'NaN');

    // Return x if x is 0.
    if (!x.s) return round$1(new Ctor(x), pr);

    // Prevent rounding of intermediate calculations.
    external = false;
    q = divide(x, y, 0, 1).times(y);
    external = true;

    return x.minus(q);
};


/*
 * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
 * i.e. the base e raised to the power the value of this Decimal, truncated to `precision`
 * significant digits.
 *
 */
P$1.naturalExponential = P$1.exp = function () {
    return exp(this);
};


/*
 * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
 * truncated to `precision` significant digits.
 *
 */
P$1.naturalLogarithm = P$1.ln = function () {
    return ln(this);
};


/*
 * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
 * -1.
 *
 */
P$1.negated = P$1.neg = function () {
    var x = new this.constructor(this);
    x.s = -x.s || 0;
    return x;
};


/*
 * Return a new Decimal whose value is the value of this Decimal plus `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.plus = P$1.add = function (y) {
    var x = this;
    y = new x.constructor(y);
    return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
};


/*
 * Return the number of significant digits of the value of this Decimal.
 *
 * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
 *
 */
P$1.precision = P$1.sd = function (z) {
    var e, sd, w,
        x = this;

    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

    e = getBase10Exponent(x) + 1;
    w = x.d.length - 1;
    sd = w * LOG_BASE + 1;
    w = x.d[w];

    // If non-zero...
    if (w) {

        // Subtract the number of trailing zeros of the last word.
        for (; w % 10 == 0; w /= 10) sd--;

        // Add the number of digits of the first word.
        for (w = x.d[0]; w >= 10; w /= 10) sd++;
    }

    return z && e > sd ? e : sd;
};


/*
 * Return a new Decimal whose value is the square root of this Decimal, truncated to `precision`
 * significant digits.
 *
 */
P$1.squareRoot = P$1.sqrt = function () {
    var e, n, pr, r, s, t, wpr,
        x = this,
        Ctor = x.constructor;

    // Negative or zero?
    if (x.s < 1) {
        if (!x.s) return new Ctor(0);

        // sqrt(-x) = NaN
        throw Error(decimalError + 'NaN');
    }

    e = getBase10Exponent(x);
    external = false;

    // Initial estimate.
    s = Math.sqrt(+x);

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
        n = digitsToString(x.d);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(n);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
            n = '5e' + e;
        } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new Ctor(n);
    } else {
        r = new Ctor(s.toString());
    }

    pr = Ctor.precision;
    s = wpr = pr + 3;

    // Newton-Raphson iteration.
    for (; ;) {
        t = r;
        r = t.plus(divide(x, t, wpr + 2)).times(0.5);

        if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
            n = n.slice(wpr - 3, wpr + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
            // 4999, i.e. approaching a rounding boundary, continue the iteration.
            if (s == wpr && n == '4999') {

                // On the first iteration only, check to see if rounding up gives the exact result as the
                // nines may infinitely repeat.
                round$1(t, pr + 1, 0);

                if (t.times(t).eq(x)) {
                    r = t;
                    break;
                }
            } else if (n != '9999') {
                break;
            }

            wpr += 4;
        }
    }

    external = true;

    return round$1(r, pr);
};


/*
 * Return a new Decimal whose value is the value of this Decimal times `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.times = P$1.mul = function (y) {
    var carry, e, i, k, r, rL, t, xdL, ydL,
        x = this,
        Ctor = x.constructor,
        xd = x.d,
        yd = (y = new Ctor(y)).d;

    // Return 0 if either is 0.
    if (!x.s || !y.s) return new Ctor(0);

    y.s *= x.s;
    e = x.e + y.e;
    xdL = xd.length;
    ydL = yd.length;

    // Ensure xd points to the longer array.
    if (xdL < ydL) {
        r = xd;
        xd = yd;
        yd = r;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
    }

    // Initialise the result array with zeros.
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--;) r.push(0);

    // Multiply!
    for (i = ydL; --i >= 0;) {
        carry = 0;
        for (k = xdL + i; k > i;) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
        }

        r[k] = (r[k] + carry) % BASE | 0;
    }

    // Remove trailing zeros.
    for (; !r[--rL];) r.pop();

    if (carry) ++e;
    else r.shift();

    y.d = r;
    y.e = e;

    return external ? round$1(y, Ctor.precision) : y;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
 * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
 *
 * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P$1.toDecimalPlaces = P$1.todp = function (dp, rm) {
    var x = this,
        Ctor = x.constructor;

    x = new Ctor(x);
    if (dp === void 0) return x;

    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    return round$1(x, dp + getBase10Exponent(x) + 1, rm);
};


/*
 * Return a string representing the value of this Decimal in exponential notation rounded to
 * `dp` fixed decimal places using rounding mode `rounding`.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P$1.toExponential = function (dp, rm) {
    var str,
        x = this,
        Ctor = x.constructor;

    if (dp === void 0) {
        str = toString(x, true);
    } else {
        checkInt32(dp, 0, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        x = round$1(new Ctor(x), dp + 1, rm);
        str = toString(x, true, dp + 1);
    }

    return str;
};


/*
 * Return a string representing the value of this Decimal in normal (fixed-point) notation to
 * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
 * omitted.
 *
 * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 * (-0).toFixed(3) is '0.000'.
 * (-0.5).toFixed(0) is '-0'.
 *
 */
P$1.toFixed = function (dp, rm) {
    var str, y,
        x = this,
        Ctor = x.constructor;

    if (dp === void 0) return toString(x);

    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    y = round$1(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);
    str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);

    // To determine whether to add the minus sign look at the value before it was rounded,
    // i.e. look at `x` rather than `y`.
    return x.isneg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
 * rounding mode `rounding`.
 *
 */
P$1.toInteger = P$1.toint = function () {
    var x = this,
        Ctor = x.constructor;
    return round$1(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
};


/*
 * Return the value of this Decimal converted to a number primitive.
 *
 */
P$1.toNumber = function () {
    return +this;
};


/*
 * Return a new Decimal whose value is the value of this Decimal raised to the power `y`,
 * truncated to `precision` significant digits.
 *
 * For non-integer or very large exponents pow(x, y) is calculated using
 *
 *   x^y = exp(y*ln(x))
 *
 * The maximum error is 1 ulp (unit in last place).
 *
 * y {number|string|Decimal} The power to which to raise this Decimal.
 *
 */
P$1.toPower = P$1.pow = function (y) {
    var e, k, pr, r, sign, yIsInt,
        x = this,
        Ctor = x.constructor,
        guard = 12,
        yn = +(y = new Ctor(y));

    // pow(x, 0) = 1
    if (!y.s) return new Ctor(ONE);

    x = new Ctor(x);

    // pow(0, y > 0) = 0
    // pow(0, y < 0) = Infinity
    if (!x.s) {
        if (y.s < 1) throw Error(decimalError + 'Infinity');
        return x;
    }

    // pow(1, y) = 1
    if (x.eq(ONE)) return x;

    pr = Ctor.precision;

    // pow(x, 1) = x
    if (y.eq(ONE)) return round$1(x, pr);

    e = y.e;
    k = y.d.length - 1;
    yIsInt = e >= k;
    sign = x.s;

    if (!yIsInt) {

        // pow(x < 0, y non-integer) = NaN
        if (sign < 0) throw Error(decimalError + 'NaN');

        // If y is a small integer use the 'exponentiation by squaring' algorithm.
    } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r = new Ctor(ONE);

        // Max k of 9007199254740991 takes 53 loop iterations.
        // Maximum digits array length; leaves [28, 34] guard digits.
        e = Math.ceil(pr / LOG_BASE + 4);

        external = false;

        for (; ;) {
            if (k % 2) {
                r = r.times(x);
                truncate(r.d, e);
            }

            k = mathfloor(k / 2);
            if (k === 0) break;

            x = x.times(x);
            truncate(x.d, e);
        }

        external = true;

        return y.s < 0 ? new Ctor(ONE).div(r) : round$1(r, pr);
    }

    // Result is negative if x is negative and the last digit of integer y is odd.
    sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;

    x.s = 1;
    external = false;
    r = y.times(ln(x, pr + guard));
    external = true;
    r = exp(r);
    r.s = sign;

    return r;
};


/*
 * Return a string representing the value of this Decimal rounded to `sd` significant digits
 * using rounding mode `rounding`.
 *
 * Return exponential notation if `sd` is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P$1.toPrecision = function (sd, rm) {
    var e, str,
        x = this,
        Ctor = x.constructor;

    if (sd === void 0) {
        e = getBase10Exponent(x);
        str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
    } else {
        checkInt32(sd, 1, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        x = round$1(new Ctor(x), sd, rm);
        e = getBase10Exponent(x);
        str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);
    }

    return str;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
 * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
 * omitted.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P$1.toSignificantDigits = P$1.tosd = function (sd, rm) {
    var x = this,
        Ctor = x.constructor;

    if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
    } else {
        checkInt32(sd, 1, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
    }

    return round$1(new Ctor(x), sd, rm);
};


/*
 * Return a string representing the value of this Decimal.
 *
 * Return exponential notation if this Decimal has a positive exponent equal to or greater than
 * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
 *
 */
P$1.toString = P$1.valueOf = P$1.val = P$1.toJSON = P$1[Symbol.for('nodejs.util.inspect.custom')] = function () {
    var x = this,
        e = getBase10Exponent(x),
        Ctor = x.constructor;

    return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
};


// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


/*
 *  add                 P.minus, P.plus
 *  checkInt32          P.todp, P.toExponential, P.toFixed, P.toPrecision, P.tosd
 *  digitsToString      P.log, P.sqrt, P.pow, toString, exp, ln
 *  divide              P.div, P.idiv, P.log, P.mod, P.sqrt, exp, ln
 *  exp                 P.exp, P.pow
 *  getBase10Exponent   P.exponent, P.sd, P.toint, P.sqrt, P.todp, P.toFixed, P.toPrecision,
 *                      P.toString, divide, round, toString, exp, ln
 *  getLn10             P.log, ln
 *  getZeroString       digitsToString, toString
 *  ln                  P.log, P.ln, P.pow, exp
 *  parseDecimal        Decimal
 *  round               P.abs, P.idiv, P.log, P.minus, P.mod, P.neg, P.plus, P.toint, P.sqrt,
 *                      P.times, P.todp, P.toExponential, P.toFixed, P.pow, P.toPrecision, P.tosd,
 *                      divide, getLn10, exp, ln
 *  subtract            P.minus, P.plus
 *  toString            P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf
 *  truncate            P.pow
 *
 *  Throws:             P.log, P.mod, P.sd, P.sqrt, P.pow,  checkInt32, divide, round,
 *                      getLn10, exp, ln, parseDecimal, Decimal, config
 */


function add(x, y) {
    var carry, d, e, i, k, len, xd, yd,
        Ctor = x.constructor,
        pr = Ctor.precision;

    // If either is zero...
    if (!x.s || !y.s) {

        // Return x if y is zero.
        // Return y if y is non-zero.
        if (!y.s) y = new Ctor(x);
        return external ? round$1(y, pr) : y;
    }

    xd = x.d;
    yd = y.d;

    // x and y are finite, non-zero numbers with the same sign.

    k = x.e;
    e = y.e;
    xd = xd.slice();
    i = k - e;

    // If base 1e7 exponents differ...
    if (i) {
        if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
        } else {
            d = yd;
            e = k;
            len = xd.length;
        }

        // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
        k = Math.ceil(pr / LOG_BASE);
        len = k > len ? k + 1 : len + 1;

        if (i > len) {
            i = len;
            d.length = 1;
        }

        // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
        d.reverse();
        for (; i--;) d.push(0);
        d.reverse();
    }

    len = xd.length;
    i = yd.length;

    // If yd is longer than xd, swap xd and yd so xd points to the longer array.
    if (len - i < 0) {
        i = len;
        d = yd;
        yd = xd;
        xd = d;
    }

    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
    for (carry = 0; i;) {
        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
        xd[i] %= BASE;
    }

    if (carry) {
        xd.unshift(carry);
        ++e;
    }

    // Remove trailing zeros.
    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    for (len = xd.length; xd[--len] == 0;) xd.pop();

    y.d = xd;
    y.e = e;

    return external ? round$1(y, pr) : y;
}


function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
        throw Error(invalidArgument + i);
    }
}


function digitsToString(d) {
    var i, k, ws,
        indexOfLastWord = d.length - 1,
        str = '',
        w = d[0];

    if (indexOfLastWord > 0) {
        str += w;
        for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + '';
            k = LOG_BASE - ws.length;
            if (k) str += getZeroString(k);
            str += ws;
        }

        w = d[i];
        ws = w + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
    } else if (w === 0) {
        return '0';
    }

    // Remove trailing zeros of last w.
    for (; w % 10 === 0;) w /= 10;

    return str + w;
}


var divide = (function () {

    // Assumes non-zero x and k, and hence non-zero result.
    function multiplyInteger(x, k) {
        var temp,
            carry = 0,
            i = x.length;

        for (x = x.slice(); i--;) {
            temp = x[i] * k + carry;
            x[i] = temp % BASE | 0;
            carry = temp / BASE | 0;
        }

        if (carry) x.unshift(carry);

        return x;
    }

    function compare(a, b, aL, bL) {
        var i, r;

        if (aL != bL) {
            r = aL > bL ? 1 : -1;
        } else {
            for (i = r = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                    r = a[i] > b[i] ? 1 : -1;
                    break;
                }
            }
        }

        return r;
    }

    function subtract(a, b, aL) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * BASE + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1;) a.shift();
    }

    return function (x, y, pr, dp) {
        var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz,
            Ctor = x.constructor,
            sign = x.s == y.s ? 1 : -1,
            xd = x.d,
            yd = y.d;

        // Either 0?
        if (!x.s) return new Ctor(x);
        if (!y.s) throw Error(decimalError + 'Division by zero');

        e = x.e - y.e;
        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign);
        qd = q.d = [];

        // Result exponent may be one less than e.
        for (i = 0; yd[i] == (xd[i] || 0);) ++i;
        if (yd[i] > (xd[i] || 0)) --e;

        if (pr == null) {
            sd = pr = Ctor.precision;
        } else if (dp) {
            sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
        } else {
            sd = pr;
        }

        if (sd < 0) return new Ctor(0);

        // Convert precision in number of base 10 digits to base 1e7 digits.
        sd = sd / LOG_BASE + 2 | 0;
        i = 0;

        // divisor < 1e7
        if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;

            // k is the carry.
            for (; (i < xL || k) && sd--; i++) {
                t = k * BASE + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
            }

            // divisor >= 1e7
        } else {

            // Normalise xd and yd so highest order digit of yd is >= BASE/2
            k = BASE / (yd[0] + 1) | 0;

            if (k > 1) {
                yd = multiplyInteger(yd, k);
                xd = multiplyInteger(xd, k);
                yL = yd.length;
                xL = xd.length;
            }

            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;

            // Add zeros to make remainder as long as divisor.
            for (; remL < yL;) rem[remL++] = 0;

            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];

            if (yd[1] >= BASE / 2) ++yd0;

            do {
                k = 0;

                // Compare divisor and remainder.
                cmp = compare(yd, rem, yL, remL);

                // If divisor < remainder.
                if (cmp < 0) {

                    // Calculate trial digit, k.
                    rem0 = rem[0];
                    if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);

                    // k will be how many times the divisor goes into the current remainder.
                    k = rem0 / yd0 | 0;

                    //  Algorithm:
                    //  1. product = divisor * trial digit (k)
                    //  2. if product > remainder: product -= divisor, k--
                    //  3. remainder -= product
                    //  4. if product was < remainder at 2:
                    //    5. compare new remainder and divisor
                    //    6. If remainder > divisor: remainder -= divisor, k++

                    if (k > 1) {
                        if (k >= BASE) k = BASE - 1;

                        // product = divisor * trial digit.
                        prod = multiplyInteger(yd, k);
                        prodL = prod.length;
                        remL = rem.length;

                        // Compare product and remainder.
                        cmp = compare(prod, rem, prodL, remL);

                        // product > remainder.
                        if (cmp == 1) {
                            k--;

                            // Subtract divisor from product.
                            subtract(prod, yL < prodL ? yz : yd, prodL);
                        }
                    } else {

                        // cmp is -1.
                        // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                        // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                        if (k == 0) cmp = k = 1;
                        prod = yd.slice();
                    }

                    prodL = prod.length;
                    if (prodL < remL) prod.unshift(0);

                    // Subtract product from remainder.
                    subtract(rem, prod, remL);

                    // If product was < previous remainder.
                    if (cmp == -1) {
                        remL = rem.length;

                        // Compare divisor and new remainder.
                        cmp = compare(yd, rem, yL, remL);

                        // If divisor < new remainder, subtract divisor from remainder.
                        if (cmp < 1) {
                            k++;

                            // Subtract divisor from remainder.
                            subtract(rem, yL < remL ? yz : yd, remL);
                        }
                    }

                    remL = rem.length;
                } else if (cmp === 0) {
                    k++;
                    rem = [0];
                }    // if cmp === 1, k will be 0

                // Add the next digit, k, to the result array.
                qd[i++] = k;

                // Update the remainder.
                if (cmp && rem[0]) {
                    rem[remL++] = xd[xi] || 0;
                } else {
                    rem = [xd[xi]];
                    remL = 1;
                }

            } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        }

        // Leading zero?
        if (!qd[0]) qd.shift();

        q.e = e;

        return round$1(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
    };
})();


/*
 * Return a new Decimal whose value is the natural exponential of `x` truncated to `sd`
 * significant digits.
 *
 * Taylor/Maclaurin series.
 *
 * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
 *
 * Argument reduction:
 *   Repeat x = x / 32, k += 5, until |x| < 0.1
 *   exp(x) = exp(x / 2^k)^(2^k)
 *
 * Previously, the argument was initially reduced by
 * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
 * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
 * found to be slower than just dividing repeatedly by 32 as above.
 *
 * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
 *
 *  exp(x) is non-terminating for any finite, non-zero x.
 *
 */
function exp(x, sd) {
    var denominator, guard, pow, sum, t, wpr,
        i = 0,
        k = 0,
        Ctor = x.constructor,
        pr = Ctor.precision;

    if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x));

    // exp(0) = 1
    if (!x.s) return new Ctor(ONE);

    if (sd == null) {
        external = false;
        wpr = pr;
    } else {
        wpr = sd;
    }

    t = new Ctor(0.03125);

    while (x.abs().gte(0.1)) {
        x = x.times(t);    // x = x / 2^5
        k += 5;
    }

    // Estimate the precision increase necessary to ensure the first 4 rounding digits are correct.
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(ONE);
    Ctor.precision = wpr;

    for (; ;) {
        pow = round$1(pow.times(x), wpr);
        denominator = denominator.times(++i);
        t = sum.plus(divide(pow, denominator, wpr));

        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            while (k--) sum = round$1(sum.times(sum), wpr);
            Ctor.precision = pr;
            return sd == null ? (external = true, round$1(sum, pr)) : sum;
        }

        sum = t;
    }
}


// Calculate the base 10 exponent from the base 1e7 exponent.
function getBase10Exponent(x) {
    var e = x.e * LOG_BASE,
        w = x.d[0];

    // Add the number of digits of the first word of the digits array.
    for (; w >= 10; w /= 10) e++;
    return e;
}


function getLn10(Ctor, sd, pr) {

    if (sd > Ctor.LN10.sd()) {


        // Reset global state in case the exception is caught.
        external = true;
        if (pr) Ctor.precision = pr;
        throw Error(decimalError + 'LN10 precision limit exceeded');
    }

    return round$1(new Ctor(Ctor.LN10), sd);
}


function getZeroString(k) {
    var zs = '';
    for (; k--;) zs += '0';
    return zs;
}


/*
 * Return a new Decimal whose value is the natural logarithm of `x` truncated to `sd` significant
 * digits.
 *
 *  ln(n) is non-terminating (n != 1)
 *
 */
function ln(y, sd) {
    var c, c0, denominator, e, numerator, sum, t, wpr, x2,
        n = 1,
        guard = 10,
        x = y,
        xd = x.d,
        Ctor = x.constructor,
        pr = Ctor.precision;

    // ln(-x) = NaN
    // ln(0) = -Infinity
    if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));

    // ln(1) = 0
    if (x.eq(ONE)) return new Ctor(0);

    if (sd == null) {
        external = false;
        wpr = pr;
    } else {
        wpr = sd;
    }

    if (x.eq(10)) {
        if (sd == null) external = true;
        return getLn10(Ctor, wpr);
    }

    wpr += guard;
    Ctor.precision = wpr;
    c = digitsToString(xd);
    c0 = c.charAt(0);
    e = getBase10Exponent(x);

    if (Math.abs(e) < 1.5e15) {

        // Argument reduction.
        // The series converges faster the closer the argument is to 1, so using
        // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
        // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
        // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
        // later be divided by this number, then separate out the power of 10 using
        // ln(a*10^b) = ln(a) + b*ln(10).

        // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
        //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
        // max n is 6 (gives 0.7 - 1.3)
        while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
        }

        e = getBase10Exponent(x);

        if (c0 > 1) {
            x = new Ctor('0.' + c);
            e++;
        } else {
            x = new Ctor(c0 + '.' + c.slice(1));
        }
    } else {

        // The argument reduction method above may result in overflow if the argument y is a massive
        // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
        // function using ln(x*10^e) = ln(x) + e*ln(10).
        t = getLn10(Ctor, wpr + 2, pr).times(e + '');
        x = ln(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);

        Ctor.precision = pr;
        return sd == null ? (external = true, round$1(x, pr)) : x;
    }

    // x is reduced to a value near 1.

    // Taylor series.
    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
    // where x = (y - 1)/(y + 1)    (|x| < 1)
    sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
    x2 = round$1(x.times(x), wpr);
    denominator = 3;

    for (; ;) {
        numerator = round$1(numerator.times(x2), wpr);
        t = sum.plus(divide(numerator, new Ctor(denominator), wpr));

        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            sum = sum.times(2);

            // Reverse the argument reduction.
            if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
            sum = divide(sum, new Ctor(n), wpr);

            Ctor.precision = pr;
            return sd == null ? (external = true, round$1(sum, pr)) : sum;
        }

        sum = t;
        denominator += 2;
    }
}


/*
 * Parse the value of a new Decimal `x` from string `str`.
 */
function parseDecimal(x, str) {
    var e, i, len;

    // Decimal point?
    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

    // Exponential form?
    if ((i = str.search(/e/i)) > 0) {

        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
    } else if (e < 0) {

        // Integer.
        e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48;) ++i;

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(len - 1) === 48;) --len;
    str = str.slice(i, len);

    if (str) {
        len -= i;
        e = e - i - 1;
        x.e = mathfloor(e / LOG_BASE);
        x.d = [];

        // Transform base

        // e is the base 10 exponent.
        // i is where to slice str to get the first word of the digits array.
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;

        if (i < len) {
            if (i) x.d.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
            str = str.slice(i);
            i = LOG_BASE - str.length;
        } else {
            i -= len;
        }

        for (; i--;) str += '0';
        x.d.push(+str);

        if (external && (x.e > MAX_E || x.e < -MAX_E)) throw Error(exponentOutOfRange + e);
    } else {

        // Zero.
        x.s = 0;
        x.e = 0;
        x.d = [0];
    }

    return x;
}


/*
 * Round `x` to `sd` significant digits, using rounding mode `rm` if present (truncate otherwise).
 */
function round$1(x, sd, rm) {
    var i, j, k, n, rd, doRound, w, xdi,
        xd = x.d;

    // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
    // w: the word of xd which contains the rounding digit, a base 1e7 number.
    // xdi: the index of w within xd.
    // n: the number of digits of w.
    // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
    // they had leading zeros)
    // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

    // Get the length of the first word of the digits array xd.
    for (n = 1, k = xd[0]; k >= 10; k /= 10) n++;
    i = sd - n;

    // Is the rounding digit in the first word of xd?
    if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
    } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) return x;
        w = k = xd[xdi];

        // Get the number of digits of w.
        for (n = 1; k >= 10; k /= 10) n++;

        // Get the index of rd within w.
        i %= LOG_BASE;

        // Get the index of rd within w, adjusted for leading zeros.
        // The number of leading zeros of w is given by LOG_BASE - n.
        j = i - LOG_BASE + n;
    }

    if (rm !== void 0) {
        k = mathpow(10, n - j - 1);

        // Get the rounding digit at index j of w.
        rd = w / k % 10 | 0;

        // Are there any non-zero digits after the rounding digit?
        doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;

        // The expression `w % mathpow(10, n - j - 1)` returns all the digits of w to the right of the
        // digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression will give
        // 714.

        doRound = rm < 4
            ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
            : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 &&

                // Check whether the digit to the left of the rounding digit is odd.
                ((i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
                rm == (x.s < 0 ? 8 : 7));
    }

    if (sd < 1 || !xd[0]) {
        if (doRound) {
            k = getBase10Exponent(x);
            xd.length = 1;

            // Convert sd to decimal places.
            sd = sd - k - 1;

            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = mathfloor(-sd / LOG_BASE) || 0;
        } else {
            xd.length = 1;

            // Zero.
            xd[0] = x.e = x.s = 0;
        }

        return x;
    }

    // Remove excess digits.
    if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
    } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);

        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
        // j > 0 means i > number of leading zeros of w.
        xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
    }

    if (doRound) {
        for (; ;) {

            // Is the digit to be rounded up in the first word of xd?
            if (xdi == 0) {
                if ((xd[0] += k) == BASE) {
                    xd[0] = 1;
                    ++x.e;
                }

                break;
            } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE) break;
                xd[xdi--] = 0;
                k = 1;
            }
        }
    }

    // Remove trailing zeros.
    for (i = xd.length; xd[--i] === 0;) xd.pop();

    if (external && (x.e > MAX_E || x.e < -MAX_E)) {
        throw Error(exponentOutOfRange + getBase10Exponent(x));
    }

    return x;
}


function subtract(x, y) {
    var d, e, i, j, k, len, xd, xe, xLTy, yd,
        Ctor = x.constructor,
        pr = Ctor.precision;

    // Return y negated if x is zero.
    // Return x if y is zero and x is non-zero.
    if (!x.s || !y.s) {
        if (y.s) y.s = -y.s;
        else y = new Ctor(x);
        return external ? round$1(y, pr) : y;
    }

    xd = x.d;
    yd = y.d;

    // x and y are non-zero numbers with the same sign.

    e = y.e;
    xe = x.e;
    xd = xd.slice();
    k = xe - e;

    // If exponents differ...
    if (k) {
        xLTy = k < 0;

        if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
        } else {
            d = yd;
            e = xe;
            len = xd.length;
        }

        // Numbers with massively different exponents would result in a very high number of zeros
        // needing to be prepended, but this can be avoided while still ensuring correct rounding by
        // limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

        if (k > i) {
            k = i;
            d.length = 1;
        }

        // Prepend zeros to equalise exponents.
        d.reverse();
        for (i = k; i--;) d.push(0);
        d.reverse();

        // Base 1e7 exponents equal.
    } else {

        // Check digits to determine which is the bigger number.

        i = xd.length;
        len = yd.length;
        xLTy = i < len;
        if (xLTy) len = i;

        for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
                xLTy = xd[i] < yd[i];
                break;
            }
        }

        k = 0;
    }

    if (xLTy) {
        d = xd;
        xd = yd;
        yd = d;
        y.s = -y.s;
    }

    len = xd.length;

    // Append zeros to xd if shorter.
    // Don't add zeros to yd if shorter as subtraction only needs to start at yd length.
    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

    // Subtract yd from xd.
    for (i = yd.length; i > k;) {
        if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
            --xd[j];
            xd[i] += BASE;
        }

        xd[i] -= yd[i];
    }

    // Remove trailing zeros.
    for (; xd[--len] === 0;) xd.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xd[0] === 0; xd.shift()) --e;

    // Zero?
    if (!xd[0]) return new Ctor(0);

    y.d = xd;
    y.e = e;

    //return external && xd.length >= pr / LOG_BASE ? round(y, pr) : y;
    return external ? round$1(y, pr) : y;
}


function toString(x, isExp, sd) {
    var k,
        e = getBase10Exponent(x),
        str = digitsToString(x.d),
        len = str.length;

    if (isExp) {
        if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
        } else if (len > 1) {
            str = str.charAt(0) + '.' + str.slice(1);
        }

        str = str + (e < 0 ? 'e' : 'e+') + e;
    } else if (e < 0) {
        str = '0.' + getZeroString(-e - 1) + str;
        if (sd && (k = sd - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
        str += getZeroString(e + 1 - len);
        if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
    } else {
        if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
        if (sd && (k = sd - len) > 0) {
            if (e + 1 === len) str += '.';
            str += getZeroString(k);
        }
    }

    return x.s < 0 ? '-' + str : str;
}


// Does not strip trailing zeros.
function truncate(arr, len) {
    if (arr.length > len) {
        arr.length = len;
        return true;
    }
}


// Decimal methods


/*
 *  clone
 *  config/set
 */


/*
 * Create and return a Decimal constructor with the same configuration properties as this Decimal
 * constructor.
 *
 */
function clone(obj) {
    var i, p, ps;

    /*
     * The Decimal constructor and exported function.
     * Return a new Decimal instance.
     *
     * value {number|string|Decimal} A numeric value.
     *
     */
    function Decimal(value) {
        var x = this;

        // Decimal called without new.
        if (!(x instanceof Decimal)) return new Decimal(value);

        // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
        // which points to Object.
        x.constructor = Decimal;

        // Duplicate.
        if (value instanceof Decimal) {
            x.s = value.s;
            x.e = value.e;
            x.d = (value = value.d) ? value.slice() : value;
            return;
        }

        if (typeof value === 'number') {

            // Reject Infinity/NaN.
            if (value * 0 !== 0) {
                throw Error(invalidArgument + value);
            }

            if (value > 0) {
                x.s = 1;
            } else if (value < 0) {
                value = -value;
                x.s = -1;
            } else {
                x.s = 0;
                x.e = 0;
                x.d = [0];
                return;
            }

            // Fast path for small integers.
            if (value === ~~value && value < 1e7) {
                x.e = 0;
                x.d = [value];
                return;
            }

            return parseDecimal(x, value.toString());
        } else if (typeof value !== 'string') {
            throw Error(invalidArgument + value);
        }

        // Minus sign?
        if (value.charCodeAt(0) === 45) {
            value = value.slice(1);
            x.s = -1;
        } else {
            x.s = 1;
        }

        if (isDecimal.test(value)) parseDecimal(x, value);
        else throw Error(invalidArgument + value);
    }

    Decimal.prototype = P$1;

    Decimal.ROUND_UP = 0;
    Decimal.ROUND_DOWN = 1;
    Decimal.ROUND_CEIL = 2;
    Decimal.ROUND_FLOOR = 3;
    Decimal.ROUND_HALF_UP = 4;
    Decimal.ROUND_HALF_DOWN = 5;
    Decimal.ROUND_HALF_EVEN = 6;
    Decimal.ROUND_HALF_CEIL = 7;
    Decimal.ROUND_HALF_FLOOR = 8;

    Decimal.clone = clone;
    Decimal.config = Decimal.set = config;

    if (obj === void 0) obj = {};
    if (obj) {
        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'LN10'];
        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }

    Decimal.config(obj);

    return Decimal;
}


/*
 * Configure global settings for a Decimal constructor.
 *
 * `obj` is an object with one or more of the following properties,
 *
 *   precision  {number}
 *   rounding   {number}
 *   toExpNeg   {number}
 *   toExpPos   {number}
 *
 * E.g. Decimal.config({ precision: 20, rounding: 4 })
 *
 */
function config(obj) {
    if (!obj || typeof obj !== 'object') {
        throw Error(decimalError + 'Object expected');
    }
    var i, p, v,
        ps = [
            'precision', 1, MAX_DIGITS,
            'rounding', 0, 8,
            'toExpNeg', -1 / 0, 0,
            'toExpPos', 0, 1 / 0
        ];

    for (i = 0; i < ps.length; i += 3) {
        if ((v = obj[p = ps[i]]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
            else throw Error(invalidArgument + p + ': ' + v);
        }
    }

    if ((v = obj[p = 'LN10']) !== void 0) {
        if (v == Math.LN10) this[p] = new this(v);
        else throw Error(invalidArgument + p + ': ' + v);
    }

    return this;
}


// Create and configure initial Decimal constructor.
var Decimal$1 = clone(defaults);

// Internal constant.
ONE = new Decimal$1(1);

var _Decimal = Decimal$1;

/*
 *  big.js v5.2.2
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>
 *  https://github.com/MikeMcl/big.js/LICENCE
 */


/************************************** EDITABLE DEFAULTS *****************************************/


// The default values below must be integers within the stated ranges.

/*
 * The maximum number of decimal places (DP) of the results of operations involving division:
 * div and sqrt, and pow with negative exponents.
 */
var DP = 20,          // 0 to MAX_DP

    /*
     * The rounding mode (RM) used when rounding to the above decimal places.
     *
     *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
     *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
     *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
     *  3  Away from zero.                                  (ROUND_UP)
     */
    RM = 1,             // 0, 1, 2 or 3

    // The maximum value of DP and Big.DP.
    MAX_DP = 1E6,       // 0 to 1000000

    // The maximum magnitude of the exponent argument to the pow method.
    MAX_POWER = 1E6,    // 1 to 1000000

    /*
     * The negative exponent (NE) at and beneath which toString returns exponential notation.
     * (JavaScript numbers: -7)
     * -1000000 is the minimum recommended exponent value of a Big.
     */
    NE = -7,            // 0 to -1000000

    /*
     * The positive exponent (PE) at and above which toString returns exponential notation.
     * (JavaScript numbers: 21)
     * 1000000 is the maximum recommended exponent value of a Big.
     * (This limit is not enforced or checked.)
     */
    PE = 21,            // 0 to 1000000


    /**************************************************************************************************/


    // Error messages.
    NAME = '[big.js] ',
    INVALID = NAME + 'Invalid ',
    INVALID_DP = INVALID + 'decimal places',
    INVALID_RM = INVALID + 'rounding mode',
    DIV_BY_ZERO = NAME + 'Division by zero',

    // The shared prototype object.
    P = {},
    UNDEFINED = void 0,
    NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;


/*
 * Create and return a Big constructor.
 *
 */
function _Big_() {

    /*
     * The Big constructor and exported function.
     * Create and return a new instance of a Big number object.
     *
     * n {number|string|Big} A numeric value.
     */
    function Big(n) {
        var x = this;

        // Enable constructor usage without new.
        if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

        // Duplicate.
        if (n instanceof Big) {
            x.s = n.s;
            x.e = n.e;
            x.c = n.c.slice();
        } else {
            parse(x, n);
        }

        /*
         * Retain a reference to this Big constructor, and shadow Big.prototype.constructor which
         * points to Object.
         */
        x.constructor = Big;
    }

    Big.prototype = P;
    Big.DP = DP;
    Big.RM = RM;
    Big.NE = NE;
    Big.PE = PE;
    Big.version = '5.2.2';

    return Big;
}


/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse(x, n) {
    var e, i, nl;

    // Minus zero?
    if (n === 0 && 1 / n < 0) n = '-0';
    else if (!NUMERIC.test(n += '')) throw Error(INVALID + 'number');

    // Determine sign.
    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

    // Decimal point?
    if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

    // Exponential form?
    if ((i = n.search(/e/i)) > 0) {

        // Determine exponent.
        if (e < 0) e = i;
        e += +n.slice(i + 1);
        n = n.substring(0, i);
    } else if (e < 0) {

        // Integer.
        e = n.length;
    }

    nl = n.length;

    // Determine leading zeros.
    for (i = 0; i < nl && n.charAt(i) == '0';) ++i;

    if (i == nl) {

        // Zero.
        x.c = [x.e = 0];
    } else {

        // Determine trailing zeros.
        for (; nl > 0 && n.charAt(--nl) == '0';);
        x.e = e - i - 1;
        x.c = [];

        // Convert string to array of digits without leading/trailing zeros.
        for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
    }

    return x;
}


/*
 * Round Big x to a maximum of dp decimal places using rounding mode rm.
 * Called by stringify, P.div, P.round and P.sqrt.
 *
 * x {Big} The Big to round.
 * dp {number} Integer, 0 to MAX_DP inclusive.
 * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)
 * [more] {boolean} Whether the result of division was truncated.
 */
function round(x, dp, rm, more) {
    var xc = x.c,
        i = x.e + dp + 1;

    if (i < xc.length) {
        if (rm === 1) {

            // xc[i] is the digit after the digit that may be rounded up.
            more = xc[i] >= 5;
        } else if (rm === 2) {
            more = xc[i] > 5 || xc[i] == 5 &&
                (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);
        } else if (rm === 3) {
            more = more || !!xc[0];
        } else {
            more = false;
            if (rm !== 0) throw Error(INVALID_RM);
        }

        if (i < 1) {
            xc.length = 1;

            if (more) {

                // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                x.e = -dp;
                xc[0] = 1;
            } else {

                // Zero.
                xc[0] = x.e = 0;
            }
        } else {

            // Remove any digits after the required decimal places.
            xc.length = i--;

            // Round up?
            if (more) {

                // Rounding up may mean the previous digit has to be rounded up.
                for (; ++xc[i] > 9;) {
                    xc[i] = 0;
                    if (!i--) {
                        ++x.e;
                        xc.unshift(1);
                    }
                }
            }

            // Remove trailing zeros.
            for (i = xc.length; !xc[--i];) xc.pop();
        }
    } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
        throw Error(INVALID_RM);
    }

    return x;
}


/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 *
 * x {Big}
 * id? {number} Caller id.
 *         1 toExponential
 *         2 toFixed
 *         3 toPrecision
 *         4 valueOf
 * n? {number|undefined} Caller's argument.
 * k? {number|undefined}
 */
function stringify(x, id, n, k) {
    var e, s,
        Big = x.constructor,
        z = !x.c[0];

    if (n !== UNDEFINED) {
        if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
            throw Error(id == 3 ? INVALID + 'precision' : INVALID_DP);
        }

        x = new Big(x);

        // The index of the digit that may be rounded up.
        n = k - x.e;

        // Round?
        if (x.c.length > ++k) round(x, n, Big.RM);

        // toFixed: recalculate k as x.e may have changed if value rounded up.
        if (id == 2) k = x.e + n + 1;

        // Append zeros?
        for (; x.c.length < k;) x.c.push(0);
    }

    e = x.e;
    s = x.c.join('');
    n = s.length;

    // Exponential notation?
    if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big.NE || e >= Big.PE)) {
        s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

        // Normal notation.
    } else if (e < 0) {
        for (; ++e;) s = '0' + s;
        s = '0.' + s;
    } else if (e > 0) {
        if (++e > n) for (e -= n; e--;) s += '0';
        else if (e < n) s = s.slice(0, e) + '.' + s.slice(e);
    } else if (n > 1) {
        s = s.charAt(0) + '.' + s.slice(1);
    }

    return x.s < 0 && (!z || id == 4) ? '-' + s : s;
}


// Prototype/instance methods


/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
    var x = new this.constructor(this);
    x.s = 1;
    return x;
};


/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
*/
P.cmp = function (y) {
    var isneg,
        x = this,
        xc = x.c,
        yc = (y = new x.constructor(y)).c,
        i = x.s,
        j = y.s,
        k = x.e,
        l = y.e;

    // Either zero?
    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    isneg = i < 0;

    // Compare exponents.
    if (k != l) return k > l ^ isneg ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = -1; ++i < j;) {
        if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
    }

    // Compare lengths.
    return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};


/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
    var x = this,
        Big = x.constructor,
        a = x.c,                  // dividend
        b = (y = new Big(y)).c,   // divisor
        k = x.s == y.s ? 1 : -1,
        dp = Big.DP;

    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) throw Error(INVALID_DP);

    // Divisor is zero?
    if (!b[0]) throw Error(DIV_BY_ZERO);

    // Dividend is 0? Return +-0.
    if (!a[0]) return new Big(k * 0);

    var bl, bt, n, cmp, ri,
        bz = b.slice(),
        ai = bl = b.length,
        al = a.length,
        r = a.slice(0, bl),   // remainder
        rl = r.length,
        q = y,                // quotient
        qc = q.c = [],
        qi = 0,
        d = dp + (q.e = x.e - y.e) + 1;    // number of digits of the result

    q.s = k;
    k = d < 0 ? 0 : d;

    // Create version of divisor with leading zero.
    bz.unshift(0);

    // Add zeros to make remainder as long as divisor.
    for (; rl++ < bl;) r.push(0);

    do {

        // n is how many times the divisor goes into current remainder.
        for (n = 0; n < 10; n++) {

            // Compare divisor and remainder.
            if (bl != (rl = r.length)) {
                cmp = bl > rl ? 1 : -1;
            } else {
                for (ri = -1, cmp = 0; ++ri < bl;) {
                    if (b[ri] != r[ri]) {
                        cmp = b[ri] > r[ri] ? 1 : -1;
                        break;
                    }
                }
            }

            // If divisor < remainder, subtract divisor from remainder.
            if (cmp < 0) {

                // Remainder can't be more than 1 digit longer than divisor.
                // Equalise lengths using divisor with extra leading zero?
                for (bt = rl == bl ? b : bz; rl;) {
                    if (r[--rl] < bt[rl]) {
                        ri = rl;
                        for (; ri && !r[--ri];) r[ri] = 9;
                        --r[ri];
                        r[rl] += 10;
                    }
                    r[rl] -= bt[rl];
                }

                for (; !r[0];) r.shift();
            } else {
                break;
            }
        }

        // Add the digit n to the result array.
        qc[qi++] = cmp ? n : ++n;

        // Update the remainder.
        if (r[0] && cmp) r[rl] = a[ai] || 0;
        else r = [a[ai]];

    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

    // Leading zero? Do not remove if result is simply zero (qi == 1).
    if (!qc[0] && qi != 1) {

        // There can't be more than one zero.
        qc.shift();
        q.e--;
    }

    // Round?
    if (qi > d) round(q, dp, Big.RM, r[0] !== UNDEFINED);

    return q;
};


/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
    return !this.cmp(y);
};


/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
    return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
    return this.cmp(y) > -1;
};


/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
    return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
    return this.cmp(y) < 1;
};


/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
    var i, j, t, xlty,
        x = this,
        Big = x.constructor,
        a = x.s,
        b = (y = new Big(y)).s;

    // Signs differ?
    if (a != b) {
        y.s = -b;
        return x.plus(y);
    }

    var xc = x.c.slice(),
        xe = x.e,
        yc = y.c,
        ye = y.e;

    // Either zero?
    if (!xc[0] || !yc[0]) {

        // y is non-zero? x is non-zero? Or both are zero.
        return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);
    }

    // Determine which is the bigger number. Prepend zeros to equalise exponents.
    if (a = xe - ye) {

        if (xlty = a < 0) {
            a = -a;
            t = xc;
        } else {
            ye = xe;
            t = yc;
        }

        t.reverse();
        for (b = a; b--;) t.push(0);
        t.reverse();
    } else {

        // Exponents equal. Check digit by digit.
        j = ((xlty = xc.length < yc.length) ? xc : yc).length;

        for (a = b = 0; b < j; b++) {
            if (xc[b] != yc[b]) {
                xlty = xc[b] < yc[b];
                break;
            }
        }
    }

    // x < y? Point xc to the array of the bigger number.
    if (xlty) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
    }

    /*
     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
     * needs to start at yc.length.
     */
    if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

    // Subtract yc from xc.
    for (b = i; j > a;) {
        if (xc[--j] < yc[j]) {
            for (i = j; i && !xc[--i];) xc[i] = 9;
            --xc[i];
            xc[j] += 10;
        }

        xc[j] -= yc[j];
    }

    // Remove trailing zeros.
    for (; xc[--b] === 0;) xc.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xc[0] === 0;) {
        xc.shift();
        --ye;
    }

    if (!xc[0]) {

        // n - n = +0
        y.s = 1;

        // Result must be zero.
        xc = [ye = 0];
    }

    y.c = xc;
    y.e = ye;

    return y;
};


/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
    var ygtx,
        x = this,
        Big = x.constructor,
        a = x.s,
        b = (y = new Big(y)).s;

    if (!y.c[0]) throw Error(DIV_BY_ZERO);

    x.s = y.s = 1;
    ygtx = y.cmp(x) == 1;
    x.s = a;
    y.s = b;

    if (ygtx) return new Big(x);

    a = Big.DP;
    b = Big.RM;
    Big.DP = Big.RM = 0;
    x = x.div(y);
    Big.DP = a;
    Big.RM = b;

    return this.minus(x.times(y));
};


/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
    var t,
        x = this,
        Big = x.constructor,
        a = x.s,
        b = (y = new Big(y)).s;

    // Signs differ?
    if (a != b) {
        y.s = -b;
        return x.minus(y);
    }

    var xe = x.e,
        xc = x.c,
        ye = y.e,
        yc = y.c;

    // Either zero? y is non-zero? x is non-zero? Or both are zero.
    if (!xc[0] || !yc[0]) return yc[0] ? y : new Big(xc[0] ? x : a * 0);

    xc = xc.slice();

    // Prepend zeros to equalise exponents.
    // Note: reverse faster than unshifts.
    if (a = xe - ye) {
        if (a > 0) {
            ye = xe;
            t = yc;
        } else {
            a = -a;
            t = xc;
        }

        t.reverse();
        for (; a--;) t.push(0);
        t.reverse();
    }

    // Point xc to the longer array.
    if (xc.length - yc.length < 0) {
        t = yc;
        yc = xc;
        xc = t;
    }

    a = yc.length;

    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
    for (b = 0; a; xc[a] %= 10) b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;

    // No need to check for zero, as +x + +y != 0 && -x + -y != 0

    if (b) {
        xc.unshift(b);
        ++ye;
    }

    // Remove trailing zeros.
    for (a = xc.length; xc[--a] === 0;) xc.pop();

    y.c = xc;
    y.e = ye;

    return y;
};


/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
    var x = this,
        one = new x.constructor(1),
        y = one,
        isneg = n < 0;

    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) throw Error(INVALID + 'exponent');
    if (isneg) n = -n;

    for (; ;) {
        if (n & 1) y = y.times(x);
        n >>= 1;
        if (!n) break;
        x = x.times(x);
    }

    return isneg ? one.div(y) : y;
};


/*
 * Return a new Big whose value is the value of this Big rounded using rounding mode rm
 * to a maximum of dp decimal places, or, if dp is negative, to an integer which is a
 * multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 * If rm is not specified, use Big.RM.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)
 */
P.round = function (dp, rm) {
    var Big = this.constructor;
    if (dp === UNDEFINED) dp = 0;
    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) throw Error(INVALID_DP);
    return round(new Big(this), dp, rm === UNDEFINED ? Big.RM : rm);
};


/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
    var r, c, t,
        x = this,
        Big = x.constructor,
        s = x.s,
        e = x.e,
        half = new Big(0.5);

    // Zero?
    if (!x.c[0]) return new Big(x);

    // Negative?
    if (s < 0) throw Error(NAME + 'No square root');

    // Estimate.
    s = Math.sqrt(x + '');

    // Math.sqrt underflow/overflow?
    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
    if (s === 0 || s === 1 / 0) {
        c = x.c.join('');
        if (!(c.length + e & 1)) c += '0';
        s = Math.sqrt(c);
        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
        r = new Big((s == 1 / 0 ? '1e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
    } else {
        r = new Big(s);
    }

    e = r.e + (Big.DP += 4);

    // Newton-Raphson iteration.
    do {
        t = r;
        r = half.times(t.plus(x.div(t)));
    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));

    return round(r, Big.DP -= 4, Big.RM);
};


/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
    var c,
        x = this,
        Big = x.constructor,
        xc = x.c,
        yc = (y = new Big(y)).c,
        a = xc.length,
        b = yc.length,
        i = x.e,
        j = y.e;

    // Determine sign of result.
    y.s = x.s == y.s ? 1 : -1;

    // Return signed 0 if either 0.
    if (!xc[0] || !yc[0]) return new Big(y.s * 0);

    // Initialise exponent of result as x.e + y.e.
    y.e = i + j;

    // If array xc has fewer digits than yc, swap xc and yc, and lengths.
    if (a < b) {
        c = xc;
        xc = yc;
        yc = c;
        j = a;
        a = b;
        b = j;
    }

    // Initialise coefficient array of result with zeros.
    for (c = new Array(j = a + b); j--;) c[j] = 0;

    // Multiply.

    // i is initially xc.length.
    for (i = b; i--;) {
        b = 0;

        // a is yc.length.
        for (j = a + i; j > i;) {

            // Current sum of products at this digit position, plus carry.
            b = c[j] + yc[i] * xc[j - i - 1] + b;
            c[j--] = b % 10;

            // carry
            b = b / 10 | 0;
        }

        c[j] = (c[j] + b) % 10;
    }

    // Increment result exponent if there is a final carry, otherwise remove leading zero.
    if (b) ++y.e;
    else c.shift();

    // Remove trailing zeros.
    for (i = c.length; !c[--i];) c.pop();
    y.c = c;

    return y;
};


/*
 * Return a string representing the value of this Big in exponential notation to dp fixed decimal
 * places and rounded using Big.RM.
 *
 * dp? {number} Integer, 0 to MAX_DP inclusive.
 */
P.toExponential = function (dp) {
    return stringify(this, 1, dp, dp);
};


/*
 * Return a string representing the value of this Big in normal notation to dp fixed decimal
 * places and rounded using Big.RM.
 *
 * dp? {number} Integer, 0 to MAX_DP inclusive.
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp) {
    return stringify(this, 2, dp, this.e + dp);
};


/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * Big.RM. Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Integer, 1 to MAX_DP inclusive.
 */
P.toPrecision = function (sd) {
    return stringify(this, 3, sd, sd - 1);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P.toString = function () {
    return stringify(this);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = P.toJSON = function () {
    return stringify(this, 4);
};


// Export


var Big$1 = _Big_();

var toFormat$1 = { exports: {} };

/*
 *  toFormat v2.0.0
 *  Adds a toFormat instance method to big.js or decimal.js
 *  Copyright (c) 2017 Michael Mclaughlin
 *  MIT Licence
 */

(function (module) {
    /*
     * Adds a `toFormat` method to `Ctor.prototype` and a `format` object to `Ctor`, where `Ctor` is
     * a big number constructor such as `Decimal` (decimal.js) or `Big` (big.js).
     */
    function toFormat(Ctor) {

        /*
         *  Returns a string representing the value of this big number in fixed-point notation to `dp`
         *  decimal places using rounding mode `rm`, and formatted according to the properties of the
         * `fmt`, `this.format` and `this.constructor.format` objects, in that order of precedence.
         *
         *  Example:
         *
         *  x = new Decimal('123456789.987654321')
         *
         *  // Add a format object to the constructor...
         *  Decimal.format = {
         *    decimalSeparator: '.',
         *    groupSeparator: ',',
         *    groupSize: 3,
         *    secondaryGroupSize: 0,
         *    fractionGroupSeparator: '',     // '\xA0' non-breaking space
         *    fractionGroupSize : 0
         *  }
         *
         *  x.toFormat();                // 123,456,789.987654321
         *  x.toFormat(2, 1);            // 123,456,789.98
         *
         *  // And/or add a format object to the big number itself...
         *  x.format = {
         *    decimalSeparator: ',',
         *    groupSeparator: '',
         *  }
         *
         *  x.toFormat();                // 123456789,987654321
         *
         *  format = {
         *    decimalSeparator: '.',
         *    groupSeparator: ' ',
         *    groupSize: 3,
         *    fractionGroupSeparator: ' ',     // '\xA0' non-breaking space
         *    fractionGroupSize : 5
         *  }
      
         *  // And/or pass a format object to the method call.
         *  x.toFormat(format);          // 123 456 789.98765 4321
         *  x.toFormat(4, format);       // 123 456 789.9877
         *  x.toFormat(2, 1, format);    // 123 456 789.98
         *
         *  [dp] {number} Decimal places. Integer.
         *  [rm] {number} Rounding mode. Integer, 0 to 8. (Ignored if using big.js.)
         *  [fmt] {Object} A format object.
         *
         */
        Ctor.prototype.toFormat = function toFormat(dp, rm, fmt) {

            if (!this.e && this.e !== 0) return this.toString();   // Infinity/NaN

            var arr, g1, g2, i,
                u,                             // undefined
                nd,                            // number of integer digits
                intd,                          // integer digits
                intp,                          // integer part
                fracp,                         // fraction part
                dsep,                          // decimalSeparator
                gsep,                          // groupSeparator
                gsize,                         // groupSize
                sgsize,                        // secondaryGroupSize
                fgsep,                         // fractionGroupSeparator
                fgsize,                        // fractionGroupSize
                tfmt = this.format || {},
                cfmt = this.constructor.format || {};

            if (dp != u) {
                if (typeof dp == 'object') {
                    fmt = dp;
                    dp = u;
                } else if (rm != u) {
                    if (typeof rm == 'object') {
                        fmt = rm;
                        rm = u;
                    } else if (typeof fmt != 'object') {
                        fmt = {};
                    }
                } else {
                    fmt = {};
                }
            } else {
                fmt = {};
            }

            arr = this.toFixed(dp, rm).split('.');
            intp = arr[0];
            fracp = arr[1];
            intd = this.s < 0 ? intp.slice(1) : intp;
            nd = intd.length;

            dsep = fmt.decimalSeparator;
            if (dsep == u) {
                dsep = tfmt.decimalSeparator;
                if (dsep == u) {
                    dsep = cfmt.decimalSeparator;
                    if (dsep == u) dsep = '.';
                }
            }

            gsep = fmt.groupSeparator;
            if (gsep == u) {
                gsep = tfmt.groupSeparator;
                if (gsep == u) gsep = cfmt.groupSeparator;
            }

            if (gsep) {
                gsize = fmt.groupSize;
                if (gsize == u) {
                    gsize = tfmt.groupSize;
                    if (gsize == u) {
                        gsize = cfmt.groupSize;
                        if (gsize == u) gsize = 0;
                    }
                }

                sgsize = fmt.secondaryGroupSize;
                if (sgsize == u) {
                    sgsize = tfmt.secondaryGroupSize;
                    if (sgsize == u) {
                        sgsize = cfmt.secondaryGroupSize;
                        if (sgsize == u) sgsize = 0;
                    }
                }

                if (sgsize) {
                    g1 = +sgsize;
                    g2 = +gsize;
                    nd -= g2;
                } else {
                    g1 = +gsize;
                    g2 = +sgsize;
                }

                if (g1 > 0 && nd > 0) {
                    i = nd % g1 || g1;
                    intp = intd.substr(0, i);
                    for (; i < nd; i += g1) intp += gsep + intd.substr(i, g1);
                    if (g2 > 0) intp += gsep + intd.slice(i);
                    if (this.s < 0) intp = '-' + intp;
                }
            }

            if (fracp) {
                fgsep = fmt.fractionGroupSeparator;
                if (fgsep == u) {
                    fgsep = tfmt.fractionGroupSeparator;
                    if (fgsep == u) fgsep = cfmt.fractionGroupSeparator;
                }

                if (fgsep) {
                    fgsize = fmt.fractionGroupSize;
                    if (fgsize == u) {
                        fgsize = tfmt.fractionGroupSize;
                        if (fgsize == u) {
                            fgsize = cfmt.fractionGroupSize;
                            if (fgsize == u) fgsize = 0;
                        }
                    }

                    fgsize = +fgsize;

                    if (fgsize) {
                        fracp = fracp.replace(new RegExp('\\d{' + fgsize + '}\\B', 'g'), '$&' + fgsep);
                    }
                }

                return intp + dsep + fracp;
            } else {

                return intp;
            }
        };

        Ctor.format = {
            decimalSeparator: '.',
            groupSeparator: ',',
            groupSize: 3,
            secondaryGroupSize: 0,
            fractionGroupSeparator: '',
            fractionGroupSize: 0
        };

        return Ctor;
    }

    if (module.exports) module.exports = toFormat;
}(toFormat$1));

var toFormat = toFormat$1.exports;

var SupportedChainId;

(function (SupportedChainId) {
    SupportedChainId[SupportedChainId["MAINNET"] = 1] = "MAINNET";
    SupportedChainId[SupportedChainId["ROPSTEN"] = 3] = "ROPSTEN";
    SupportedChainId[SupportedChainId["RINKEBY"] = 4] = "RINKEBY";
    SupportedChainId[SupportedChainId["GOERLI"] = 5] = "GOERLI";
    SupportedChainId[SupportedChainId["KOVAN"] = 42] = "KOVAN";
    SupportedChainId[SupportedChainId["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
    SupportedChainId[SupportedChainId["ARBITRUM_RINKEBY"] = 421611] = "ARBITRUM_RINKEBY";
    SupportedChainId[SupportedChainId["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
    SupportedChainId[SupportedChainId["OPTIMISM"] = 10] = "OPTIMISM";
    SupportedChainId[SupportedChainId["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
    SupportedChainId[SupportedChainId["POLYGON"] = 137] = "POLYGON";
    SupportedChainId[SupportedChainId["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
    SupportedChainId[SupportedChainId["CELO"] = 42220] = "CELO";
    SupportedChainId[SupportedChainId["CELO_ALFAJORES"] = 44787] = "CELO_ALFAJORES";
})(SupportedChainId || (SupportedChainId = {}));

var TradeType$1;

(function (TradeType) {
    TradeType[TradeType["EXACT_INPUT"] = 0] = "EXACT_INPUT";
    TradeType[TradeType["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType$1 || (TradeType$1 = {}));

var Rounding;

(function (Rounding) {
    Rounding[Rounding["ROUND_DOWN"] = 0] = "ROUND_DOWN";
    Rounding[Rounding["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
    Rounding[Rounding["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding || (Rounding = {}));

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}

var _toSignificantRoundin, _toFixedRounding;
var Decimal = /*#__PURE__*/toFormat(_Decimal);
var Big = /*#__PURE__*/toFormat(Big$1);
var toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);
var toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);
var Fraction = /*#__PURE__*/function () {
    function Fraction(numerator, denominator) {
        if (denominator === void 0) {
            denominator = JSBI.BigInt(1);
        }

        this.numerator = JSBI.BigInt(numerator);
        this.denominator = JSBI.BigInt(denominator);
    }

    Fraction.tryParseFraction = function tryParseFraction(fractionish) {
        if (fractionish instanceof JSBI || typeof fractionish === 'number' || typeof fractionish === 'string') return new Fraction(fractionish);
        if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish;
        throw new Error('Could not parse fraction');
    } // performs floor division
        ;

    var _proto = Fraction.prototype;

    _proto.invert = function invert() {
        return new Fraction(this.denominator, this.numerator);
    };

    _proto.add = function add(other) {
        var otherParsed = Fraction.tryParseFraction(other);

        if (JSBI.equal(this.denominator, otherParsed.denominator)) {
            return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);
        }

        return new Fraction(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
    };

    _proto.subtract = function subtract(other) {
        var otherParsed = Fraction.tryParseFraction(other);

        if (JSBI.equal(this.denominator, otherParsed.denominator)) {
            return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);
        }

        return new Fraction(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
    };

    _proto.lessThan = function lessThan(other) {
        var otherParsed = Fraction.tryParseFraction(other);
        return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
    };

    _proto.equalTo = function equalTo(other) {
        var otherParsed = Fraction.tryParseFraction(other);
        return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
    };

    _proto.greaterThan = function greaterThan(other) {
        var otherParsed = Fraction.tryParseFraction(other);
        return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
    };

    _proto.multiply = function multiply(other) {
        var otherParsed = Fraction.tryParseFraction(other);
        return new Fraction(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));
    };

    _proto.divide = function divide(other) {
        var otherParsed = Fraction.tryParseFraction(other);
        return new Fraction(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));
    };

    _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (format === void 0) {
            format = {
                groupSeparator: ''
            };
        }

        if (rounding === void 0) {
            rounding = Rounding.ROUND_HALF_UP;
        }

        !Number.isInteger(significantDigits) ? process.env.NODE_ENV !== "production" ? invariant(false, significantDigits + " is not an integer.") : invariant(false) : void 0;
        !(significantDigits > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, significantDigits + " is not positive.") : invariant(false) : void 0;
        Decimal.set({
            precision: significantDigits + 1,
            rounding: toSignificantRounding[rounding]
        });
        var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
        return quotient.toFormat(quotient.decimalPlaces(), format);
    };

    _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (format === void 0) {
            format = {
                groupSeparator: ''
            };
        }

        if (rounding === void 0) {
            rounding = Rounding.ROUND_HALF_UP;
        }

        !Number.isInteger(decimalPlaces) ? process.env.NODE_ENV !== "production" ? invariant(false, decimalPlaces + " is not an integer.") : invariant(false) : void 0;
        !(decimalPlaces >= 0) ? process.env.NODE_ENV !== "production" ? invariant(false, decimalPlaces + " is negative.") : invariant(false) : void 0;
        Big.DP = decimalPlaces;
        Big.RM = toFixedRounding[rounding];
        return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
    }
        /**
         * Helper method for converting any super class back to a fraction
         */
        ;

    _createClass(Fraction, [{
        key: "quotient",
        get: function get() {
            return JSBI.divide(this.numerator, this.denominator);
        } // remainder after floor division

    }, {
        key: "remainder",
        get: function get() {
            return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator);
        }
    }, {
        key: "asFraction",
        get: function get() {
            return new Fraction(this.numerator, this.denominator);
        }
    }]);

    return Fraction;
}();

var ONE_HUNDRED = /*#__PURE__*/new Fraction( /*#__PURE__*/JSBI.BigInt(100));
/**
 * Converts a fraction to a percent
 * @param fraction the fraction to convert
 */

function toPercent(fraction) {
    return new Percent(fraction.numerator, fraction.denominator);
}

var Percent = /*#__PURE__*/function (_Fraction) {
    _inheritsLoose(Percent, _Fraction);

    function Percent() {
        var _this;

        _this = _Fraction.apply(this, arguments) || this;
        /**
         * This boolean prevents a fraction from being interpreted as a Percent
         */

        _this.isPercent = true;
        return _this;
    }

    var _proto = Percent.prototype;

    _proto.add = function add(other) {
        return toPercent(_Fraction.prototype.add.call(this, other));
    };

    _proto.subtract = function subtract(other) {
        return toPercent(_Fraction.prototype.subtract.call(this, other));
    };

    _proto.multiply = function multiply(other) {
        return toPercent(_Fraction.prototype.multiply.call(this, other));
    };

    _proto.divide = function divide(other) {
        return toPercent(_Fraction.prototype.divide.call(this, other));
    };

    _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (significantDigits === void 0) {
            significantDigits = 5;
        }

        return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);
    };

    _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (decimalPlaces === void 0) {
            decimalPlaces = 2;
        }

        return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);
    };

    return Percent;
}(Fraction);

/**
 * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies
 */

var BaseCurrency =
    /**
     * Constructs an instance of the base class `BaseCurrency`.
     * @param chainId the chain ID on which this currency resides
     * @param decimals decimals of the currency
     * @param symbol symbol of the currency
     * @param name of the currency
     */
    function BaseCurrency(chainId, decimals, symbol, name) {
        !Number.isSafeInteger(chainId) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;
        !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;
        this.chainId = chainId;
        this.decimals = decimals;
        this.symbol = symbol;
        this.name = name;
    };

/**
 * Validates an address and returns the parsed (checksummed) version of that address
 * @param address the unchecksummed hex address
 */

function validateAndParseAddress(address) {
    try {
        return getAddress(address);
    } catch (error) {
        throw new Error(address + " is not a valid address.");
    }
} // Checks a string starts with 0x, is 42 characters long and contains only hex characters after 0x

var startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/;
/**
 * Checks if an address is valid by checking 0x prefix, length === 42 and hex encoding.
 * @param address the unchecksummed hex address
 */

function checkValidAddress(address) {
    if (startsWith0xLen42HexRegex.test(address)) {
        return address;
    }

    throw new Error(address + " is not a valid address.");
}

/**
 * Represents an ERC20 token with a unique address and some metadata.
 */

var Token = /*#__PURE__*/function (_BaseCurrency) {
    _inheritsLoose(Token, _BaseCurrency);

    /**
     *
     * @param chainId {@link BaseCurrency#chainId}
     * @param address The contract address on the chain on which this token lives
     * @param decimals {@link BaseCurrency#decimals}
     * @param symbol {@link BaseCurrency#symbol}
     * @param name {@link BaseCurrency#name}
     * @param bypassChecksum If true it only checks for length === 42, startsWith 0x and contains only hex characters
     */
    function Token(chainId, address, decimals, symbol, name, bypassChecksum) {
        var _this;

        _this = _BaseCurrency.call(this, chainId, decimals, symbol, name) || this;
        _this.isNative = false;
        _this.isToken = true;

        if (bypassChecksum) {
            _this.address = checkValidAddress(address);
        } else {
            _this.address = validateAndParseAddress(address);
        }

        return _this;
    }
    /**
     * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.
     * @param other other token to compare
     */


    var _proto = Token.prototype;

    _proto.equals = function equals(other) {
        return other.isToken && this.chainId === other.chainId && this.address === other.address;
    }
        /**
         * Returns true if the address of this token sorts before the address of the other token
         * @param other other token to compare
         * @throws if the tokens have the same address
         * @throws if the tokens are on different chains
         */
        ;

    _proto.sortsBefore = function sortsBefore(other) {
        !(this.chainId === other.chainId) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CHAIN_IDS') : invariant(false) : void 0;
        !(this.address !== other.address) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ADDRESSES') : invariant(false) : void 0;
        return this.address.toLowerCase() < other.address.toLowerCase();
    }
        /**
         * Return this token, which does not need to be wrapped
         */
        ;

    _createClass(Token, [{
        key: "wrapped",
        get: function get() {
            return this;
        }
    }]);

    return Token;
}(BaseCurrency);

var _WETH;
/**
 * Known WETH9 implementation addresses, used in our implementation of Ether#wrapped
 */

(_WETH = {}, _WETH[1] = /*#__PURE__*/new Token(1, '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', 18, 'WETH', 'Wrapped Ether'), _WETH[3] = /*#__PURE__*/new Token(3, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[4] = /*#__PURE__*/new Token(4, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[5] = /*#__PURE__*/new Token(5, '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6', 18, 'WETH', 'Wrapped Ether'), _WETH[42] = /*#__PURE__*/new Token(42, '0xd0A1E359811322d97991E03f863a0C30C2cF029C', 18, 'WETH', 'Wrapped Ether'), _WETH[10] = /*#__PURE__*/new Token(10, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[69] = /*#__PURE__*/new Token(69, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[42161] = /*#__PURE__*/new Token(42161, '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1', 18, 'WETH', 'Wrapped Ether'), _WETH[421611] = /*#__PURE__*/new Token(421611, '0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681', 18, 'WETH', 'Wrapped Ether'), _WETH);

function computeFiatValuePriceImpact(fiatValueInput, fiatValueOutput) {
    if (!fiatValueOutput || !fiatValueInput)
        return undefined;
    //if (!fiatValueInput.currency.equals(fiatValueOutput.currency)) return undefined
    if (JSBI.equal(fiatValueInput.quotient, JSBI.BigInt(0)))
        return undefined;
    const pct = new Percent('1').subtract(fiatValueOutput.divide(fiatValueInput));
    return new Percent(pct.numerator, pct.denominator);
}

const ContentBox$3 = styled(Box)`
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  padding: 15px;
  border-radius: 8px;
  margin-top: 10px;
`;
const DataBox$3 = styled(Box)`
  align-items: center;
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const ValueText$1 = styled(Text)`
  color: ${({ theme, severity }) => {
        var _a, _b;
        return severity === 3 || severity === 4
            ? theme.error
            : severity === 2
                ? theme.warning
                : severity === 1
                    ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary
                    : severity === 0
                        ? theme.success
                        : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.secondary;
    }};
`;

const LimitOrderDetailInfo = ({ trade }) => {
    var _a, _b, _c, _d;
    const { chainId } = usePangolinWeb3();
    const { derivedOrderInfo: { parsedAmounts, rawAmounts }, } = useGelatoLimitOrders();
    const { gasPrice, realExecutionPriceAsString } = useGasOverhead(parsedAmounts.input, parsedAmounts.output);
    const priceText = realExecutionPriceAsString === 'never executes'
        ? realExecutionPriceAsString
        : `${(_b = '1 ' + ((_a = parsedAmounts === null || parsedAmounts === void 0 ? void 0 : parsedAmounts.input) === null || _a === void 0 ? void 0 : _a.currency.symbol) + ' = ' + realExecutionPriceAsString) !== null && _b !== void 0 ? _b : '-'} ${(_c = parsedAmounts === null || parsedAmounts === void 0 ? void 0 : parsedAmounts.output) === null || _c === void 0 ? void 0 : _c.currency.symbol}`;
    const formattedGasPrice = gasPrice ? `${parseFloat(formatUnits(gasPrice, 'gwei')).toFixed(0)} GWEI` : '-';
    const library = useGelatoLimitOrdersLib();
    const outputAmount = parsedAmounts.output;
    const rawOutputAmount = (_d = rawAmounts.output) !== null && _d !== void 0 ? _d : '0';
    const { minReturn, slippagePercentage, gelatoFeePercentage } = useMemo(() => {
        var _a;
        if (!outputAmount || !library || !chainId)
            return {
                minReturn: undefined,
                slippagePercentage: undefined,
                gelatoFeePercentage: undefined,
            };
        const { minReturn } = library.getFeeAndSlippageAdjustedMinReturn(rawOutputAmount);
        const slippagePercentage = library.slippageBPS / 100;
        const gelatoFeePercentage = library.gelatoFeeBPS / 100;
        //const minReturnParsed = CurrencyAmount.fromRawAmount(trade?.outputAmount?.currency, minReturn)
        const minReturnParsed = new TokenAmount((_a = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _a === void 0 ? void 0 : _a.currency, minReturn);
        return {
            minReturn: minReturnParsed,
            slippagePercentage,
            gelatoFeePercentage,
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [outputAmount, chainId, library, rawOutputAmount]);
    const renderRow = (label, value) => {
        return (jsxs(DataBox$3, { children: [jsx(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 14 }, { children: label })), jsx(ValueText$1, Object.assign({ fontSize: 14 }, { children: value }))] }, label));
    };
    return (jsxs(ContentBox$3, {
        children: [renderRow('Gas Price', `${formattedGasPrice}`), renderRow('Real Execution Price', `${realExecutionPriceAsString ? `${priceText}` : '-'}`), renderRow('Gelato Fee', `${gelatoFeePercentage ? `${gelatoFeePercentage}` : '-'}%`), slippagePercentage !== INITIAL_ALLOWED_SLIPPAGE &&
            renderRow('Slippage Tolerance', `${slippagePercentage ? `${slippagePercentage}` : '-'}%`), renderRow(minReturn ? 'Minimum Received' : 'Maximum Sold', minReturn ? `${minReturn.toSignificant(4)} ${outputAmount ? outputAmount.currency.symbol : '-'}` : '-')]
    }));
};

function FiatValue({ fiatValue, priceImpact, }) {
    var _a;
    const theme = useContext(ThemeContext);
    const priceImpactColor = useMemo(() => {
        var _a;
        if (!priceImpact)
            return undefined;
        if (priceImpact.lessThan('0'))
            return theme.success;
        const severity = warningSeverity(priceImpact);
        if (severity < 1)
            return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary;
        if (severity < 3)
            return theme.warning;
        return theme.error;
    }, [priceImpact, theme.success, theme.error, (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary, theme.warning]);
    return (jsxs(Text, Object.assign({ fontSize: 14, color: fiatValue ? 'swapWidget.primary' : 'swapWidget.secondary', ml: 10 }, { children: [fiatValue ? '~' : '', "$", fiatValue ? fiatValue === null || fiatValue === void 0 ? void 0 : fiatValue.toSignificant(6, { groupSeparator: ',' }) : '-', priceImpact ? (jsxs("span", Object.assign({ style: { color: priceImpactColor } }, { children: [" (", priceImpact.multiply('-1').toSignificant(3), "%)"] }))) : null] })));
}

const Root$j = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const Header$5 = styled(Box)`
  padding: 0px 10px;
`;
const TokenRow$2 = styled(Box)`
  display: grid;
  grid-template-columns: max-content auto max-content;
  align-items: center;
`;
styled(Box)`
  padding: 10px;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 8px;
  margin-top: 15px;
`;
styled(Text)`
  width: 100%;
  font-style: italic;
  font-size: 12px;
  text-align: left;
`;
const Footer$3 = styled(Box)`
  padding: 0px 10px;
`;
const ErrorWrapper$6 = styled(Box)`
  display: grid;
  grid-template-rows: minmax(300px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const ErrorBox$6 = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const SubmittedWrapper$3 = styled(Box)`
  display: grid;
  grid-template-rows: minmax(300px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const Link$3 = styled(Text)`
  text-decoration: none;
`;

const ConfirmLimitOrderDrawer = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { isOpen, onClose, trade, onAcceptChanges, recipient, onConfirm, attemptingTxn, swapErrorMessage, txHash } = props;
    const [showInverted, setShowInverted] = useState(false);
    const chainId = useChainId();
    const theme = useContext(ThemeContext);
    const { derivedOrderInfo: { price, parsedAmounts }, } = useGelatoLimitOrders();
    let formattedPrice;
    try {
        formattedPrice = showInverted ? price === null || price === void 0 ? void 0 : price.toSignificant(4) : (_a = price === null || price === void 0 ? void 0 : price.invert()) === null || _a === void 0 ? void 0 : _a.toSignificant(4);
    }
    catch (error) {
        formattedPrice = '0';
    }
    const label = showInverted ? `${(_b = price === null || price === void 0 ? void 0 : price.quoteCurrency) === null || _b === void 0 ? void 0 : _b.symbol}` : `${(_c = price === null || price === void 0 ? void 0 : price.baseCurrency) === null || _c === void 0 ? void 0 : _c.symbol} `;
    const labelInverted = showInverted ? `${(_d = price === null || price === void 0 ? void 0 : price.baseCurrency) === null || _d === void 0 ? void 0 : _d.symbol} ` : `${(_e = price === null || price === void 0 ? void 0 : price.quoteCurrency) === null || _e === void 0 ? void 0 : _e.symbol}`;
    const text = `${(_f = '1 ' + labelInverted + ' = ' + formattedPrice) !== null && _f !== void 0 ? _f : '-'} ${label}`;
    const flipPrice = useCallback(() => setShowInverted(!showInverted), [setShowInverted, showInverted]);
    const showAcceptChanges = false;
    const inputAmount = parsedAmounts.input;
    const outputAmount = parsedAmounts.output;
    const inputCurrency1 = inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.currency;
    const outputCurrency1 = outputAmount === null || outputAmount === void 0 ? void 0 : outputAmount.currency;
    const inputTokenInfo = inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.tokenInfo;
    const outputTokenInfo = outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.tokenInfo;
    const getInputCurrency = () => {
        if (inputCurrency1 && (inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.symbol) === CAVAX[chainId].symbol) {
            return CAVAX[chainId];
        }
        else if (inputTokenInfo && inputTokenInfo.symbol === CAVAX[chainId].symbol) {
            return CAVAX[chainId];
        }
        else if (inputTokenInfo) {
            return new Token$1(inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.chainId, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.address, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.decimals, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.symbol, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.name);
        }
        else if (inputCurrency1) {
            return new Token$1(inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.chainId, inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.address, inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.decimals, inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.symbol, inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.name);
        }
        else {
            return undefined;
        }
    };
    const getOutputCurrency = () => {
        if (outputCurrency1 && (outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.symbol) === CAVAX[chainId].symbol) {
            return CAVAX[chainId];
        }
        else if (outputTokenInfo && (outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.symbol) === CAVAX[chainId].symbol) {
            return CAVAX[chainId];
        }
        else if (outputTokenInfo) {
            return new Token$1(outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.chainId, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.address, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.decimals, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.symbol, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.name);
        }
        else if (outputCurrency1) {
            return new Token$1(outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.chainId, outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.address, outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.decimals, outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.symbol, outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.name);
        }
        else {
            return undefined;
        }
    };
    const inputCurrency = getInputCurrency();
    const outputCurrency = getOutputCurrency();
    const fiatValueInput = useUSDCPrice(inputCurrency);
    const fiatValueOutput = useUSDCPrice(outputCurrency);
    if (!inputAmount || !outputAmount)
        return null;
    // text to show while loading
    const pendingText = `Submitting order to swap ${(_g = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _g === void 0 ? void 0 : _g.toSignificant(6)} ${inputCurrency === null || inputCurrency === void 0 ? void 0 : inputCurrency.symbol} for ${(_h = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _h === void 0 ? void 0 : _h.toSignificant(6)} ${outputCurrency === null || outputCurrency === void 0 ? void 0 : outputCurrency.symbol}`;
    const ConfirmContent = (jsxs(Root$j, { children: [jsxs(Header$5, { children: [jsxs(TokenRow$2, { children: [jsx(CurrencyLogo, { currency: inputCurrency, size: 24, imageSize: 48 }), jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: 'swapWidget.primary', style: { marginLeft: '12px' } }, { children: inputAmount.toSignificant(6) })), jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 24, fontWeight: 500, style: { marginLeft: '10px' } }, { children: inputCurrency === null || inputCurrency === void 0 ? void 0 : inputCurrency.symbol }))] }), jsx(ArrowDown, { size: "16", color: (_j = theme.swapWidget) === null || _j === void 0 ? void 0 : _j.interactiveColor, style: { marginLeft: '4px', minWidth: '16px' } }), jsxs(TokenRow$2, { children: [jsx(CurrencyLogo, { currency: outputCurrency, size: 24, imageSize: 48 }), jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, style: { marginLeft: '12px' }, color: 'swapWidget.primary' }, { children: outputAmount.toSignificant(6) })), jsx(FiatValue, { fiatValue: fiatValueOutput, priceImpact: computeFiatValuePriceImpact(fiatValueInput, fiatValueOutput) })] })), jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 24, fontWeight: 500, style: { marginLeft: '10px' } }, { children: outputCurrency === null || outputCurrency === void 0 ? void 0 : outputCurrency.symbol }))] }), showAcceptChanges, jsxs(Box, Object.assign({ mt: '30px', display: "flex", alignItems: "center", justifyContent: "space-between", onClick: flipPrice, style: { cursor: 'pointer' } }, { children: [jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 16 }, { children: "Limit Price" })), jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 16 }, { children: text }))] })), jsx(Box, Object.assign({ mt: '15px' }, { children: jsxs(Text, Object.assign({ color: "swapWidget.primary", fontSize: 16 }, { children: ["Output will be sent to", ' ', jsx("b", Object.assign({ title: recipient || '' }, { children: isAddress(recipient || '') ? shortenAddress(recipient || '', chainId) : recipient || '' }))] })) }))] }), jsxs(Footer$3, { children: [jsx(LimitOrderDetailInfo, { trade: trade }), jsx(Box, Object.assign({ my: '10px' }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: onConfirm, isDisabled: showAcceptChanges }, { children: "Confirm Order" })) }))] })] }));
    const PendingContent = jsx(Loader, { size: 100, label: pendingText });
    const ErroContent = (jsxs(ErrorWrapper$6, { children: [jsxs(ErrorBox$6, { children: [jsx(AlertTriangle, { color: theme.error, style: { strokeWidth: 1.5 }, size: 64 }), jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'error', style: { textAlign: 'center', width: '85%' } }, { children: swapErrorMessage }))] }), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: "Dismiss" }))] }));
    const SubmittedContent = (jsxs(SubmittedWrapper$3, { children: [jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", paddingY: '20px' }, { children: [jsx(Box, Object.assign({ flex: "1", display: "flex", alignItems: "center" }, { children: jsx(ArrowUpCircle, { strokeWidth: 0.5, size: 90, color: theme.primary }) })), jsx(Text, Object.assign({ color: "swapWidget.primary", fontWeight: 500, fontSize: 20 }, { children: "Transaction Submitted" })), chainId && txHash && (jsx(Link$3, Object.assign({ as: "a", fontWeight: 500, fontSize: 14, color: 'primary', href: getEtherscanLink(chainId, txHash, 'transaction'), target: "_blank" }, { children: "View on explorer" })))] })), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: "Close" }))] }));
    const getSwapError = () => {
        if (swapErrorMessage) {
            return ErroContent;
        }
        else if (txHash) {
            return SubmittedContent;
        }
        else if (attemptingTxn) {
            return PendingContent;
        }
        else {
            return ConfirmContent;
        }
    };
    return (jsx(Drawer, Object.assign({ title: swapErrorMessage || txHash || attemptingTxn ? '' : 'Confirm Order', isOpen: isOpen, onClose: onClose }, { children: getSwapError() })));
};

const Frame$4 = styled(Box)`
  display: flex;
  flex-direction: column;
  gap: 15px;
  height: 100%;
  padding: 10px;
`;
const InputOptions$1 = styled(Box)`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 5px;
`;
const WarningButton = styled(Button)`
  background-color: ${({ theme }) => theme.error};
  color: white;
`;
const Close = styled(Button)`
  position: absolute;
  top: 15px;
  right: 15px;
  color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary; }};
  width: 30px;
  height: 30px;
`;
const ModalFrame = styled(Box)`
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: justify;
  position: relative;

  width: 25vw;

  ${({ theme }) => theme.mediaWidth.upToSmall`
    width: 100% !important;
  `};

  ${({ theme }) => theme.mediaWidth.upToMedium`
    width: 50vw;
  `};
`;
const SettingsButton = styled(Box)`
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveBgColor; }};
  color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveColor; }};
  border-radius: 4px;
  padding: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;

  &:hover,
  &:focus {
    opacity: 0.8;
  }
`;

const SwapWrapper$2 = styled(Box)`
  width: 100%;
  /* min-width: 400px; */
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  position: relative;
  overflow: hidden;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
`;

const TradeOption$1 = ({ swapType, setSwapType, isLimitOrderVisible, showSettings = false, openSwapSettings = () => { }, }) => {
    return (jsx(SwapWrapper$2, {
        children: jsx(Box, Object.assign({ p: 10 }, {
            children: jsxs(Box, Object.assign({ display: "flex", alignItems: "center", style: { gap: '6px' } }, {
                children: [jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 24, fontWeight: 500, style: { flexGrow: 1 } }, { children: "Trade" })), showSettings && swapType === 'MARKET' && (jsx(SettingsButton, Object.assign({ onClick: openSwapSettings }, { children: jsx(Settings, { size: 20 }) }))), isLimitOrderVisible && (jsx(Box, Object.assign({ width: "130px" }, {
                    children: jsx(ToggleButtons, {
                        options: Object.values(SwapTypes), value: swapType, onChange: (value) => {
                            setSwapType(value);
                        }
                    })
                })))]
            }))
        }))
    }));
};

const WarningWrapper = styled.div`
  border-radius: 20px;
  border: ${({ theme }) => `1px solid ${theme.error}`};
  background: rgba(248, 45, 58, 0.05);
  padding: 1rem;
  color: ${({ theme }) => theme.error};
  position: relative;
  @media screen and (max-width: 800px) {
    width: 80% !important;
    margin-left: 5%;
  }
`;
const StyledWarningIcon$1 = styled(AlertTriangle)`
  min-height: 20px;
  min-width: 20px;
  stroke: ${({ theme }) => theme.error};
`;
const ConvertLink = styled.a`
  color: ${({ theme }) => theme.error};
  text-decoration: none;
`;
const AutoColumn$1 = styled.div`
  display: grid;
  grid-auto-rows: auto;
  grid-row-gap: '4px';
`;

function DeprecatedWarning() {
    return (jsx(WarningWrapper, { children: jsxs(AutoColumn$1, { children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "fit-content" }, { children: [jsx(StyledWarningIcon$1, {}), jsx(Text, Object.assign({ fontWeight: 600, ml: '10px', color: "swapWidget.primary" }, { children: "Old AEB tokens Alert" }))] })), jsxs(Text, Object.assign({ fontWeight: 500, mt: '10px', color: "swapWidget.primary" }, { children: ["Please note these tokens were used by the old AEB bridge and have been deprecated. If you still hold old AEB tokens, please convert them here", ' ', jsx(ConvertLink, Object.assign({ href: 'https://bridge.avax.network/convert', target: "_blank" }, { children: "https://bridge.avax.network/convert" }))] }))] }) }));
}

const Root$i = styled(Box)`
  width: 100%;
  /* min-width: 360px; */
  position: relative;
  overflow: hidden;
`;
const SwapWrapper$1 = styled(Box)`
  border-bottom-left-radius: 10px;
  border-bottom-right-radius: 10px;
  width: 100%;
  /* min-width: 360px; */
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  position: relative;
  overflow: hidden;
`;
const CurrencyInputTextBox$1 = styled(CurrencyInput)`
  align-items: center;
  border-radius: 4px;
`;
const InputText = styled(TextInput)`
  align-items: center;
  border-radius: 4px;
`;
const ArrowWrapper$5 = styled.div`
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveBgColor; }};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;
const PValue$2 = styled(Box)`
  margin-left: 7px;
  margin-right: 7px;
  align-items: center;
  display: flex;
  width: 100%;
  font-size: 16px;
  color: ${({ theme, isActive }) => { var _a, _b; return (isActive ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.secondary); }};
  border-bottom: ${({ theme, isActive }) => { var _a; return (isActive ? `1px solid ${(_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary}` : 0); }};
  cursor: pointer;
  &:hover {
    color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary; }};
  }
`;

var Rate;
(function (Rate) {
    Rate["DIV"] = "DIV";
    Rate["MUL"] = "MUL";
})(Rate || (Rate = {}));
const LimitOrder = ({ swapType, setSwapType, isLimitOrderVisible, defaultInputAddress, defaultOutputAddress, }) => {
    var _a, _b, _c, _d;
    const [isTokenDrawerOpen, setIsTokenDrawerOpen] = useState(false);
    const [selectedPercentage, setSelectedPercentage] = useState(0);
    const [tokenDrawerType, setTokenDrawerType] = useState(LimitNewField.INPUT);
    const [activeTab, setActiveTab] = useState('SELL');
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useToken = useTokenHook[chainId];
    const theme = useContext(ThemeContext);
    const percentageValue = [25, 50, 75, 100];
    const { handlers: { handleInput: onUserInput, handleRateType, handleCurrencySelection: onCurrencySelection, handleSwitchTokens: onSwitchTokens, handleLimitOrderSubmission, }, derivedOrderInfo: { parsedAmounts, currencies, currencyBalances, trade, formattedAmounts, inputError: swapInputError, rawAmounts, price, }, orderState: { independentField, rateType }, } = useGelatoLimitOrders();
    const { onCurrencySelection: onSwapCurrencySelection } = useSwapActionHandlers(chainId);
    // get custom setting values for user
    const [allowedSlippage] = useUserSlippageTolerance();
    const recipient = account !== null && account !== void 0 ? account : null;
    const isValid = !swapInputError;
    const gelatoInputCurrency = currencies[LimitField.INPUT];
    const gelatoOutputCurrency = currencies[LimitField.OUTPUT];
    const inputTokenInfo = gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.tokenInfo;
    const outputTokenInfo = gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.tokenInfo;
    const getInputCurrency = () => {
        if (gelatoInputCurrency && (gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.symbol) === CAVAX[chainId].symbol) {
            return CAVAX[chainId];
        }
        else if (inputTokenInfo && (inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.symbol) === CAVAX[chainId].symbol) {
            return CAVAX[chainId];
        }
        else if (inputTokenInfo) {
            return new Token$1(inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.chainId, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.address, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.decimals, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.symbol, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.name);
        }
        else if (gelatoInputCurrency && (gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.isToken)) {
            return new Token$1(gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.chainId, gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.address, gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.decimals, gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.symbol, gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.name);
        }
        else {
            return undefined;
        }
    };
    const getOutputCurrency = () => {
        if (gelatoOutputCurrency && (gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.symbol) === CAVAX[chainId].symbol) {
            return CAVAX[chainId];
        }
        else if (outputTokenInfo && (outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.symbol) === CAVAX[chainId].symbol) {
            return CAVAX[chainId];
        }
        else if (outputTokenInfo) {
            return new Token$1(outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.chainId, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.address, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.decimals, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.symbol, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.name);
        }
        else if (gelatoOutputCurrency && (gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.isToken)) {
            return new Token$1(gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.chainId, gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.address, gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.decimals, gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.symbol, gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.name);
        }
        else {
            return undefined;
        }
    };
    const handleActiveTab = (tab) => {
        if (activeTab === tab)
            return;
        handleRateType(rateType, price);
        setActiveTab(tab);
    };
    // toggle wallet when disconnected
    const toggleWalletModal = useWalletModalToggle();
    const handleTypeInput = useCallback((value) => {
        onUserInput(LimitNewField.INPUT, value);
    }, [onUserInput]);
    const handleTypeOutput = useCallback((value) => {
        onUserInput(LimitNewField.OUTPUT, value);
    }, [onUserInput]);
    // price
    const handleTypeDesiredRate = useCallback((value) => {
        onUserInput(LimitNewField.PRICE, value);
    }, [onUserInput]);
    // setting default tokens
    const defaultInputToken = useToken(defaultInputAddress);
    const defaultInputCurrency = defaultInputToken ? unwrappedToken(defaultInputToken, chainId) : undefined;
    const defaultOutputToken = useToken(defaultOutputAddress);
    const defaultOutputCurrency = defaultOutputToken ? unwrappedToken(defaultOutputToken, chainId) : undefined;
    useEffect(() => {
        if (defaultInputCurrency) {
            onCurrencySelect(defaultInputCurrency, LimitNewField.INPUT);
        }
        if (defaultOutputCurrency) {
            onCurrencySelect(defaultOutputCurrency, LimitNewField.OUTPUT);
        }
    }, [chainId, defaultInputAddress, defaultOutputAddress, defaultInputCurrency, defaultOutputCurrency]);
    // modal and loading
    const [{ showConfirm, tradeToConfirm, swapErrorMessage, attemptingTxn, txHash }, setSwapState] = useState({
        showConfirm: false,
        tradeToConfirm: undefined,
        attemptingTxn: false,
        swapErrorMessage: undefined,
        txHash: undefined,
    });
    const tradePrice = trade === null || trade === void 0 ? void 0 : trade.executionPrice;
    // check whether the user has approved the router on the input token
    const [approval, approveCallback] = useApproveCallbackFromInputCurrencyAmount(parsedAmounts.input);
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = useState(false);
    // mark when a user has submitted an approval, reset onTokenSelection for input field
    useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const maxAmountInput = galetoMaxAmountSpend(chainId, currencyBalances[LimitField.INPUT]);
    // for limit swap
    const handleSwap = useCallback(() => {
        var _a, _b, _c, _d, _e, _f;
        if (!handleLimitOrderSubmission) {
            return;
        }
        setSwapState({
            attemptingTxn: true,
            tradeToConfirm,
            showConfirm,
            swapErrorMessage: undefined,
            txHash: undefined,
        });
        try {
            if (!((_a = currencies.input) === null || _a === void 0 ? void 0 : _a.wrapped.address)) {
                throw new Error('Invalid input currency');
            }
            if (!((_b = currencies.output) === null || _b === void 0 ? void 0 : _b.wrapped.address)) {
                throw new Error('Invalid output currency');
            }
            if (!rawAmounts.input) {
                throw new Error('Invalid input amount');
            }
            if (!rawAmounts.output) {
                throw new Error('Invalid output amount');
            }
            if (!account) {
                throw new Error('No account');
            }
            handleLimitOrderSubmission({
                inputToken: ((_c = currencies.input) === null || _c === void 0 ? void 0 : _c.isNative) ? NATIVE : (_d = currencies.input) === null || _d === void 0 ? void 0 : _d.wrapped.address,
                outputToken: ((_e = currencies.output) === null || _e === void 0 ? void 0 : _e.isNative) ? NATIVE : (_f = currencies.output) === null || _f === void 0 ? void 0 : _f.wrapped.address,
                inputAmount: rawAmounts.input,
                outputAmount: rawAmounts.output,
                owner: account,
            })
                .then(({ hash }) => {
                    setSwapState({
                        attemptingTxn: false,
                        tradeToConfirm,
                        showConfirm,
                        swapErrorMessage: undefined,
                        txHash: hash,
                    });
                })
                .catch((error) => {
                    setSwapState({
                        attemptingTxn: false,
                        tradeToConfirm,
                        showConfirm,
                        swapErrorMessage: error.message,
                        txHash: undefined,
                    });
                    // we only care if the error is something _other_ than the user rejected the tx
                    if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {
                        console.error(error);
                    }
                });
        }
        catch (error) {
            setSwapState({
                attemptingTxn: false,
                tradeToConfirm,
                showConfirm,
                swapErrorMessage: error.message,
                txHash: undefined,
            });
            // we only care if the error is something _other_ than the user rejected the tx
            if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {
                console.error(error);
            }
        }
    }, [
        handleLimitOrderSubmission,
        tradeToConfirm,
        showConfirm,
        currencies.input,
        currencies.output,
        rawAmounts.input,
        rawAmounts.output,
        account,
    ]);
    const handleSelectTokenDrawerClose = useCallback(() => {
        setIsTokenDrawerOpen(false);
    }, [setIsTokenDrawerOpen]);
    // show approve flow when: no error on inputs, not approved or pending, or approved in current session
    // never show if price impact is above threshold in non expert mode
    const showApproveFlow = !swapInputError &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED));
    const handleConfirmDismiss = useCallback(() => {
        setSwapState({ showConfirm: false, tradeToConfirm, attemptingTxn, swapErrorMessage, txHash });
        // if there was a tx hash, we want to clear the input
        if (txHash) {
            onUserInput(LimitNewField.INPUT, '');
        }
    }, [attemptingTxn, onUserInput, swapErrorMessage, tradeToConfirm, txHash]);
    const handleAcceptChanges = useCallback(() => {
        setSwapState({ tradeToConfirm: trade, swapErrorMessage, txHash, attemptingTxn, showConfirm });
    }, [attemptingTxn, showConfirm, swapErrorMessage, trade, txHash]);
    const onCurrencySelect = useCallback((currency, tokenDrawerTypeArg) => {
        const type = tokenDrawerTypeArg !== null && tokenDrawerTypeArg !== void 0 ? tokenDrawerTypeArg : tokenDrawerType;
        if (type === LimitNewField.INPUT) {
            setApprovalSubmitted(false); // reset 2 step UI for approvals
        }
        // here need to add isToken because in Galato hook require this variable to select currency
        const newCurrency = Object.assign({}, currency);
        if ((currency === null || currency === void 0 ? void 0 : currency.symbol) === CAVAX[chainId].symbol) {
            newCurrency.isNative = true;
        }
        else {
            newCurrency.isToken = true;
        }
        onCurrencySelection(type, newCurrency);
        // this is to update tokens on chart on token selection
        onSwapCurrencySelection(type, currency);
    }, [tokenDrawerType, onCurrencySelection, onSwapCurrencySelection]);
    const handleApprove = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        yield approveCallback();
    }), [approveCallback]);
    const isAEBToken = useIsSelectedAEBToken();
    const handlePlaceOrder = () => {
        setSwapState({
            tradeToConfirm: trade,
            attemptingTxn: false,
            swapErrorMessage: undefined,
            showConfirm: true,
            txHash: undefined,
        });
    };
    const renderButton = () => {
        var _a;
        if (!account) {
            return (jsx(Button, Object.assign({ isDisabled: !account, variant: "primary", onClick: toggleWalletModal }, { children: "Connect Wallet" })));
        }
        if (showApproveFlow) {
            return (jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, {
                children: [jsx(Box, Object.assign({ mr: "10px", width: "100%" }, {
                    children: jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', onClick: handleApprove, isDisabled: approval !== ApprovalState.NOT_APPROVED || approvalSubmitted, loading: approval === ApprovalState.PENDING, loadingText: "Approving" }, {
                        children: approvalSubmitted && approval === ApprovalState.APPROVED
                            ? 'Approved'
                            : 'Approve' + ((_a = currencies[LimitField.INPUT]) === null || _a === void 0 ? void 0 : _a.symbol)
                    }))
                })), jsx(Button, Object.assign({ variant: "primary", onClick: () => handlePlaceOrder(), id: "swap-button", isDisabled: !isValid || approval !== ApprovalState.APPROVED }, { children: "Place Order" }))]
            })));
        }
        return (jsx(Button, Object.assign({ variant: "primary", onClick: () => handlePlaceOrder(), id: "swap-button", isDisabled: !isValid || !!swapInputError, backgroundColor: isValid ? 'primary' : undefined }, { children: swapInputError ? swapInputError : 'Place Order' })));
    };
    const renderPercentage = () => {
        return (jsx(Box, Object.assign({ display: "flex", pb: "5px" }, {
            children: percentageValue.map((value, index) => (jsxs(PValue$2, Object.assign({
                isActive: selectedPercentage === value, onClick: () => {
                    var _a;
                    setSelectedPercentage(value);
                    if (maxAmountInput) {
                        const multipyAmount = JSBI$1.multiply(maxAmountInput === null || maxAmountInput === void 0 ? void 0 : maxAmountInput.numerator, JSBI$1.BigInt(value)); //Currency from uniswap sdk-core not contain raw function
                        const divideAmount = JSBI$1.divide(multipyAmount, JSBI$1.BigInt(100));
                        const token = wrappedGelatoCurrency((_a = maxAmountInput === null || maxAmountInput === void 0 ? void 0 : maxAmountInput.currency) !== null && _a !== void 0 ? _a : undefined, chainId);
                        const newFinalAmount = new TokenAmount(token, divideAmount);
                        onUserInput(LimitNewField.INPUT, newFinalAmount.toExact());
                    }
                }
            }, { children: [value, "%"] }), index)))
        })));
    };
    const inputCurrency = getInputCurrency();
    const outputCurrency = getOutputCurrency();
    return (jsxs(Root$i, {
        children: [jsx(TradeOption$1, { swapType: swapType, setSwapType: setSwapType, isLimitOrderVisible: isLimitOrderVisible }), jsxs(SwapWrapper$1, {
            children: [jsx(Box, Object.assign({ width: "100%", display: "flex", justifyContent: "center" }, {
                children: jsx(Box, Object.assign({ textAlign: "center", width: "120px" }, {
                    children: jsx(ToggleButtons, {
                        options: ['SELL', 'BUY'], value: activeTab, onChange: (value) => {
                            handleActiveTab(value);
                        }
                    })
                }))
            })), jsxs(Box, Object.assign({ p: 10 }, {
                children: [isAEBToken && jsx(DeprecatedWarning, {}), jsx(CurrencyInputTextBox$1, {
                    label: independentField === LimitNewField.OUTPUT && trade ? 'From (estimated)' : 'From', value: formattedAmounts[LimitField.INPUT], onChange: (value) => {
                        setSelectedPercentage(0);
                        handleTypeInput(value);
                    }, onTokenClick: () => {
                        setTokenDrawerType(LimitNewField.INPUT);
                        setIsTokenDrawerOpen(true);
                    }, currency: inputCurrency, fontSize: 24, isNumeric: true, placeholder: "0.00", id: "swap-currency-input", addonLabel: renderPercentage()
                }), jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: "flex", justifyContent: 'center', mt: 10 }, { children: jsx(ArrowWrapper$5, { children: rateType === Rate.MUL ? (jsx(X, { size: "16", color: (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveColor })) : (jsx(Divide, { size: "16", color: (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.interactiveColor })) }) })), jsx(Box, { children: jsx(InputText, { value: formattedAmounts[LimitField.PRICE], onChange: (value) => handleTypeDesiredRate(value), fontSize: 24, isNumeric: true, placeholder: "0.00", label: "Price" }) }), jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: "flex", justifyContent: 'center', mt: 10 }, {
                    children: jsx(ArrowWrapper$5, Object.assign({
                        onClick: () => {
                            setApprovalSubmitted(false); // reset 2 step UI for approvals
                            onSwitchTokens();
                        }
                    }, { children: jsx(RefreshCcw, { size: "16", color: (_c = theme.swapWidget) === null || _c === void 0 ? void 0 : _c.interactiveColor }) }))
                })), jsx(CurrencyInputTextBox$1, {
                    label: independentField === LimitNewField.INPUT && trade ? 'To (estimated)' : 'To', value: formattedAmounts[LimitField.OUTPUT], onChange: (value) => {
                        setSelectedPercentage(0);
                        handleTypeOutput(value);
                    }, onTokenClick: () => {
                        setTokenDrawerType(LimitNewField.OUTPUT);
                        setIsTokenDrawerOpen(true);
                    }, currency: outputCurrency, fontSize: 24, isNumeric: true, placeholder: "0.00", id: "swap-currency-output", addonLabel: tradePrice && (jsxs(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 16 }, { children: ["Price: ", tradePrice === null || tradePrice === void 0 ? void 0 : tradePrice.toSignificant(6), " ", (_d = tradePrice === null || tradePrice === void 0 ? void 0 : tradePrice.quoteCurrency) === null || _d === void 0 ? void 0 : _d.symbol] })))
                }), trade && jsx(LimitOrderDetailInfo, { trade: trade }), jsx(Box, Object.assign({ width: "100%", mt: 10 }, { children: renderButton() }))]
            }))]
        }), isTokenDrawerOpen && (jsx(SelectTokenDrawer$1, { isOpen: isTokenDrawerOpen, onClose: handleSelectTokenDrawerClose, onCurrencySelect: onCurrencySelect, selectedCurrency: tokenDrawerType === LimitNewField.INPUT ? inputCurrency : outputCurrency, otherSelectedCurrency: tokenDrawerType === LimitNewField.INPUT ? outputCurrency : inputCurrency })), trade && (jsx(ConfirmLimitOrderDrawer, { isOpen: showConfirm, trade: trade, originalTrade: tradeToConfirm, onAcceptChanges: handleAcceptChanges, attemptingTxn: attemptingTxn, txHash: txHash, recipient: recipient, allowedSlippage: allowedSlippage, onConfirm: handleSwap, swapErrorMessage: swapErrorMessage, onClose: handleConfirmDismiss }))]
    }));
};

const ContentBox$2 = styled(Box)`
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  padding: 15px;
  border-radius: 8px;
  margin-top: 10px;
`;
const DataBox$2 = styled(Box)`
  align-items: center;
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const ValueText = styled(Text)`
  color: ${({ theme, severity }) => {
        var _a, _b;
        return severity === 3 || severity === 4
            ? theme.error
            : severity === 2
                ? theme.warning
                : severity === 1
                    ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary
                    : severity === 0
                        ? theme.success
                        : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.secondary;
    }};
`;

const SwapDetailInfo = ({ trade }) => {
    var _a, _b, _c, _d;
    const [allowedSlippage] = useUserSlippageTolerance();
    const [feeInfo] = useDaasFeeInfo();
    const { priceImpactWithoutFee, realizedLPFee, realizedLPFeeAmount } = computeTradePriceBreakdown(trade);
    const isExactIn = trade.tradeType === TradeType$2.EXACT_INPUT;
    const slippageAdjustedAmounts = computeSlippageAdjustedAmounts(trade, allowedSlippage);
    const amount = isExactIn
        ? (_b = `${(_a = slippageAdjustedAmounts[Field.OUTPUT]) === null || _a === void 0 ? void 0 : _a.toSignificant(4)} ${trade.outputAmount.currency.symbol}`) !== null && _b !== void 0 ? _b : '-'
        : (_d = `${(_c = slippageAdjustedAmounts[Field.INPUT]) === null || _c === void 0 ? void 0 : _c.toSignificant(4)} ${trade.inputAmount.currency.symbol}`) !== null && _d !== void 0 ? _d : '-';
    const priceImpact = priceImpactWithoutFee
        ? priceImpactWithoutFee.lessThan(ONE_BIPS)
            ? '<0.01%'
            : `${priceImpactWithoutFee.toFixed(2)}%`
        : '-';
    const lpFeeAmount = realizedLPFeeAmount
        ? `${realizedLPFeeAmount.toSignificant(4)} ${trade.inputAmount.currency.symbol}`
        : '-';
    const totalFee = realizedLPFee
        ? `${realizedLPFee.add(new Percent$1(feeInfo.feeTotal.toString(), BIPS_BASE)).multiply('100').toSignificant(4)}%`
        : '-';
    const renderRow = (label, value, showSeverity) => {
        return (jsxs(DataBox$2, { children: [jsx(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 14 }, { children: label })), jsx(ValueText, Object.assign({ fontSize: 14, severity: showSeverity ? warningSeverity(priceImpactWithoutFee) : -1 }, { children: value }))] }, label));
    };
    return (jsxs(ContentBox$2, { children: [allowedSlippage !== INITIAL_ALLOWED_SLIPPAGE && renderRow('Slippage tolerance', `${allowedSlippage / 100}%`), renderRow(isExactIn ? 'Minimum Received' : 'Maximum Sold', amount), renderRow('Price Impact', priceImpact, true), (feeInfo === null || feeInfo === void 0 ? void 0 : feeInfo.feeTotal) > 0 ? renderRow('Total Fee', totalFee) : renderRow('Liquidity Provider Fee', lpFeeAmount)] }));
};

const Root$h = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const Header$4 = styled(Box)`
  padding: 0px 10px;
`;
const TokenRow$1 = styled(Box)`
  display: grid;
  grid-template-columns: max-content auto max-content;
  align-items: center;
`;
const PriceUpdateBlock = styled(Box)`
  padding: 10px;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 8px;
  margin-top: 15px;
`;
const OutputText$1 = styled(Text)`
  width: 100%;
  font-style: italic;
  font-size: 12px;
  text-align: left;
`;
const Footer$2 = styled(Box)`
  padding: 0px 10px;
`;
const ErrorWrapper$5 = styled(Box)`
  display: grid;
  grid-template-rows: minmax(300px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const ErrorBox$5 = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const SubmittedWrapper$2 = styled(Box)`
  display: grid;
  grid-template-rows: minmax(300px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const Link$2 = styled(Text)`
  text-decoration: none;
`;

const ConfirmSwapDrawer$1 = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { isOpen, onClose, trade, originalTrade, allowedSlippage, onAcceptChanges, onConfirm, attemptingTxn, swapErrorMessage, txHash, recipient, } = props;
    const { chainId } = usePangolinWeb3();
    const theme = useContext(ThemeContext);
    const slippageAdjustedAmounts = useMemo(() => computeSlippageAdjustedAmounts(trade, allowedSlippage), [trade, allowedSlippage]);
    const { priceImpactWithoutFee } = useMemo(() => computeTradePriceBreakdown(trade), [trade]);
    const priceImpactSeverity = warningSeverity(priceImpactWithoutFee);
    const showAcceptChanges = useMemo(() => Boolean(trade && originalTrade && tradeMeaningfullyDiffers(trade, originalTrade)), [originalTrade, trade]);
    // text to show while loading
    const pendingText = `Swapping ${(_a = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _a === void 0 ? void 0 : _a.toSignificant(6)} ${(_c = (_b = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _b === void 0 ? void 0 : _b.currency) === null || _c === void 0 ? void 0 : _c.symbol} for ${(_d = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _d === void 0 ? void 0 : _d.toSignificant(6)} ${(_f = (_e = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _e === void 0 ? void 0 : _e.currency) === null || _f === void 0 ? void 0 : _f.symbol}`;
    const ConfirmContent = (jsxs(Root$h, {
        children: [jsxs(Header$4, {
            children: [jsxs(TokenRow$1, { children: [jsx(CurrencyLogo, { currency: trade.inputAmount.currency, size: 24, imageSize: 48 }), jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: showAcceptChanges && trade.tradeType === TradeType$2.EXACT_OUTPUT ? 'primary' : 'swapWidget.primary', style: { marginLeft: '12px' } }, { children: trade.inputAmount.toSignificant(6) })), jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: "swapWidget.primary", style: { marginLeft: '10px' } }, { children: trade.inputAmount.currency.symbol }))] }), jsx(ArrowDown, { size: "16", color: (_g = theme.swapWidget) === null || _g === void 0 ? void 0 : _g.interactiveColor, style: { marginLeft: '4px', minWidth: '16px' } }), jsxs(TokenRow$1, {
                children: [jsx(CurrencyLogo, { currency: trade.outputAmount.currency, size: 24, imageSize: 48 }), jsx(Text, Object.assign({
                    fontSize: 24, fontWeight: 500, style: { marginLeft: '12px' }, color: priceImpactSeverity > 2
                        ? 'error'
                        : showAcceptChanges && trade.tradeType === TradeType$2.EXACT_INPUT
                            ? 'primary'
                            : 'swapWidget.primary'
                }, { children: trade.outputAmount.toSignificant(6) })), jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 24, fontWeight: 500, style: { marginLeft: '10px' } }, { children: trade.outputAmount.currency.symbol }))]
            }), showAcceptChanges && (jsxs(PriceUpdateBlock, { children: [jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 14 }, { children: "Price Updated" })), jsx(Button, Object.assign({ onClick: onAcceptChanges, variant: "primary", width: 150, padding: "5px 10px" }, { children: "Accept" }))] })), jsx(Box, Object.assign({ mt: '15px' }, {
                children: trade.tradeType === TradeType$2.EXACT_INPUT ? (jsx(OutputText$1, Object.assign({ color: "swapWidget.secondary" }, {
                    children: jsx(Trans, {
                        i18nKey: "swap.outputEstimated", values: {
                            amount: (_h = slippageAdjustedAmounts[Field.OUTPUT]) === null || _h === void 0 ? void 0 : _h.toSignificant(6),
                            currencySymbol: trade.outputAmount.currency.symbol,
                        }
                    })
                }))) : (jsx(OutputText$1, Object.assign({ color: "swapWidget.secondary" }, {
                    children: jsx(Trans, {
                        i18nKey: "swap.inputEstimated", values: {
                            amount: (_j = slippageAdjustedAmounts[Field.INPUT]) === null || _j === void 0 ? void 0 : _j.toSignificant(6),
                            currencySymbol: trade.inputAmount.currency.symbol,
                        }
                    })
                })))
            })), recipient && jsxs(OutputText$1, Object.assign({ color: "swapWidget.primary" }, { children: ["Sending to: ", recipient] }))]
        }), jsxs(Footer$2, { children: [jsx(SwapDetailInfo, { trade: trade }), jsx(Box, Object.assign({ my: '10px' }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: onConfirm, isDisabled: showAcceptChanges }, { children: priceImpactSeverity > 2 ? 'Swap Anyway' : 'Confirm Swap' })) }))] })]
    }));
    const PendingContent = jsx(Loader, { size: 100, label: pendingText });
    const ErroContent = (jsxs(ErrorWrapper$5, { children: [jsxs(ErrorBox$5, { children: [jsx(AlertTriangle, { color: theme.error, style: { strokeWidth: 1.5 }, size: 64 }), jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'error', style: { textAlign: 'center', width: '85%' } }, { children: swapErrorMessage }))] }), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: "Dismiss" }))] }));
    const SubmittedContent = (jsxs(SubmittedWrapper$2, { children: [jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", paddingY: '20px' }, { children: [jsx(Box, Object.assign({ flex: "1", display: "flex", alignItems: "center" }, { children: jsx(ArrowUpCircle, { strokeWidth: 0.5, size: 90, color: theme.primary }) })), jsx(Text, Object.assign({ color: "swapWidget.primary", fontWeight: 500, fontSize: 20 }, { children: "Transaction Submitted" })), chainId && txHash && (jsx(Link$2, Object.assign({ as: "a", fontWeight: 500, fontSize: 14, color: 'primary', href: getEtherscanLink(chainId, txHash, 'transaction') }, { children: "View on explorer" })))] })), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: "Close" }))] }));
    return (jsx(Drawer, Object.assign({ title: swapErrorMessage || txHash || attemptingTxn ? '' : 'Confirm Swap', isOpen: isOpen, onClose: onClose }, { children: swapErrorMessage ? ErroContent : txHash ? SubmittedContent : attemptingTxn ? PendingContent : ConfirmContent })));
};

const PValue$1 = styled(Box)`
  margin-left: 3px;
  margin-right: 3px;
  align-items: center;
  display: flex;
  width: 100%;
  font-size: 12px;
  padding: 5px;
  color: ${({ theme, isActive }) => { var _a, _b; return (isActive ? (_a = theme.numberOptions) === null || _a === void 0 ? void 0 : _a.activeTextColor : (_b = theme.numberOptions) === null || _b === void 0 ? void 0 : _b.text); }};
  background-color: ${({ theme, isActive }) => { var _a, _b; return isActive ? (_a = theme.numberOptions) === null || _a === void 0 ? void 0 : _a.activeBackgroundColor : (_b = theme.numberOptions) === null || _b === void 0 ? void 0 : _b.inactiveBackgroundColor; }};
  border: ${({ theme, isActive }) => { var _a; return (isActive ? 0 : `1px solid ${(_a = theme.numberOptions) === null || _a === void 0 ? void 0 : _a.borderColor}`); }};
  border-radius: 5px;
  cursor: pointer;
  text-align: center;
  justify-content: center;
`;

const NumberOptions = (props) => {
    const { options = [25, 50, 75, 100], isPercentage = false, onChange, currentValue, isDisabled, variant } = props;
    return (jsxs(Box, {
        children: [variant === 'step' && (jsxs(Steps, Object.assign({
            onChange: (value) => {
                onChange && onChange(value);
            }, current: currentValue, progressDot: true
        }, { children: [jsx(Step, { disabled: isDisabled }), jsx(Step, { disabled: isDisabled }), jsx(Step, { disabled: isDisabled }), jsx(Step, { disabled: isDisabled }), jsx(Step, { disabled: isDisabled })] }))), variant === 'box' && (jsx(Box, Object.assign({ display: "flex", pb: "5px" }, {
            children: options.map((value, index) => (jsx(PValue$1, Object.assign({
                isActive: currentValue === value, onClick: () => {
                    onChange && onChange(value);
                }
            }, { children: isPercentage ? `${value}%` : value }), index)))
        })))]
    }));
};

const InputOptions = styled(Box)`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 5px;
`;

const SlippageInput = ({ expertMode = false, slippageTolerance, showTitle = true, setSlippageTolerance, }) => {
    const { t } = useTranslation();
    return (jsxs(Box, Object.assign({ height: "90px" }, {
        children: [showTitle && jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: t('settings.slippage') })), jsxs(InputOptions, {
            children: [jsx(TextInput, {
                value: slippageTolerance, addonAfter: jsx(Box, Object.assign({ bgColor: "swapWidget.detailsBackground", paddingX: "10px", paddingY: "4px", borderRadius: 4 }, { children: jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: t('settings.percent') })) })), isNumeric: true, placeholder: "1", onChange: (value) => {
                    setSlippageTolerance(value);
                }
            }), jsx(NumberOptions, { options: [0.1, 0.5, 1], isPercentage: true, currentValue: parseFloat(slippageTolerance), variant: "box", onChange: (number) => setSlippageTolerance(number.toString()), isDisabled: false })]
        }), Number(slippageTolerance) <= 0.1 && (jsx(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 12, marginBottom: 10 }, { children: t('transactionSettings.transactionMayFail') }))), Number(slippageTolerance) > 50 && !expertMode ? (jsx(Text, Object.assign({ color: "error", fontSize: "10px", marginBottom: 10 }, { children: t('transactionSettings.transactionActiveExpertMode') }))) : (Number(slippageTolerance) > 5 && (jsx(Text, Object.assign({ color: "primary", fontSize: 12, marginBottom: 10 }, { children: t('transactionSettings.transactionMayFrontrun') }))))]
    })));
};

function useOnClickOutside(node, handler) {
    const handlerRef = useRef(handler);
    useEffect(() => {
        handlerRef.current = handler;
    }, [handler]);
    useEffect(() => {
        const handleClickOutside = (e) => {
            var _a, _b;
            if ((_b = (_a = node.current) === null || _a === void 0 ? void 0 : _a.contains(e.target)) !== null && _b !== void 0 ? _b : false) {
                return;
            }
            if (handlerRef.current)
                handlerRef.current();
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [node]);
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const StyledDialogOverlay = styled.div`
  z-index: 999;
  background-color: transparent;
  overflow: hidden;
  display: ${({ isOpen }) => (!isOpen ? 'none' : 'flex')};
  align-items: center;
  justify-content: center;
  position: fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  background-color: ${({ theme, background }) => (background ? background : theme.modalBG)};
`;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const Container$1 = styled.div`
  background: ${({ theme }) => theme.bg8};
  border-radius: 10px;
  ${({ theme }) => theme.mediaWidth.upToSmall`
    border-radius: 0px;
    width: 100%;
    height: 100%;
  `};
`;
function Modal({ isOpen, onDismiss, children, overlayBG, closeOnClickOutside = true }) {
    const node = useRef();
    const handleClose = useCallback(() => {
        onDismiss();
    }, [onDismiss]);
    useOnClickOutside(node, isOpen && closeOnClickOutside ? handleClose : undefined);
    return (jsx(Portal, { children: jsx(StyledDialogOverlay, Object.assign({ isOpen: isOpen, background: overlayBG }, { children: isOpen && jsx(Container$1, Object.assign({ ref: node }, { children: children })) })) }));
}

const WarningModal = ({ isOpen, close, setExpertMode }) => {
    const confirmAction = () => {
        const text = prompt('Please type the word "confirm" to enable expert mode.');
        if (text === 'confirm') {
            setExpertMode(true);
            close();
        }
    };
    return (jsx(Modal, Object.assign({ isOpen: isOpen, onDismiss: close }, { children: jsxs(ModalFrame, { children: [jsx(Close, Object.assign({ variant: "plain", onClick: close }, { children: jsx(X, { size: 28 }) })), jsx(Text, Object.assign({ fontSize: 28, fontWeight: 800, color: "swapWidget.primary" }, { children: "Are you sure?" })), jsxs(Box, Object.assign({ marginTop: 20 }, { children: [jsx(Text, Object.assign({ color: "swapWidget.primary" }, { children: "Expert mode turns off the confirm transaction prompt and allows high slippage trades that often result in bad rates and lost funds." })), jsx(Text, Object.assign({ color: "swapWidget.primary", fontWeight: 800, fontSize: 20, marginTop: 20, marginBottom: 40 }, { children: "ONLY USE THIS MODE IF YOU KNOW WHAT YOU ARE DOING." })), jsx(WarningButton, Object.assign({ variant: "primary", onClick: confirmAction }, { children: "Turn on expert mode" }))] }))] }) })));
};

const SwapSettingsDrawer = ({ isOpen, close }) => {
    const [userExpertMode, setUserExpertMode] = useExpertModeManager();
    const [userslippage, setUserSlippageTolerance] = useUserSlippageTolerance();
    const [userDeadline, setUserDeadline] = useUserDeadline();
    const [deadline, setDeadline] = useState(userDeadline);
    const [expertMode, setExpertMode] = useState(userExpertMode);
    const [slippageTolerance, setSlippageTolerance] = useState((userslippage / 100).toString());
    const [isValidValues, setValidValues] = useState(true);
    const [modalOpen, setModalOpen] = useState(false);
    const save = useCallback(() => {
        if (deadline.length == 0) {
            setUserDeadline(DEFAULT_DEADLINE_FROM_NOW);
        }
        else {
            setUserDeadline(deadline);
        }
        setUserExpertMode(expertMode);
        if (slippageTolerance.length == 0) {
            setUserSlippageTolerance(0);
        }
        else {
            let slippageToleranceNumber = parseFloat(slippageTolerance);
            if (!expertMode && slippageToleranceNumber > 50) {
                setUserSlippageTolerance(5000);
            }
            else {
                if (slippageToleranceNumber > 100) {
                    slippageToleranceNumber = 100;
                }
                setUserSlippageTolerance(Math.ceil(slippageToleranceNumber * 100));
            }
        }
        close();
    }, [deadline, expertMode, slippageTolerance]);
    useEffect(() => {
        const slippageToleranceNumber = parseFloat(slippageTolerance);
        if (slippageTolerance.length == 0) {
            setValidValues(false);
        }
        else if (!expertMode && slippageToleranceNumber > 50) {
            setValidValues(false);
        }
        else if (slippageToleranceNumber > 100 || slippageToleranceNumber <= 0) {
            setValidValues(false);
        }
        else {
            setValidValues(true);
        }
    }, [expertMode, slippageTolerance]);
    return (jsxs(Drawer, Object.assign({ title: "Settings", isOpen: isOpen, onClose: close }, {
        children: [jsx(WarningModal, { isOpen: modalOpen, close: () => setModalOpen(false), setExpertMode: setExpertMode }), jsxs(Frame$4, {
            children: [jsx(SlippageInput, { expertMode: expertMode, slippageTolerance: slippageTolerance, setSlippageTolerance: setSlippageTolerance }), jsxs(Box, Object.assign({ height: "90px" }, { children: [jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: "Time Limit" })), jsxs(InputOptions$1, { children: [jsx(TextInput, { value: deadline, addonAfter: jsx(Box, Object.assign({ bgColor: "swapWidget.detailsBackground", paddingX: "8px", paddingY: "4px", borderRadius: 4 }, { children: jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: "Seconds" })) })), isNumeric: true, placeholder: "10", onChange: (number) => setDeadline(number.toString()) }), jsx(NumberOptions, { options: [60, 300, 600], currentValue: parseInt(deadline), variant: "box", onChange: (number) => setDeadline(number.toString()), isDisabled: false })] }), Number(deadline) <= 1 && (jsxs(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 12, marginBottom: 10 }, { children: [' ', "Your transaction may fail"] })))] })), jsxs(Box, Object.assign({ display: "flex", flexDirection: "row", alignItems: "center", justifyContent: "center", style: { gap: '15px' } }, {
                children: [jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: "Toggle Expert Mode" })), jsx(Box, Object.assign({ width: "120px" }, {
                    children: jsx(ToggleButtons, {
                        options: ['ON', 'OFF'], value: expertMode ? 'ON' : 'OFF', onChange: (value) => {
                            if (value === 'ON' && !expertMode) {
                                setModalOpen(true);
                            }
                            else if (value === 'OFF' && expertMode) {
                                setExpertMode(false);
                            }
                        }
                    })
                }))]
            })), jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", alignContent: "center", style: { gap: '10px' } }, { children: [jsx(Button, Object.assign({ variant: "primary", onClick: save, isDisabled: !isValidValues }, { children: "Save & Close" })), jsx(Button, Object.assign({ variant: "plain", onClick: close, color: "swapWidget.secondary" }, { children: "Close" }))] }))]
        })]
    })));
};

const SwapRouteWrapper = styled(Box)`
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  width: 100%;
  margin: 0px auto;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  padding: 10px;
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  justify-content: center;
`;

const SwapRoute = ({ trade }) => {
    const theme = useContext(ThemeContext);
    return (jsx(SwapRouteWrapper, {
        children: trade.route.path.map((token, i, path) => {
            var _a;
            const isLastItem = i === path.length - 1;
            return (jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center", my: '5px' }, { children: [jsx(CurrencyLogo, { currency: token, size: 24 }), jsx(Box, Object.assign({ ml: '10px' }, { children: jsx(Text, Object.assign({ fontSize: 14, color: 'swapWidget.primary' }, { children: token.symbol })) }))] })), isLastItem ? null : jsx(ChevronRight, { color: (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveColor })] }), i));
        })
    }));
};

const Wrapper$c = styled.div`
  background: ${({ theme }) => { var _a; return transparentize(0.6, (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor); }};
  padding: 0.75rem;
  border-radius: 20px;
`;
const WarningContainer = styled.div`
  max-width: 420px;
  width: 100%;
  padding: 1rem;
  background: ${({ theme }) => transparentize(0.9, theme.error)};
  border: 1px solid ${({ theme }) => theme.error};
  border-radius: 20px;
  overflow: auto;
`;
const StyledWarningIcon = styled(AlertTriangle)`
  stroke: ${({ theme }) => theme.error};
`;
const AutoColumn = styled.div`
  display: grid;
  grid-auto-rows: auto;
  grid-row-gap: ${({ gap }) => (gap === 'sm' && '8px') || (gap === 'md' && '12px') || (gap === 'lg' && '24px') || gap};
  justify-items: ${({ justify }) => justify && justify};
`;

function TokenWarningCard({ token }) {
    var _a, _b, _c, _d;
    const { chainId } = usePangolinWeb3();
    const tokenSymbol = (_b = (_a = token === null || token === void 0 ? void 0 : token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : '';
    const tokenName = (_d = (_c = token === null || token === void 0 ? void 0 : token.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) !== null && _d !== void 0 ? _d : '';
    const allTokens = useAllTokens();
    const duplicateNameOrSymbol = useMemo(() => {
        if (!token || !chainId)
            return false;
        return Object.keys(allTokens).some((tokenAddress) => {
            var _a, _b;
            const userToken = allTokens[tokenAddress];
            if (userToken.equals(token)) {
                return false;
            }
            return ((_a = userToken.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === tokenSymbol || ((_b = userToken.name) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === tokenName;
        });
    }, [token, chainId, allTokens, tokenSymbol, tokenName]);
    if (!token)
        return null;
    return (jsx(Wrapper$c, Object.assign({ error: duplicateNameOrSymbol }, {
        children: jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "100%", flexWrap: "wrap", margin: "-6px" }, {
            children: [jsxs(AutoColumn, Object.assign({ gap: "24px" }, { children: [jsx(CurrencyLogo, { currency: token, size: 24, imageSize: 48 }), jsx("div", { children: " " })] })), jsxs(AutoColumn, Object.assign({ gap: "10px", justify: "flex-start" }, {
                children: [jsxs(Text, Object.assign({ fontWeight: 500, fontSize: 20, color: 'swapWidget.secondary' }, {
                    children: [token && token.name && token.symbol && token.name !== token.symbol
                        ? `${token.name} (${token.symbol})`
                        : token.name || token.symbol, ' ']
                })), chainId && (jsx(ExternalLink, Object.assign({ style: { fontWeight: 400 }, href: getEtherscanLink(chainId, token.address, 'token') }, { children: jsxs(Text, Object.assign({ fontWeight: 500, color: 'primary', fontSize: 16 }, { children: [shortenAddress(token.address, chainId), " (View on explorer)"] })) })))]
            }))]
        }))
    })));
}
function TokenWarningModal({ isOpen, tokens, onConfirm, }) {
    const [understandChecked, setUnderstandChecked] = useState(false);
    const toggleUnderstand = useCallback(() => setUnderstandChecked((uc) => !uc), []);
    const handleDismiss = useCallback(() => null, []);
    return (jsx(Modal, Object.assign({ isOpen: isOpen, onDismiss: handleDismiss }, {
        children: jsx(WarningContainer, Object.assign({ className: "token-warning-container" }, {
            children: jsxs(AutoColumn, Object.assign({ gap: "lg" }, {
                children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "100%", flexWrap: "wrap", margin: "-6px" }, { children: [jsx(StyledWarningIcon, {}), jsx(Text, Object.assign({ fontWeight: 500, fontSize: 20, color: 'error' }, { children: "Token imported" }))] })), jsxs(Text, Object.assign({ color: 'error', fontSize: 16 }, { children: ["Anyone can create an ERC-20 token on Avalanche with ", jsx("em", { children: "any" }), " name, including creating fake versions of existing tokens and tokens that claim to represent projects that do not have a token."] })), jsx(Text, Object.assign({ color: 'error', fontSize: 16 }, { children: "This interface can load arbitrary tokens by token addresses. Please take extra caution and do your research when interacting with arbitrary ERC-20 tokens." })), jsxs(Text, Object.assign({ color: 'error', fontSize: 16 }, { children: ["If you purchase an arbitrary token, ", jsx("strong", { children: "you may be unable to sell it back." })] })), tokens.map((token) => {
                    return jsx(TokenWarningCard, { token: token }, token.address);
                }), jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "100%", justifyContent: "space-between" }, {
                    children: [jsx("div", { children: jsxs("label", Object.assign({ style: { cursor: 'pointer', userSelect: 'none' } }, { children: [jsx("input", { type: "checkbox", className: "understand-checkbox", checked: understandChecked, onChange: toggleUnderstand }), ' ', "I understand"] })) }), jsx(Button, Object.assign({
                        isDisabled: !understandChecked, variant: "primary", width: '140px', padding: "0.5rem 1rem", onClick: () => {
                            onConfirm();
                        }
                    }, { children: "Continue" }))]
                }))]
            }))
        }))
    })));
}

/**
 * Given the price impact, get user confirmation.
 *
 * @param priceImpactWithoutFee price impact of the trade without the fee.
 */
function confirmPriceImpactWithoutFee(priceImpactWithoutFee) {
    if (!priceImpactWithoutFee.lessThan(PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN)) {
        return (window.prompt(`This swap has a price impact of at least ${PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN.toFixed(0)}%. Please type the word "confirm" to continue with this swap`) === 'confirm');
    }
    else if (!priceImpactWithoutFee.lessThan(ALLOWED_PRICE_IMPACT_HIGH)) {
        return window.confirm(`This swap has a price impact of at least ${ALLOWED_PRICE_IMPACT_HIGH.toFixed(0)} %. Please confirm that you would like to continue with this swap.`);
    }
    return true;
}

const Root$g = styled(Box)`
  width: 100%;
  /* min-width: 360px; */
  position: relative;
  overflow: hidden;
`;
const SwapWrapper = styled(Box)`
  border-bottom-left-radius: ${({ showRoute }) => (showRoute ? `0px` : `10px`)};
  border-bottom-right-radius: ${({ showRoute }) => (showRoute ? `0px` : `10px`)};
  width: 100%;
  /* min-width: 360px; */
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  position: relative;
  overflow: hidden;
`;
const CurrencyInputTextBox = styled(CurrencyInput)`
  align-items: center;
  border-radius: 4px;
`;
const ArrowWrapper$4 = styled.div`
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveBgColor; }};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;
const PValue = styled(Box)`
  margin-left: 7px;
  margin-right: 7px;
  align-items: center;
  display: flex;
  width: 100%;
  font-size: 16px;
  color: ${({ theme, isActive }) => { var _a, _b; return (isActive ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.secondary); }};
  border-bottom: ${({ theme, isActive }) => { var _a; return (isActive ? `1px solid ${(_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary}` : 0); }};
  cursor: pointer;
  &:hover {
    color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary; }};
  }
`;
const LinkStyledButton = styled.button`
  border: none;
  text-decoration: none;
  background: none;

  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  color: ${({ theme, disabled }) => { var _a, _b; return (disabled ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.primary); }};
  font-weight: 500;

  :hover {
    text-decoration: ${({ disabled }) => (disabled ? null : 'underline')};
  }

  :focus {
    outline: none;
    text-decoration: ${({ disabled }) => (disabled ? null : 'underline')};
  }

  :active {
    text-decoration: none;
  }
`;

const MarketOrder = ({ swapType, setSwapType, isLimitOrderVisible, showSettings, partnerDaaS = ZERO_ADDRESS, defaultInputAddress, defaultOutputAddress, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    // const [isRetryDrawerOpen, setIsRetryDrawerOpen] = useState(false);
    const [isTokenDrawerOpen, setIsTokenDrawerOpen] = useState(false);
    const [openSettings, setOpenSettings] = useState(false);
    const [selectedPercentage, setSelectedPercentage] = useState(0);
    const [tokenDrawerType, setTokenDrawerType] = useState(Field.INPUT);
    const percentageValue = [25, 50, 75, 100];
    const loadedUrlParams = useDefaultsFromURLSearch();
    // token warning stuff
    const [loadedInputCurrency, loadedOutputCurrency] = [
        useCurrency(loadedUrlParams === null || loadedUrlParams === void 0 ? void 0 : loadedUrlParams.inputCurrencyId),
        useCurrency(loadedUrlParams === null || loadedUrlParams === void 0 ? void 0 : loadedUrlParams.outputCurrencyId),
    ];
    const [dismissTokenWarning, setDismissTokenWarning] = useState(false);
    const urlLoadedTokens = useMemo(() => { var _a, _b; return (_b = (_a = [loadedInputCurrency, loadedOutputCurrency]) === null || _a === void 0 ? void 0 : _a.filter((c) => c instanceof Token$1)) !== null && _b !== void 0 ? _b : []; }, [loadedInputCurrency, loadedOutputCurrency]);
    const handleConfirmTokenWarning = useCallback(() => {
        setDismissTokenWarning(true);
    }, []);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useToken = useTokenHook[chainId];
    const theme = useContext(ThemeContext);
    const useWrapCallback = useWrapCallbackHook[chainId];
    const useApproveCallbackFromTrade = useApproveCallbackFromTradeHook[chainId];
    const useSwapCallback = useSwapCallbackHook[chainId];
    // toggle wallet when disconnected
    const toggleWalletModal = useWalletModalToggle();
    // for expert mode
    // const toggleSettings = useToggleSettingsMenu()
    const [isExpertMode] = useExpertModeManager();
    // get custom setting values for user
    const [allowedSlippage] = useUserSlippageTolerance();
    const [feeTo, setFeeTo] = useDaasFeeTo();
    useEffect(() => {
        if (feeTo === partnerDaaS)
            return;
        setFeeTo(partnerDaaS);
    }, [feeTo, partnerDaaS]);
    // swap state
    const { independentField, typedValue, recipient } = useSwapState();
    const { v1Trade, v2Trade, currencyBalances, parsedAmount, currencies, inputError: swapInputError, isLoading: isLoadingSwap, } = useDerivedSwapInfo();
    const { wrapType, execute: onWrap, inputError: wrapInputError, } = useWrapCallback(currencies[Field.INPUT], currencies[Field.OUTPUT], typedValue);
    const showWrap = wrapType !== WrapType.NOT_APPLICABLE;
    const { address: recipientAddress } = useENS(recipient);
    const toggledVersion = useToggledVersion();
    const tradesByVersion = {
        [Version.v1]: v1Trade,
        [Version.v2]: v2Trade,
    };
    const trade = showWrap ? undefined : tradesByVersion[toggledVersion];
    // const defaultTrade = showWrap ? undefined : tradesByVersion[DEFAULT_VERSION]
    // const betterTradeLinkVersion: Version | undefined = undefined
    const parsedAmounts = showWrap
        ? {
            [Field.INPUT]: parsedAmount,
            [Field.OUTPUT]: parsedAmount,
        }
        : {
            [Field.INPUT]: independentField === Field.INPUT ? parsedAmount : trade === null || trade === void 0 ? void 0 : trade.inputAmount,
            [Field.OUTPUT]: independentField === Field.OUTPUT ? parsedAmount : trade === null || trade === void 0 ? void 0 : trade.outputAmount,
        };
    const { onSwitchTokens, onCurrencySelection, onUserInput, onChangeRecipient } = useSwapActionHandlers(chainId);
    const isValid = !swapInputError;
    const dependentField = independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT;
    const inputCurrency = currencies[Field.INPUT];
    const outputCurrency = currencies[Field.OUTPUT];
    const handleTypeInput = useCallback((value) => {
        onUserInput(Field.INPUT, value);
    }, [onUserInput]);
    const handleTypeOutput = useCallback((value) => {
        onUserInput(Field.OUTPUT, value);
    }, [onUserInput]);
    // setting default tokens
    const defaultInputToken = useToken(defaultInputAddress);
    const defaultInputCurrency = defaultInputToken ? unwrappedToken(defaultInputToken, chainId) : undefined;
    const defaultOututToken = useToken(defaultOutputAddress);
    const defaultOutputCurrency = defaultOututToken ? unwrappedToken(defaultOututToken, chainId) : undefined;
    useEffect(() => {
        if (defaultInputCurrency) {
            onCurrencySelection(Field.INPUT, defaultInputCurrency);
        }
        if (defaultOutputCurrency) {
            onCurrencySelection(Field.OUTPUT, defaultOutputCurrency);
        }
    }, [chainId, defaultInputAddress, defaultOutputAddress, defaultInputCurrency, defaultOutputCurrency]);
    // modal and loading
    const [{ showConfirm, tradeToConfirm, swapErrorMessage, attemptingTxn, txHash }, setSwapState] = useState({
        showConfirm: false,
        tradeToConfirm: undefined,
        attemptingTxn: false,
        swapErrorMessage: undefined,
        txHash: undefined,
    });
    const formattedAmounts = {
        [independentField]: typedValue,
        [dependentField]: showWrap
            ? (_b = (_a = parsedAmounts[independentField]) === null || _a === void 0 ? void 0 : _a.toExact()) !== null && _b !== void 0 ? _b : ''
            : (_d = (_c = parsedAmounts[dependentField]) === null || _c === void 0 ? void 0 : _c.toSignificant(6)) !== null && _d !== void 0 ? _d : '',
    };
    const route = trade === null || trade === void 0 ? void 0 : trade.route;
    const tradePrice = trade === null || trade === void 0 ? void 0 : trade.executionPrice;
    const userHasSpecifiedInputOutput = Boolean(currencies[Field.INPUT] && currencies[Field.OUTPUT] && ((_e = parsedAmounts[independentField]) === null || _e === void 0 ? void 0 : _e.greaterThan(JSBI$1.BigInt(0))));
    const noRoute = !route;
    // check whether the user has approved the router on the input token
    const [approval, approveCallback] = useApproveCallbackFromTrade(chainId, trade, allowedSlippage);
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = useState(false);
    // mark when a user has submitted an approval, reset onTokenSelection for input field
    useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const maxAmountInput = maxAmountSpend(chainId, currencyBalances[Field.INPUT]);
    // the callback to execute the swap
    const { callback: swapCallback, error: swapCallbackError } = useSwapCallback(trade, allowedSlippage, recipient);
    const { priceImpactWithoutFee } = computeTradePriceBreakdown(trade);
    const handleSwap = useCallback(() => {
        if (priceImpactWithoutFee && !confirmPriceImpactWithoutFee(priceImpactWithoutFee)) {
            return;
        }
        if (!swapCallback) {
            return;
        }
        setSwapState({ attemptingTxn: true, tradeToConfirm, showConfirm, swapErrorMessage: undefined, txHash: undefined });
        swapCallback()
            .then((hash) => {
                var _a, _b, _c, _d;
                setSwapState({ attemptingTxn: false, tradeToConfirm, showConfirm, swapErrorMessage: undefined, txHash: hash });
                // eslint-disable-next-line import/no-named-as-default-member
                ReactGA.event({
                    category: 'Swap',
                    action: recipient === null
                        ? 'Swap w/o Send'
                        : (recipientAddress !== null && recipientAddress !== void 0 ? recipientAddress : recipient) === account
                            ? 'Swap w/o Send + recipient'
                            : 'Swap w/ Send',
                    label: [(_b = (_a = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _a === void 0 ? void 0 : _a.currency) === null || _b === void 0 ? void 0 : _b.symbol, (_d = (_c = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _c === void 0 ? void 0 : _c.currency) === null || _d === void 0 ? void 0 : _d.symbol, Version.v2].join('/'),
                });
            })
            .catch((error) => {
                setSwapState({
                    attemptingTxn: false,
                    tradeToConfirm,
                    showConfirm,
                    swapErrorMessage: error.message,
                    txHash: undefined,
                });
                // we only care if the error is something _other_ than the user rejected the tx
                if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {
                    console.error(error);
                }
            });
    }, [tradeToConfirm, account, priceImpactWithoutFee, recipient, recipientAddress, showConfirm, swapCallback, trade]);
    const handleSelectTokenDrawerClose = useCallback(() => {
        setIsTokenDrawerOpen(false);
    }, [setIsTokenDrawerOpen]);
    // errors
    // const [showInverted, setShowInverted] = useState<boolean>(false)
    // warnings on slippage
    const priceImpactSeverity = warningSeverity(priceImpactWithoutFee);
    // show approve flow when: no error on inputs, not approved or pending, or approved in current session
    // never show if price impact is above threshold in non expert mode
    const showApproveFlow = !swapInputError &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED)) &&
        !(priceImpactSeverity > 3 && !isExpertMode);
    const handleConfirmDismiss = useCallback(() => {
        setSwapState({ showConfirm: false, tradeToConfirm, attemptingTxn, swapErrorMessage, txHash });
        // if there was a tx hash, we want to clear the input
        if (txHash) {
            onUserInput(Field.INPUT, '');
        }
    }, [attemptingTxn, onUserInput, swapErrorMessage, tradeToConfirm, txHash]);
    const handleAcceptChanges = useCallback(() => {
        setSwapState({ tradeToConfirm: trade, swapErrorMessage, txHash, attemptingTxn, showConfirm });
    }, [attemptingTxn, showConfirm, swapErrorMessage, trade, txHash]);
    // const handleMaxInput = useCallback(() => {
    //   maxAmountInput && onUserInput(Field.INPUT, maxAmountInput.toExact())
    // }, [maxAmountInput, onUserInput])
    const onCurrencySelect = useCallback((currency) => {
        if (tokenDrawerType === Field.INPUT) {
            setApprovalSubmitted(false); // reset 2 step UI for approvals
        }
        onCurrencySelection(tokenDrawerType, currency);
    }, [tokenDrawerType, onCurrencySelection]);
    const isAEBToken = useIsSelectedAEBToken();
    const selectedTokens = useSelectedTokenList();
    const whitelistedTokens = useTokenList(DEFAULT_TOKEN_LISTS_SELECTED);
    const isTrustedToken = useCallback((token) => {
        if (!chainId || !selectedTokens)
            return true; // Assume trusted at first to avoid flashing a warning
        return (TRUSTED_TOKEN_ADDRESSES[chainId].includes(token.address) || // trust token from manually whitelisted token
            isTokenOnList(selectedTokens, chainId, token) || // trust all tokens from selected token list by user
            isTokenOnList(whitelistedTokens, chainId, token) // trust all defi + AB tokens
        );
    }, [chainId, selectedTokens, whitelistedTokens]);
    const closeSwapSettings = useCallback(() => {
        setOpenSettings(false);
    }, [setOpenSettings]);
    const openSwapSettings = useCallback(() => {
        setOpenSettings(true);
    }, [setOpenSettings]);
    const showRoute = Boolean(trade && ((_g = (_f = trade === null || trade === void 0 ? void 0 : trade.route) === null || _f === void 0 ? void 0 : _f.path) === null || _g === void 0 ? void 0 : _g.length) > 2);
    if (openSettings && showSettings) {
        return (jsx(Box, Object.assign({ minHeight: 450 }, { children: jsx(SwapSettingsDrawer, { isOpen: openSettings, close: closeSwapSettings }) })));
    }
    const renderButton = () => {
        var _a;
        if (!account) {
            return (jsx(Button, Object.assign({ isDisabled: !account, variant: "primary", onClick: toggleWalletModal }, { children: "Connect Wallet" })));
        }
        if (showWrap) {
            return (jsx(Button, Object.assign({ variant: "primary", isDisabled: Boolean(wrapInputError), onClick: onWrap }, { children: wrapInputError !== null && wrapInputError !== void 0 ? wrapInputError : (wrapType === WrapType.WRAP ? 'Wrap' : wrapType === WrapType.UNWRAP ? 'unwrap' : null) })));
        }
        if (isLoadingSwap && !swapInputError) {
            return (jsx(Button, Object.assign({ variant: "primary", isDisabled: true }, { children: "Loading" })));
        }
        if (noRoute && userHasSpecifiedInputOutput) {
            return (jsx(Button, Object.assign({ variant: "primary", isDisabled: true }, { children: "Insufficient liquidity for this trade." })));
        }
        if (showApproveFlow) {
            return (jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, {
                children: [jsx(Box, Object.assign({ mr: "10px", width: "100%" }, {
                    children: jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', onClick: () => approveCallback(), isDisabled: approval !== ApprovalState.NOT_APPROVED || approvalSubmitted, loading: approval === ApprovalState.PENDING, loadingText: "Approving" }, {
                        children: approvalSubmitted && approval === ApprovalState.APPROVED
                            ? 'Approved'
                            : 'Approve' + ((_a = currencies[Field.INPUT]) === null || _a === void 0 ? void 0 : _a.symbol)
                    }))
                })), jsx(Button, Object.assign({
                    variant: "primary", onClick: () => {
                        setSwapState({
                            tradeToConfirm: trade,
                            attemptingTxn: false,
                            swapErrorMessage: undefined,
                            showConfirm: true,
                            txHash: undefined,
                        });
                    }, id: "swap-button", isDisabled: !isValid || approval !== ApprovalState.APPROVED || (priceImpactSeverity > 3 && !isExpertMode)
                }, {
                    children: priceImpactSeverity > 3 && !isExpertMode
                        ? 'Price Impact High'
                        : 'Swap' + `${priceImpactSeverity > 2 ? 'Anyway' : ''}`
                }))]
            })));
        }
        return (jsx(Button, Object.assign({
            variant: "primary", onClick: () => {
                setSwapState({
                    tradeToConfirm: trade,
                    attemptingTxn: false,
                    swapErrorMessage: undefined,
                    showConfirm: true,
                    txHash: undefined,
                });
            }, id: "swap-button", isDisabled: !isValid || (priceImpactSeverity > 3 && !isExpertMode) || !!swapCallbackError || !!swapInputError, backgroundColor: isValid && priceImpactSeverity > 2 ? 'primary' : undefined, color: isValid && priceImpactSeverity <= 2 ? 'black' : undefined
        }, {
            children: swapInputError
                ? swapInputError
                : priceImpactSeverity > 3 && !isExpertMode
                    ? 'Price Impact High'
                    : 'Swap' + `${priceImpactSeverity > 2 ? 'Anyway' : ''}`
        })));
    };
    const renderPercentage = () => {
        return (jsx(Box, Object.assign({ display: "flex", pb: "5px" }, {
            children: percentageValue.map((value, index) => (jsxs(PValue, Object.assign({
                isActive: selectedPercentage === value, onClick: () => {
                    var _a;
                    setSelectedPercentage(value);
                    if (maxAmountInput) {
                        const multipyAmount = JSBI$1.multiply(maxAmountInput === null || maxAmountInput === void 0 ? void 0 : maxAmountInput.raw, JSBI$1.BigInt(value));
                        const divideAmount = JSBI$1.divide(multipyAmount, JSBI$1.BigInt(100));
                        const token = wrappedCurrency((_a = maxAmountInput === null || maxAmountInput === void 0 ? void 0 : maxAmountInput.currency) !== null && _a !== void 0 ? _a : undefined, chainId);
                        const newFinalAmount = new TokenAmount(token, divideAmount);
                        onUserInput(Field.INPUT, newFinalAmount.toExact());
                    }
                }
            }, { children: [value, "%"] }), index)))
        })));
    };
    return (jsxs(Root$g, {
        children: [jsx(TradeOption$1, { swapType: swapType, setSwapType: setSwapType, isLimitOrderVisible: isLimitOrderVisible, showSettings: showSettings, openSwapSettings: openSwapSettings }), jsx(TokenWarningModal, { isOpen: urlLoadedTokens.length > 0 && !dismissTokenWarning && !urlLoadedTokens.every(isTrustedToken), tokens: urlLoadedTokens, onConfirm: handleConfirmTokenWarning }), jsx(SwapWrapper, Object.assign({ showRoute: showRoute }, {
            children: jsxs(Box, Object.assign({ p: 10 }, {
                children: [isAEBToken && jsx(DeprecatedWarning, {}), jsx(CurrencyInputTextBox, {
                    label: independentField === Field.OUTPUT && !showWrap && trade ? 'From (estimated)' : 'From', value: formattedAmounts[Field.INPUT], onChange: (value) => {
                        setSelectedPercentage(0);
                        handleTypeInput(value);
                    }, onTokenClick: () => {
                        setTokenDrawerType(Field.INPUT);
                        setIsTokenDrawerOpen(true);
                    }, currency: inputCurrency, fontSize: 24, isNumeric: true, placeholder: "0.00", id: "swap-currency-input", addonLabel: renderPercentage()
                }), jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: "flex", justifyContent: 'center', mt: 10 }, {
                    children: jsx(ArrowWrapper$4, Object.assign({
                        onClick: () => {
                            setApprovalSubmitted(false); // reset 2 step UI for approvals
                            onSwitchTokens();
                        }
                    }, { children: jsx(RefreshCcw, { size: "16", color: (_h = theme.swapWidget) === null || _h === void 0 ? void 0 : _h.interactiveColor }) }))
                })), jsx(CurrencyInputTextBox, {
                    label: independentField === Field.INPUT && !showWrap && trade ? 'To (estimated)' : 'To', value: formattedAmounts[Field.OUTPUT], onChange: (value) => {
                        setSelectedPercentage(0);
                        handleTypeOutput(value);
                    }, onTokenClick: () => {
                        setTokenDrawerType(Field.OUTPUT);
                        setIsTokenDrawerOpen(true);
                    }, currency: outputCurrency, fontSize: 24, isNumeric: true, placeholder: "0.00", id: "swap-currency-output", addonLabel: tradePrice && (jsxs(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 16 }, { children: ["Price: ", tradePrice === null || tradePrice === void 0 ? void 0 : tradePrice.toSignificant(6), " ", (_j = tradePrice === null || tradePrice === void 0 ? void 0 : tradePrice.quoteCurrency) === null || _j === void 0 ? void 0 : _j.symbol] })))
                }), recipient === null && !showWrap && isExpertMode ? (jsx(Box, Object.assign({ display: "flex", flexDirection: "column", marginTop: 10 }, { children: jsx(LinkStyledButton, Object.assign({ id: "add-recipient-button", onClick: () => onChangeRecipient(''), style: { alignSelf: 'end' } }, { children: "+ Add Recipient" })) }))) : null, recipient !== null && !showWrap ? (jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", marginTop: 10, marginBottom: 10 }, {
                    children: [jsx(LinkStyledButton, Object.assign({ id: "add-recipient-button", onClick: () => onChangeRecipient(null), style: { alignSelf: 'end' } }, { children: "- Remove Recipient" })), jsx(TextInput, {
                        label: "Recipient", placeholder: "Wallet Address", value: recipient, onChange: (value) => {
                            const withoutSpaces = value.replace(/\s+/g, '');
                            onChangeRecipient(withoutSpaces);
                        }, addonLabel: recipient && !isAddress(recipient) && jsx(Text, Object.assign({ color: "warning" }, { children: "Invalid Address" }))
                    })]
                }))) : null, trade && jsx(SwapDetailInfo, { trade: trade }), jsx(Box, Object.assign({ width: "100%", mt: 10 }, { children: renderButton() }))]
            }))
        })), trade && showRoute && jsx(SwapRoute, { trade: trade }), isTokenDrawerOpen && (jsx(SelectTokenDrawer$1, { isOpen: isTokenDrawerOpen, onClose: handleSelectTokenDrawerClose, onCurrencySelect: onCurrencySelect, selectedCurrency: tokenDrawerType === Field.INPUT ? inputCurrency : outputCurrency, otherSelectedCurrency: tokenDrawerType === Field.INPUT ? outputCurrency : inputCurrency })), trade && showConfirm && (jsx(ConfirmSwapDrawer$1, { isOpen: showConfirm, trade: trade, originalTrade: tradeToConfirm, onAcceptChanges: handleAcceptChanges, attemptingTxn: attemptingTxn, txHash: txHash, recipient: recipient, allowedSlippage: allowedSlippage, onConfirm: handleSwap, swapErrorMessage: swapErrorMessage, onClose: handleConfirmDismiss }))]
    }));
};

const Root$f = styled(Box)`
  width: 100%;
  min-width: 320px;
  position: relative;
  overflow: hidden;

  * {
    box-sizing: border-box;
  }
`;

const SwapWidget = ({ isLimitOrderVisible = false, onSwapTypeChange, showSettings = true, partnerDaaS = ZERO_ADDRESS, defaultInputToken, defaultOutputToken, }) => {
    const [swapType, setSwapType] = useState(SwapTypes.MARKET);
    return (jsx(Root$f, {
        children: swapType === SwapTypes.LIMIT ? (jsx(LimitOrder, {
            swapType: swapType, setSwapType: (type) => {
                setSwapType(type);
                onSwapTypeChange && onSwapTypeChange(type);
            }, isLimitOrderVisible: isLimitOrderVisible, defaultInputAddress: defaultInputToken, defaultOutputAddress: defaultOutputToken
        })) : (jsx(MarketOrder, {
            swapType: swapType, setSwapType: (type) => {
                setSwapType(type);
                onSwapTypeChange && onSwapTypeChange(type);
            }, isLimitOrderVisible: isLimitOrderVisible, showSettings: showSettings, partnerDaaS: partnerDaaS, defaultInputAddress: defaultInputToken, defaultOutputAddress: defaultOutputToken
        }))
    }));
};

const Wrapper$b = styled(Box)`
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 5px;
`;

const ShowMore = (props) => {
    const { onToggle, showMore } = props;
    const theme = useContext(ThemeContext);
    return (jsxs(Wrapper$b, Object.assign({ onClick: () => onToggle() }, { children: [jsx(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, marginLeft: '6px', textAlign: "center" }, { children: showMore ? 'See Less' : 'See More' })), showMore ? (jsx(ChevronUp, { size: "16", color: theme.text2, style: { marginLeft: '4px' } })) : (jsx(ChevronDown, { size: "16", color: theme.text2, style: { marginLeft: '4px' } }))] })));
};

function useToggle(initialState = false) {
    const [state, setState] = useState(initialState);
    const toggle = useCallback(() => setState((state) => !state), []);
    return [state, toggle];
}

function useSelectedCurrencyLists() {
    var _a;
    const { chainId = ChainId.AVALANCHE } = usePangolinWeb3();
    const allTokens = useAllTokens();
    const coins = Object.values(allTokens || {});
    let addresses = useSelector((state) => { var _a; return [].concat(((_a = state === null || state === void 0 ? void 0 : state.pwatchlists) === null || _a === void 0 ? void 0 : _a.currencies) || []); });
    addresses = [(_a = PNG[chainId]) === null || _a === void 0 ? void 0 : _a.address, ...addresses];
    let allSelectedToken = [];
    addresses.forEach((address) => {
        const filterTokens = coins.filter((coin) => address.toLowerCase() === coin.address.toLowerCase());
        allSelectedToken = [...allSelectedToken, ...filterTokens];
    });
    return allSelectedToken;
}
function useIsSelectedCurrency(address) {
    var _a;
    const { chainId = ChainId.AVALANCHE } = usePangolinWeb3();
    let addresses = useSelector((state) => { var _a; return [].concat(((_a = state === null || state === void 0 ? void 0 : state.pwatchlists) === null || _a === void 0 ? void 0 : _a.currencies) || []); });
    addresses = [(_a = PNG[chainId]) === null || _a === void 0 ? void 0 : _a.address, ...addresses];
    return (addresses || []).includes(address);
}

const Hidden = styled(Box)`
  ${({ theme, upToExtraSmall }) => upToExtraSmall &&
        theme.mediaWidth.upToExtraSmall`
      display: none;
    `};

  ${({ theme, upToSmall }) => upToSmall &&
        theme.mediaWidth.upToSmall`
      display: none;
    `};

  ${({ theme, upToMedium }) => upToMedium &&
        theme.mediaWidth.upToMedium`
      display: none;
    `};

  ${({ theme, upToLarge }) => upToLarge &&
        theme.mediaWidth.upToLarge`
      display: none;
    `};
`;
const Visible = styled(Box)`
  display: none;
  ${({ theme, upToExtraSmall }) => upToExtraSmall &&
        theme.mediaWidth.upToExtraSmall`
    display: block;
  `};

  ${({ theme, upToSmall }) => upToSmall &&
        theme.mediaWidth.upToSmall`
    display: block;
  `};

  ${({ theme, upToMedium }) => upToMedium &&
        theme.mediaWidth.upToMedium`
    display: block;
  `};

  ${({ theme, upToLarge }) => upToLarge &&
        theme.mediaWidth.upToLarge`
    display: block;
  `};
`;
const CloseIcon = styled(X)`
  cursor: pointer;
`;

const GET_BLOCKS = (timestamps) => {
    let queryString = 'query blocks {';
    queryString += timestamps.map((timestamp) => {
        return `t${timestamp}:blocks(first: 1, orderBy: timestamp, orderDirection: asc, where: { timestamp_gt: ${timestamp}, timestamp_lt: ${timestamp + 60 * 60 * 24 * 7
            } }) {
      number
    }`;
    });
    queryString += '}';
    return gql(queryString);
};

const PRICES_BY_BLOCK = (tokenAddress, blocks) => {
    let queryString = 'query blocks {';
    queryString += blocks.map(
        (block) => `
      t${block.timestamp}:token(id:"${tokenAddress}", block: { number: ${block.number} }) { 
        derivedETH
      }
    `,
    );
    queryString += ',';
    queryString += blocks.map(
        (block) => `
      b${block.timestamp}: bundle(id:"1", block: { number: ${block.number} }) { 
        ethPrice
      }
    `,
    );

    queryString += '}';
    return gql(queryString);
};

const client = new ApolloClient({
    link: new HttpLink({
        uri: `${SUBGRAPH_BASE_URL}/exchange`,
    }),
    cache: new InMemoryCache(),
    shouldBatch: true,
});

const blockClient = new ApolloClient({
    link: new HttpLink({
        uri: 'https://api.thegraph.com/subgraphs/name/dasconnor/avalanche-blocks',
    }),
    cache: new InMemoryCache(),
});

const avalancheMininchefV2Client = new GraphQLClient(
    'https://api.thegraph.com/subgraphs/name/sarjuhansaliya/minichefv2-dummy',
    { headers: {} },
);

const mininchefV2Clients = {
    [ChainId.AVALANCHE]: avalancheMininchefV2Client,
    [ChainId.FUJI]: undefined,
    [ChainId.WAGMI]: undefined,
    [ChainId.COSTON]: undefined,
    [ChainId.SONGBIRD]: undefined,
    [ChainId.NEAR_MAINNET]: undefined,
    [ChainId.NEAR_TESTNET]: undefined,
};

const GET_TOKEN_DAY_DATAS = gql`
  query tokenDayDatas($token: String!) {
    tokenDayDatas(first: 7, orderBy: date, orderDirection: desc, where: { token: $token }) {
      id
      date
      priceUSD
      token {
        symbol
      }
    }
  }
`;

function splitQuery(query, localClient, vars, list, skipCount = 100) {
    return __awaiter(this, void 0, void 0, function* () {
        let fetchedData = {};
        let allFound = false;
        let skip = 0;
        while (!allFound) {
            let end = list.length;
            if (skip + skipCount < list.length) {
                end = skip + skipCount;
            }
            const sliced = list.slice(skip, end);
            const result = yield localClient.query({
                query: query(...vars, sliced),
                fetchPolicy: 'cache-first',
            });
            fetchedData = Object.assign(Object.assign({}, fetchedData), result.data);
            if (Object.keys(result.data).length < skipCount || skip + skipCount > list.length) {
                allFound = true;
            }
            else {
                skip += skipCount;
            }
        }
        return fetchedData;
    });
}

dayjs.extend(utc);
function useAllTokenWeeklyPriceChartData() {
    return useSelector((state) => { var _a; return ((_a = state === null || state === void 0 ? void 0 : state.ptoken) === null || _a === void 0 ? void 0 : _a.weekly) || {}; });
}
function useAllTokenPricesChartData() {
    return useSelector((state) => { var _a; return ((_a = state === null || state === void 0 ? void 0 : state.ptoken) === null || _a === void 0 ? void 0 : _a.tokenPrices) || {}; });
}
function useTokenWeeklyChartData(tokenAddress) {
    const data1 = useAllTokenWeeklyPriceChartData();
    const chartData = data1 === null || data1 === void 0 ? void 0 : data1[tokenAddress];
    const dispatch = useDispatch();
    useEffect(() => {
        function checkForChartData() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!chartData) {
                    const data = yield getTokenWeeklyChartData(tokenAddress);
                    dispatch(updateTokenWeeklyPriceChartData({ address: tokenAddress, chartData: data }));
                }
            });
        }
        checkForChartData();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [chartData, tokenAddress]);
    return chartData;
}
const getTokenWeeklyChartData = (tokenAddress) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    let data = [];
    try {
        const result = yield client.query({
            query: GET_TOKEN_DAY_DATAS,
            variables: {
                token: tokenAddress,
            },
            fetchPolicy: 'cache-first',
        });
        data = (_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.tokenDayDatas;
    }
    catch (e) {
        console.log(e);
    }
    data = data.sort((a, b) => (parseInt(a.date) > parseInt(b.date) ? 1 : -1));
    return data;
});
function useTokenPriceData(tokenAddress, timeWindow, interval = 3600, type = 'ALL') {
    const data1 = useAllTokenPricesChartData();
    const chartData = data1 === null || data1 === void 0 ? void 0 : data1[tokenAddress];
    const dispatch = useDispatch();
    useEffect(() => {
        const currentTime = dayjs === null || dayjs === void 0 ? void 0 : dayjs.utc();
        // February 8th 2021 - Arcanum Factory is created
        const startTime = type === 'ALL'
            ? dayjs('2021-02-11').startOf('hour').unix()
            : currentTime
                .subtract(1, timeWindow)
                .startOf('hour')
                .unix();
        function fetch() {
            return __awaiter(this, void 0, void 0, function* () {
                const data = yield getIntervalTokenData(tokenAddress, startTime, undefined, interval);
                dispatch(updateTokenPriceChartData({ address: tokenAddress, chartData: data }));
            });
        }
        fetch();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [interval, timeWindow, tokenAddress]);
    return chartData;
}
const getIntervalTokenData = (tokenAddress, startTime, to = dayjs.utc().unix(), interval = 3600 * 24) => __awaiter(void 0, void 0, void 0, function* () {
    var _b, _c;
    const utcEndTime = to;
    let time = startTime;
    // create an array of hour start times until we reach current hour
    // buffer by half hour to catch case where graph isnt synced to latest block
    const timestamps = [];
    while (time < utcEndTime) {
        timestamps.push(time);
        time += interval;
    }
    // backout if invalid timestamp format
    if (timestamps.length === 0) {
        return [];
    }
    // once you have all the timestamps, get the blocks for each timestamp in a bulk query
    let blocks;
    try {
        blocks = yield getBlocksFromTimestamps(timestamps, 100);
        // catch failing case
        if (!blocks || blocks.length === 0) {
            return [];
        }
        const result = yield splitQuery(PRICES_BY_BLOCK, client, [tokenAddress], blocks, 50);
        // format token ETH price results
        const values = [];
        for (const row in result) {
            const timestamp = row.split('t')[1];
            if (!timestamp)
                continue;
            const derivedETH = parseFloat((_b = result[`t${timestamp}`]) === null || _b === void 0 ? void 0 : _b.derivedETH);
            const ethPrice = parseFloat((_c = result[`b${timestamp}`]) === null || _c === void 0 ? void 0 : _c.ethPrice);
            const priceUSD = ethPrice * derivedETH;
            values.push({
                timestamp,
                derivedETH,
                ethPrice,
                priceUSD,
            });
        }
        const formattedHistory = [];
        // for each hour, construct the open and close price
        for (let i = 0; i < values.length - 1; i++) {
            formattedHistory.push({
                timestamp: values[i].timestamp,
                priceUSD: parseFloat(values === null || values === void 0 ? void 0 : values[i].priceUSD),
            });
        }
        return formattedHistory;
    }
    catch (e) {
        console.log(e);
        console.log('error fetching blocks');
        return [];
    }
});
function getBlocksFromTimestamps(timestamps, skipCount = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        if ((timestamps === null || timestamps === void 0 ? void 0 : timestamps.length) === 0) {
            return [];
        }
        const fetchedData = yield splitQuery(GET_BLOCKS, blockClient, [], timestamps, skipCount);
        const blocks = [];
        if (fetchedData) {
            for (const t in fetchedData) {
                if (fetchedData[t].length > 0) {
                    blocks.push({
                        timestamp: t.split('t')[1],
                        number: fetchedData[t][0]['number'],
                    });
                }
            }
        }
        return blocks;
    });
}

dayjs.extend(utc);
const toK = (num) => {
    return numeral(num).format('0.[00]a');
};
// using a currency library here in case we want to add more in future
const priceFormatter = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
});
const toNiceDateYear = (date) => {
    return dayjs.utc(dayjs.unix(date)).format('MMMM DD, YYYY');
};
const formattedNum = (number, usd = false) => {
    if (isNaN(number) || number === '' || number === undefined) {
        return usd ? '$0' : 0;
    }
    const num = parseFloat(number);
    if (num > 500000000) {
        return (usd ? '$' : '') + toK(num.toFixed(0));
    }
    if (num === 0) {
        if (usd) {
            return '$0';
        }
        return 0;
    }
    if (num < 0.0001 && num > 0) {
        return usd ? '< $0.0001' : '< 0.0001';
    }
    if (num > 1000) {
        return usd
            ? '$' + Number(parseFloat(num).toFixed(0)).toLocaleString()
            : '' + Number(parseFloat(num).toFixed(0)).toLocaleString();
    }
    if (usd) {
        if (num < 0.1) {
            return '$' + Number(parseFloat(num).toFixed(4));
        }
        else {
            const usdString = priceFormatter.format(num);
            return '$' + usdString.slice(1, usdString.length);
        }
    }
    return Number(parseFloat(num).toFixed(5));
};

const WatchListRoot = styled(Box)`
  width: 100%;
  height: 100%;
  border-radius: 10px;
  padding: 20px;
  background-color: ${({ theme }) => theme.color2};
  display: flex;
  flex-direction: column;
`;
const DesktopWatchList = styled(Box)`
  display: flex;
  flex-direction: column;
  ${({ theme }) => theme.mediaWidth.upToSmall`
    display: none;
  `};
`;
const MobileWatchList = styled.div`
  display: none;
  ${({ theme }) => theme.mediaWidth.upToSmall`
  display: block;
`};
`;
const GridContainer$1 = styled(Box)`
  display: grid;
  grid-template-columns: ${({ coinChartVisible }) => (!coinChartVisible ? `100%` : `minmax(auto, 50%) 50%`)};
  grid-gap: 8px;
  flex: 1;
  min-height: 263px;
  ${({ theme }) => theme.mediaWidth.upToSmall`
    grid-template-columns: none;
    grid-template-rows: max-content;
  `};
`;
styled(Box)`
  height: 1px;
  background-color: ${({ theme }) => theme.bg7};
  margin: 10px 0px 10px 0px;
  width: 100%;
`;
styled(Box)`
  max-height: 200px;
  overflow-y: auto;
`;
// WatchList Row Styles
const RowWrapper$2 = styled(Box)`
  padding: 0px 10px;
  display: grid;
  grid-template-columns: 100px minmax(auto, 1fr) max-content;
  align-items: center;
  border-bottom: 1px solid ${({ theme }) => theme.text9};
  cursor: ${({ isSelected }) => (isSelected ? 'default' : 'pointer')} !important;
  background-color: ${({ theme, isSelected }) => (isSelected ? theme.color10 : theme.color2)};

  height: 48px;

  &:hover {
    background-color: ${({ theme }) => theme.color10};
  }
`;
const DeleteButton = styled.button`
  background-image: linear-gradient(to right, rgba(255, 0, 0, 0), ${({ theme }) => theme.bg6});
  background-color: transparent;
  border: 0px;
  color: ${({ theme }) => theme.text1};
  cursor: pointer;
  display: block;
  height: 64px;
  width: 100%;
  position: absolute;
`;
// Coin Chart Styles
const SelectedCoinInfo = styled(Box)`
  display: grid;
  grid-template-columns: max-content auto max-content;
  grid-gap: 8px;
  align-items: center;
`;
const TrackIcons = styled(Box)`
  display: grid;
  grid-template-columns: max-content max-content;
  grid-gap: 15px;
  align-items: center;
`;
const DurationBtns = styled(Box)`
  display: flex;
  justify-content: space-between;
  align-items: center;
`;
const Title$1 = styled(Text)`
  font-size: 24px;
  font-weight: 500;
  color: ${({ theme }) => theme.text1};

  ${({ theme }) => theme.mediaWidth.upToSmall`
    font-size: 24px
  `};
`;

const CoinChart = ({ coin, visibleTradeButton, tradeLinkUrl, redirect }) => {
    const chainId = useChainId();
    const weekFrame = TIMEFRAME.find((value) => value.label === '1W');
    const { tokenUsdPrice } = useCoinGeckoTokenPrice(coin);
    const [timeWindow, setTimeWindow] = useState(weekFrame ||
        {});
    const tokenPrice = useUSDCPrice(coin);
    const usdcPrice = tokenUsdPrice || (tokenPrice === null || tokenPrice === void 0 ? void 0 : tokenPrice.toSignificant(4));
    const { onCurrencySelection } = useSwapActionHandlers(chainId);
    const onCurrencySelect = useCallback((currency) => {
        onCurrencySelection(Field.INPUT, currency);
    }, [onCurrencySelection]);
    const pangolinData = useTokenPriceData(((coin === null || coin === void 0 ? void 0 : coin.address) || '').toLowerCase(), timeWindow === null || timeWindow === void 0 ? void 0 : timeWindow.momentIdentifier, timeWindow === null || timeWindow === void 0 ? void 0 : timeWindow.interval, timeWindow === null || timeWindow === void 0 ? void 0 : timeWindow.label) || [];
    const coinGekoData = useCoinGeckoTokenPriceChart(coin, timeWindow === null || timeWindow === void 0 ? void 0 : timeWindow.days) || [];
    const token = unwrappedToken(coin, chainId);
    const priceChart = coinGekoData.length > 0 ? [...coinGekoData] : [...pangolinData];
    // add current price in chart
    if (priceChart.length > 0 && usdcPrice) {
        const timestampnow = Math.floor(Date.now() / 1000);
        priceChart.push({
            priceUSD: parseFloat(usdcPrice),
            timestamp: `${timestampnow}`,
        });
    }
    return (jsxs(Box, {
        children: [jsxs(SelectedCoinInfo, {
            children: [jsx(CurrencyLogo, { currency: token, size: 48 }), jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: "24px", fontWeight: 500 }, { children: token.symbol })), jsxs(Text, Object.assign({ color: "green1", fontSize: "16px" }, { children: ["$", usdcPrice ? usdcPrice : '-'] }))] }), jsxs(TrackIcons, {
                children: [jsx(Button, Object.assign({ variant: "primary", backgroundColor: "primary", color: "black", width: '32px', height: '32px', padding: "0px", href: `${ANALYTICS_PAGE}/#/token/${coin === null || coin === void 0 ? void 0 : coin.address}`, target: "_blank", as: "a" }, { children: jsx(Link$4, { size: 12 }) })), visibleTradeButton &&
                    (redirect ? (jsx(Button, Object.assign({ variant: "plain", backgroundColor: "oceanBlue", color: "white", padding: "0px 10px", height: "32px", href: `/#${tradeLinkUrl}?inputCurrency=${coin === null || coin === void 0 ? void 0 : coin.address}`, target: "", as: "a" }, { children: "Trade" }))) : (jsx(Button, Object.assign({
                        variant: "plain", backgroundColor: "oceanBlue", color: "white", padding: "0px 10px", height: "32px", onClick: () => {
                            onCurrencySelect(coin);
                        }
                    }, { children: "Trade" }))))]
            })]
        }), jsx(ResponsiveContainer, Object.assign({ height: 150, width: '100%' }, {
            children: jsxs(LineChart, Object.assign({ data: priceChart }, {
                children: [jsx(Line, { type: "monotone", dataKey: "priceUSD", stroke: '#18C145', dot: false }), jsx(Tooltip$1, {
                    cursor: true, formatter: (priceUSD) => {
                        return [`${formattedNum(priceUSD, true)}`, 'USD'];
                    }, labelFormatter: (_label, data) => {
                        var _a, _b;
                        return toNiceDateYear((_b = (_a = data === null || data === void 0 ? void 0 : data[0]) === null || _a === void 0 ? void 0 : _a.payload) === null || _b === void 0 ? void 0 : _b.timestamp);
                    }, labelStyle: { paddingTop: 4 }, wrapperStyle: { top: -70, left: -10, zIndex: 9999 }
                })]
            }))
        })), jsx(DurationBtns, { children: TIMEFRAME.map((btn) => (jsx(Button, Object.assign({ variant: "plain", padding: "0px", width: "auto", color: timeWindow.label === btn.label ? 'mustardYellow' : 'text1', onClick: () => setTimeWindow(btn) }, { children: btn === null || btn === void 0 ? void 0 : btn.label }), btn === null || btn === void 0 ? void 0 : btn.label))) })]
    }));
};

function filterTokens$1(tokens, search) {
    if (search.length === 0)
        return tokens;
    const searchingAddress = isAddress(search);
    if (searchingAddress) {
        return tokens.filter((token) => token.address === searchingAddress);
    }
    const lowerSearchParts = search
        .toLowerCase()
        .split(/\s+/)
        .filter((s) => s.length > 0);
    if (lowerSearchParts.length === 0) {
        return tokens;
    }
    const matchesSearch = (s) => {
        const sParts = s
            .toLowerCase()
            .split(/\s+/)
            .filter((value) => value.length > 0);
        return lowerSearchParts.every((p) => p.length === 0 || sParts.some((sp) => sp.startsWith(p) || sp.endsWith(p)));
    };
    return tokens.filter((token) => {
        const { symbol, name } = token;
        return (symbol && matchesSearch(symbol)) || (name && matchesSearch(name));
    });
}

// compare two token amounts with highest one coming first
function balanceComparator$1(balanceA, balanceB) {
    if (balanceA && balanceB) {
        return balanceA.greaterThan(balanceB) ? -1 : balanceA.equalTo(balanceB) ? 0 : 1;
    }
    else if (balanceA && balanceA.greaterThan('0')) {
        return -1;
    }
    else if (balanceB && balanceB.greaterThan('0')) {
        return 1;
    }
    return 0;
}
function getTokenComparator$1(balances) {
    return function sortTokens(tokenA, tokenB) {
        // -1 = a is first
        // 1 = b is first
        // sort by balances
        const balanceA = balances[tokenA.address];
        const balanceB = balances[tokenB.address];
        const balanceComp = balanceComparator$1(balanceA, balanceB);
        if (balanceComp !== 0)
            return balanceComp;
        if (tokenA.symbol && tokenB.symbol) {
            // sort by symbol
            return tokenA.symbol.toLowerCase() < tokenB.symbol.toLowerCase() ? -1 : 1;
        }
        else {
            return tokenA.symbol ? -1 : tokenB.symbol ? -1 : 0;
        }
    };
}
function useTokenComparator$1(inverted, firstTokens) {
    const balances = useAllTokenBalances();
    const comparator = useMemo(() => getTokenComparator$1(balances !== null && balances !== void 0 ? balances : {}), [balances]);
    return useMemo(() => {
        // if firstToken add firstToken in top of array
        if (firstTokens) {
            return (tokenA, tokenB) => {
                const firstTokenIndex = firstTokens.findIndex((t) => t.address === tokenA.address);
                const secondTokenIndex = firstTokens.findIndex((t) => t.address === tokenB.address);
                if (firstTokenIndex !== -1 || secondTokenIndex !== -1) {
                    return secondTokenIndex - firstTokenIndex;
                }
                return comparator(tokenA, tokenB) * (inverted ? -1 : 1);
            };
        }
        if (inverted) {
            return (tokenA, tokenB) => comparator(tokenA, tokenB) * -1;
        }
        else {
            return comparator;
        }
    }, [inverted, firstTokens, comparator]);
}

// modified from https://usehooks.com/usePrevious/
function usePrevious(value) {
    // The ref object is a generic container whose current property is mutable ...
    // ... and can hold any value, similar to an instance property on a class
    const ref = useRef();
    // Store current value in ref
    useEffect(() => {
        ref.current = value;
    }, [value]); // Only re-run if value changes
    // Return previous value (happens before update in useEffect above)
    return ref.current;
}

styled(Box)`
  padding: 10px;
`;
const AddInputWrapper$1 = styled(Box)`
  display: grid;
  grid-gap: 10px;
`;
const PopoverContainer$1 = styled(Box)`
  z-index: 100;
  background: ${({ theme }) => theme.bg6};
  box-shadow: 0px 0px 1px rgba(0, 0, 0, 0.01), 0px 4px 8px rgba(0, 0, 0, 0.04), 0px 16px 24px rgba(0, 0, 0, 0.04),
    0px 24px 32px rgba(0, 0, 0, 0.01);
  color: ${({ theme }) => theme.text2};
  border-radius: 0.5rem;
  padding: 5px;
  display: flex;
  flex-direction: column;
  font-size: 1rem;
  text-align: left;
  height: 200px;
  position: absolute;
  min-width: 20.125rem;
  right: -6px;
  margin-top: 20px;
  &:after {
    content: '';
    position: absolute;
    top: -14px;
    left: 280px;
    border-style: solid;
    border-width: 0px 15px 15px;
    border-color: ${({ theme }) => theme.bg6} transparent;
    display: block;
    width: 0;
    z-index: 1;
  }
`;
const RowWrapper$1 = styled.div`
  padding: 5px 5px;
  display: grid;
  grid-template-columns: 100px minmax(auto, calc(100% - 150px)) 50px;
  align-items: center;
  border-bottom: 1px solid ${({ theme }) => theme.text9};
  border-radius: 4px 4px 0px 0px;
  height: 45px;

  cursor: ${({ disabled }) => !disabled && 'pointer'};
  pointer-events: ${({ disabled }) => disabled && 'none'};

  &:hover {
    background-color: ${({ theme, disabled }) => !disabled && theme.bg3};
  }

  opacity: ${({ disabled }) => (disabled ? 0.5 : 1)};
`;
const CurrencyList$2 = styled.div`
  display: flex;
  flex: 1;
  flex-direction: column;
  position: relative;
  overflow-y: auto;
`;

const WatchlistCurrencyRow = ({ currency, onSelect, style }) => {
    const usdcPrice = useUSDCPrice(currency);
    const isSelected = useIsSelectedCurrency(currency === null || currency === void 0 ? void 0 : currency.address);
    const chainId = useChainId();
    const handleSelect = useCallback(() => {
        onSelect(currency === null || currency === void 0 ? void 0 : currency.address);
    }, [onSelect, currency]);
    const token = unwrappedToken(currency, chainId);
    return (jsxs(RowWrapper$1, Object.assign({ disabled: isSelected, style: style }, { children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsx(CurrencyLogo, { size: 24, currency: token }), jsx(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 400, marginLeft: '6px' }, { children: token === null || token === void 0 ? void 0 : token.symbol }))] })), jsx(Box, Object.assign({ ml: '10px', textAlign: "right" }, { children: jsxs(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 400 }, { children: ["$", usdcPrice ? usdcPrice === null || usdcPrice === void 0 ? void 0 : usdcPrice.toSignificant(4, { groupSeparator: ',' }) : '-'] })) })), jsx(Box, Object.assign({ ml: '10px', textAlign: "right" }, { children: jsx(Button, Object.assign({ variant: "secondary", backgroundColor: "bg9", color: "text6", padding: '0px', onClick: handleSelect, height: "24px" }, { children: "Add" })) }))] })));
};

const currencyKey$1 = (currency, chainId) => {
    var _a, _b;
    return currency instanceof Token$1
        ? currency.address
        : currency === CAVAX[chainId] && ((_a = CAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.symbol)
            ? (_b = CAVAX[chainId]) === null || _b === void 0 ? void 0 : _b.symbol
            : '';
};
const CurrencyPopover = ({ getRef = () => {
    /* */
}, coins, isOpen, onSelectCurrency, }) => {
    const [searchQuery, setSearchQuery] = useState('');
    const [invertSearchOrder] = useState(false);
    const chainId = useChainId();
    const inputRef = useRef(null);
    const lastOpen = usePrevious(isOpen);
    useEffect(() => {
        if (isOpen && !lastOpen) {
            setSearchQuery('');
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen]);
    useEffect(() => {
        if (isOpen && inputRef.current) {
            setTimeout(() => {
                var _a;
                (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }, 500);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen]);
    const isAddressSearch = isAddress(searchQuery);
    const searchToken = useToken(searchQuery);
    const tokenComparator = useTokenComparator$1(invertSearchOrder, [WAVAX[chainId]]);
    const filteredTokens = useMemo(() => {
        if (isAddressSearch)
            return searchToken ? [searchToken] : [];
        return filterTokens$1(Object.values(coins), searchQuery);
    }, [isAddressSearch, searchToken, coins, searchQuery]);
    const filteredSortedTokens = useMemo(() => {
        if (searchToken)
            return [searchToken];
        const sorted = filteredTokens.sort(tokenComparator);
        const symbolMatch = searchQuery
            .toLowerCase()
            .split(/\s+/)
            .filter((s) => s.length > 0);
        if (symbolMatch.length > 1)
            return sorted;
        return [
            ...(searchToken ? [searchToken] : []),
            // sort any exact symbol matches first
            ...sorted.filter((token) => { var _a; return ((_a = token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === symbolMatch[0]; }),
            ...sorted.filter((token) => { var _a; return ((_a = token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== symbolMatch[0]; }),
        ];
    }, [filteredTokens, searchQuery, searchToken, tokenComparator]);
    const currencies = filteredSortedTokens;
    const dispatch = useDispatch();
    const onCurrencySelection = useCallback((address) => {
        dispatch(addCurrency(address));
    }, [dispatch]);
    const Row = useCallback(({ data, index, style }) => {
        const currency = data === null || data === void 0 ? void 0 : data[index];
        return currency ? (jsx(WatchlistCurrencyRow, {
            style: style, currency: currency, onSelect: (address) => {
                onSelectCurrency(currency);
                onCurrencySelection(address);
            }
        }, index)) : null;
    },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []);
    return (jsxs(PopoverContainer$1, Object.assign({ ref: (ref) => getRef(ref) }, {
        children: [jsx(Box, Object.assign({ padding: "0px 10px" }, {
            children: jsx(AddInputWrapper$1, {
                children: jsx(TextInput, {
                    placeholder: "Search", onChange: (value) => {
                        setSearchQuery(value);
                    }, value: searchQuery, getRef: (ref) => (inputRef.current = ref)
                })
            })
        })), jsx(CurrencyList$2, { children: jsx(AutoSizer, Object.assign({ disableWidth: true }, { children: ({ height }) => (jsx(FixedSizeList, Object.assign({ height: height, width: "100%", itemCount: currencies.length, itemSize: 45, itemData: currencies, itemKey: (index, data) => currencyKey$1(data[index], chainId) }, { children: Row }))) })) })]
    })));
};

const WatchlistRow = ({ coin, onClick, onRemove, isSelected }) => {
    var _a, _b, _c;
    const chainId = useChainId();
    const [showChart, setShowChart] = useState(false);
    const [showDeleteButton, setShowDeleteButton] = useState(false);
    const theme = useContext(ThemeContext);
    const { tokenUsdPrice } = useCoinGeckoTokenPrice(coin);
    const tokenPrice = useUSDCPrice(coin);
    const usdcPrice = tokenUsdPrice || (tokenPrice === null || tokenPrice === void 0 ? void 0 : tokenPrice.toSignificant(4));
    const coinGekoData = useCoinGeckoTokenPriceChart(coin) || [];
    const pangolinData = useTokenWeeklyChartData((_a = coin === null || coin === void 0 ? void 0 : coin.address) === null || _a === void 0 ? void 0 : _a.toLowerCase());
    const chartData = coinGekoData.length > 0 ? coinGekoData : pangolinData;
    const currentUSDPrice = ((_b = chartData === null || chartData === void 0 ? void 0 : chartData[(chartData || []).length - 1]) === null || _b === void 0 ? void 0 : _b.priceUSD) || 0;
    const previousUSDPrice = ((_c = chartData === null || chartData === void 0 ? void 0 : chartData[0]) === null || _c === void 0 ? void 0 : _c.priceUSD) || 0;
    const diffPercent = currentUSDPrice - previousUSDPrice < 0 ? -1 : 1;
    const decreaseValue = currentUSDPrice - previousUSDPrice;
    const perc = (decreaseValue / previousUSDPrice) * 100;
    const token = unwrappedToken(coin, chainId);
    const dispatch = useDispatch();
    const removeToken = () => {
        onRemove();
        dispatch(removeCurrency(coin === null || coin === void 0 ? void 0 : coin.address));
    };
    useEffect(() => {
        if (usdcPrice) {
            setTimeout(() => {
                // show chart only after price of token comes to display chart in visible space
                setShowChart(true);
            });
        }
    }, [usdcPrice, setShowChart]);
    return (jsxs(RowWrapper$2, Object.assign({ isSelected: isSelected, onMouseEnter: () => setShowDeleteButton(true), onMouseLeave: () => setShowDeleteButton(false) }, { children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center", height: '100%', onClick: onClick }, { children: [jsx(CurrencyLogo, { size: 24, currency: token, imageSize: 48 }), jsx(Text, Object.assign({ color: "text1", fontSize: 20, fontWeight: 500, marginLeft: '6px' }, { children: token.symbol }))] })), jsx(Box, Object.assign({ px: "7px", display: "flex", alignItems: "center", height: '100%', onClick: onClick }, { children: showChart && (jsx(ResponsiveContainer, Object.assign({ width: '99%' }, { children: jsx(LineChart, Object.assign({ data: chartData, margin: { top: 23 } }, { children: jsx(Line, { type: "monotone", dataKey: "priceUSD", stroke: diffPercent >= 0 ? theme.green1 : theme.red1, dot: false }) })) }))) })), jsxs(Box, Object.assign({ textAlign: "right", minWidth: 30, height: '100%' }, { children: [showDeleteButton && coin.address !== PNG[chainId].address && (jsx(Box, Object.assign({ zIndex: 2, position: "relative" }, { children: jsx(DeleteButton, Object.assign({ onClick: removeToken }, { children: jsx(X, { fontSize: 16, fontWeight: 600, style: { float: 'right' } }) })) }))), jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", height: "100%", onClick: onClick }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 500 }, { children: usdcPrice ? `$${usdcPrice}` : '-' })), !isNaN(perc) && (jsxs(Text, Object.assign({ color: diffPercent > 0 ? 'green1' : 'red1', fontSize: '8px', fontWeight: 500 }, { children: [perc.toFixed(3), "%"] })))] }))] }))] })));
};

const WatchList = ({ coinChartVisible = true, visibleTradeButton = true, tradeLinkUrl, redirect = false, }) => {
    var _a;
    const { chainId = ChainId.AVALANCHE } = usePangolinWeb3();
    const [showMore, setShowMore] = useState(false);
    const allTokens = useAllTokens();
    const coins = Object.values(allTokens || {});
    const watchListCurrencies = useSelectedCurrencyLists();
    const theme = useContext(ThemeContext);
    const [selectedToken, setSelectedToken] = useState((watchListCurrencies === null || watchListCurrencies === void 0 ? void 0 : watchListCurrencies[0]) || {});
    const [open, toggle] = useToggle(false);
    const node = useRef();
    const popoverRef = useRef(null);
    const referenceElement = useRef(null);
    const currencies = useMemo(() => ((watchListCurrencies || []).length === 0 ? [PNG[chainId]] : watchListCurrencies), [chainId, watchListCurrencies]);
    useOnClickOutside(node, open ? toggle : undefined);
    const renderWatchlistRow = (coin) => {
        return (jsx(WatchlistRow, { coin: coin, onClick: () => setSelectedToken(coin), onRemove: () => setSelectedToken(PNG[chainId]), isSelected: (coin === null || coin === void 0 ? void 0 : coin.address) === (selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.address) }, coin.address));
    };
    const renderCoinChart = () => {
        return (jsx(Hidden, Object.assign({ upToSmall: true }, { children: jsx(CoinChart, { coin: selectedToken, visibleTradeButton: visibleTradeButton, tradeLinkUrl: tradeLinkUrl, redirect: redirect }) })));
    };
    return (jsxs(WatchListRoot, {
        children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, {
            children: [jsx(Title$1, { children: "Watchlist" }), jsxs(Box, Object.assign({ bgColor: theme.bg5, position: "relative", p: '5px', ref: node }, {
                children: [jsx(Box, Object.assign({ ref: referenceElement, onClick: toggle }, { children: jsx(Button, Object.assign({ variant: "primary", backgroundColor: "primary", color: "white", width: '32px', height: '32px', padding: "0px" }, { children: jsx(Plus, { size: 12, color: 'black' }) })) })), open && (jsx(CurrencyPopover, {
                    getRef: (ref) => (popoverRef.current = ref), coins: coins, isOpen: open, onSelectCurrency: (currency) => {
                        setSelectedToken(currency);
                        toggle();
                    }
                }))]
            }))]
        })), jsxs(GridContainer$1, Object.assign({ coinChartVisible: coinChartVisible }, { children: [((_a = CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet) && coinChartVisible && renderCoinChart(), jsx(DesktopWatchList, { children: jsx(Scrollbars, { children: (currencies || []).map(renderWatchlistRow) }) }), jsxs(MobileWatchList, { children: [(currencies || []).slice(0, 3).map(renderWatchlistRow), showMore && (currencies || []).slice(3).map(renderWatchlistRow), currencies.length > 3 && jsx(ShowMore, { showMore: showMore, onToggle: () => setShowMore(!showMore) })] })] }))]
    }));
};

var Earth = "data:image/png;base64,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";

// Get News in Arcanum Strapi api
function useGetNews() {
    var _a;
    const chainId = useChainId();
    const chain = (_a = getChainByNumber(chainId)) !== null && _a !== void 0 ? _a : AVALANCHE_MAINNET;
    const query = qs.stringify({
        sort: ['-date_created'],
        filter: {
            status: {
                _eq: 'published',
            },
        },
    }, {
        encodeValuesOnly: true,
    });
    return useQuery(['getNews', chain.id], () => __awaiter(this, void 0, void 0, function* () {
        var _b;
        const response = yield axios.get(`${DIRECTUS_URL_NEWS}/items/news?${query}`, {
            timeout: 60000,
        });
        const data = response.data;
        const news = (_b = data === null || data === void 0 ? void 0 : data.data) === null || _b === void 0 ? void 0 : _b.map((element) => {
            return {
                id: element === null || element === void 0 ? void 0 : element.id,
                title: element === null || element === void 0 ? void 0 : element.title,
                content: element === null || element === void 0 ? void 0 : element.content,
                createdAt: new Date(element === null || element === void 0 ? void 0 : element.date_created),
                updatedAt: !(element === null || element === void 0 ? void 0 : element.date_updated) ? null : new Date(element === null || element === void 0 ? void 0 : element.date_updated),
                chains: element === null || element === void 0 ? void 0 : element.chain,
            };
        });
        return news.filter((element) => element.chains.includes(chain.symbol.toLocaleUpperCase()) || element.chains.includes('all'));
    }), {
        cacheTime: 60 * 60 * 1000,
        refetchInterval: 60 * 10 * 1000, // 10 minutes
    });
}

// news section
const NewsSection = styled(Box)`
  background-color: ${({ theme }) => theme.bg2};
  background-image: url(${(props) => props.img});
  background-repeat: no-repeat;
  background-position: bottom right;
  height: 100%;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  overflow: hidden;
  & .slick-slider {
    height: 100%;
    padding: 0px;

    .slick-dots {
      bottom: 0px;
      li button:before {
        color: ${({ theme }) => theme.text1};
      }
      li.slick-active button:before {
        color: ${({ theme }) => theme.text1};
      }
    }
  }

  & .slick-slide {
    height: auto;

    & div {
      height: 100%;
    }
  }

  & .slick-list {
    height: 100%;
    overflow: hidden;
  }

  & .slick-track {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: stretch;
    height: 100%;
  }

  ${({ theme }) => theme.mediaWidth.upToSmall`
    height: 600px;
  `};
`;
const NewsTitle = styled(Box)`
  align-self: start;
  font-weight: bold;
  font-size: 24px;
  line-height: 48px;
  padding: 20px;
  background: linear-gradient(0deg, #ffc800, #ffc800);
  border-radius: 5px 0px 5px 0px;
`;
const NewsContent = styled(Box)`
  color: ${({ theme }) => theme.text7};
  font-weight: 400;
  font-size: 16px;
  line-height: 27px;
  height: 90% !important;
  padding: 0px 20px;
  & a {
    color: ${({ theme }) => theme.text7};
  }
`;
const NewsDate = styled(Box)`
  font-size: 10px;
  line-height: 15px;
  display: flex;
  align-items: center;
  color: #929292;
  margin-bottom: 15px;
  height: 10% !important;
  padding: 0px 10px;
`;
const SlickNext = styled(Box)`
  background: ${({ theme }) => theme.primary};
  width: 32px;
  height: 32px;
  border-radius: 16px;
  display: flex;
  justify-content: center;
  align-items: center;

  &:hover {
    cursor: pointer;
  }
  z-index: 9999;
`;
const TitleWrapper = styled(Box)`
  display: flex;
  justify-content: space-between;
`;
const ArrowWrapper$3 = styled(Box)`
  display: flex;
  gap: 10px;
  padding: 20px;
`;

// import 'slick-carousel/slick/slick.css';
// import 'slick-carousel/slick/slick-theme.css';
const NewsFeedSettings = {
    dots: false,
    infinite: true,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: false,
    autoplay: false,
    autoplaySpeed: 10000,
};
const NewsWidget = ({ boxHeight = '400px' }) => {
    const theme = useContext(ThemeContext);
    const sliderRef = useRef(null);
    const handleNewsNext = () => {
        var _a;
        (_a = sliderRef === null || sliderRef === void 0 ? void 0 : sliderRef.current) === null || _a === void 0 ? void 0 : _a.slickNext();
    };
    const handleNewsBack = () => {
        var _a;
        (_a = sliderRef === null || sliderRef === void 0 ? void 0 : sliderRef.current) === null || _a === void 0 ? void 0 : _a.slickPrev();
    };
    const { data: news, isLoading } = useGetNews();
    return (jsxs(NewsSection, Object.assign({ img: Earth }, {
        children: [jsxs(TitleWrapper, { children: [jsx(NewsTitle, { children: "News" }), jsxs(ArrowWrapper$3, { children: [jsx(SlickNext, Object.assign({ onClick: handleNewsBack, style: { right: 60 } }, { children: jsx(ArrowLeft, { size: 20, style: { minWidth: 24 } }) })), jsx(SlickNext, Object.assign({ onClick: handleNewsNext }, { children: jsx(ArrowRight, { size: 20, style: { minWidth: 24 } }) }))] })] }), jsx("div", Object.assign({ style: { height: '100%' } }, {
            children: !isLoading ? (jsx(Slider, Object.assign({ ref: sliderRef }, NewsFeedSettings, {
                children: news &&
                    news.map((element) => {
                        var _a, _b;
                        return (jsxs("div", {
                            children: [jsx(NewsContent, {
                                children: jsx(Scrollbars, Object.assign({
                                    style: { minHeight: boxHeight, padding: '0px 10px' },
                                    // eslint-disable-next-line react/prop-types
                                    renderView: (props) => jsx("div", Object.assign({}, props, { style: Object.assign(Object.assign({}, props.style), { overflowX: 'hidden' }) })), renderThumbVertical: (props) => (jsx("div", Object.assign({}, props, { style: Object.assign(Object.assign({}, props.style), { backgroundColor: theme.text1, opacity: 0.2, cursor: 'pointer', borderRadius: '3px' }) })))
                                }, {
                                    children: jsx(ReactMarkdown, Object.assign({
                                        remarkPlugins: [remarkGfm], linkTarget: '_blank', components: {
                                            /* eslint-disable react/prop-types */
                                            a: (_a) => {
                                                var { children } = _a, props = __rest(_a, ["children"]);
                                                const linkProps = props;
                                                if (props.target === '_blank') {
                                                    linkProps['rel'] = 'noopener noreferrer';
                                                }
                                                return jsx("a", Object.assign({}, linkProps, { children: children }));
                                            },
                                        }
                                    }, { children: element.content }))
                                }))
                            }), jsxs(NewsDate, {
                                children: [(element === null || element === void 0 ? void 0 : element.updatedAt)
                                    ? (_a = element === null || element === void 0 ? void 0 : element.updatedAt) === null || _a === void 0 ? void 0 : _a.toLocaleTimeString()
                                    : element === null || element === void 0 ? void 0 : element.createdAt.toLocaleTimeString(), ", ", element.updatedAt ? (_b = element === null || element === void 0 ? void 0 : element.updatedAt) === null || _b === void 0 ? void 0 : _b.toDateString() : element === null || element === void 0 ? void 0 : element.createdAt.toDateString()]
                            })]
                        }, element.id));
                    })
            }))) : (jsx(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "center", height: "100%" }, { children: jsx(Loader, { size: 100 }) })))
        }))]
    })));
};

const Frame$3 = styled(Box)`
  width: 40vw;
  background-color: ${({ theme }) => theme.bg2};
  padding: 30px;
  display: grid;
  position: relative;
  grid-template-areas:"text buttons"
                      "chains chains";
  grid-template-columns: grid-template-columns: repeat(2, 50%);

  ${({ theme }) => theme.mediaWidth.upToMedium`
    width: 60vw;
  `};

  ${({ theme }) => theme.mediaWidth.upToSmall`
    width: 100vw;
  `};

`;
const ButtonFrame = styled(Box)`
  grid-area: buttons;
  display: flex;
  justify-content: flex-end;
  align-items: flex-start;
`;
const CloseButton$1 = styled(CloseIcon)`
  color: ${({ theme }) => theme.text1};
  position: absolute;
  right: 3px;
  top: 3px;
`;
const ChainsList = styled(Box)`
  display: grid;
  grid-template-columns: repeat(2, auto);
  gap: 20px;
`;
const ChainButton = styled.button`
  background-color: ${({ theme }) => theme.bg8};
  display: flex;
  align-items: center;
  border: 0px;
  border-radius: 5px;
  cursor: pointer;
  padding: 10px;
  height: 48px;
  font-weight: 500;

  :hover {
    opacity: 0.5;
  }
`;
const Logo = styled.img`
  border-radius: 20px;
  height: 28px;
  width: 28px;
  margin-right: 10px;
`;

var NETWORK_TYPE;
(function (NETWORK_TYPE) {
    NETWORK_TYPE["MAINNET"] = "Mainnet";
    NETWORK_TYPE["TESTNET"] = "Testnet";
})(NETWORK_TYPE || (NETWORK_TYPE = {}));
const NetworkSelection = (props) => {
    const { open, closeModal } = props;
    const [mainnet, setMainnet] = useState(true);
    const [chainListHeight, setChainListHeight] = useState(48);
    const { ethereum } = window;
    const chains = ALL_CHAINS.filter((chain) => chain.pangolin_is_live && chain.mainnet === mainnet);
    const provider = useMemo(() => {
        if (window.xfi && window.xfi.ethereum) {
            return window.xfi.ethereum;
        }
        else if (window.bitkeep && window.isBitKeep) {
            return window.bitkeep.ethereum;
        }
        return window.ethereum;
    }, undefined);
    useEffect(() => {
        if (chains.length / 2 <= 1)
            setChainListHeight(48);
        else if (chains.length / 2 <= 2)
            setChainListHeight(116);
        else
            setChainListHeight(184);
    }, [mainnet]);
    const changeChain = (chain) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        if (ethereum) {
            try {
                yield provider.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: `0x${(_a = chain === null || chain === void 0 ? void 0 : chain.chain_id) === null || _a === void 0 ? void 0 : _a.toString(16)}` }],
                });
                window.location.reload();
                closeModal();
            }
            catch (error) {
                // This error code indicates that the chain has not been added to MetaMask.
                const metamask = error;
                if (metamask.code === 4902) {
                    try {
                        yield provider.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainName: chain.name,
                                    chainId: `0x${(_b = chain === null || chain === void 0 ? void 0 : chain.chain_id) === null || _b === void 0 ? void 0 : _b.toString(16)}`,
                                    //nativeCurrency: chain.nativeCurrency,
                                    rpcUrls: [chain.rpc_uri],
                                    blockExplorerUrls: chain.blockExplorerUrls,
                                    iconUrls: chain.logo,
                                    nativeCurrency: chain.nativeCurrency,
                                },
                            ],
                        });
                        closeModal();
                    }
                    catch (_error) {
                        return;
                    }
                }
            }
        }
    });
    return (jsx(Modal, Object.assign({ isOpen: open, onDismiss: closeModal }, {
        children: jsxs(Frame$3, {
            children: [jsx(CloseButton$1, { onClick: closeModal }), jsx(Text, Object.assign({ color: "text1", fontSize: "24px", marginBottom: 20, style: { gridArea: 'text' } }, { children: "Select Chain" })), jsx(ButtonFrame, {
                children: jsx(ToggleButtons, {
                    options: [NETWORK_TYPE.MAINNET, NETWORK_TYPE.TESTNET], value: mainnet === true ? NETWORK_TYPE.MAINNET : NETWORK_TYPE.TESTNET, onChange: (value) => {
                        setMainnet(value === NETWORK_TYPE.MAINNET);
                    }
                })
            }), jsx(Box, Object.assign({ height: chainListHeight, style: { gridArea: 'chains' } }, { children: jsx(Scrollbars$1, { children: jsx(ChainsList, { children: chains.map((chain, index) => (jsxs(ChainButton, Object.assign({ onClick: () => changeChain(chain) }, { children: [jsx(Logo, { src: chain.logo }), jsx(Text, Object.assign({ color: "text1" }, { children: chain.name }))] }), index))) }) }) }))]
        })
    })));
};

const InfoCard = styled.button`
  background-color: ${({ theme, active }) => (active ? theme.bg3 : theme.bg2)};
  padding: 1rem;
  outline: none;
  border: 1px solid;
  border-radius: 12px;
  width: 100% !important;
  &:focus {
    box-shadow: 0 0 0 1px ${({ theme }) => theme.primary1};
  }
  border-color: ${({ theme, active }) => (active ? 'transparent' : theme.bg3)};
`;
const OptionCard = styled(InfoCard)`
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  margin-top: 2rem;
  padding: 1rem;
`;
const OptionCardLeft = styled.div`
  ${({ theme }) => theme.flexColumnNoWrap};
  justify-content: center;
  height: 100%;
`;
const OptionCardClickable = styled(OptionCard)`
  margin-top: 0;
  &:hover {
    cursor: ${({ clickable }) => (clickable ? 'pointer' : '')};
    border: ${({ clickable, theme }) => (clickable ? `1px solid ${theme.primary}` : ``)};
  }
  opacity: ${({ disabled }) => (disabled ? '0.5' : '1')};
`;
const GreenCircle = styled.div`
  ${({ theme }) => theme.flexRowNoWrap}
  justify-content: center;
  align-items: center;

  &:first-child {
    height: 8px;
    width: 8px;
    margin-right: 8px;
    background-color: ${({ theme }) => theme.green1};
    border-radius: 50%;
  }
`;
const CircleWrapper = styled.div`
  color: ${({ theme }) => theme.green1};
  display: flex;
  justify-content: center;
  align-items: center;
`;
const HeaderText = styled.div`
  ${({ theme }) => theme.flexRowNoWrap};
  color: ${(props) => (props.color === 'blue' ? ({ theme }) => theme.primary1 : ({ theme }) => theme.text1)};
  font-size: 1rem;
  font-weight: 500;
`;
const SubHeader = styled.div`
  color: ${({ theme }) => theme.text1};
  margin-top: 10px;
  font-size: 12px;
`;
const IconWrapper = styled.div`
  ${({ theme }) => theme.flexColumnNoWrap};
  align-items: center;
  justify-content: center;
  & > img,
  span {
    height: ${({ size }) => (size ? size + 'px' : '24px')};
    width: ${({ size }) => (size ? size + 'px' : '24px')};
  }
  ${({ theme }) => theme.mediaWidth.upToMedium`
    align-items: flex-end;
  `};
`;

function Option({ link = null, clickable = true, size, onClick = null, color, header, subheader = null, icon, active = false, id, }) {
    const content = (jsxs(OptionCardClickable, Object.assign({ id: id, onClick: onClick, clickable: clickable && !active, active: active }, { children: [jsxs(OptionCardLeft, { children: [jsxs(HeaderText, Object.assign({ color: color }, { children: [active ? (jsx(CircleWrapper, { children: jsx(GreenCircle, { children: jsx("div", {}) }) })) : (''), header] })), subheader && jsx(SubHeader, { children: subheader })] }), jsx(IconWrapper, Object.assign({ size: size }, { children: jsx("img", { src: icon, alt: 'Icon' }) }))] })));
    if (link) {
        return jsx(ExternalLink, Object.assign({ href: link }, { children: content }));
    }
    return content;
}

const rotate = keyframes`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`;
const StyledSVG$1 = styled.svg`
  animation: 2s ${rotate} linear infinite;
  height: ${({ size }) => size};
  width: ${({ size }) => size};
  path {
    stroke: ${({ stroke, theme }) => stroke !== null && stroke !== void 0 ? stroke : theme.primary1};
  }
`;

/**
 * Takes in custom size and stroke for circle color, default to primary color as fill,
 * need ...rest for layered styles on top
 */
function CircleLoader(_a) {
    var { size = '16px', stroke } = _a, rest = __rest(_a, ["size", "stroke"]);
    return (jsx(StyledSVG$1, Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", size: size, stroke: stroke }, rest, { children: jsx("path", { d: "M12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 9.27455 20.9097 6.80375 19.1414 5", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round" }) })));
}

const PendingSection = styled.div`
  ${({ theme }) => theme.flexColumnNoWrap};
  align-items: center;
  justify-content: center;
  width: 100%;
  & > * {
    width: 100%;
  }
`;
const StyledLoader = styled(CircleLoader)`
  margin-right: 1rem;
`;
const LoadingMessage = styled.div`
  ${({ theme }) => theme.flexRowNoWrap};
  align-items: center;
  justify-content: flex-start;
  border-radius: 12px;
  margin-bottom: 20px;
  color: ${({ theme, error }) => (error ? theme.red1 : 'inherit')};
  border: 1px solid ${({ theme, error }) => (error ? theme.red1 : theme.text4)};

  & > * {
    padding: 1rem;
  }
`;
const ErrorGroup = styled.div`
  ${({ theme }) => theme.flexRowNoWrap};
  align-items: center;
  justify-content: flex-start;
`;
const ErrorButton = styled.div`
  border-radius: 8px;
  font-size: 12px;
  color: ${({ theme }) => theme.text1};
  background-color: ${({ theme }) => theme.bg4};
  margin-left: 1rem;
  padding: 0.5rem;
  font-weight: 600;
  user-select: none;

  &:hover {
    cursor: pointer;
    background-color: ${({ theme }) => darken(0.1, theme.text4)};
  }
`;
const LoadingWrapper$1 = styled.div`
  ${({ theme }) => theme.flexRowNoWrap};
  align-items: center;
  justify-content: center;
`;

function PendingView({ option, connector, error = false, setPendingError, tryActivation, }) {
    return (jsxs(PendingSection, {
        children: [jsx(LoadingMessage, Object.assign({ error: error }, {
            children: jsx(LoadingWrapper$1, {
                children: error ? (jsxs(ErrorGroup, {
                    children: [jsx("div", { children: "Error connecting." }), jsx(ErrorButton, Object.assign({
                        onClick: () => {
                            setPendingError(false);
                            connector && option && tryActivation(connector, option);
                        }
                    }, { children: "Try Again" }))]
                })) : (jsxs(Fragment, { children: [jsx(StyledLoader, {}), "Initializing..."] }))
            })
        })), option && (jsx(Option, { id: `connect-${option.name}`, clickable: false, color: option.color, header: option.name, subheader: option.description, icon: option.iconName }, option.name))]
    }));
}

const CloseButton = styled(CloseIcon)`
  color: ${({ theme }) => theme.text1};
  position: relative;
  right: -3px;
  top: 3px;
`;
const Wrapper$a = styled.div`
  ${({ theme }) => theme.flexColumnNoWrap}
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  max-width: 422px;
  border-radius: 10px;
  background-color: ${({ theme, background }) => (background ? background : theme.bg2)};
  ${({ theme }) => theme.mediaWidth.upToMedium`max-width: 100%`};
`;
const ModalWrapper = styled(Box)`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0rem 2rem;
  ${({ theme }) => theme.mediaWidth.upToMedium`padding: 0rem 1rem`};
`;
const HeaderRow = styled.div`
  ${({ theme }) => theme.flexRowNoWrap};
  padding: 1rem 0rem;
  font-weight: 500;
  color: ${({ theme }) => theme.color4};
`;
const ContentWrapper$1 = styled.div`
  padding: 0 2rem 2rem 2rem;
  ${({ theme }) => theme.mediaWidth.upToMedium`padding: 0 1rem 1rem 1rem`};
`;
const UpperSection = styled.div`
  position: relative;

  h5 {
    margin: 0;
    margin-bottom: 0.5rem;
    font-size: 1rem;
    font-weight: 400;
  }

  h5:last-child {
    margin-bottom: 0px;
  }

  h4 {
    margin-top: 0;
    font-weight: 500;
  }
`;
const Blurb = styled.div`
  ${({ theme }) => theme.flexRowNoWrap}
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 2rem;
  ${({ theme }) => theme.mediaWidth.upToMedium`
    margin: 1rem;
    font-size: 12px;
  `};
`;
const OptionGrid = styled.div`
  display: grid;
  grid-gap: 10px;
  ${({ theme }) => theme.mediaWidth.upToMedium`
    grid-template-columns: 1fr;
    grid-gap: 10px;
  `};
`;
const HoverText = styled.div`
  :hover {
    cursor: pointer;
  }
`;

const WALLET_TUTORIAL = `${LANDING_PAGE}/tutorials/getting-started/#set-up-metamask`;
var CHAIN_TYPE;
(function (CHAIN_TYPE) {
    CHAIN_TYPE["EVM_CHAINS"] = "EVM CHAINS";
    CHAIN_TYPE["NON_EVM_CHAINS"] = "NON-EVM CHAINS";
})(CHAIN_TYPE || (CHAIN_TYPE = {}));
const WALLET_VIEWS = {
    OPTIONS: 'options',
    OPTIONS_SECONDARY: 'options_secondary',
    ACCOUNT: 'account',
    PENDING: 'pending',
};
const getConnectorKey = (connector) => { var _a; return (_a = Object.keys(SUPPORTED_WALLETS).find((key) => SUPPORTED_WALLETS[key].connector === connector)) !== null && _a !== void 0 ? _a : null; };
const WalletModal = ({ open, closeModal, background, shouldShowBackButton, onWalletConnect, onClickBack, }) => {
    var _a;
    // important that these are destructed from the account-specific web3-react context
    const { connector, activate, error: web3Error } = useWeb3React();
    const [walletType, setWalletType] = useState(CHAIN_TYPE.EVM_CHAINS);
    const [walletView, setWalletView] = useState('');
    const [pendingWallet, setPendingWallet] = useState();
    const [selectedOption, setSelectedOption] = useState();
    const [pendingError, setPendingError] = useState();
    const [triedSafe, setTriedSafe] = useState(!IS_IN_IFRAME);
    const walletModalOpen = open;
    const walletOptions = useMemo(() => {
        if (walletType === CHAIN_TYPE.EVM_CHAINS) {
            return Object.keys(SUPPORTED_WALLETS)
                .filter((key) => SUPPORTED_WALLETS[key].isEVM)
                .reduce((obj, key) => {
                    obj[key] = SUPPORTED_WALLETS[key];
                    return obj;
                }, {});
        }
        else {
            return Object.keys(SUPPORTED_WALLETS)
                .filter((key) => !SUPPORTED_WALLETS[key].isEVM)
                .reduce((obj, key) => {
                    obj[key] = SUPPORTED_WALLETS[key];
                    return obj;
                }, {});
        }
    }, [walletType]);
    const addAvalancheNetwork = useCallback(() => {
        connector === null || connector === void 0 ? void 0 : connector.getProvider().then((provider) => {
            provider === null || provider === void 0 ? void 0 : provider.request({
                method: 'wallet_addEthereumChain',
                params: [AVALANCHE_CHAIN_PARAMS],
            }).then(() => {
                onWalletConnect(getConnectorKey(connector));
            }).catch((error) => {
                console.log(error);
            });
        });
    }, [connector]);
    // always reset to account view
    useEffect(() => {
        const name = Object.keys(SUPPORTED_WALLETS).find((key) => SUPPORTED_WALLETS[key].connector === connector);
        if (name) {
            const activeOption = SUPPORTED_WALLETS[name];
            if (activeOption && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.isEVM)) {
                setWalletType(CHAIN_TYPE.NON_EVM_CHAINS);
            }
            else {
                setWalletType(CHAIN_TYPE.EVM_CHAINS);
            }
        }
        if (walletModalOpen) {
            setPendingError(false);
            setWalletView('');
        }
    }, [walletModalOpen]);
    const isMetamask = window.ethereum && window.ethereum.isMetaMask;
    const isTalisman = window.ethereum && window.ethereum.isTalisman;
    const isRabby = window.ethereum && window.ethereum.isRabby;
    const isCbWalletDappBrowser = (_a = window === null || window === void 0 ? void 0 : window.ethereum) === null || _a === void 0 ? void 0 : _a.isCoinbaseWallet;
    const isWalletlink = !!(window === null || window === void 0 ? void 0 : window.WalletLinkProvider) || !!(window === null || window === void 0 ? void 0 : window.walletLinkExtension);
    const isCbWallet = isCbWalletDappBrowser || isWalletlink;
    const isBitKeep = window.isBitKeep && !!window.bitkeep.ethereum;
    const tryActivation = (activationConnector, option) => __awaiter(void 0, void 0, void 0, function* () {
        var _b, _c;
        const name = Object.keys(walletOptions).find((key) => walletOptions[key].connector === activationConnector);
        // log selected wallet
        // eslint-disable-next-line import/no-named-as-default-member
        ReactGA.event({
            category: 'Wallet',
            action: 'Change Wallet',
            label: name,
        });
        setPendingWallet(connector); // set wallet for pending view
        setSelectedOption(option);
        setWalletView(WALLET_VIEWS.PENDING);
        // if the connector is walletconnect and the user has already tried to connect, manually reset the connector
        if (activationConnector instanceof WalletConnectConnector && ((_c = (_b = activationConnector.walletConnectProvider) === null || _b === void 0 ? void 0 : _b.wc) === null || _c === void 0 ? void 0 : _c.uri)) {
            activationConnector.walletConnectProvider = undefined;
        }
        if (!triedSafe && activationConnector instanceof SafeAppConnector) {
            activationConnector.isSafeApp().then((loadedInSafe) => {
                if (loadedInSafe) {
                    activate(activationConnector, undefined, true)
                        .then(() => {
                            onWalletConnect(getConnectorKey(activationConnector));
                        })
                        .catch(() => {
                            setTriedSafe(true);
                        });
                }
                setTriedSafe(true);
            });
        }
        else if (activationConnector) {
            activate(activationConnector, undefined, true)
                .then(() => {
                    if (isCbWallet) {
                        addAvalancheNetwork();
                    }
                    else {
                        onWalletConnect(getConnectorKey(activationConnector));
                    }
                })
                .catch((error) => {
                    if (error instanceof UnsupportedChainIdError) {
                        activate(activationConnector); // a little janky...can't use setError because the connector isn't set
                    }
                    else {
                        setPendingError(true);
                    }
                });
        }
    });
    function getActiveOption() {
        if (connector === injected) {
            if (isRabby) {
                return SUPPORTED_WALLETS.RABBY;
            }
            else if (isTalisman) {
                return SUPPORTED_WALLETS.TALISMAN;
            }
            else if (isBitKeep) {
                return SUPPORTED_WALLETS.BITKEEP;
            }
            else if (isMetamask) {
                return SUPPORTED_WALLETS.METAMASK;
            }
            return SUPPORTED_WALLETS.INJECTED;
        }
        const name = Object.keys(walletOptions).find((key) => walletOptions[key].connector === connector);
        if (name) {
            return walletOptions[name];
        }
        return undefined;
    }
    //get wallets user can switch too, depending on device/browser
    function getOptions() {
        const isXDEFI = window.ethereum && window.ethereum.isXDEFI;
        const activeOption = getActiveOption();
        return Object.keys(walletOptions).map((key) => {
            const option = walletOptions[key];
            // check for mobile options
            if (isMobile) {
                if (!window.web3 && !window.ethereum && option.mobile) {
                    return (jsx(Option, {
                        onClick: () => {
                            option.connector !== connector && !option.href && tryActivation(option.connector, option);
                        }, id: `connect-${key}`, active: activeOption && option.name === activeOption.name, color: option.color, link: option.href, header: option.name, subheader: null, icon: option.iconName
                    }, key));
                }
                return null;
            }
            // overwrite injected when needed
            if (option.connector === injected) {
                if (option.name === 'Rabby Wallet') {
                    if (!isRabby) {
                        return (jsx(Option, { id: `connect-${key}`, color: '#7a7cff', header: 'Install Rabby Wallet', subheader: null, link: 'https://rabby.io/', icon: option.iconName }, key));
                    }
                }
                // don't show injected if there's no injected provider
                if (!(window.web3 || window.ethereum)) {
                    if (option.name === 'MetaMask') {
                        return (jsx(Option, { id: `connect-${key}`, color: '#E8831D', header: 'Install Metamask', subheader: null, link: 'https://metamask.io/', icon: option.iconName }, key));
                    }
                    else {
                        return null; //dont want to return install twice
                    }
                }
                // don't return metamask if injected provider isn't metamask
                else if (option.name === 'MetaMask' && !isMetamask) {
                    return null;
                }
                // likewise for generic
                else if (option.name === 'Injected' && isMetamask) {
                    return null;
                }
            }
            // overwrite injected when needed
            else if (option.connector === bitKeep) {
                if (!isBitKeep) {
                    return (jsx(Option, { id: `connect-${key}`, color: '#7a7cff', header: 'Install BitKeep', subheader: null, link: 'https://bitkeep.com/', icon: option.iconName }, key));
                }
            }
            else if (option.connector === xDefi) {
                // don't show injected if there's no injected provider
                if (!window.xfi) {
                    if (option.name === 'XDEFI Wallet') {
                        return (jsx(Option, { id: `connect-${key}`, color: '#315CF5', header: 'Install XDEFI Wallet', subheader: null, link: 'https://www.xdefi.io/', icon: option.iconName }, key));
                    }
                    else {
                        return null; //dont want to return install twice
                    }
                }
                // likewise for generic
                else if (option.name === 'Injected' && (isMetamask || isXDEFI)) {
                    return null;
                }
            }
            else if (option.connector === talisman) {
                // provide talisman install link if not installed
                if (!window.talismanEth) {
                    return (jsx(Option, { id: `connect-${key}`, color: option.color, header: 'Install Talisman', subheader: null, link: 'https://talisman.xyz', icon: option.iconName }, key));
                }
            }
            // Not show Gnosis Safe option without Gnosis Interface
            if (option.connector === gnosisSafe && !IS_IN_IFRAME) {
                return null;
            }
            // return rest of options
            return (!isMobile &&
                !option.mobileOnly && (jsx(Option, {
                    id: `connect-${key}`, onClick: () => {
                        option.connector !== connector && !option.href && tryActivation(option.connector, option);
                    }, active: activeOption && option.name === activeOption.name, color: option.color, link: option.href, header: option.name, subheader: null, icon: option.iconName
                }, key)));
        });
    }
    const renderHeader = () => {
        if (web3Error) {
            return (jsx(HeaderRow, { children: web3Error instanceof UnsupportedChainIdError ? 'Wrong Network' : 'Error connecting' }));
        }
        else if (walletView === WALLET_VIEWS.PENDING || shouldShowBackButton) {
            return (jsx(HeaderRow, {
                children: jsx(HoverText, Object.assign({
                    onClick: () => {
                        if (onClickBack && shouldShowBackButton) {
                            onClickBack();
                        }
                        else {
                            setPendingError(false);
                            setWalletView('');
                        }
                    }
                }, { children: "Back" }))
            }));
        }
        else {
            return (jsx(HeaderRow, { children: jsx(HoverText, { children: "Connect to a wallet" }) }));
        }
    };
    const renderContent = () => {
        const isXDEFI = window.xfi && window.xfi.ethereum && window.xfi.ethereum.isXDEFI;
        const supportsAddNetwork = isMetamask || isCbWallet || isXDEFI || isTalisman || isBitKeep;
        if (web3Error) {
            return (jsx(ContentWrapper$1, { children: web3Error instanceof UnsupportedChainIdError ? (jsxs(Fragment, { children: [jsx("h5", { children: "Please connect to the appropriate Avalanche network." }), supportsAddNetwork && (jsx(Button, Object.assign({ variant: "primary", onClick: addAvalancheNetwork }, { children: "Switch to Avalanche Chain" })))] })) : ('Error connecting. Try refreshing the page.') }));
        }
        else {
            return (jsxs(ContentWrapper$1, {
                children: [walletView === WALLET_VIEWS.PENDING ? (jsx(PendingView, { option: selectedOption, connector: pendingWallet, error: pendingError, setPendingError: setPendingError, tryActivation: tryActivation })) : (jsxs(Fragment, {
                    children: [jsx(Box, Object.assign({ mt: "5px", width: "100%", mb: "5px" }, {
                        children: jsx(ToggleButtons, {
                            options: [CHAIN_TYPE.EVM_CHAINS, CHAIN_TYPE.NON_EVM_CHAINS], value: walletType, onChange: (value) => {
                                setWalletType(value);
                            }
                        })
                    })), jsx(OptionGrid, { children: getOptions() })]
                })), walletView !== WALLET_VIEWS.PENDING && (jsxs(Blurb, { children: [jsx("span", { children: "New to Avalanche? \u00A0" }), ' ', jsx(ExternalLink, Object.assign({ href: WALLET_TUTORIAL }, { children: "Learn more about setting up a wallet" }))] }))]
            }));
        }
    };
    function getModalContent() {
        return (jsxs(UpperSection, { children: [jsxs(ModalWrapper, { children: [renderHeader(), jsx(CloseButton, { onClick: closeModal })] }), renderContent()] }));
    }
    return (jsx(Modal, Object.assign({
        isOpen: walletModalOpen, onDismiss: () => {
            closeModal();
        }
    }, { children: jsx(Wrapper$a, Object.assign({ background: background }, { children: getModalContent() })) })));
};

const openApi = axios.create({
    baseURL: OPEN_API_DEBANK,
    timeout: 2000,
});
class TokenDataUser {
    constructor(token, price, amount, protocol, logo) {
        this.token = token;
        this.price = price;
        this.amount = amount;
        this.usdValue = price * amount;
        this.protocol = protocol;
        this.logo = logo;
    }
}
class PairDataUser {
    constructor(pair, usdValue, protocol, logos) {
        this.pair = pair;
        this.usdValue = usdValue;
        this.protocol = protocol;
        this.logos = logos;
    }
}
// Get the USD balance of address of all chains (supported by Debank)
function useGetChainsBalances() {
    const { account } = usePangolinWeb3();
    const query = qs.stringify({
        id: account,
    }, {
        encodeValuesOnly: true,
    });
    return useQuery(['getChainsBalances', account], () => __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (account) {
            const response = yield openApi.get(`/total_balance?${query}`);
            const data = response.data;
            const chainbalances = {
                total: data === null || data === void 0 ? void 0 : data.total_usd_value,
                chains: [],
            };
            (_a = data === null || data === void 0 ? void 0 : data.chain_list) === null || _a === void 0 ? void 0 : _a.forEach((chain) => {
                const _chain = ALL_CHAINS.filter((value) => value.chain_id === (chain === null || chain === void 0 ? void 0 : chain.community_id))[0];
                if (_chain && (chain === null || chain === void 0 ? void 0 : chain.usd_value) >= 0.01) {
                    chainbalances.chains.push({
                        chainID: chain === null || chain === void 0 ? void 0 : chain.community_id,
                        balance: chain === null || chain === void 0 ? void 0 : chain.usd_value,
                    });
                }
            });
            chainbalances.chains.sort((a, b) => b.balance - a.balance);
            return chainbalances;
        }
        return null;
    }), { refetchOnWindowFocus: false });
}
// Get the Tokens of wallet
function useGetWalletChainTokens(chainId) {
    const { account } = usePangolinWeb3();
    let chain = getChainByNumber(chainId);
    const getPangolinPairs = () => __awaiter(this, void 0, void 0, function* () {
        const query = qs.stringify({
            id: account,
            protocol_id: 'avax_pangolin',
        }, {
            encodeValuesOnly: true,
        });
        if (account) {
            const response = yield openApi.get(`/protocol?${query}`);
            const data = response.data;
            const requestPairs = data === null || data === void 0 ? void 0 : data.portfolio_item_list.map((pair) => {
                var _a, _b, _c;
                const token1 = (_a = pair === null || pair === void 0 ? void 0 : pair.detail) === null || _a === void 0 ? void 0 : _a.supply_token_list[0];
                const token2 = (_b = pair === null || pair === void 0 ? void 0 : pair.detail) === null || _b === void 0 ? void 0 : _b.supply_token_list[1];
                // If token2 does not exist its because this pair is not a pair but a single staking
                if (!token2) {
                    return new TokenDataUser(new Token$1(chainId, token1 === null || token1 === void 0 ? void 0 : token1.id, token1 === null || token1 === void 0 ? void 0 : token1.decimals, `${token1 === null || token1 === void 0 ? void 0 : token1.symbol} - Staked`, token1 === null || token1 === void 0 ? void 0 : token1.name), token1 === null || token1 === void 0 ? void 0 : token1.price, token1 === null || token1 === void 0 ? void 0 : token1.amount);
                }
                const tokenA = new TokenAmount(new Token$1(chainId, token1 === null || token1 === void 0 ? void 0 : token1.id, token1 === null || token1 === void 0 ? void 0 : token1.decimals, token1 === null || token1 === void 0 ? void 0 : token1.symbol, token1 === null || token1 === void 0 ? void 0 : token1.name), token1 === null || token1 === void 0 ? void 0 : token1.amount.toString().replace('.', ''));
                const tokenB = new TokenAmount(new Token$1(chainId, token2 === null || token2 === void 0 ? void 0 : token2.id, token2 === null || token2 === void 0 ? void 0 : token2.decimals, token2 === null || token2 === void 0 ? void 0 : token2.symbol, token2 === null || token2 === void 0 ? void 0 : token2.name), token2 === null || token2 === void 0 ? void 0 : token2.amount.toString().replace('.', ''));
                return new PairDataUser(new Pair(tokenA, tokenB, chainId), (_c = pair === null || pair === void 0 ? void 0 : pair.stats) === null || _c === void 0 ? void 0 : _c.net_usd_value, undefined, [
                    token1 === null || token1 === void 0 ? void 0 : token1.logo_url,
                    token2 === null || token2 === void 0 ? void 0 : token2.logo_url,
                ]);
            });
            return requestPairs;
        }
        return [];
    });
    const getTokens = () => __awaiter(this, void 0, void 0, function* () {
        if (account) {
            if (!chain || !chain.mainnet) {
                chain = AVALANCHE_MAINNET;
            }
            const query = qs.stringify({
                id: account,
                chain_id: chain.symbol.toLowerCase(),
            }, {
                encodeValuesOnly: true,
            });
            const response = yield openApi.get(`/token_list?${query}`);
            const data = response.data;
            let requestTokens = data
                .filter((token) => (token === null || token === void 0 ? void 0 : token.is_wallet) && (token === null || token === void 0 ? void 0 : token.is_verified))
                .map((token) => {
                    var _a, _b;
                    if (((_a = token === null || token === void 0 ? void 0 : token.id) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ((_b = CAVAX[chainId]) === null || _b === void 0 ? void 0 : _b.symbol).toLowerCase()) {
                        return new TokenDataUser(CAVAX[chainId], token === null || token === void 0 ? void 0 : token.price, token === null || token === void 0 ? void 0 : token.amount);
                    }
                    if (!isAddress(token === null || token === void 0 ? void 0 : token.id)) {
                        return new TokenDataUser(new Token$1(chainId, ZERO_ADDRESS, token === null || token === void 0 ? void 0 : token.decimals, token === null || token === void 0 ? void 0 : token.symbol, token === null || token === void 0 ? void 0 : token.name), token === null || token === void 0 ? void 0 : token.price, token === null || token === void 0 ? void 0 : token.amount, undefined, token === null || token === void 0 ? void 0 : token.logo_url);
                    }
                    return new TokenDataUser(new Token$1(chainId, token === null || token === void 0 ? void 0 : token.id, token === null || token === void 0 ? void 0 : token.decimals, token === null || token === void 0 ? void 0 : token.symbol, token === null || token === void 0 ? void 0 : token.name), token === null || token === void 0 ? void 0 : token.price, token === null || token === void 0 ? void 0 : token.amount, undefined, token === null || token === void 0 ? void 0 : token.logo_url);
                });
            if (chainId === ChainId.AVALANCHE) {
                const pairs = yield getPangolinPairs();
                requestTokens = [...requestTokens, ...pairs];
            }
            return requestTokens.sort((a, b) => b.usdValue - a.usdValue).filter((token) => token.usdValue >= 0.01);
        }
        return null;
    });
    return useQuery(['getWalletChainTokens', chainId.toString(), account], () => __awaiter(this, void 0, void 0, function* () {
        const tokens = yield getTokens();
        return tokens;
    }), {
        refetchInterval: 600000,
        refetchOnWindowFocus: false,
    });
}

const PortfolioRoot = styled(Box)`
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 15px;

  padding: 20px;

  border-radius: 10px;
  background-color: ${({ theme }) => theme.color2};
`;
const PortfolioHeader = styled(Box)`
  width: 100%;
  display: flex;
  flex-direction: row;
  gap: 5px;
`;
const HideButton = styled.button`
  background-color: ${({ theme }) => theme.bg6};
  color: ${({ theme }) => theme.text15};

  min-width: 20px;
  min-height: 20px;

  font-size: 12px;
  border-radius: 5px;
  border: 0px;
  padding: 5px;

  display: flex;
  align-items: center;

  cursor: pointer;

  :hover,
  :focus {
    opacity: 0.8;
  }

  align-self: flex-start;

  ${({ theme }) => theme.mediaWidth.upToMedium`
    #portfolio-text {
      display: none;
    }
  `}
`;
const ChainCard = styled(Box)`
  height: 80px;
  padding: 10px;
  background-color: ${({ theme }) => theme.bg6};
  border-radius: 4px;
  display: flex;
  flex-direction: row;

  justify-content: center;
  align-items: center;

  gap: 10px;

  font-weight: 500;
`;
const Frame$2 = styled(Box)`
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 20px;
`;

const ToggleBalanceButton = ({ showBalances, handleShowBalances }) => {
    return (jsx(HideButton, Object.assign({ onClick: handleShowBalances }, { children: showBalances ? (jsxs(Fragment, { children: [jsx(EyeOff, { size: 12, id: "portfolio-icon" }), jsx(Text, Object.assign({ fontSize: ['8px', '10px', '12px'], id: "portfolio-text", style: { marginLeft: '5px' } }, { children: "Hide Your Balance" }))] })) : (jsxs(Fragment, { children: [jsx(Eye, { size: 12, id: "portfolio-icon" }), jsx(Text, Object.assign({ fontSize: 12, id: "portfolio-text", style: { marginLeft: '5px' } }, { children: "Show Your Balance" }))] })) })));
};

const Portfolio$1 = () => {
    const theme = useContext(ThemeContext);
    const { account } = usePangolinWeb3();
    const { data: balances, isRefetching, isLoading } = useGetChainsBalances();
    const [showBalances, setShowBalances] = useState(true);
    const handleShowBalances = useCallback(() => {
        setShowBalances(!showBalances);
    }, [showBalances]);
    const renderChain = (_chain, key) => {
        const chain = ALL_CHAINS.filter((value) => value.chain_id === _chain.chainID)[0];
        const balance = _chain.balance.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 });
        return (jsxs(ChainCard, { children: [jsx("img", { width: "48px", height: "48px", src: chain === null || chain === void 0 ? void 0 : chain.logo, alt: 'Chain logo' }), jsxs(Box, Object.assign({ height: "100%", display: "flex", justifyContent: "center", flexDirection: "column" }, { children: [jsx(Text, Object.assign({ fontSize: 14, color: "text1" }, { children: chain.name })), showBalances ? (jsxs(Text, Object.assign({ fontSize: 14, color: "text13" }, { children: ["$", balance] }))) : (jsx(Box, Object.assign({ display: "flex", flexDirection: "row" }, { children: [...Array(4)].map((_value, _key) => (jsx(Lock, { color: theme.text13, size: 14 }, _key))) })))] }))] }, key));
    };
    const renderTotalBalance = () => {
        if (showBalances) {
            return (jsxs(Text, Object.assign({ fontSize: 18, color: "text1", fontWeight: 600 }, {
                children: ["$", balances
                    ? balances.total.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 })
                    : 0]
            })));
        }
        return jsx(Lock, { color: theme.text1, size: 18 });
    };
    return (jsxs(PortfolioRoot, { children: [jsxs(PortfolioHeader, { children: [jsx(Text, Object.assign({ fontSize: ['16px', '16px', '24px'], color: "text1", fontWeight: 600, style: { flexGrow: 1 } }, { children: "Portfolio Value in All Chains" })), jsx(ToggleBalanceButton, { showBalances: showBalances, handleShowBalances: handleShowBalances })] }), jsx(Box, Object.assign({ display: "flex", flexGrow: 1, width: "100%", alignItems: "center", justifyContent: "center", flexDirection: "column" }, { children: !account ? (jsx(Text, Object.assign({ fontSize: 20, color: "text1", textAlign: "center" }, { children: "Connect a wallet to see your Portfolio" }))) : isRefetching || isLoading || !balances ? (jsx(Loader, { size: 100 })) : (jsxs(Fragment, { children: [jsxs(Box, Object.assign({ padding: 10, borderRadius: 4, display: "flex", marginBottom: 15, alignItems: "center", bgColor: "bg6", flexWrap: "wrap", width: "100%", style: { boxSizing: 'border-box' } }, { children: [jsx(Text, Object.assign({ fontSize: 18, color: "text1", style: { flexGrow: 1, minWidth: '200px' } }, { children: "Total Amount Invested" })), renderTotalBalance()] })), jsx(Box, Object.assign({ width: "100%", minHeight: "140px" }, { children: balances.chains.length > 0 ? (jsx(Scrollbars, Object.assign({ style: { width: '100%', height: '100%', minHeight: '140px' } }, { children: jsx(Frame$2, { children: balances.chains.map((chain, key) => renderChain(chain, key)) }) }))) : (jsx(Text, Object.assign({ fontSize: 18, color: "text1", textAlign: "center" }, { children: "Not found balances" }))) }))] })) }))] }));
};

const Root$e = styled(Box)`
  width: 100%;
  height: 100%;

  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;

  padding: 20px;

  border-radius: 10px;
  background-color: ${({ theme }) => theme.color2};
`;
const Header$3 = styled(Box)`
  width: 100%;
  display: flex;
  flex-direction: row;
  gap: 5px;
`;
const SelectedCard = styled(Box)`
  height: 60px;

  background-color: ${({ theme, selected }) => (selected ? theme.bg3 : theme.bg6)};
  padding: 2px;
  border-radius: 4px;
  display: flex;
  flex-direction: row;

  justify-content: center;
  align-items: center;

  gap: 10px;
  cursor: pointer;

  font-weight: 500;

  &:hover,
  &:focus {
    opacity: 0.8;
  }
`;
const Frame$1 = styled(Box)`
  width: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 10px;
`;
const RowWrapper = styled(Box)`
  padding: 0px 10px;
  display: grid;
  grid-template-columns: auto auto;
  align-items: center;
  border-bottom: 1px solid ${({ theme }) => theme.text9};
  border-radius: 4px 4px 0px 0px;
  background-color: ${({ theme }) => theme.color2};

  height: 64px;

  &:hover {
    background-color: ${({ theme }) => theme.color3};
  }
`;
const Body = styled(Box)`
  width: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));

  grid-gap: 20px;
`;

const PortfolioRow = ({ coin, pair, showBalances }) => {
    var _a, _b, _c, _d, _e;
    const theme = useContext(ThemeContext);
    const renderLogo = (size) => {
        var _a, _b, _c;
        if (coin) {
            if ((coin.token instanceof Token$1 && coin.token.chainId == ChainId.AVALANCHE) || !(coin.token instanceof Token$1)) {
                return jsx(CurrencyLogo, { size: size, currency: coin.token });
            }
            else if (coin === null || coin === void 0 ? void 0 : coin.logo) {
                return jsx(StyledLogo, { srcs: [coin.logo], size: `${size}px` });
            }
        }
        if (pair) {
            if (((_a = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _a === void 0 ? void 0 : _a.chainId) == ChainId.AVALANCHE) {
                return jsx(DoubleCurrencyLogo, { currency0: (_b = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _b === void 0 ? void 0 : _b.token0, currency1: (_c = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _c === void 0 ? void 0 : _c.token1, size: 24 });
            }
            else if (pair.logos) {
                return (jsxs(Wrapper$d, Object.assign({ margin: false, sizeraw: size }, { children: [jsx(StyledLogo, { srcs: [pair.logos[0]], size: `${size}px`, style: { zIndex: 2 } }), jsx(StyledLogo, { srcs: [pair.logos[1]], size: `${size}px`, style: { position: 'absolute', left: '-' + (size / 2).toString() + 'px' } })] })));
            }
        }
        return jsx(HelpCircle, { size: size });
    };
    const amount = coin && !pair ? coin.price * coin.amount : pair && !coin ? pair.usdValue : 0;
    return (jsxs(RowWrapper, { children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [renderLogo(24), coin && (jsx(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 500, marginLeft: '6px' }, { children: (_a = coin === null || coin === void 0 ? void 0 : coin.token) === null || _a === void 0 ? void 0 : _a.symbol }))), pair && (jsxs(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 500, marginLeft: '6px' }, { children: [(_c = (_b = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _b === void 0 ? void 0 : _b.token0) === null || _c === void 0 ? void 0 : _c.symbol, " - ", (_e = (_d = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _d === void 0 ? void 0 : _d.token1) === null || _e === void 0 ? void 0 : _e.symbol] })))] })), jsx(Box, Object.assign({ textAlign: "right" }, { children: !showBalances ? (jsx(Lock, { color: theme.text13, size: 16 })) : (jsxs(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 500 }, { children: ["$", amount.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 })] }))) }))] }));
};

const MyPortfolio = () => {
    const theme = useContext(ThemeContext);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const [showBalances, setShowBalances] = useState(true);
    const [selectChain, setSelectChain] = useState(43114);
    const { data: balances, isLoading } = useGetChainsBalances();
    const { data: chainTokens, isLoading: isLoadingTokens } = useGetWalletChainTokens(selectChain);
    useEffect(() => {
        if (balances) {
            if (balances.chains.length > 0) {
                // if chainId in balances.chains then selectChain = chainId
                const _chain = balances.chains.find((chain) => chain.chainID === chainId);
                setSelectChain(_chain ? chainId : balances.chains[0].chainID);
            }
        }
    }, [balances]);
    const handleShowBalances = useCallback(() => {
        setShowBalances(!showBalances);
    }, [showBalances]);
    const renderChain = (_chain, key) => {
        const chain = ALL_CHAINS.filter((value) => value.chain_id === _chain.chainID)[0];
        const balance = _chain.balance.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 });
        const isSelected = selectChain === _chain.chainID;
        return (jsxs(SelectedCard, Object.assign({ onClick: () => setSelectChain(_chain.chainID), selected: isSelected }, { children: [jsx("img", { width: "26px", height: "26px", src: chain === null || chain === void 0 ? void 0 : chain.logo, alt: 'Chain logo' }), jsxs(Box, Object.assign({ height: "100%", display: "flex", justifyContent: "center", flexDirection: "column" }, { children: [jsx(Text, Object.assign({ fontSize: 12, color: "text1" }, { children: chain.name })), showBalances ? (jsxs(Text, Object.assign({ fontSize: 12, color: "text13" }, { children: ["$", balance] }))) : (jsx(Box, Object.assign({ display: "flex", flexDirection: "row" }, { children: [...Array(4)].map((_value, _key) => (jsx(Lock, { color: theme.text13, size: 14 }, _key))) })))] }))] }), key));
    };
    const renderTotalBalance = () => {
        if (showBalances) {
            return (jsxs(Text, Object.assign({ fontSize: 16, color: "text1", fontWeight: 600 }, {
                children: ["$", balances
                    ? balances.total.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 })
                    : 0]
            })));
        }
        return jsx(Lock, { color: theme.text1, size: 18 });
    };
    const renderRow = (item, index) => {
        return (jsx(PortfolioRow, { coin: item instanceof TokenDataUser ? item : undefined, pair: item instanceof PairDataUser ? item : undefined, showBalances: showBalances }, index));
    };
    return (jsxs(Root$e, { children: [jsxs(Header$3, { children: [jsx(Text, Object.assign({ fontSize: ['16px', '16px', '24px'], color: "text1", fontWeight: 600, style: { flexGrow: 1 } }, { children: "Your Portfolio" })), jsx(ToggleBalanceButton, { showBalances: showBalances, handleShowBalances: handleShowBalances })] }), jsx(Box, Object.assign({ width: "100%", display: "flex", flexGrow: 1, justifyContent: "center" }, { children: !account ? (jsx(Box, Object.assign({ height: "100%", display: "flex", alignItems: "center" }, { children: jsx(Text, Object.assign({ fontSize: 20, color: "text1", textAlign: "center" }, { children: "Connect a wallet to see your portfolio" })) }))) : isLoading || !balances ? (jsx(Loader, { size: 100 })) : balances && balances.chains.length == 0 ? (jsx(Box, Object.assign({ height: "100%", display: "flex", alignItems: "center", flexWrap: "wrap" }, { children: jsx(Text, Object.assign({ fontSize: 18, color: "text1", textAlign: "center" }, { children: "Not found balances" })) }))) : (jsxs(Body, { children: [jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", width: "100%" }, { children: [jsxs(Box, Object.assign({ padding: 10, borderRadius: 4, display: "flex", marginBottom: 15, alignItems: "center", bgColor: "bg6", flexWrap: "wrap" }, { children: [jsx(Text, Object.assign({ fontSize: 18, color: "text1", style: { flexGrow: 1, minWidth: '200px' } }, { children: "Total:" })), renderTotalBalance()] })), jsx(Box, Object.assign({ width: "100%", height: "100%", minHeight: "128px" }, { children: jsx(Scrollbars, Object.assign({ style: { width: '100%', height: '100%' } }, { children: jsx(Frame$1, { children: balances.chains.map((chain, key) => renderChain(chain, key)) }) })) }))] })), jsx(Box, Object.assign({ width: "100%" }, { children: isLoadingTokens || !chainTokens ? (jsx(Loader, { size: 100 })) : chainTokens.length == 0 ? (jsx(Text, Object.assign({ fontSize: 18, color: "text1", textAlign: "center" }, { children: "Not found tokens on this chain" }))) : (jsx(Box, Object.assign({ height: "100%", minHeight: "128px" }, { children: jsx(Scrollbars, Object.assign({ style: { width: '100%', height: '100%' } }, { children: chainTokens.map((item, index) => renderRow(item, index)) })) }))) }))] })) }))] }));
};

var AnalyticsIcon = "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2221%22%20height%3D%2219.421%22%20viewBox%3D%220%200%2021%2019.421%22%3E%20%20%3Cg%20id%3D%22Analytics%22%20transform%3D%22translate%28-34.934%201014.056%29%22%3E%20%20%20%20%3Cpath%20id%3D%22Path_209%22%20data-name%3D%22Path%20209%22%20d%3D%22M55.931-1001.787H34.943v-.237q0-5.541%2C0-11.081a.843.843%2C0%2C0%2C1%2C.942-.951H55.013a.836.836%2C0%2C0%2C1%2C.928.923q0%2C5.573%2C0%2C11.145C55.941-1001.925%2C55.935-1001.863%2C55.931-1001.787Zm-9.2-9.231-3.434%2C3.436-2.1-2.12-3.323%2C3.329.436.426%2C2.969-2.974%2C2.162%2C2.17%2C3.347-3.447%2C1.9%2C1.907%2C3.275-3.277.694.8.406-2.255-2.233.349-.034.073.657.6-2.85%2C2.851Zm5.6%2C8.2v-6.428H51.151v6.428Zm-4.235-.008h1.2v-4.126h-1.2Zm-3.033-3.926v3.924h1.173v-3.924Zm-1.914%2C1.421h-1.2v2.506h1.2Zm-4.235.5v2h1.182v-2Z%22%20transform%3D%22translate%28-0.008%29%22%20fill%3D%22%23707070%22%2F%3E%20%20%20%20%3Cpath%20id%3D%22Path_210%22%20data-name%3D%22Path%20210%22%20d%3D%22M34.935-783.157H55.92c0%2C.068.012.13.012.191%2C0%2C.633%2C0%2C1.267%2C0%2C1.9a.84.84%2C0%2C0%2C1-.916.917q-9.585%2C0-19.169%2C0a.838.838%2C0%2C0%2C1-.912-.921C34.933-781.758%2C34.935-782.447%2C34.935-783.157Zm11.194%2C1.484a.689.689%2C0%2C0%2C0-.693-.708.688.688%2C0%2C0%2C0-.7.684.681.681%2C0%2C0%2C0%2C.682.714A.681.681%2C0%2C0%2C0%2C46.129-781.673Z%22%20transform%3D%22translate%280%20-217.728%29%22%20fill%3D%22%23707070%22%2F%3E%20%20%20%20%3Cpath%20id%3D%22Path_211%22%20data-name%3D%22Path%20211%22%20d%3D%22M164.39-712.733h-2.815a.45.45%2C0%2C0%2C1-.19-.007.712.712%2C0%2C0%2C1-.288-.209.27.27%2C0%2C0%2C1%2C.091-.36%2C4.188%2C4.188%2C0%2C0%2C0%2C1.3-1.684.208.208%2C0%2C0%2C1%2C.159-.1q1.717-.008%2C3.433%2C0a.23.23%2C0%2C0%2C1%2C.167.115%2C4.144%2C4.144%2C0%2C0%2C0%2C1.3%2C1.633.32.32%2C0%2C0%2C1%2C.135.391.329.329%2C0%2C0%2C1-.353.217Q165.861-712.736%2C164.39-712.733Z%22%20transform%3D%22translate%28-118.932%20-281.909%29%22%20fill%3D%22%23707070%22%2F%3E%20%20%3C%2Fg%3E%3C%2Fsvg%3E";

const AnalyticsLink = styled.a`
  display: flex;
  align-items: center;
  padding: 0px 0px 0px 4px;
  border-radius: 4px;

  svg {
    height: 16px;
  }

  path {
    fill: ${({ theme }) => theme.text1};
  }

  &:hover,
  &focus {
    path {
      fill: ${({ theme }) => theme.yellow1};
    }
  }
`;

const Stat = ({ title, titlePosition, stat, titleColor, titleFontSize, statColor, statFontSize, currency, statAlign, showAnalytics = false, }) => {
    const chainId = useChainId();
    const token = currency instanceof Currency && currency instanceof Token$1 ? currency : WAVAX[chainId];
    function getAlignment() {
        if (statAlign === 'center') {
            return 'center';
        }
        else if (statAlign === 'right') {
            return 'flex-end';
        }
        else {
            return 'flex-start';
        }
    }
    return (jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", alignItems: getAlignment() }, { children: [titlePosition === 'top' && title && (jsxs(Box, Object.assign({ display: "flex", flexDirection: "row", style: { gap: '5px' }, alignItems: "center" }, { children: [jsx(Text, Object.assign({ color: titleColor || 'text1', fontSize: titleFontSize || 20 }, { children: title })), showAnalytics && (jsx(AnalyticsLink, Object.assign({ href: `${ANALYTICS_PAGE}/#/token/${token.address}`, target: "_blank" }, { children: jsx("img", { src: AnalyticsIcon, alt: "analytics-icon" }) })))] }))), jsxs(Box, Object.assign({ display: "flex", alignItems: "center", mt: titlePosition === 'top' ? '8px' : '0px', mb: titlePosition === 'bottom' ? '8px' : '0px' }, { children: [jsx(Text, Object.assign({ color: statColor || 'text1', fontSize: statFontSize || 16 }, { children: stat })), currency && (jsx(Box, Object.assign({ ml: 10, height: 24 }, { children: jsx(CurrencyLogo, { currency: currency, size: 24, imageSize: 48 }) })))] })), titlePosition === 'bottom' && title && (jsx(Text, Object.assign({ color: titleColor || 'text1', fontSize: titleFontSize || 16 }, { children: title })))] })));
};

var SpaceType;
(function (SpaceType) {
    SpaceType["card"] = "card";
    SpaceType["detail"] = "detail";
})(SpaceType || (SpaceType = {}));
var PoolType$1;
(function (PoolType) {
    PoolType["own"] = "own";
    PoolType["all"] = "all";
    PoolType["superFarms"] = "superFarms";
})(PoolType$1 || (PoolType$1 = {}));

// modified from https://usehooks.com/useDebounce/
function useDebounce(value, delay) {
    const [debouncedValue, setDebouncedValue] = useState(value);
    useEffect(() => {
        // Update debounced value after delay
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);
        // Cancel the timeout if value changes (also on delay change or unmount)
        // This is how we prevent debounced value from updating if value is changed ...
        // .. within the delay period. Timeout gets cleared and restarted.
        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);
    return debouncedValue;
}

const GET_MINICHEF = gql`
  query minichefs($where: Minichef_filter, $userAddress: String) {
    minichefs(where: $where) {
      id
      totalAllocPoint
      rewardPerSecond
      rewardsExpiration
      farms(first: 1000) {
        id
        pid
        tvl
        allocPoint
        rewarderAddress
        chefAddress
        pairAddress
        rewarder {
          id
          rewards {
            id
            token {
              id
              symbol
              derivedUSD
              name
              decimals
            }
            multiplier
          }
        }
        pair {
          id
          reserve0
          reserve1
          totalSupply
          token0 {
            id
            symbol
            derivedUSD
            name
            decimals
          }
          token1 {
            id
            symbol
            derivedUSD
            name
            decimals
          }
        }
        farmingPositions(where: { userAddress: $userAddress }) {
          id
          stakedTokenBalance
        }
      }
    }
  }
`;

const PANGOLIN_PAIR_INTERFACE = new Interface(abi$1);

// returns undefined if input token is undefined, or fails to get token contract,
// or contract total supply cannot be fetched
function useTotalSupply(token) {
    var _a, _b;
    const contract = useTokenContract(token === null || token === void 0 ? void 0 : token.address, false);
    const totalSupply = (_b = (_a = useSingleCallResult(contract, 'totalSupply')) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b[0];
    // Special case to handle PNG's proxy burnt total supply
    if (token === null || token === void 0 ? void 0 : token.equals(PNG[ChainId.AVALANCHE])) {
        return new TokenAmount(token, '230000000000000000000000000');
    }
    return token && totalSupply ? new TokenAmount(token, totalSupply.toString()) : undefined;
}
function useNearTotalSupply(tokenOrPair) {
    const chainId = useChainId();
    const [totalSupply, setTotalSupply] = useState();
    useEffect(() => {
        function getTotalSupply() {
            return __awaiter(this, void 0, void 0, function* () {
                if (tokenOrPair && tokenOrPair instanceof Pair) {
                    const pool = yield nearFn.getPool(chainId, tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.token0, tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.token1);
                    const totalSupplyAmt = new TokenAmount(tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.liquidityToken, pool === null || pool === void 0 ? void 0 : pool.shares_total_supply);
                    setTotalSupply(totalSupplyAmt);
                }
                else if (tokenOrPair instanceof Token$1) {
                    const totalSupply = yield nearFn.getTotalSupply(tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.address);
                    const totalSupplyAmt = new TokenAmount(tokenOrPair, totalSupply);
                    setTotalSupply(totalSupplyAmt);
                }
            });
        }
        getTotalSupply();
    }, [tokenOrPair, chainId]);
    return useMemo(() => totalSupply, [totalSupply]);
}
const useTotalSupplyHook = {
    [ChainId.FUJI]: useTotalSupply,
    [ChainId.AVALANCHE]: useTotalSupply,
    [ChainId.WAGMI]: useTotalSupply,
    [ChainId.COSTON]: useTotalSupply,
    [ChainId.SONGBIRD]: useTotalSupply,
    [ChainId.NEAR_MAINNET]: useNearTotalSupply,
    [ChainId.NEAR_TESTNET]: useNearTotalSupply,
};

const useGetFarmApr = (pid) => {
    const chainId = useChainId();
    const swapFeeApr = useSelector((state) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.aprs) === null || _b === void 0 ? void 0 : _b[chainId]) === null || _c === void 0 ? void 0 : _c[pid]) === null || _d === void 0 ? void 0 : _d.swapFeeApr; });
    const combinedApr = useSelector((state) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.aprs) === null || _b === void 0 ? void 0 : _b[chainId]) === null || _c === void 0 ? void 0 : _c[pid]) === null || _d === void 0 ? void 0 : _d.combinedApr; });
    const stakingApr = useSelector((state) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.aprs) === null || _b === void 0 ? void 0 : _b[chainId]) === null || _c === void 0 ? void 0 : _c[pid]) === null || _d === void 0 ? void 0 : _d.stakingApr; });
    return useMemo(() => ({
        swapFeeApr,
        combinedApr,
        stakingApr,
    }), [swapFeeApr, combinedApr, stakingApr]);
};
const useGetEarnedAmount = (pid) => {
    const chainId = useChainId();
    const png = PNG[chainId];
    const amount = useSelector((state) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.earnedAmounts) === null || _b === void 0 ? void 0 : _b[chainId]) === null || _c === void 0 ? void 0 : _c[pid]) === null || _d === void 0 ? void 0 : _d.earnedAmount; });
    return useMemo(() => ({
        earnedAmount: new TokenAmount(png, JSBI$1.BigInt(amount !== null && amount !== void 0 ? amount : 0)),
    }), [png, amount]);
};
const useSortFarmAprs = () => {
    const chainId = useChainId();
    const allAprs = useSelector((state) => { var _a, _b; return (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.aprs) === null || _b === void 0 ? void 0 : _b[chainId]; });
    return useMemo(() => (allAprs ? Object.values(allAprs).sort((a, b) => b.combinedApr - a.combinedApr) : []), [allAprs]);
};
const fetchChunkedAprs = (pids, chainId, chunkSize = 4) => __awaiter(void 0, void 0, void 0, function* () {
    const pidChunks = [];
    for (let i = 0; i < pids.length; i += chunkSize) {
        const pidChunk = pids.slice(i, i + chunkSize);
        pidChunks.push(pidChunk);
    }
    const chunkedResults = yield Promise.all(pidChunks.map((chunk) => fetch(`${PANGOLIN_API_BASE_URL}/v2/${chainId}/pangolin/aprs/${chunk.join(',')}`).then((res) => res.json())));
    return chunkedResults.flat();
});
const useGetMinichefPids = () => {
    const chainId = useChainId();
    const farms = useSelector((state) => { var _a, _b; return ((_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.minichefStakingData[chainId]) === null || _b === void 0 ? void 0 : _b.farms) || []; });
    const pIds1 = farms === null || farms === void 0 ? void 0 : farms.map((farm) => farm === null || farm === void 0 ? void 0 : farm.pid);
    const pIds1String = (pIds1 || []).sort().join();
    const poolMap = useMinichefPools();
    const pIds2 = Object.values(poolMap || {}).map(String);
    const pIds2String = (pIds2 || []).sort().join();
    return useMemo(() => {
        return pIds1.length > 0 ? pIds1 : pIds2;
    }, [pIds1String, pIds2String]);
};
function useFetchFarmAprs() {
    const chainId = useChainId();
    const pids = useGetMinichefPids();
    const dispatch = useDispatch();
    useEffect(() => {
        if (!chainId || !pids || pids.length === 0)
            return;
        fetchChunkedAprs(pids, chainId).then((res) => {
            const newResult = res.reduce((acc, value, i) => (Object.assign(Object.assign({}, acc), { [pids[i]]: Object.assign(Object.assign({}, value), { pid: pids[i] }) })), {});
            if (res.length > 0) {
                dispatch(updateMinichefStakingAllAprs({
                    data: { chainId: chainId, data: newResult },
                }));
            }
        });
    }, [pids, chainId, dispatch]);
}
function useUpdateAllFarmsEarnAmount() {
    const poolIdArray = useGetMinichefPids();
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const minichefContract = useStakingContract(MINICHEF_ADDRESS[chainId]);
    const dispatch = useDispatch();
    const userInfoInput = useMemo(() => {
        if (!poolIdArray || !account)
            return [];
        return poolIdArray.map((pid) => [pid, account]);
    }, [poolIdArray, account]);
    const pendingRewards = useSingleContractMultipleData(minichefContract, 'pendingReward', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const prevPendingRewards = usePrevious(pendingRewards);
    useEffect(() => {
        var _a;
        const isAllFetched = pendingRewards.every((item) => !item.loading);
        const areValuesSame = isEqual(pendingRewards, prevPendingRewards);
        if (isAllFetched && !areValuesSame) {
            const pendingRewardsObj = {};
            for (let index = 0; index < pendingRewards.length; index++) {
                const pid = poolIdArray[index];
                const pendingRewardInfo = pendingRewards[index];
                pendingRewardsObj[pid] = {
                    pid: pid,
                    earnedAmount: (_a = pendingRewardInfo === null || pendingRewardInfo === void 0 ? void 0 : pendingRewardInfo.result) === null || _a === void 0 ? void 0 : _a['pending'].toString(),
                };
            }
            dispatch(updateMinichefStakingAllFarmsEarnedAmount({ data: { chainId: chainId, data: pendingRewardsObj } }));
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [pendingRewards, prevPendingRewards]);
}
const sortingOnAvaxStake = (info_a, info_b) => {
    var _a, _b;
    // only first has ended
    if (info_a.isPeriodFinished && !info_b.isPeriodFinished)
        return 1;
    // only second has ended
    if (!info_a.isPeriodFinished && info_b.isPeriodFinished)
        return -1;
    // greater stake in avax comes first
    return ((_a = info_a.totalStakedInUsd) === null || _a === void 0 ? void 0 : _a.greaterThan((_b = info_b.totalStakedInUsd) !== null && _b !== void 0 ? _b : BIG_INT_ZERO)) ? -1 : 1;
};
const sortingOnStakedAmount = (info_a, info_b) => {
    // only the first is being staked, so we should bring the first up
    if (info_a.stakedAmount.greaterThan(BIG_INT_ZERO) && !info_b.stakedAmount.greaterThan(BIG_INT_ZERO))
        return -1;
    // only the second is being staked, so we should bring the first down
    if (!info_a.stakedAmount.greaterThan(BIG_INT_ZERO) && info_b.stakedAmount.greaterThan(BIG_INT_ZERO))
        return 1;
    return 0;
};
const useMinichefPools = () => {
    const minichefContract = useMiniChefContract();
    const lpTokens = useSingleCallResult(minichefContract, 'lpTokens', []).result;
    const lpTokensArr = lpTokens === null || lpTokens === void 0 ? void 0 : lpTokens[0];
    return useMemo(() => {
        const poolMap = {};
        if (lpTokensArr) {
            lpTokensArr.forEach((address, index) => {
                poolMap[address] = index;
            });
        }
        return poolMap;
    }, [lpTokensArr]);
};
function useMinichefPendingRewards(miniChefStaking) {
    var _a, _b, _c, _d, _e;
    const { account } = usePangolinWeb3();
    const rewardData = useRef({});
    const rewardAddress = miniChefStaking === null || miniChefStaking === void 0 ? void 0 : miniChefStaking.rewardsAddress;
    const rewardContract = useRewardViaMultiplierContract(rewardAddress !== ZERO_ADDRESS ? rewardAddress : undefined);
    const getRewardTokensRes = useSingleCallResult(rewardContract, 'getRewardTokens');
    const getRewardMultipliersRes = useSingleCallResult(rewardContract, 'getRewardMultipliers');
    const { earnedAmount: _earnedAmount } = useGetEarnedAmount(miniChefStaking === null || miniChefStaking === void 0 ? void 0 : miniChefStaking.pid);
    const earnedAmount = (miniChefStaking === null || miniChefStaking === void 0 ? void 0 : miniChefStaking.earnedAmount) || _earnedAmount;
    const rewardTokensAddress = (_a = getRewardTokensRes === null || getRewardTokensRes === void 0 ? void 0 : getRewardTokensRes.result) === null || _a === void 0 ? void 0 : _a[0];
    const rewardTokensMultiplier = (_b = getRewardMultipliersRes === null || getRewardMultipliersRes === void 0 ? void 0 : getRewardMultipliersRes.result) === null || _b === void 0 ? void 0 : _b[0];
    const earnedAmountStr = earnedAmount ? JSBI$1.BigInt(earnedAmount === null || earnedAmount === void 0 ? void 0 : earnedAmount.raw).toString() : JSBI$1.BigInt(0).toString();
    const pendingTokensRes = useSingleContractMultipleData(rewardContract, 'pendingTokens', account ? [[0, account, earnedAmountStr]] : []);
    const isLoading = (_c = pendingTokensRes === null || pendingTokensRes === void 0 ? void 0 : pendingTokensRes[0]) === null || _c === void 0 ? void 0 : _c.loading;
    const rewardTokens = useTokens(rewardTokensAddress);
    const rewardAmounts = ((_e = (_d = pendingTokensRes === null || pendingTokensRes === void 0 ? void 0 : pendingTokensRes[0]) === null || _d === void 0 ? void 0 : _d.result) === null || _e === void 0 ? void 0 : _e.amounts) || []; // eslint-disable-line react-hooks/exhaustive-deps
    const rewardTokensAmount = useMemo(() => {
        if (!rewardTokens)
            return [];
        return rewardTokens.map((rewardToken, index) => new TokenAmount(rewardToken, rewardAmounts[index] || 0));
    }, [rewardAmounts, rewardTokens]);
    useEffect(() => {
        if (!isLoading) {
            rewardData.current = {
                rewardTokensAmount,
                rewardTokensMultiplier,
            };
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [rewardTokensAmount, rewardTokensMultiplier, isLoading]);
    return rewardData.current;
}
function useGetPoolDollerWorth(pair) {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useTokenBalance = useTokenBalanceHook[chainId];
    const useTotalSupply = useTotalSupplyHook[chainId];
    const _useUSDCPrice = useUSDCPriceHook[chainId];
    const token0 = pair === null || pair === void 0 ? void 0 : pair.token0;
    const currency0 = unwrappedToken(token0, chainId);
    const currency0PriceTmp = _useUSDCPrice(currency0);
    const currency0Price = ((_a = CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet) ? currency0PriceTmp : undefined;
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    const userArl = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pairOrToken);
    const totalPoolTokens = useTotalSupply(pairOrToken);
    const [token0Deposited] = !!pair &&
        !!totalPoolTokens &&
        !!userArl &&
        JSBI$1.greaterThan(totalPoolTokens.raw, BIG_INT_ZERO) &&
        JSBI$1.greaterThan(userArl.raw, BIG_INT_ZERO) &&
        // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply
        JSBI$1.greaterThanOrEqual(totalPoolTokens.raw, userArl.raw)
        ? pair.getLiquidityValues(totalPoolTokens, userArl, { feeOn: false })
        : [undefined, undefined];
    let liquidityInUSD = 0;
    if (((_b = CHAINS[chainId]) === null || _b === void 0 ? void 0 : _b.mainnet) && currency0Price && token0Deposited) {
        liquidityInUSD = Number(currency0Price.toFixed()) * 2 * Number(token0Deposited === null || token0Deposited === void 0 ? void 0 : token0Deposited.toSignificant(6));
    }
    return useMemo(() => ({
        userArl,
        liquidityInUSD,
    }), [userArl, liquidityInUSD]);
}
// based on typed value
function useDerivedStakeInfo(typedValue, stakingToken, userLiquidityUnstaked) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = useTranslation();
    const parsedInput = tryParseAmount(typedValue, stakingToken, chainId);
    const parsedAmount = parsedInput && userLiquidityUnstaked && JSBI$1.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw)
        ? parsedInput
        : undefined;
    let error;
    if (!account) {
        error = t('stakeHooks.connectWallet');
    }
    if (parsedInput && !parsedAmount) {
        error = error !== null && error !== void 0 ? error : t('stakeHooks.insufficientBalance', { symbol: stakingToken.symbol });
    }
    if (!parsedAmount) {
        error = error !== null && error !== void 0 ? error : t('stakeHooks.enterAmount');
    }
    return {
        parsedAmount,
        error,
    };
}
function useGetRewardTokens(rewardTokens, rewardTokensAddress) {
    const _rewardTokens = useTokens(rewardTokensAddress);
    return useMemo(() => {
        if (!rewardTokens && _rewardTokens) {
            // filter only tokens
            const tokens = _rewardTokens.filter((token) => token && token instanceof Token$1);
            return tokens;
        }
        return rewardTokens;
    }, [_rewardTokens, rewardTokens]);
}
const calculateTotalStakedAmountInAvax = function (amountStaked, amountAvailable, reserveInWavax, chainId) {
    if (JSBI$1.GT(amountAvailable, 0)) {
        // take the total amount of LP tokens staked, multiply by AVAX value of all LP tokens, divide by all LP tokens
        return new TokenAmount(WAVAX[chainId], JSBI$1.divide(JSBI$1.multiply(JSBI$1.multiply(amountStaked, reserveInWavax), JSBI$1.BigInt(2)), amountAvailable));
    }
    else {
        return new TokenAmount(WAVAX[chainId], JSBI$1.BigInt(0));
    }
};
const calculateTotalStakedAmountInAvaxFromPng = function (amountStaked, amountAvailable, avaxPngPairReserveOfPng, avaxPngPairReserveOfWavax, reserveInPng, chainId) {
    if (JSBI$1.EQ(amountAvailable, JSBI$1.BigInt(0))) {
        return new TokenAmount(WAVAX[chainId], JSBI$1.BigInt(0));
    }
    const oneToken = JSBI$1.BigInt(1000000000000000000);
    const avaxPngRatio = JSBI$1.divide(JSBI$1.multiply(oneToken, avaxPngPairReserveOfWavax), avaxPngPairReserveOfPng);
    const valueOfPngInAvax = JSBI$1.divide(JSBI$1.multiply(reserveInPng, avaxPngRatio), oneToken);
    return new TokenAmount(WAVAX[chainId], JSBI$1.divide(JSBI$1.multiply(JSBI$1.multiply(amountStaked, valueOfPngInAvax), JSBI$1.BigInt(2)), amountAvailable));
};
const getExtraTokensWeeklyRewardRate = (rewardRatePerWeek, token, tokenMultiplier) => {
    const TEN_EIGHTEEN = JSBI$1.exponentiate(JSBI$1.BigInt(10), JSBI$1.BigInt(18));
    const rewardMultiplier = JSBI$1.BigInt(tokenMultiplier || 1);
    const unadjustedRewardPerWeek = JSBI$1.multiply(rewardMultiplier, rewardRatePerWeek === null || rewardRatePerWeek === void 0 ? void 0 : rewardRatePerWeek.raw);
    const finalReward = JSBI$1.divide(unadjustedRewardPerWeek, TEN_EIGHTEEN);
    return new TokenAmount(token, finalReward);
};
const tokenComparator = ({ address: addressA }, { address: addressB }) => {
    // Sort AVAX last
    if (addressA === WAVAX[ChainId.AVALANCHE].address)
        return 1;
    else if (addressB === WAVAX[ChainId.AVALANCHE].address)
        return -1;
    // Sort PNG first
    else if (addressA === PNG[ChainId.AVALANCHE].address)
        return -1;
    else if (addressB === PNG[ChainId.AVALANCHE].address)
        return 1;
    // Sort axlUST first
    else if (addressA === axlUST[ChainId.AVALANCHE].address)
        return -1;
    else if (addressB === axlUST[ChainId.AVALANCHE].address)
        return 1;
    // Sort USDC first
    else if (addressA === USDC[ChainId.AVALANCHE].address)
        return -1;
    else if (addressB === USDC[ChainId.AVALANCHE].address)
        return 1;
    // Sort USDCe first
    else if (addressA === USDCe[ChainId.AVALANCHE].address)
        return -1;
    else if (addressB === USDCe[ChainId.AVALANCHE].address)
        return 1;
    else
        return 0;
};
/* eslint-disable @typescript-eslint/no-unused-vars */
const useDummyMinichefHook = (_version, _pairToFilterBy) => {
    return [];
};
const useMinichefStakingInfos = (version = 2, pairToFilterBy) => {
    var _a;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const minichefContract = useMiniChefContract();
    const poolMap = useMinichefPools();
    const lpTokens = Object.keys(poolMap);
    // if chain is not avalanche skip the first pool because it's dummyERC20
    if (chainId !== ChainId.AVALANCHE) {
        lpTokens.shift();
    }
    const _tokens0Call = useMultipleContractSingleData(lpTokens, PANGOLIN_PAIR_INTERFACE, 'token0', []);
    const _tokens1Call = useMultipleContractSingleData(lpTokens, PANGOLIN_PAIR_INTERFACE, 'token1', []);
    const tokens0Adrr = useMemo(() => {
        return _tokens0Call.map((result) => {
            return result.result && result.result.length > 0 ? result.result[0] : null;
        });
    }, [_tokens0Call]);
    const tokens1Adrr = useMemo(() => {
        return _tokens1Call.map((result) => (result.result && result.result.length > 0 ? result.result[0] : null));
    }, [_tokens1Call]);
    const tokens0 = useTokens(tokens0Adrr);
    const tokens1 = useTokens(tokens1Adrr);
    const info = useMemo(() => {
        const filterPair = (item) => {
            if (pairToFilterBy === undefined) {
                return true;
            }
            if (pairToFilterBy === null) {
                return false;
            }
            return pairToFilterBy.involvesToken(item.tokens[0]) && pairToFilterBy.involvesToken(item.tokens[1]);
        };
        const _infoTokens = [];
        if (tokens0 && tokens1 && (tokens0 === null || tokens0 === void 0 ? void 0 : tokens0.length) === (tokens1 === null || tokens1 === void 0 ? void 0 : tokens1.length)) {
            tokens0.forEach((token0, index) => {
                var _a;
                const token1 = tokens1[index];
                if (token0 && token1) {
                    _infoTokens.push({
                        tokens: [token0, token1],
                        stakingRewardAddress: (_a = minichefContract === null || minichefContract === void 0 ? void 0 : minichefContract.address) !== null && _a !== void 0 ? _a : '',
                        version: version,
                    });
                }
            });
            return _infoTokens.filter(filterPair);
        }
        return _infoTokens;
    }, [chainId, minichefContract, tokens0, tokens1, pairToFilterBy, version]);
    const _tokens = useMemo(() => (info ? info.map(({ tokens }) => tokens) : []), [info]);
    const pairs = usePairs(_tokens);
    // @dev: If no farms load, you likely loaded an incorrect config from doubleSideConfig.js
    // Enable this and look for an invalid pair
    const pairAddresses = useMemo(() => {
        return pairs.map(([, pair]) => pair === null || pair === void 0 ? void 0 : pair.liquidityToken.address);
    }, [pairs]);
    const pairTotalSupplies = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'totalSupply');
    const balances = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'balanceOf', [
        MINICHEF_ADDRESS[chainId],
    ]);
    const [avaxPngPairState, avaxPngPair] = usePair(WAVAX[chainId], PNG[chainId]);
    const poolIdArray = useMemo(() => {
        if (!pairAddresses || !poolMap)
            return [];
        const NOT_FOUND = -1;
        const results = pairAddresses.map((address) => { var _a; return (_a = poolMap[address !== null && address !== void 0 ? address : '']) !== null && _a !== void 0 ? _a : NOT_FOUND; });
        if (results.some((result) => result === NOT_FOUND))
            return [];
        return results;
    }, [poolMap, pairAddresses]);
    const poolsIdInput = useMemo(() => {
        if (!poolIdArray)
            return [];
        return poolIdArray.map((pid) => [pid]);
    }, [poolIdArray]);
    const poolInfos = useSingleContractMultipleData(minichefContract, 'poolInfo', poolsIdInput !== null && poolsIdInput !== void 0 ? poolsIdInput : []);
    const rewarders = useSingleContractMultipleData(minichefContract, 'rewarder', poolsIdInput !== null && poolsIdInput !== void 0 ? poolsIdInput : []);
    const userInfoInput = useMemo(() => {
        if (!poolIdArray || !account)
            return [];
        return poolIdArray.map((pid) => [pid, account]);
    }, [poolIdArray, account]);
    const userInfos = useSingleContractMultipleData(minichefContract, 'userInfo', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const pendingRewards = useSingleContractMultipleData(minichefContract, 'pendingReward', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const rewardsAddresses = useMemo(() => {
        if ((rewarders || []).length === 0)
            return [];
        if (rewarders.some((item) => item.loading))
            return [];
        return rewarders.map((reward) => { var _a; return (_a = reward === null || reward === void 0 ? void 0 : reward.result) === null || _a === void 0 ? void 0 : _a[0]; });
    }, [rewarders]);
    const rewardTokensAddresses = useMultipleContractSingleData(rewardsAddresses, REWARDER_VIA_MULTIPLIER_INTERFACE, 'getRewardTokens', []);
    const rewardTokensMultipliers = useMultipleContractSingleData(rewardsAddresses, REWARDER_VIA_MULTIPLIER_INTERFACE, 'getRewardMultipliers', []);
    const rewardPerSecond = useSingleCallResult(minichefContract, 'rewardPerSecond', []).result;
    const totalAllocPoint = useSingleCallResult(minichefContract, 'totalAllocPoint', []).result;
    const rewardsExpiration = useSingleCallResult(minichefContract, 'rewardsExpiration', []).result;
    const usdPriceTmp = useUSDCPrice(WAVAX[chainId]);
    const usdPrice = ((_a = CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet) ? usdPriceTmp : undefined;
    return useMemo(() => {
        if (!chainId || !PNG[chainId])
            return [];
        return pairAddresses.reduce((memo, _pairAddress, index) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
            const pairTotalSupplyState = pairTotalSupplies[index];
            const balanceState = balances[index];
            const poolInfo = poolInfos[index];
            const userPoolInfo = userInfos[index];
            const [pairState, pair] = pairs[index];
            const pendingRewardInfo = pendingRewards[index];
            const rewardTokensAddress = rewardTokensAddresses[index];
            const rewardTokensMultiplier = rewardTokensMultipliers[index];
            const rewardsAddress = rewardsAddresses[index];
            if ((pairTotalSupplyState === null || pairTotalSupplyState === void 0 ? void 0 : pairTotalSupplyState.loading) === false &&
                (poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.loading) === false &&
                (balanceState === null || balanceState === void 0 ? void 0 : balanceState.loading) === false &&
                pair &&
                avaxPngPair &&
                pairState !== PairState.LOADING &&
                avaxPngPairState !== PairState.LOADING &&
                rewardPerSecond &&
                totalAllocPoint &&
                (rewardsExpiration === null || rewardsExpiration === void 0 ? void 0 : rewardsExpiration[0]) &&
                (rewardTokensAddress === null || rewardTokensAddress === void 0 ? void 0 : rewardTokensAddress.loading) === false) {
                if ((balanceState === null || balanceState === void 0 ? void 0 : balanceState.error) ||
                    pairTotalSupplyState.error ||
                    pairState === PairState.INVALID ||
                    pairState === PairState.NOT_EXISTS ||
                    avaxPngPairState === PairState.INVALID ||
                    avaxPngPairState === PairState.NOT_EXISTS) {
                    console.error('Failed to load staking rewards info');
                    return memo;
                }
                const pid = poolMap[pair.liquidityToken.address].toString();
                // get the LP token
                const token0 = pair === null || pair === void 0 ? void 0 : pair.token0;
                const token1 = pair === null || pair === void 0 ? void 0 : pair.token1;
                const tokens = [token0, token1].sort(tokenComparator);
                const dummyPair = new Pair(new TokenAmount(tokens[0], '0'), new TokenAmount(tokens[1], '0'), chainId);
                const lpToken = dummyPair.liquidityToken;
                const poolAllocPointAmount = new TokenAmount(lpToken, JSBI$1.BigInt((_a = poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.result) === null || _a === void 0 ? void 0 : _a['allocPoint']));
                const totalAllocPointAmount = new TokenAmount(lpToken, JSBI$1.BigInt(totalAllocPoint === null || totalAllocPoint === void 0 ? void 0 : totalAllocPoint[0]));
                const rewardRatePerSecAmount = new TokenAmount(PNG[chainId], JSBI$1.BigInt(rewardPerSecond === null || rewardPerSecond === void 0 ? void 0 : rewardPerSecond[0]));
                const poolRewardRate = new TokenAmount(PNG[chainId], JSBI$1.divide(JSBI$1.multiply(poolAllocPointAmount.raw, rewardRatePerSecAmount.raw), totalAllocPointAmount.raw));
                const totalRewardRatePerWeek = new TokenAmount(PNG[chainId], JSBI$1.multiply(poolRewardRate.raw, BIG_INT_SECONDS_IN_WEEK));
                const periodFinishMs = (_c = (_b = rewardsExpiration === null || rewardsExpiration === void 0 ? void 0 : rewardsExpiration[0]) === null || _b === void 0 ? void 0 : _b.mul(1000)) === null || _c === void 0 ? void 0 : _c.toNumber();
                // periodFinish will be 0 immediately after a reward contract is initialized
                const isPeriodFinished = periodFinishMs === 0 ? false : periodFinishMs < Date.now() || poolAllocPointAmount.equalTo('0');
                const totalSupplyStaked = JSBI$1.BigInt((_d = balanceState === null || balanceState === void 0 ? void 0 : balanceState.result) === null || _d === void 0 ? void 0 : _d[0]);
                const totalSupplyAvailable = JSBI$1.BigInt((_e = pairTotalSupplyState === null || pairTotalSupplyState === void 0 ? void 0 : pairTotalSupplyState.result) === null || _e === void 0 ? void 0 : _e[0]);
                const totalStakedAmount = new TokenAmount(lpToken, JSBI$1.BigInt((_f = balanceState === null || balanceState === void 0 ? void 0 : balanceState.result) === null || _f === void 0 ? void 0 : _f[0]));
                const stakedAmount = new TokenAmount(lpToken, JSBI$1.BigInt((_h = (_g = userPoolInfo === null || userPoolInfo === void 0 ? void 0 : userPoolInfo.result) === null || _g === void 0 ? void 0 : _g['amount']) !== null && _h !== void 0 ? _h : 0));
                const earnedAmount = new TokenAmount(PNG[chainId], JSBI$1.BigInt((_k = (_j = pendingRewardInfo === null || pendingRewardInfo === void 0 ? void 0 : pendingRewardInfo.result) === null || _j === void 0 ? void 0 : _j['pending']) !== null && _k !== void 0 ? _k : 0));
                const multiplier = JSBI$1.BigInt((_l = poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.result) === null || _l === void 0 ? void 0 : _l['allocPoint']);
                let totalStakedInUsd = CHAINS[chainId || ChainId].mainnet
                    ? new TokenAmount(DAIe[chainId], BIG_INT_ZERO)
                    : undefined;
                const totalStakedInWavax = new TokenAmount(WAVAX[chainId], BIG_INT_ZERO);
                if (JSBI$1.equal(totalSupplyAvailable, BIG_INT_ZERO));
                else if (pair.involvesToken(DAIe[chainId])) {
                    const pairValueInDAI = JSBI$1.multiply(pair.reserveOfToken(DAIe[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInDAI = JSBI$1.divide(JSBI$1.multiply(pairValueInDAI, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = CHAINS[chainId || ChainId].mainnet
                        ? new TokenAmount(DAIe[chainId], stakedValueInDAI)
                        : undefined;
                }
                else if (pair.involvesToken(USDCe[chainId])) {
                    const pairValueInUSDC = JSBI$1.multiply(pair.reserveOfToken(USDCe[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInUSDC = JSBI$1.divide(JSBI$1.multiply(pairValueInUSDC, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = CHAINS[chainId || ChainId].mainnet
                        ? new TokenAmount(USDCe[chainId], stakedValueInUSDC)
                        : undefined;
                }
                else if (pair.involvesToken(USDC[chainId])) {
                    const pairValueInUSDC = JSBI$1.multiply(pair.reserveOfToken(USDC[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInUSDC = JSBI$1.divide(JSBI$1.multiply(pairValueInUSDC, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = CHAINS[chainId || ChainId].mainnet
                        ? new TokenAmount(USDC[chainId], stakedValueInUSDC)
                        : undefined;
                }
                else if (pair.involvesToken(axlUST[chainId])) {
                    const pairValueInUST = JSBI$1.multiply(pair.reserveOfToken(axlUST[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInUST = JSBI$1.divide(JSBI$1.multiply(pairValueInUST, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = CHAINS[chainId || ChainId].mainnet
                        ? new TokenAmount(axlUST[chainId], stakedValueInUST)
                        : undefined;
                }
                else if (pair.involvesToken(USDTe[chainId])) {
                    const pairValueInUSDT = JSBI$1.multiply(pair.reserveOfToken(USDTe[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInUSDT = JSBI$1.divide(JSBI$1.multiply(pairValueInUSDT, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = CHAINS[chainId || ChainId].mainnet
                        ? new TokenAmount(USDTe[chainId], stakedValueInUSDT)
                        : undefined;
                }
                else if (pair.involvesToken(WAVAX[chainId])) {
                    const _totalStakedInWavax = calculateTotalStakedAmountInAvax(totalSupplyStaked, totalSupplyAvailable, pair.reserveOfToken(WAVAX[chainId]).raw, chainId);
                    totalStakedInUsd = CHAINS[chainId || ChainId].mainnet
                        ? _totalStakedInWavax && (usdPrice === null || usdPrice === void 0 ? void 0 : usdPrice.quote(_totalStakedInWavax, chainId))
                        : undefined;
                }
                else if (pair.involvesToken(PNG[chainId])) {
                    const _totalStakedInWavax = calculateTotalStakedAmountInAvaxFromPng(totalSupplyStaked, totalSupplyAvailable, avaxPngPair.reserveOfToken(PNG[chainId]).raw, avaxPngPair.reserveOfToken(WAVAX[chainId]).raw, pair.reserveOfToken(PNG[chainId]).raw, chainId);
                    totalStakedInUsd = CHAINS[chainId || ChainId].mainnet
                        ? _totalStakedInWavax && (usdPrice === null || usdPrice === void 0 ? void 0 : usdPrice.quote(_totalStakedInWavax, chainId))
                        : undefined;
                }
                else {
                    // Contains no stablecoin, WAVAX, nor PNG
                    console.error(`Could not identify total staked value for pair ${pair.liquidityToken.address}`);
                }
                const getHypotheticalWeeklyRewardRate = (_stakedAmount, _totalStakedAmount, _totalRewardRatePerSecond) => {
                    return new TokenAmount(PNG[chainId], JSBI$1.greaterThan(_totalStakedAmount.raw, JSBI$1.BigInt(0))
                        ? JSBI$1.divide(JSBI$1.multiply(JSBI$1.multiply(_totalRewardRatePerSecond.raw, _stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK), _totalStakedAmount.raw)
                        : JSBI$1.BigInt(0));
                };
                const userRewardRatePerWeek = getHypotheticalWeeklyRewardRate(stakedAmount, totalStakedAmount, poolRewardRate);
                memo.push({
                    pid,
                    stakingRewardAddress: MINICHEF_ADDRESS[chainId],
                    tokens,
                    earnedAmount,
                    rewardRatePerWeek: userRewardRatePerWeek,
                    totalRewardRatePerSecond: poolRewardRate,
                    totalRewardRatePerWeek: totalRewardRatePerWeek,
                    stakedAmount,
                    totalStakedAmount,
                    totalStakedInWavax,
                    totalStakedInUsd,
                    multiplier: JSBI$1.divide(multiplier, JSBI$1.BigInt(100)),
                    periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,
                    isPeriodFinished,
                    getHypotheticalWeeklyRewardRate,
                    getExtraTokensWeeklyRewardRate,
                    rewardTokensAddress: [(_m = PNG[chainId]) === null || _m === void 0 ? void 0 : _m.address, ...(((_o = rewardTokensAddress === null || rewardTokensAddress === void 0 ? void 0 : rewardTokensAddress.result) === null || _o === void 0 ? void 0 : _o[0]) || [])],
                    rewardTokensMultiplier: [BigNumber.from(1), ...(((_p = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier.result) === null || _p === void 0 ? void 0 : _p[0]) || [])],
                    rewardsAddress,
                });
            }
            return memo;
        }, []);
    }, [
        chainId,
        PNG[chainId],
        pairTotalSupplies,
        poolInfos,
        userInfos,
        pairs,
        avaxPngPair,
        avaxPngPairState,
        rewardPerSecond,
        totalAllocPoint,
        pendingRewards,
        rewardsExpiration,
        balances,
        usdPrice,
        pairAddresses,
        rewardTokensAddresses,
        rewardsAddresses,
        rewardTokensMultipliers,
        poolMap,
    ]);
};
const fetchMinichefData = (account, chainId) => () => __awaiter(void 0, void 0, void 0, function* () {
    const mininchefV2Client = mininchefV2Clients[chainId];
    if (!mininchefV2Client) {
        return null;
    }
    const { minichefs } = yield mininchefV2Client.request(GET_MINICHEF, { userAddress: account });
    return minichefs;
});
function useGetAllFarmData() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const allFarms = useQuery(['get-minichef-farms-v2', account], fetchMinichefData(account || '', chainId), {
        refetchInterval: 1000 * 60 * 5, // 5 minutes
    });
    const dispatch = useDispatch();
    useEffect(() => {
        var _a;
        if (allFarms.isError) {
            // if there is error then empty the data in redux
            dispatch(updateMinichefStakingAllData({
                data: {
                    chainId: chainId,
                    data: {
                        id: '',
                        totalAllocPoint: 0,
                        rewardPerSecond: 0,
                        rewardsExpiration: 0,
                        farms: [],
                    },
                },
            }));
        }
        else if (!(allFarms === null || allFarms === void 0 ? void 0 : allFarms.isLoading) && !(allFarms === null || allFarms === void 0 ? void 0 : allFarms.isError)) {
            dispatch(updateMinichefStakingAllData({
                data: {
                    chainId: chainId,
                    data: (_a = allFarms === null || allFarms === void 0 ? void 0 : allFarms.data) === null || _a === void 0 ? void 0 : _a[0],
                },
            }));
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [allFarms === null || allFarms === void 0 ? void 0 : allFarms.data, allFarms === null || allFarms === void 0 ? void 0 : allFarms.isLoading, allFarms === null || allFarms === void 0 ? void 0 : allFarms.isError]);
}
function useGetDummyAllFarmData() {
    // This is intentional
}
function useAllMinichefStakingInfoData() {
    const chainId = useChainId();
    return useSelector((state) => { var _a, _b; return ((_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.minichefStakingData) === null || _b === void 0 ? void 0 : _b[chainId]) || {}; });
}
// get data for all farms
const useGetMinichefStakingInfosViaSubgraph = () => {
    const minichefData = useAllMinichefStakingInfoData();
    const farms = minichefData === null || minichefData === void 0 ? void 0 : minichefData.farms;
    const chainId = useChainId();
    const png = PNG[chainId];
    const rewardsExpiration = minichefData === null || minichefData === void 0 ? void 0 : minichefData.rewardsExpiration;
    const totalAllocPoint = minichefData === null || minichefData === void 0 ? void 0 : minichefData.totalAllocPoint;
    const rewardPerSecond = minichefData === null || minichefData === void 0 ? void 0 : minichefData.rewardPerSecond;
    return useMemo(() => {
        if (!chainId || !png || !(farms === null || farms === void 0 ? void 0 : farms.length))
            return [];
        return farms.reduce(function (memo, farm) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            const rewardsAddress = farm === null || farm === void 0 ? void 0 : farm.rewarderAddress;
            const rewardsAddresses = farm.rewarder.rewards;
            const pair = farm.pair;
            const axlUSTToken = axlUST[chainId];
            const axlUSTAddress = axlUSTToken.address;
            const pairToken0 = pair === null || pair === void 0 ? void 0 : pair.token0;
            const token0 = new Token$1(chainId, getAddress$1(pairToken0.id), Number(pairToken0.decimals), axlUSTAddress.toLowerCase() === pairToken0.id.toLowerCase() ? axlUSTToken.symbol : pairToken0.symbol, pairToken0.name);
            const pairToken1 = pair === null || pair === void 0 ? void 0 : pair.token1;
            const token1 = new Token$1(chainId, getAddress$1(pairToken1.id), Number(pairToken1.decimals), axlUSTAddress.toLowerCase() === pairToken1.id.toLowerCase() ? axlUSTToken.symbol : pairToken1.symbol, pairToken1.name);
            const tokens = [token0, token1].sort(tokenComparator);
            const dummyPair = new Pair(new TokenAmount(tokens[0], '0'), new TokenAmount(tokens[1], '0'), chainId);
            const lpToken = dummyPair.liquidityToken;
            const poolAllocPointAmount = new TokenAmount(lpToken, JSBI$1.BigInt(farm === null || farm === void 0 ? void 0 : farm.allocPoint));
            const totalAllocPointAmount = new TokenAmount(lpToken, JSBI$1.BigInt(totalAllocPoint !== null && totalAllocPoint !== void 0 ? totalAllocPoint : 0));
            const rewardRatePerSecAmount = new TokenAmount(png, JSBI$1.BigInt(rewardPerSecond !== null && rewardPerSecond !== void 0 ? rewardPerSecond : 0));
            const poolRewardRate = new TokenAmount(png, JSBI$1.divide(JSBI$1.multiply(poolAllocPointAmount.raw, rewardRatePerSecAmount.raw), totalAllocPointAmount.raw));
            const totalRewardRatePerWeek = new TokenAmount(png, JSBI$1.multiply(poolRewardRate.raw, BIG_INT_SECONDS_IN_WEEK));
            const periodFinishMs = (rewardsExpiration || 0) * 1000;
            // periodFinish will be 0 immediately after a reward contract is initialized
            const isPeriodFinished = periodFinishMs === 0 ? false : periodFinishMs < Date.now() || poolAllocPointAmount.equalTo('0');
            const minichefTvl = parseUnits((_a = farm === null || farm === void 0 ? void 0 : farm.tvl) === null || _a === void 0 ? void 0 : _a.toString());
            const totalSupplyReserve0 = parseUnits((_b = farm === null || farm === void 0 ? void 0 : farm.pair) === null || _b === void 0 ? void 0 : _b.reserve0.toString());
            const totalSupply = parseUnits(((_c = farm === null || farm === void 0 ? void 0 : farm.pair) === null || _c === void 0 ? void 0 : _c.totalSupply.toString()) === '0' ? '1' : (_d = farm === null || farm === void 0 ? void 0 : farm.pair) === null || _d === void 0 ? void 0 : _d.totalSupply.toString());
            const token0derivedUSD = parseUnits((_g = Number((_f = (_e = farm === null || farm === void 0 ? void 0 : farm.pair) === null || _e === void 0 ? void 0 : _e.token0) === null || _f === void 0 ? void 0 : _f.derivedUSD)) === null || _g === void 0 ? void 0 : _g.toFixed(10));
            const pairTokenValueInUSD = token0derivedUSD.mul(parseUnits('2'));
            const calculatedStakedUsdValue = minichefTvl.mul(totalSupplyReserve0).div(totalSupply);
            // we have 2 10^18, so we need to divide ONE_TOKEN 2 times
            const finalStakedValueInUSD = pairTokenValueInUSD
                .mul(calculatedStakedUsdValue)
                .div(ONE_TOKEN.toString())
                .div(ONE_TOKEN.toString());
            const totalStakedAmount = new TokenAmount(lpToken, minichefTvl.toString() || JSBI$1.BigInt(0));
            const totalStakedInUsd = new TokenAmount(lpToken, finalStakedValueInUSD.toString() || JSBI$1.BigInt(0));
            const stakedAmount = new TokenAmount(lpToken, parseUnits((_l = (_k = (_j = (_h = farm === null || farm === void 0 ? void 0 : farm.farmingPositions) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.stakedTokenBalance) === null || _k === void 0 ? void 0 : _k.toString()) !== null && _l !== void 0 ? _l : '0').toString());
            const earnedAmount = new TokenAmount(png, JSBI$1.BigInt((_m = farm === null || farm === void 0 ? void 0 : farm.earnedAmount) !== null && _m !== void 0 ? _m : 0));
            const multiplier = JSBI$1.BigInt(farm === null || farm === void 0 ? void 0 : farm.allocPoint);
            const pid = farm === null || farm === void 0 ? void 0 : farm.pid;
            const rewardTokens = rewardsAddresses.map((rewardToken) => {
                const tokenObj = rewardToken.token;
                return new Token$1(chainId, getAddress$1(tokenObj.id), tokenObj.decimals, tokenObj.symbol, tokenObj.name);
            });
            const rewardTokensAddress = rewardsAddresses.map((rewardToken) => {
                const tokenObj = rewardToken.token;
                return getAddress$1(tokenObj.id);
            });
            const getHypotheticalWeeklyRewardRate = (_stakedAmount, _totalStakedAmount, _totalRewardRatePerSecond) => {
                return new TokenAmount(png, JSBI$1.greaterThan(_totalStakedAmount.raw, JSBI$1.BigInt(0))
                    ? JSBI$1.divide(JSBI$1.multiply(JSBI$1.multiply(_totalRewardRatePerSecond.raw, _stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK), _totalStakedAmount.raw)
                    : JSBI$1.BigInt(0));
            };
            const userRewardRatePerWeek = getHypotheticalWeeklyRewardRate(stakedAmount, totalStakedAmount, poolRewardRate);
            memo.push({
                stakingRewardAddress: MINICHEF_ADDRESS[chainId],
                pid,
                tokens,
                multiplier,
                isPeriodFinished,
                totalStakedAmount,
                totalStakedInUsd,
                rewardRatePerWeek: userRewardRatePerWeek,
                totalRewardRatePerSecond: poolRewardRate,
                totalRewardRatePerWeek: totalRewardRatePerWeek,
                getHypotheticalWeeklyRewardRate,
                getExtraTokensWeeklyRewardRate,
                stakedAmount,
                earnedAmount,
                rewardsAddress,
                rewardsAddresses,
                rewardTokens,
                rewardTokensAddress,
            });
            return memo;
        }, []);
    }, [chainId, png, rewardPerSecond, totalAllocPoint, rewardsExpiration, farms]);
};
/* eslint-disable @typescript-eslint/no-unused-vars */
const useDummyMinichefStakingInfosViaSubgraph = () => {
    return [];
};
/* eslint-enable max-lines */

const ZERO$1 = JSBI$1.BigInt(0);
function useMintState() {
    return useSelector((state) => state.pmint);
}
function useDerivedMintInfo(currencyA, currencyB) {
    var _a, _b, _c, _d;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useTotalSupply = useTotalSupplyHook[chainId];
    const { t } = useTranslation();
    const { independentField, typedValue, otherTypedValue } = useMintState();
    const dependentField = independentField === Field$1.CURRENCY_A ? Field$1.CURRENCY_B : Field$1.CURRENCY_A;
    // error handling
    let insufficientInput = false;
    // tokens
    const currencies = useMemo(() => ({
        [Field$1.CURRENCY_A]: currencyA !== null && currencyA !== void 0 ? currencyA : undefined,
        [Field$1.CURRENCY_B]: currencyB !== null && currencyB !== void 0 ? currencyB : undefined,
    }), [currencyA, currencyB]);
    // pair
    const [pairState, pair] = usePair(currencies[Field$1.CURRENCY_A], currencies[Field$1.CURRENCY_B]);
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    const totalSupply = useTotalSupply(pairOrToken);
    const noLiquidity = pairState === PairState.NOT_EXISTS || !totalSupply || Boolean(totalSupply && JSBI$1.equal(totalSupply.raw, ZERO$1));
    // balances
    const balances = useCurrencyBalances(chainId, account !== null && account !== void 0 ? account : undefined, [
        currencies[Field$1.CURRENCY_A],
        currencies[Field$1.CURRENCY_B],
    ]);
    const currencyBalances = {
        [Field$1.CURRENCY_A]: balances[0],
        [Field$1.CURRENCY_B]: balances[1],
    };
    // amounts
    const independentAmount = tryParseAmount(typedValue, currencies[independentField], chainId);
    const dependentAmount = useMemo(() => {
        if (noLiquidity) {
            if (otherTypedValue && currencies[dependentField]) {
                return tryParseAmount(otherTypedValue, currencies[dependentField], chainId);
            }
            return undefined;
        }
        else if (independentAmount) {
            // we wrap the currencies just to get the price in terms of the other token
            const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId);
            const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];
            if (tokenA && tokenB && wrappedIndependentAmount && pair && chainId) {
                const dependentCurrency = dependentField === Field$1.CURRENCY_B ? currencyB : currencyA;
                const dependentTokenAmount = dependentField === Field$1.CURRENCY_B
                    ? pair.priceOf(tokenA, tokenB).quote(wrappedIndependentAmount, chainId)
                    : pair.priceOf(tokenB, tokenA).quote(wrappedIndependentAmount, chainId);
                return dependentCurrency === CAVAX[chainId]
                    ? CurrencyAmount.ether(dependentTokenAmount.raw, chainId)
                    : dependentTokenAmount;
            }
            return undefined;
        }
        else {
            return undefined;
        }
    }, [
        noLiquidity,
        otherTypedValue,
        currencies,
        dependentField,
        independentAmount,
        currencyA,
        chainId,
        currencyB,
        pair,
    ]);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const parsedAmounts = {
        [Field$1.CURRENCY_A]: independentField === Field$1.CURRENCY_A ? independentAmount : dependentAmount,
        [Field$1.CURRENCY_B]: independentField === Field$1.CURRENCY_A ? dependentAmount : independentAmount,
    };
    const price = useMemo(() => {
        if (noLiquidity) {
            const { [Field$1.CURRENCY_A]: _currencyAAmount, [Field$1.CURRENCY_B]: _currencyBAmount } = parsedAmounts;
            if (_currencyAAmount && _currencyBAmount) {
                return new Price(_currencyAAmount.currency, _currencyBAmount.currency, _currencyAAmount.raw, _currencyBAmount.raw);
            }
            return undefined;
        }
        else {
            const wrappedCurrencyA = wrappedCurrency(currencyA, chainId);
            const wrappedCurrencyB = wrappedCurrency(currencyB, chainId);
            return pair && wrappedCurrencyA && wrappedCurrencyB
                ? pair.priceOf(wrappedCurrencyA, wrappedCurrencyB)
                : undefined;
        }
    }, [chainId, currencyA, currencyB, noLiquidity, pair, parsedAmounts]);
    // liquidity minted
    const liquidityMinted = useMemo(() => {
        const { [Field$1.CURRENCY_A]: _currencyAAmount, [Field$1.CURRENCY_B]: _currencyBAmount } = parsedAmounts;
        const [tokenAmountA, tokenAmountB] = [
            wrappedCurrencyAmount(_currencyAAmount, chainId),
            wrappedCurrencyAmount(_currencyBAmount, chainId),
        ];
        insufficientInput = false; // eslint-disable-line react-hooks/exhaustive-deps
        if (pair && totalSupply && tokenAmountA && tokenAmountB) {
            try {
                return pair.getLiquidityMinted(totalSupply, [tokenAmountA, tokenAmountB]);
            }
            catch (err) {
                if (err instanceof InsufficientInputAmountError) {
                    insufficientInput = true;
                    return undefined;
                }
                else {
                    throw err;
                }
            }
        }
        else {
            return undefined;
        }
    }, [parsedAmounts, chainId, pair, totalSupply]);
    const poolTokenPercentage = useMemo(() => {
        if (liquidityMinted && totalSupply) {
            return new Percent$1(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);
        }
        else {
            return undefined;
        }
    }, [liquidityMinted, totalSupply]);
    let error;
    if (!account) {
        error = t('mintHooks.connectWallet');
    }
    if (insufficientInput) {
        error = t('mintHooks.insufficientInputAmount');
    }
    if (pairState === PairState.INVALID) {
        error = error !== null && error !== void 0 ? error : t('mintHooks.invalidPair');
    }
    if (!parsedAmounts[Field$1.CURRENCY_A] || !parsedAmounts[Field$1.CURRENCY_B]) {
        error = error !== null && error !== void 0 ? error : t('mintHooks.enterAmount');
    }
    const { [Field$1.CURRENCY_A]: currencyAAmount, [Field$1.CURRENCY_B]: currencyBAmount } = parsedAmounts;
    if (currencyAAmount && ((_a = currencyBalances === null || currencyBalances === void 0 ? void 0 : currencyBalances[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.lessThan(currencyAAmount))) {
        error = t('mintHooks.insufficient') + ((_b = currencies[Field$1.CURRENCY_A]) === null || _b === void 0 ? void 0 : _b.symbol) + t('mintHooks.balance');
    }
    if (currencyBAmount && ((_c = currencyBalances === null || currencyBalances === void 0 ? void 0 : currencyBalances[Field$1.CURRENCY_B]) === null || _c === void 0 ? void 0 : _c.lessThan(currencyBAmount))) {
        error = t('mintHooks.insufficient') + ((_d = currencies[Field$1.CURRENCY_B]) === null || _d === void 0 ? void 0 : _d.symbol) + t('mintHooks.balance');
    }
    return {
        dependentField,
        currencies,
        pair,
        pairState,
        currencyBalances,
        parsedAmounts,
        price,
        noLiquidity,
        liquidityMinted,
        poolTokenPercentage,
        error,
    };
}
function useMintActionHandlers(noLiquidity) {
    const dispatch = useDispatch();
    const onFieldAInput = useCallback((typedValue) => {
        dispatch(typeInput$1({ field: Field$1.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }));
    }, [dispatch, noLiquidity]);
    const onFieldBInput = useCallback((typedValue) => {
        dispatch(typeInput$1({ field: Field$1.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }));
    }, [dispatch, noLiquidity]);
    return {
        onFieldAInput,
        onFieldBInput,
    };
}

const Root$d = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const Header$2 = styled(Box)`
  padding: 0px 20px;
`;
const OutputText = styled(Text)`
  width: 100%;
  line-height: 18px;
  text-align: left;
  color: ${({ theme }) => theme.color11};
`;
const Footer$1 = styled(Box)`
  padding: 0px 10px;
`;
const ErrorWrapper$4 = styled(Box)`
  display: grid;
  grid-template-rows: minmax(100px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const ErrorBox$4 = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const StatWrapper$4 = styled(Box)`
  display: grid;
  grid-template-columns: minmax(auto, 33%) minmax(auto, 33%) minmax(auto, 33%);
  ${({ theme }) => theme.mediaWidth.upToSmall`
    grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  `};
  grid-gap: 12px;
`;

const ConfirmSwapDrawer = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    const { isOpen, onClose, allowedSlippage, attemptingTxn, liquidityMinted, poolErrorMessage, txHash, noLiquidity, price, currencies, parsedAmounts, poolTokenPercentage, onAdd, onComplete = () => {
        /**/
    }, onAddToFarm, type, } = props;
    const theme = useContext(ThemeContext);
    const { t } = useTranslation();
    const pendingText = `Supplying ${(_a = parsedAmounts[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.toSignificant(6)} ${(_b = currencies[Field$1.CURRENCY_A]) === null || _b === void 0 ? void 0 : _b.symbol} and ${(_c = parsedAmounts[Field$1.CURRENCY_B]) === null || _c === void 0 ? void 0 : _c.toSignificant(6)} ${(_d = currencies[Field$1.CURRENCY_B]) === null || _d === void 0 ? void 0 : _d.symbol}`;
    const DetailConfirmContent = (jsxs(Root$d, {
        children: [jsxs(Header$2, {
            children: [noLiquidity ? (jsxs(Box, Object.assign({ display: "flex" }, { children: [jsx(Text, Object.assign({ fontSize: ['26px', '22px'], fontWeight: 500, lineHeight: "42px", marginRight: 10, color: "text1" }, { children: ((_e = currencies[Field$1.CURRENCY_A]) === null || _e === void 0 ? void 0 : _e.symbol) + '/' + ((_f = currencies[Field$1.CURRENCY_B]) === null || _f === void 0 ? void 0 : _f.symbol) })), jsx(DoubleCurrencyLogo, { currency0: currencies[Field$1.CURRENCY_A], currency1: currencies[Field$1.CURRENCY_B], size: 24 })] }))) : (jsxs(Box, {
                children: [jsxs(Box, Object.assign({ display: "flex" }, { children: [jsx(Text, Object.assign({ fontSize: ['26px', '22px'], fontWeight: 500, lineHeight: "42px", marginRight: 10, color: "text1" }, { children: liquidityMinted === null || liquidityMinted === void 0 ? void 0 : liquidityMinted.toSignificant(6) })), jsx(DoubleCurrencyLogo, { currency0: currencies[Field$1.CURRENCY_A], currency1: currencies[Field$1.CURRENCY_B], size: 24 })] })), jsx(Box, {
                    children: jsx(Text, Object.assign({ fontSize: ['20px', '16px'], color: "text1", lineHeight: "40px" }, {
                        children: ((_g = currencies[Field$1.CURRENCY_A]) === null || _g === void 0 ? void 0 : _g.symbol) +
                            '/' +
                            ((_h = currencies[Field$1.CURRENCY_B]) === null || _h === void 0 ? void 0 : _h.symbol) +
                            t('addLiquidity.poolTokens')
                    }))
                }), jsx(OutputText, { children: t('addLiquidity.outputEstimated', { allowedSlippage: allowedSlippage / 100 }) })]
            })), jsxs(Box, Object.assign({ mt: 20 }, { children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center" }, { children: [jsxs(Text, Object.assign({ fontSize: "12px", color: "text1" }, { children: [(_j = currencies[Field$1.CURRENCY_A]) === null || _j === void 0 ? void 0 : _j.symbol, " ", t('addLiquidity.deposited')] })), jsxs(Box, Object.assign({ display: "flex" }, { children: [jsx(CurrencyLogo, { currency: currencies[Field$1.CURRENCY_A], size: 24 }), jsx(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: (_k = parsedAmounts[Field$1.CURRENCY_A]) === null || _k === void 0 ? void 0 : _k.toSignificant(6) }))] }))] })), jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", mt: "5px" }, { children: [jsxs(Text, Object.assign({ fontSize: "12px", color: "text1" }, { children: [(_l = currencies[Field$1.CURRENCY_B]) === null || _l === void 0 ? void 0 : _l.symbol, " ", t('addLiquidity.deposited')] })), jsxs(Box, Object.assign({ display: "flex" }, { children: [jsx(CurrencyLogo, { currency: currencies[Field$1.CURRENCY_B], size: 24 }), jsx(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: (_m = parsedAmounts[Field$1.CURRENCY_B]) === null || _m === void 0 ? void 0 : _m.toSignificant(6) }))] }))] })), jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", mt: "5px" }, { children: [jsx(Text, Object.assign({ fontSize: "12px", color: "text1" }, { children: t('addLiquidity.rates') })), jsxs(Box, { children: [jsx(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: `1 ${(_o = currencies[Field$1.CURRENCY_A]) === null || _o === void 0 ? void 0 : _o.symbol} = ${price === null || price === void 0 ? void 0 : price.toSignificant(4)} ${(_p = currencies[Field$1.CURRENCY_B]) === null || _p === void 0 ? void 0 : _p.symbol}` })), jsx(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: `1 ${(_q = currencies[Field$1.CURRENCY_B]) === null || _q === void 0 ? void 0 : _q.symbol} = ${price === null || price === void 0 ? void 0 : price.invert().toSignificant(4)} ${(_r = currencies[Field$1.CURRENCY_A]) === null || _r === void 0 ? void 0 : _r.symbol}` }))] })] })), jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", mt: "5px" }, { children: [jsx(Text, Object.assign({ fontSize: "12px", color: "text1" }, { children: t('addLiquidity.shareOfPool') })), jsxs(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: [noLiquidity ? '100' : poolTokenPercentage === null || poolTokenPercentage === void 0 ? void 0 : poolTokenPercentage.toSignificant(4), "%"] }))] }))] }))]
        }), jsx(Footer$1, { children: jsx(Box, Object.assign({ my: '10px' }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: onAdd }, { children: noLiquidity ? t('addLiquidity.createPoolSupply') : t('addLiquidity.confirmSupply') })) })) })]
    }));
    const CardConfirmContent = (jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", px: 20, pb: 20, height: "100%" }, { children: [jsxs(Box, Object.assign({ flex: 1 }, { children: [jsxs(StatWrapper$4, { children: [jsxs(Hidden, Object.assign({ upToSmall: true, display: "inline-block" }, { children: [jsx(Text, Object.assign({ color: 'text1', fontSize: [16, 14] }, { children: t('addLiquidity.deposited') })), jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsxs(Text, Object.assign({ color: 'text1', fontSize: [20, 16] }, { children: [(_s = parsedAmounts[Field$1.CURRENCY_A]) === null || _s === void 0 ? void 0 : _s.toSignificant(6), " ", (_t = currencies[Field$1.CURRENCY_A]) === null || _t === void 0 ? void 0 : _t.symbol] })) })), jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsxs(Text, Object.assign({ color: 'text1', fontSize: [20, 16] }, { children: [(_u = parsedAmounts[Field$1.CURRENCY_B]) === null || _u === void 0 ? void 0 : _u.toSignificant(6), " ", (_v = currencies[Field$1.CURRENCY_B]) === null || _v === void 0 ? void 0 : _v.symbol] })) }))] })), jsx(Stat, { title: `PGL`, stat: noLiquidity ? '-' : `     ${liquidityMinted === null || liquidityMinted === void 0 ? void 0 : liquidityMinted.toSignificant(6)}`, titlePosition: "top", titleFontSize: 16, statFontSize: [20, 16] }), jsx(Stat, { title: t('addLiquidity.shareOfPool'), stat: `${noLiquidity ? '100' : poolTokenPercentage === null || poolTokenPercentage === void 0 ? void 0 : poolTokenPercentage.toSignificant(4)}%`, titlePosition: "top", titleFontSize: 14, statFontSize: 16 })] }), jsx(Box, Object.assign({ mt: 10 }, { children: jsx(OutputText, Object.assign({ fontSize: 12, fontWeight: 400 }, { children: t('addLiquidity.outputEstimated', { allowedSlippage: allowedSlippage / 100 }) })) }))] })), jsx(Box, Object.assign({ mt: '10px' }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: onAdd, height: "46px" }, { children: noLiquidity ? t('addLiquidity.createPoolSupply') : t('addLiquidity.giveOrder') })) }))] })));
    const PendingContent = jsx(Loader, { size: 100, label: pendingText });
    const ErrorContent = (jsxs(ErrorWrapper$4, { children: [jsxs(ErrorBox$4, { children: [jsx(AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsx(Text, Object.assign({ fontWeight: 500, fontSize: [16, 14], color: 'red1', style: { textAlign: 'center', width: '85%' } }, { children: poolErrorMessage }))] }), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] }));
    const SubmittedContent = (jsx(Box, Object.assign({ padding: "10px", height: "100%" }, {
        children: jsx(TransactionCompleted, {
            submitText: `Liquidity Added`, isShowButtton: Boolean((type === SpaceType.card && onAddToFarm) || type === SpaceType.detail), onButtonClick: () => {
                onClose();
                if (onAddToFarm) {
                    onAddToFarm();
                }
                else {
                    onComplete();
                }
            }, buttonText: onAddToFarm ? t('transactionConfirmation.addToFarm') : t('transactionConfirmation.close')
        })
    })));
    const renderBody = () => {
        if (txHash) {
            return SubmittedContent;
        }
        if (attemptingTxn) {
            return PendingContent;
        }
        if (poolErrorMessage) {
            return ErrorContent;
        }
        if (type === SpaceType.detail) {
            return DetailConfirmContent;
        }
        return CardConfirmContent;
    };
    return (jsx(Drawer, Object.assign({
        title: noLiquidity ? t('addLiquidity.creatingPool') : t('addLiquidity.willReceive'), isOpen: isOpen, onClose: () => {
            type === SpaceType.card ? onComplete() : onClose();
        }, backgroundColor: type === SpaceType.card ? 'color5' : 'bg2'
    }, { children: renderBody() })));
};

const Root$c = styled(Box)`
  width: 100%;
  position: relative;
  overflow: hidden;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
`;
const GridContainer = styled(Box)`
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-gap: 8px;
`;

const PoolPriceBar = ({ currencies, noLiquidity, poolTokenPercentage, price, parsedAmounts }) => {
    var _a, _b;
    const { t } = useTranslation();
    const currency0InputValue = (_a = parsedAmounts[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.toSignificant(6);
    const chainId = useChainId();
    const currency0 = currencies[Field$1.CURRENCY_A];
    const useUSDCPrice = useUSDCPriceHook[chainId];
    const currency0PriceTmp = useUSDCPrice(currency0);
    const currency0Price = ((_b = CHAINS[chainId]) === null || _b === void 0 ? void 0 : _b.mainnet) ? currency0PriceTmp : undefined;
    const multipyAmount = currency0Price ? Number(currency0Price.toFixed()) * 2 * Number(currency0InputValue) : 0;
    const sharePoolStat = multipyAmount ? `$${multipyAmount === null || multipyAmount === void 0 ? void 0 : multipyAmount.toFixed(4)}` : '-';
    function getShareOfPool() {
        var _a;
        if (noLiquidity && price) {
            return '100%';
        }
        else if (poolTokenPercentage === null || poolTokenPercentage === void 0 ? void 0 : poolTokenPercentage.lessThan(ONE_BIPS)) {
            return '<0.01%';
        }
        else {
            return `${(_a = poolTokenPercentage === null || poolTokenPercentage === void 0 ? void 0 : poolTokenPercentage.toFixed(2)) !== null && _a !== void 0 ? _a : 0}%`;
        }
    }
    return (jsx(Root$c, { children: jsxs(GridContainer, { children: [jsx(Box, { children: jsx(Stat, { title: `${t('migratePage.usd')}`, stat: sharePoolStat, titlePosition: "top", titleFontSize: 12, statFontSize: 14, titleColor: "text2" }) }), jsx(Box, { children: jsx(Stat, { title: `${t('addLiquidity.shareOfPool')}`, stat: getShareOfPool(), titlePosition: "top", titleFontSize: 12, statFontSize: 14, titleColor: "text2" }) })] }) }));
};

const AddWrapper = styled(Box)`
  width: 100%;
  padding-right: 20px;
  padding-left: 20px;
  padding-bottom: 20px;
  height: 100%;
  display: flex;
  flex-direction: column;
`;
const StyledBalanceMax = styled.button`
  height: 28px;
  background-color: ${({ theme }) => theme.bg2};
  border: 1px solid ${({ theme }) => theme.bg2};
  border-radius: 0.5rem;
  font-size: 0.875rem;

  font-weight: 500;
  cursor: pointer;
  margin-right: 0.5rem;
  color: ${({ theme }) => theme.text2};

  ${({ theme }) => theme.mediaWidth.upToExtraSmall`
    margin-right: 0.5rem;
  `};
`;
const ArrowWrapper$2 = styled.div`
  background-color: ${({ theme }) => theme.bg6};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;
const LightCard$1 = styled(Box)`
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
`;
const InputWrapper$2 = styled(Box)`
  display: grid;
  grid-auto-flow: ${({ type }) => (type === SpaceType.detail ? 'row' : 'column')};
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 5px;
`;
const Buttons$a = styled(Box)`
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 10px;
  margin-top: 10px;
`;
const ButtonWrapper$1 = styled(Box)`
  justify-content: space-between;
  width: 100%;
  display: flex;
  padding: 0;
  align-items: center;
`;

const AddLiquidity = ({ currencyA, currencyB, onComplete, onAddToFarm, type }) => {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const theme = useContext(ThemeContext);
    const { t } = useTranslation();
    const expertMode = useIsExpertMode();
    // mint state
    const { independentField, typedValue, otherTypedValue } = useMintState();
    const { dependentField, currencies,
        // pair,
        pairState, currencyBalances, parsedAmounts, price, noLiquidity, liquidityMinted, poolTokenPercentage, error, } = useDerivedMintInfo(currencyA !== null && currencyA !== void 0 ? currencyA : undefined, currencyB !== null && currencyB !== void 0 ? currencyB : undefined);
    const { onFieldAInput, onFieldBInput } = useMintActionHandlers(noLiquidity);
    const addLiquidity = useAddLiquidityHook[chainId]();
    const useApproveCallback = useApproveCallbackHook[chainId];
    const isValid = !error;
    // modal and loading
    const [showConfirm, setShowConfirm] = useState(false);
    const [attemptingTxn, setAttemptingTxn] = useState(false); // clicked confirm
    // txn values
    const deadline = useTransactionDeadline(); // custom from users settings
    const [allowedSlippage] = useUserSlippageTolerance(); // custom from users
    const [txHash, setTxHash] = useState('');
    // get formatted amounts
    const formattedAmounts = {
        [independentField]: typedValue,
        [dependentField]: noLiquidity ? otherTypedValue : (_b = (_a = parsedAmounts[dependentField]) === null || _a === void 0 ? void 0 : _a.toSignificant(6)) !== null && _b !== void 0 ? _b : '',
    };
    // get the max amounts user can add
    const maxAmounts = [Field$1.CURRENCY_A, Field$1.CURRENCY_B].reduce((accumulator, field) => {
        return Object.assign(Object.assign({}, accumulator), { [field]: maxAmountSpend(chainId, currencyBalances[field]) });
    }, {});
    const atMaxAmounts = [Field$1.CURRENCY_A, Field$1.CURRENCY_B].reduce((accumulator, field) => {
        var _a, _b;
        return Object.assign(Object.assign({}, accumulator), { [field]: (_a = maxAmounts[field]) === null || _a === void 0 ? void 0 : _a.equalTo((_b = parsedAmounts[field]) !== null && _b !== void 0 ? _b : '0') });
    }, {});
    // check whether the user has approved the router on the tokens
    const [approvalA, approveACallback] = useApproveCallback(chainId, parsedAmounts[Field$1.CURRENCY_A], ROUTER_ADDRESS[chainId]);
    const [approvalB, approveBCallback] = useApproveCallback(chainId, parsedAmounts[Field$1.CURRENCY_B], ROUTER_ADDRESS[chainId]);
    function onAdd() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chainId || !library || !account)
                return;
            try {
                setAttemptingTxn(true);
                const addData = {
                    parsedAmounts,
                    deadline,
                    noLiquidity,
                    allowedSlippage,
                    currencies,
                };
                const response = yield addLiquidity(addData);
                setTxHash(response === null || response === void 0 ? void 0 : response.hash);
            }
            catch (err) {
                const _err = err;
                console.error(_err);
            }
            finally {
                setAttemptingTxn(false);
            }
        });
    }
    const handleDismissConfirmation = useCallback(() => {
        setShowConfirm(false);
        // if there was a tx hash, we want to clear the input
        if (txHash) {
            onFieldAInput('');
        }
        setTxHash('');
        setAttemptingTxn(false);
    }, [onFieldAInput, txHash]);
    const handleTypeInput = useCallback((value) => {
        onFieldAInput(value);
    }, [onFieldAInput]);
    const handleTypeOutput = useCallback((value) => {
        onFieldBInput(value);
    }, [onFieldBInput]);
    // toggle wallet when disconnected
    const toggleWalletModal = useWalletModalToggle();
    const selectedCurrencyBalanceA = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, currencyA !== null && currencyA !== void 0 ? currencyA : undefined);
    const selectedCurrencyBalanceB = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, currencyB !== null && currencyB !== void 0 ? currencyB : undefined);
    const renderButton = () => {
        var _a, _b, _c, _d;
        if (!account) {
            return (jsx(Button, Object.assign({ variant: "primary", onClick: toggleWalletModal, height: "46px" }, { children: t('swapPage.connectWallet') })));
        }
        else {
            return (jsxs(Buttons$a, {
                children: [(approvalA === ApprovalState.NOT_APPROVED ||
                    approvalA === ApprovalState.PENDING ||
                    approvalB === ApprovalState.NOT_APPROVED ||
                    approvalB === ApprovalState.PENDING) &&
                    isValid && (jsxs(ButtonWrapper$1, { children: [approvalA !== ApprovalState.APPROVED && (jsx(Button, Object.assign({ variant: "primary", onClick: approveACallback, isDisabled: approvalA === ApprovalState.PENDING, width: approvalB !== ApprovalState.APPROVED ? '48%' : '100%', loading: approvalA === ApprovalState.PENDING, loadingText: `${t('swapPage.approving')} ${(_a = currencies[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.symbol}`, height: "46px" }, { children: t('addLiquidity.approve') + ((_b = currencies[Field$1.CURRENCY_A]) === null || _b === void 0 ? void 0 : _b.symbol) }))), approvalB !== ApprovalState.APPROVED && (jsx(Button, Object.assign({ variant: "primary", onClick: approveBCallback, isDisabled: approvalB === ApprovalState.PENDING, width: approvalA !== ApprovalState.APPROVED ? '48%' : '100%', loading: approvalB === ApprovalState.PENDING, loadingText: `${t('swapPage.approving')} ${(_c = currencies[Field$1.CURRENCY_B]) === null || _c === void 0 ? void 0 : _c.symbol}`, height: "46px" }, { children: t('addLiquidity.approve') + ((_d = currencies[Field$1.CURRENCY_B]) === null || _d === void 0 ? void 0 : _d.symbol) })))] })), jsx(Button, Object.assign({
                        height: "46px", variant: "primary", onClick: () => {
                            expertMode ? onAdd() : setShowConfirm(true);
                        }, isDisabled: !isValid || approvalA !== ApprovalState.APPROVED || approvalB !== ApprovalState.APPROVED
                    }, { children: error !== null && error !== void 0 ? error : t('addLiquidity.supply') }))]
            }));
        }
    };
    return (jsxs(AddWrapper, {
        children: [jsxs(Box, Object.assign({ flex: 1 }, {
            children: [jsxs(InputWrapper$2, Object.assign({ type: type }, {
                children: [jsx(TextInput, {
                    value: formattedAmounts[Field$1.CURRENCY_A], addonAfter: !atMaxAmounts[Field$1.CURRENCY_A] ? (jsx(Box, Object.assign({ display: 'flex', alignItems: 'center', height: '100%', justifyContent: 'center' }, { children: jsx(StyledBalanceMax, Object.assign({ onClick: () => { var _a, _b; return onFieldAInput((_b = (_a = maxAmounts[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.toExact()) !== null && _b !== void 0 ? _b : ''); } }, { children: t('currencyInputPanel.max') })) }))) : (''), onChange: (value) => {
                        handleTypeInput(value);
                    }, label: `${currencyA === null || currencyA === void 0 ? void 0 : currencyA.symbol}`, fontSize: 16, isNumeric: true, placeholder: "0.00", addonLabel: account && (jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 12 }, { children: !!currencyA && selectedCurrencyBalanceA ? selectedCurrencyBalanceA === null || selectedCurrencyBalanceA === void 0 ? void 0 : selectedCurrencyBalanceA.toSignificant(4) : ' -' })))
                }), jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: type === 'card' ? 'none' : 'flex', justifyContent: 'center', mt: 10 }, { children: jsx(ArrowWrapper$2, { children: jsx(Plus, { size: "16", color: theme.text1 }) }) })), jsx(TextInput, {
                    value: formattedAmounts[Field$1.CURRENCY_B], addonAfter: !atMaxAmounts[Field$1.CURRENCY_B] ? (jsx(Box, Object.assign({ display: 'flex', alignItems: 'center', height: '100%', justifyContent: 'center' }, { children: jsx(StyledBalanceMax, Object.assign({ onClick: () => { var _a, _b; return onFieldBInput((_b = (_a = maxAmounts[Field$1.CURRENCY_B]) === null || _a === void 0 ? void 0 : _a.toExact()) !== null && _b !== void 0 ? _b : ''); } }, { children: t('currencyInputPanel.max') })) }))) : (''), onChange: (value) => {
                        handleTypeOutput(value);
                    }, label: `${currencyB === null || currencyB === void 0 ? void 0 : currencyB.symbol}`, fontSize: 16, isNumeric: true, placeholder: "0.00", addonLabel: account && (jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 12 }, { children: !!currencyB && selectedCurrencyBalanceB ? selectedCurrencyBalanceB === null || selectedCurrencyBalanceB === void 0 ? void 0 : selectedCurrencyBalanceB.toSignificant(4) : ' -' })))
                })]
            })), currencies[Field$1.CURRENCY_A] && currencies[Field$1.CURRENCY_B] && pairState !== PairState.INVALID && (jsx(LightCard$1, Object.assign({ padding: "0px" }, { children: jsx(PoolPriceBar, { currencies: currencies, poolTokenPercentage: poolTokenPercentage, noLiquidity: noLiquidity, price: price, parsedAmounts: parsedAmounts }) })))]
        })), jsx(Box, Object.assign({ width: "100%" }, { children: renderButton() })), showConfirm && (jsx(ConfirmSwapDrawer, { isOpen: showConfirm, allowedSlippage: allowedSlippage, poolErrorMessage: error, price: price, currencies: currencies, parsedAmounts: parsedAmounts, noLiquidity: noLiquidity, liquidityMinted: liquidityMinted, onAdd: onAdd, poolTokenPercentage: poolTokenPercentage, attemptingTxn: attemptingTxn, txHash: txHash, onClose: handleDismissConfirmation, onComplete: onComplete, onAddToFarm: onAddToFarm, type: type }))]
    }));
};

const AddLiquidityDrawer = ({ isOpen, onClose, onAddToFarm, clickedLpTokens, backgroundColor }) => {
    const { t } = useTranslation();
    const chainId = useChainId();
    const token0 = clickedLpTokens === null || clickedLpTokens === void 0 ? void 0 : clickedLpTokens[0];
    const token1 = clickedLpTokens === null || clickedLpTokens === void 0 ? void 0 : clickedLpTokens[1];
    const currencyA = token0 && unwrappedToken(token0, chainId);
    const currencyB = token1 && unwrappedToken(token1, chainId);
    return (jsx(Drawer, Object.assign({ title: t('pool.addLiquidity'), isOpen: isOpen, onClose: onClose, backgroundColor: backgroundColor }, { children: isOpen && (jsx(AddLiquidity, { currencyA: currencyA, currencyB: currencyB, onComplete: onClose, onAddToFarm: onAddToFarm, type: SpaceType.card })) })));
};

const ClaimWrapper$1 = styled(Box)`
  width: 100%;
  height: 100%;
`;
const Root$b = styled(Box)`
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 0px 10px;
`;
const RewardWrapper$1 = styled(Box)`
  display: grid;
  grid-template-columns: ${({ isSuperFarm }) => isSuperFarm ? 'minmax(auto, 50%) minmax(auto, 50%)' : 'minmax(auto, 100%)'};
  grid-gap: 8px;
  justify-content: center;
`;
const StatWrapper$3 = styled(Box)`
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
`;

const ClaimReward = ({ stakingInfo, version, onClose }) => {
    var _a;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = useTranslation();
    // monitor call to help UI loading state
    const addTransaction = useTransactionAdder();
    const [hash, setHash] = useState();
    const [attempting, setAttempting] = useState(false);
    const poolMap = useMinichefPools();
    const stakingContract = useStakingContract(stakingInfo.stakingRewardAddress);
    const { rewardTokensAmount } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_a = (rewardTokensAmount || [])) === null || _a === void 0 ? void 0 : _a.length) > 0;
    function wrappedOnDismiss() {
        setHash(undefined);
        setAttempting(false);
        onClose();
    }
    const png = PNG[chainId];
    function onClaimReward() {
        return __awaiter(this, void 0, void 0, function* () {
            if (stakingContract && poolMap && (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
                setAttempting(true);
                const method = version < 2 ? 'getReward' : 'harvest';
                const args = version < 2 ? [] : [poolMap[stakingInfo.stakedAmount.token.address], account];
                try {
                    const response = yield stakingContract[method](...args);
                    yield waitForTransaction(response, 1);
                    addTransaction(response, {
                        summary: t('earn.claimAccumulated', { symbol: png.symbol }),
                    });
                    setHash(response.hash);
                }
                catch (error) {
                    setAttempting(false);
                    const err = error;
                    // we only care if the error is something _other_ than the user rejected the tx
                    if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                        console.error(err);
                    }
                }
            }
        });
    }
    let _error;
    if (!account) {
        _error = t('earn.connectWallet');
    }
    if (!(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
        _error = _error !== null && _error !== void 0 ? _error : t('earn.enterAmount');
    }
    const { earnedAmount } = useGetEarnedAmount(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const newEarnedAmount = version < 2 ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount : earnedAmount;
    return (jsxs(ClaimWrapper$1, {
        children: [!attempting && !hash && (jsxs(Root$b, {
            children: [jsxs(Box, Object.assign({ flex: "1", display: "flex", flexDirection: "column", justifyContent: "center" }, {
                children: [jsxs(RewardWrapper$1, Object.assign({ isSuperFarm: isSuperFarm }, {
                    children: [jsx(StatWrapper$3, { children: jsx(Stat, { title: t('earn.unclaimedReward', { symbol: 'PNG' }), stat: newEarnedAmount === null || newEarnedAmount === void 0 ? void 0 : newEarnedAmount.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [24, 18], titleColor: "text1", statAlign: "center" }) }), isSuperFarm &&
                        (rewardTokensAmount === null || rewardTokensAmount === void 0 ? void 0 : rewardTokensAmount.map((rewardAmount, i) => {
                            var _a;
                            return (jsx(StatWrapper$3, { children: jsx(Stat, { title: t('earn.unclaimedReward', { symbol: (_a = rewardAmount === null || rewardAmount === void 0 ? void 0 : rewardAmount.token) === null || _a === void 0 ? void 0 : _a.symbol }), stat: rewardAmount === null || rewardAmount === void 0 ? void 0 : rewardAmount.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [24, 18], titleColor: "text1", statAlign: "center" }) }, i));
                        }))]
                })), jsx(Text, Object.assign({ fontSize: "13px", color: "text2", textAlign: "center" }, { children: t('earn.liquidityRemainsPool') }))]
            })), jsx(Box, Object.assign({ my: '10px' }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: onClaimReward }, { children: _error !== null && _error !== void 0 ? _error : t('earn.claimReward', { symbol: 'PNG' }) })) }))]
        })), attempting && !hash && jsx(Loader, { size: 100, label: " Claiming..." }), hash && jsx(TransactionCompleted, { onClose: wrappedOnDismiss, submitText: "Your rewards claimed" })]
    }));
};

const ClaimDrawer = ({ isOpen, onClose, stakingInfo, version, backgroundColor }) => {
    const { t } = useTranslation();
    return (jsx(Drawer, Object.assign({ title: t('earn.claim'), isOpen: isOpen, onClose: onClose, backgroundColor: backgroundColor }, { children: isOpen && jsx(ClaimReward, { stakingInfo: stakingInfo, onClose: onClose, version: version }) })));
};

var CircleTick = "data:image/svg+xml,%3Csvg%20width%3D%2275%22%20height%3D%2275%22%20viewBox%3D%220%200%20100%20101%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M41.9568%200.970354L41.9588%200.970004C52.2154%20-0.813656%2062.7724%200.737028%2072.0869%205.39547L72.0869%205.39554L72.0925%205.39821C72.7816%205.72146%2073.3747%206.21899%2073.8136%206.84186C74.125%207.33236%2074.2295%207.83111%2074.1662%208.31425C74.1022%208.80202%2073.8646%209.29173%2073.4626%209.7513C72.6978%2010.6255%2071.5412%2010.803%2070.2097%2010.2817L70.2095%2010.2817C69.3975%209.96428%2068.5851%209.62326%2067.769%209.28072C65.6499%208.39127%2063.5064%207.49151%2061.2818%206.96855C44.0184%202.90944%2029.1105%207.36731%2017.1063%2020.4078L17.1062%2020.4079C8.38435%2029.8929%204.82205%2041.4128%205.9675%2054.2342C7.64211%2073.1615%2021.4792%2088.9118%2040.097%2093.3534C64.8784%2099.2631%2089.8666%2082.5598%2093.9783%2057.3453C94.9766%2051.3574%2094.7476%2045.2284%2093.3051%2039.3321L93.3045%2039.3294C93.1365%2038.6746%2093.0599%2038.07%2093.153%2037.5233C93.2446%2036.9858%2093.5027%2036.4895%2094.0352%2036.0476C95.5993%2034.763%2097.8887%2035.5655%2098.246%2037.7395L98.2461%2037.7397C98.3493%2038.3651%2098.456%2038.9907%2098.5627%2039.6164C99.1502%2043.0615%2099.7381%2046.5094%2099.7497%2049.9435C99.8316%2072.6235%2084.6475%2092.2578%2062.7597%2098.1047C35.7798%20105.313%207.77252%2088.253%201.78549%2060.8669L1.78544%2060.8667C1.25591%2058.454%200.968037%2055.9972%200.678568%2053.5268C0.54421%2052.3802%200.409509%2051.2306%200.250142%2050.0812C0.453584%2025.876%2018.1556%204.90887%2041.9568%200.970354Z%22%20fill%3D%22%2318C145%22%20stroke%3D%22%23111111%22%20stroke-width%3D%220.5%22%2F%3E%3Cpath%20d%3D%22M48.6453%2055.5479L48.8719%2055.7756L49.037%2055.5C49.322%2055.024%2049.6427%2054.5704%2049.9963%2054.1432C64.3053%2039.7934%2078.6189%2025.4506%2092.9372%2011.1146L92.9373%2011.1147L92.9431%2011.1085C93.3154%2010.7094%2093.7133%2010.3351%2094.1344%209.98814C94.6193%209.61736%2095.2199%209.43142%2095.829%209.46352C96.4394%209.49569%2097.0186%209.7448%2097.4625%2010.1663L97.4647%2010.1684C97.9139%2010.5846%2098.1979%2011.1497%2098.2639%2011.7595C98.3299%2012.368%2098.1744%2012.9798%2097.8262%2013.4824C97.5281%2013.8837%2097.1943%2014.257%2096.829%2014.5978L96.8289%2014.5977L96.8225%2014.6041C81.6114%2029.8625%2066.3877%2045.1197%2051.1514%2060.3758L51.1512%2060.376C50.1611%2061.37%2049.3807%2061.8116%2048.6452%2061.8157C47.9106%2061.8199%2047.1363%2061.3881%2046.1572%2060.4068L46.157%2060.4066C45.5237%2059.7734%2044.8902%2059.1404%2044.2569%2058.5076C40.4579%2054.7116%2036.6612%2050.9179%2032.9023%2047.0711C32.6049%2046.7648%2032.3119%2046.3563%2032.0995%2045.9284C31.885%2045.4964%2031.7644%2045.0688%2031.782%2044.7195C31.7994%2044.3732%2031.9665%2043.97%2032.2283%2043.5735C32.4877%2043.1808%2032.8247%2042.8178%2033.1487%2042.5548L33.1491%2042.5545C33.8727%2041.9649%2034.856%2042.0816%2035.7268%2042.7C36.1245%2043.0003%2036.4952%2043.3351%2036.8344%2043.7005L36.8343%2043.7006L36.8409%2043.7072C40.517%2047.3815%2044.1836%2051.0653%2048.1543%2055.0546L48.6453%2055.5479Z%22%20fill%3D%22%2318C145%22%20stroke%3D%22%23111111%22%20stroke-width%3D%220.5%22%2F%3E%3C%2Fsvg%3E";

const StakeWrapper$1 = styled(Box)`
  width: 100%;
  padding: 0px 10px 10px 10px;
  height: 100%;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;
styled(TextInput)`
  background-color: ${({ theme }) => theme.color10};
  padding: 15px;
  align-items: center;
  border-radius: 4px;
`;
const ContentBox$1 = styled(Box)`
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.color10};
  margin-top: 10px;
  padding: 10px;
`;
const DataBox$1 = styled(Box)`
  align-items: center;
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const ExtraRewardDataBox$1 = styled(Box)`
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const PoolSelectWrapper$1 = styled(Box)`
  width: 100%;
  border-radius: 8px;
  padding: 10px;
  border: 1px solid transparent;
  display: flex;
  position: relative;
  box-sizing: border-box;
  justify-content: space-between;
  align-items: center;
  background-color: ${({ theme }) => theme.color10};
  color: ${({ theme }) => theme.text4};
  cursor: pointer;
`;
const InputWrapper$1 = styled(Box)`
  display: grid;
  grid-auto-flow: ${({ type }) => (type === SpaceType.detail ? 'row' : 'column')};
  grid-auto-columns: minmax(0, 1fr);
  margin-top: ${({ type }) => (type === SpaceType.detail ? '10px' : '0px')};
  grid-gap: 5px;
  align-items: ${({ type }) => (type === SpaceType.detail ? 'normal' : 'center')};
`;
const Buttons$9 = styled(Box)`
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 10px;
  margin-top: 10px;
`;
const CardContentBox$1 = styled(Box)`
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.color10};
  margin-top: 10px;
  padding: 10px;
  display: grid;
  grid-template-columns: ${({ isSuperFarm }) => isSuperFarm ? 'minmax(auto, 50%) minmax(auto, 50%)' : 'minmax(auto, 33%) minmax(auto, 33%) minmax(auto, 33%)'};
  grid-gap: 10px;
`;
const ErrorWrapper$3 = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ErrorBox$3 = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const SubmittedWrapper$1 = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ContentWrapper = styled(Box)`
  display: grid;
  grid-gap: 20px;
  padding: 20px;
  height: 100%;
`;
const Link$1 = styled(Text)`
  text-decoration: none;
  color: ${({ theme }) => theme.blue1};
`;

const ConfirmDrawer$1 = (props) => {
    const { isOpen, attemptingTxn, errorMessage, txHash, tokens, amount, dollarValue, apr, type, onClose, onStake } = props;
    const { chainId } = usePangolinWeb3();
    const theme = useContext(ThemeContext);
    const { t } = useTranslation();
    const PendingContent = jsx(Loader, { size: 100 });
    const token0 = tokens[0];
    const token1 = tokens[1];
    const ErroContent = (jsxs(ErrorWrapper$3, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxs(ErrorBox$3, { children: [jsx(AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'red1', textAlign: "center", style: { width: '85%' } }, { children: errorMessage }))] }), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] })));
    const SubmittedContent = (jsxs(SubmittedWrapper$1, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", paddingY: '20px' }, { children: [jsx(Box, Object.assign({ flex: "1", display: "flex", alignItems: "center" }, { children: jsx("img", { src: CircleTick, alt: "circle-tick" }) })), jsx(Text, Object.assign({ fontSize: 16, color: "text1", textAlign: "center" }, { children: "You have successfully staked your liq. Your stakes apr will start from 0 and the longer you stay in the pool your share of the rewards will keep increasing." })), chainId && txHash && (jsx(Link$1, Object.assign({ as: "a", fontWeight: 500, fontSize: 14, color: 'primary', href: getEtherscanLink(chainId, txHash, 'transaction'), target: "_blank" }, { children: t('transactionConfirmation.viewExplorer') })))] })), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.close') }))] })));
    const confirmContent = (jsxs(ContentWrapper, { children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", width: "100%" }, { children: [jsxs(Text, Object.assign({ fontSize: '28px', fontWeight: 500, color: "text1" }, { children: [amount === null || amount === void 0 ? void 0 : amount.toFixed(8), " ARL"] })), jsx(DoubleCurrencyLogo, { size: 24, currency0: token0, currency1: token1 })] })), jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", width: "100%" }, { children: [jsx(Stat, { title: "USD Deposited", stat: dollarValue, titlePosition: "top", titleFontSize: 16, statFontSize: [28, 20] }), jsx(Stat, { title: "Average APR", stat: apr, titlePosition: "top", titleFontSize: 16, statFontSize: [28, 20] })] })), jsx(Box, Object.assign({ padding: "20px", bgColor: "color3", borderRadius: "8px" }, { children: jsxs(Text, Object.assign({ color: "text1", textAlign: "center" }, { children: ["You are now adding liquidity into ", token0 === null || token0 === void 0 ? void 0 : token0.symbol, "-", token1 === null || token1 === void 0 ? void 0 : token1.symbol, " Farm. Longer you stake in the pool better share of the rewards you\u2019ll get."] })) })), jsx(Box, Object.assign({ alignSelf: "flex-end" }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: onStake }, { children: "Stake" })) }))] }));
    const renderBody = () => {
        if (errorMessage) {
            return ErroContent;
        }
        if (txHash) {
            return SubmittedContent;
        }
        if (attemptingTxn) {
            return PendingContent;
        }
        return confirmContent;
    };
    return (jsx(Drawer, Object.assign({ isOpen: isOpen, onClose: onClose, title: !errorMessage && !txHash && !attemptingTxn ? 'Summary' : undefined, backgroundColor: type === SpaceType.card ? 'color5' : undefined }, { children: renderBody() })));
};

const Stake$1 = ({ onComplete, type, stakingInfo, combinedApr }) => {
    var _a, _b, _c, _d, _e;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const [, stakingTokenPair] = usePair(token0, token1);
    const userLiquidityUnstaked = useTokenBalance(account !== null && account !== void 0 ? account : undefined, stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.liquidityToken);
    const { liquidityInUSD } = useGetPoolDollerWorth(stakingTokenPair);
    // track and parse user input
    const [typedValue, setTypedValue] = useState((userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact()) || '');
    const { parsedAmount, error } = useDerivedStakeInfo(typedValue, (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.token, userLiquidityUnstaked);
    const parsedAmountWrapped = wrappedCurrencyAmount(parsedAmount, chainId);
    let hypotheticalWeeklyRewardRate = new TokenAmount((_b = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek) === null || _b === void 0 ? void 0 : _b.token, '0');
    if (parsedAmountWrapped === null || parsedAmountWrapped === void 0 ? void 0 : parsedAmountWrapped.greaterThan('0')) {
        hypotheticalWeeklyRewardRate = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getHypotheticalWeeklyRewardRate(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount.add(parsedAmountWrapped), stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount.add(parsedAmountWrapped), stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalRewardRatePerSecond);
    }
    const { rewardTokensAmount, rewardTokensMultiplier } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_c = (rewardTokensAmount || [])) === null || _c === void 0 ? void 0 : _c.length) > 0;
    // state for pending and submitted txn views
    const addTransaction = useTransactionAdder();
    const [attempting, setAttempting] = useState(false);
    const [hash, setHash] = useState();
    const [stakeError, setStakeError] = useState();
    const [openDrawer, setOpenDrawer] = useState(false);
    // pair contract for this token to be staked
    const dummyPair = new Pair(new TokenAmount(stakingInfo.tokens[0], '0'), new TokenAmount(stakingInfo.tokens[1], '0'), chainId);
    const pairContract = usePairContract(dummyPair.liquidityToken.address);
    // approval data for stake
    const deadline = useTransactionDeadline();
    const { t } = useTranslation();
    const [stepIndex, setStepIndex] = useState(4);
    const [approval, approveCallback] = useApproveCallback(chainId, parsedAmount, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakingRewardAddress);
    const pangochefContract = usePangoChefContract();
    const currency0 = unwrappedToken(stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.token0, chainId);
    const currency1 = unwrappedToken(stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.token1, chainId);
    const onChangePercentage = (value) => {
        if (!userLiquidityUnstaked) {
            setTypedValue('0');
            return;
        }
        if (value === 100) {
            setTypedValue(userLiquidityUnstaked.toExact());
        }
        else {
            const newAmount = userLiquidityUnstaked
                .multiply(JSBI$1.BigInt(value))
                .divide(JSBI$1.BigInt(100));
            setTypedValue(newAmount.toFixed(18));
        }
    };
    function onStake() {
        return __awaiter(this, void 0, void 0, function* () {
            if (pangochefContract && parsedAmount && deadline) {
                setAttempting(true);
                if (approval === ApprovalState.APPROVED) {
                    try {
                        const response = yield pangochefContract.stake(stakingInfo.pid, parsedAmount.raw.toString());
                        yield waitForTransaction(response, 5);
                        addTransaction(response, {
                            summary: t('earn.depositLiquidity'),
                        });
                        setHash(response.hash);
                    }
                    catch (err) {
                        const _err = err;
                        // we only care if the error is something _other_ than the user rejected the tx
                        if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                            setStakeError(_err === null || _err === void 0 ? void 0 : _err.message);
                            console.error(_err);
                        }
                    }
                    finally {
                        setAttempting(false);
                    }
                }
                else {
                    setAttempting(false);
                    throw new Error(t('earn.attemptingToStakeError'));
                }
            }
        });
    }
    // wrapped onUserInput to clear signatures
    const onUserInput = useCallback((_typedValue) => {
        setTypedValue(_typedValue);
        const percentage = Math.ceil(Number(userLiquidityUnstaked && _typedValue
            ? JSBI$1.divide(JSBI$1.multiply(JSBI$1.BigInt(parseUnits$1(_typedValue, userLiquidityUnstaked.currency.decimals)), JSBI$1.BigInt(100)), userLiquidityUnstaked.raw).toString()
            : 0));
        setStepIndex(percentage > 100 ? 4 : Math.round(percentage / 25));
    }, []);
    function onAttemptToApprove() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!pairContract)
                throw new Error(t('earn.missingDependencies'));
            const liquidityAmount = parsedAmount;
            if (!liquidityAmount)
                throw new Error(t('earn.missingLiquidityAmount'));
            approveCallback();
        });
    }
    const renderPoolDataRow = (label, value) => {
        return (jsxs(DataBox$1, { children: [jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: label })), jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: value }))] }, label));
    };
    const handleDismissConfirmation = useCallback(() => {
        // if there was a tx hash, we want to clear the input
        if (hash) {
            setTypedValue('');
            setStepIndex(0);
        }
        setHash('');
        setStakeError(undefined);
        setAttempting(false);
        setOpenDrawer(false);
        onComplete && onComplete();
    }, [setTypedValue, hash, onComplete]);
    useEffect(() => {
        if (userLiquidityUnstaked) {
            setTypedValue(userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact());
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact()]);
    useEffect(() => {
        if (openDrawer && !attempting && !hash && !stakeError) {
            handleDismissConfirmation();
        }
        if (!openDrawer && attempting) {
            setOpenDrawer(true);
        }
    }, [attempting, hash, stakeError]);
    const onConfirm = () => {
        setOpenDrawer(true);
    };
    // userLiquidityUnstaked?.toExact() -> liquidityInUSD
    // typedValue -> ?
    const finalUsd = (userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.greaterThan('0'))
        ? (Number(typedValue) * liquidityInUSD) / Number(userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact())
        : undefined;
    const getApr = () => {
        if (combinedApr) {
            return `${combinedApr}%`;
        }
        else if (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr) {
            return `${stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr}%`;
        }
        else {
            return '-';
        }
    };
    const dollerWarth = finalUsd ? `$${Number(finalUsd).toFixed(2)}` : '-';
    const png = PNG[chainId];
    const balanceLabel = !!((_d = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _d === void 0 ? void 0 : _d.token) && userLiquidityUnstaked
        ? t('currencyInputPanel.balance') + (userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toSignificant(6))
        : '-';
    return (jsxs(StakeWrapper$1, {
        children: [!attempting && !hash && (jsxs(Fragment, {
            children: [jsxs(Box, Object.assign({ flex: 1 }, {
                children: [type === SpaceType.detail && (jsx(PoolSelectWrapper$1, { children: jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsx(DoubleCurrencyLogo, { size: 24, currency0: currency0, currency1: currency1 }), jsxs(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] }))] })) })), jsxs(InputWrapper$1, Object.assign({ type: type }, {
                    children: [jsx(TextInput, {
                        value: typedValue, addonAfter: jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsx(Text, Object.assign({ color: "text4", fontSize: [24, 18] }, { children: "ARL" })) })), onChange: (value) => {
                            onUserInput(value);
                        }, fontSize: 24, isNumeric: true, placeholder: "0.00", addonLabel: account &&
                            type === SpaceType.detail && (jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 14 }, { children: balanceLabel }))), label: type === SpaceType.card ? balanceLabel : undefined
                    }), jsx(Box, Object.assign({ mt: type === 'card' ? '25px' : '0px' }, {
                        children: jsx(NumberOptions, {
                            onChange: (value) => {
                                setStepIndex(type === 'card' ? value / 25 : value);
                                onChangePercentage(type === 'card' ? value : value * 25);
                            }, currentValue: type === 'card' ? stepIndex * 25 : stepIndex, variant: type === 'card' ? 'box' : 'step', isPercentage: true, isDisabled: (_e = userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.equalTo('0')) !== null && _e !== void 0 ? _e : true
                        })
                    }))]
                })), type === 'card' && (jsxs(CardContentBox$1, Object.assign({ isSuperFarm: isSuperFarm }, { children: [jsx(Stat, { title: t('migratePage.dollarWorth'), stat: dollerWarth, titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" }), !isSuperFarm && (jsx(Stat, { title: t('dashboardPage.earned_weeklyIncome'), stat: `${hypotheticalWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })} ${png.symbol}`, titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" })), jsx(Stat, { title: `APR`, stat: getApr(), titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" })] }))), type === SpaceType.detail && (jsx(Box, {
                    children: jsxs(ContentBox$1, {
                        children: [renderPoolDataRow(t('migratePage.dollarWorth'), `${dollerWarth}`), renderPoolDataRow(`${t('dashboardPage.earned_weeklyIncome')}`, `${hypotheticalWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })} PNG`), isSuperFarm && (jsxs(ExtraRewardDataBox$1, {
                            children: [jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: t('earn.extraReward') })), jsx(Box, Object.assign({ textAlign: "right" }, {
                                children: rewardTokensAmount === null || rewardTokensAmount === void 0 ? void 0 : rewardTokensAmount.map((reward, index) => {
                                    var _a, _b;
                                    const tokenMultiplier = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier[index];
                                    const extraTokenWeeklyRewardRate = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getExtraTokensWeeklyRewardRate) === null || _a === void 0 ? void 0 : _a.call(stakingInfo, hypotheticalWeeklyRewardRate, reward === null || reward === void 0 ? void 0 : reward.token, tokenMultiplier);
                                    if (extraTokenWeeklyRewardRate) {
                                        return (jsxs(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: [extraTokenWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' }), ' ', (_b = reward === null || reward === void 0 ? void 0 : reward.token) === null || _b === void 0 ? void 0 : _b.symbol] }), index));
                                    }
                                    return null;
                                })
                            }))]
                        }, "extra-reward"))]
                    })
                }))]
            })), jsxs(Buttons$9, { children: [jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', onClick: onAttemptToApprove, isDisabled: approval !== ApprovalState.NOT_APPROVED, loading: attempting && !hash, loadingText: t('migratePage.loading') }, { children: t('earn.approve') })), jsx(Button, Object.assign({ variant: "primary", isDisabled: !!error || approval !== ApprovalState.APPROVED, onClick: type === SpaceType.detail ? onConfirm : onStake, loading: attempting && !hash, loadingText: t('migratePage.loading') }, { children: error !== null && error !== void 0 ? error : t('earn.deposit') }))] })]
        })), jsx(ConfirmDrawer$1, { isOpen: openDrawer, onClose: handleDismissConfirmation, attemptingTxn: attempting, errorMessage: stakeError, txHash: hash, type: type, onStake: onStake, tokens: [currency0, currency1], amount: parsedAmount, dollarValue: dollerWarth, apr: '0%' })]
    }));
};

const CurrencyList$1 = styled.div`
  display: flex;
  flex: 1;
  flex-direction: column;
  overflow-y: auto;
`;
const CurrencyRowRoot$1 = styled.div`
  min-height: 56px;
  font-size: 16px;
  cursor: ${({ disabled }) => !disabled && 'pointer'};
  pointer-events: ${({ disabled }) => disabled && 'none'};
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;

  &:hover {
    background-color: ${({ theme, disabled }) => !disabled && theme.bg3};
  }

  opacity: ${({ disabled }) => (disabled ? 0.5 : 1)};
`;
const Balance$1 = styled(Text)`
  justify-self: flex-end;
  white-space: nowrap;
`;

const PoolRow = (props) => {
    const { pair, style, onSelect, isSelected } = props;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const currency0 = unwrappedToken(pair.token0, chainId);
    const currency1 = unwrappedToken(pair.token1, chainId);
    const userPgl = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pair === null || pair === void 0 ? void 0 : pair.liquidityToken);
    const handleSelect = useCallback(() => {
        onSelect(pair);
    }, [onSelect, pair]);
    return (jsxs(CurrencyRowRoot$1, Object.assign({ style: style, onClick: handleSelect, disabled: isSelected }, { children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsx(DoubleCurrencyLogo, { size: 24, currency0: currency0, currency1: currency1 }), jsxs(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] }))] })), jsx(Balance$1, Object.assign({ color: "text1", fontSize: 14 }, { children: userPgl ? userPgl.toSignificant(4) : '-' }))] })));
};

const SelectPoolDrawer = (props) => {
    const { isOpen, onClose, onPoolSelect, selectedPair } = props;
    // fetch the user's balances of all tracked V2 LP tokens
    const { allV2PairsWithLiquidity } = useGetUserLP();
    const onSelect = useCallback((pair) => {
        onPoolSelect(pair);
        onClose();
    }, [onPoolSelect, onClose]);
    const Row = useCallback(({ data, index, style }) => {
        const pair = data === null || data === void 0 ? void 0 : data[index];
        const isSelected = (selectedPair === null || selectedPair === void 0 ? void 0 : selectedPair.liquidityToken) === (pair === null || pair === void 0 ? void 0 : pair.liquidityToken);
        return pair ? jsx(PoolRow, { style: style, pair: pair, isSelected: isSelected, onSelect: onSelect }) : null;
    },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [selectedPair, onPoolSelect, onClose, onSelect]);
    return (jsx(Drawer, Object.assign({ title: "Select a token", isOpen: isOpen, onClose: onClose }, { children: jsx(CurrencyList$1, { children: jsx(AutoSizer, Object.assign({ disableWidth: true }, { children: ({ height }) => (jsx(FixedSizeList, Object.assign({ height: height, width: "100%", itemCount: allV2PairsWithLiquidity.length, itemSize: 56, itemData: allV2PairsWithLiquidity, itemKey: (index) => index }, { children: Row }))) })) }) })));
};

const StakeWrapper = styled(Box)`
  width: 100%;
  padding-left: 20px;
  padding-right: 20px;
  padding-bottom: 20px;
  height: 100%;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;
styled(TextInput)`
  background-color: ${({ theme }) => theme.bg6};
  padding: 15px;
  align-items: center;
  border-radius: 4px;
`;
const ContentBox = styled(Box)`
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
`;
const DataBox = styled(Box)`
  align-items: center;
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const ExtraRewardDataBox = styled(Box)`
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const PoolSelectWrapper = styled(Box)`
  width: 100%;
  border-radius: 8px;
  padding: 10px;
  border: 1px solid transparent;
  display: flex;
  position: relative;
  box-sizing: border-box;
  justify-content: space-between;
  align-items: center;
  background-color: ${({ theme }) => theme.bg6};
  color: ${({ theme }) => theme.text4};
  cursor: pointer;
`;
const InputWrapper = styled(Box)`
  display: grid;
  grid-auto-flow: ${({ type }) => (type === SpaceType.detail ? 'row' : 'column')};
  grid-auto-columns: minmax(0, 1fr);
  margin-top: ${({ type }) => (type === SpaceType.detail ? '10px' : '0px')};
  grid-gap: 5px;
  align-items: ${({ type }) => (type === SpaceType.detail ? 'normal' : 'center')};
`;
const Buttons$8 = styled(Box)`
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 10px;
  margin-top: 10px;
`;
const CardContentBox = styled(Box)`
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
  display: grid;
  grid-template-columns: ${({ isSuperFarm }) => isSuperFarm ? 'minmax(auto, 50%) minmax(auto, 50%)' : 'minmax(auto, 33%) minmax(auto, 33%) minmax(auto, 33%)'};
  grid-gap: 10px;
`;

const Stake = ({ version, onComplete, type, stakingInfo, combinedApr }) => {
    var _a, _b, _c, _d;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const [, stakingTokenPair] = usePair(token0, token1);
    const [selectedPair, setSelectedPair] = useState(stakingTokenPair);
    const userLiquidityUnstaked = useTokenBalance(account !== null && account !== void 0 ? account : undefined, selectedPair === null || selectedPair === void 0 ? void 0 : selectedPair.liquidityToken);
    const { liquidityInUSD } = useGetPoolDollerWorth(selectedPair);
    const [isPoolDrawerOpen, setIsPoolDrawerOpen] = useState(false);
    // track and parse user input
    const [typedValue, setTypedValue] = useState((userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact()) || '');
    const getSignature = useGetTransactionSignature();
    const { parsedAmount, error } = useDerivedStakeInfo(typedValue, (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.token, userLiquidityUnstaked);
    const parsedAmountWrapped = wrappedCurrencyAmount(parsedAmount, chainId);
    let hypotheticalWeeklyRewardRate = new TokenAmount((_b = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek) === null || _b === void 0 ? void 0 : _b.token, '0');
    if (parsedAmountWrapped === null || parsedAmountWrapped === void 0 ? void 0 : parsedAmountWrapped.greaterThan('0')) {
        hypotheticalWeeklyRewardRate = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getHypotheticalWeeklyRewardRate(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount.add(parsedAmountWrapped), stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount.add(parsedAmountWrapped), stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalRewardRatePerSecond);
    }
    const { rewardTokensAmount, rewardTokensMultiplier } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_c = (rewardTokensAmount || [])) === null || _c === void 0 ? void 0 : _c.length) > 0;
    // state for pending and submitted txn views
    const addTransaction = useTransactionAdder();
    const [attempting, setAttempting] = useState(false);
    const [hash, setHash] = useState();
    // pair contract for this token to be staked
    const dummyPair = new Pair(new TokenAmount(stakingInfo.tokens[0], '0'), new TokenAmount(stakingInfo.tokens[1], '0'), chainId);
    const pairContract = usePairContract(dummyPair.liquidityToken.address);
    // approval data for stake
    const deadline = useTransactionDeadline();
    const { t } = useTranslation();
    const [stepIndex, setStepIndex] = useState(4);
    const [signatureData, setSignatureData] = useState(null);
    const [approval, approveCallback] = useApproveCallback(chainId, parsedAmount, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakingRewardAddress);
    const stakingContract = useStakingContract(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakingRewardAddress);
    const currency0 = unwrappedToken(selectedPair === null || selectedPair === void 0 ? void 0 : selectedPair.token0, chainId);
    const currency1 = unwrappedToken(selectedPair === null || selectedPair === void 0 ? void 0 : selectedPair.token1, chainId);
    const poolMap = useMinichefPools();
    const refetchMinichefSubgraph = useRefetchMinichefSubgraph();
    const onChangePercentage = (value) => {
        if (!userLiquidityUnstaked) {
            setTypedValue('0');
            return;
        }
        if (value === 100) {
            setTypedValue(userLiquidityUnstaked.toExact());
        }
        else {
            const newAmount = userLiquidityUnstaked
                .multiply(JSBI$1.BigInt(value))
                .divide(JSBI$1.BigInt(100));
            setTypedValue(newAmount.toSignificant(6));
        }
    };
    function onStake() {
        return __awaiter(this, void 0, void 0, function* () {
            if (stakingContract && poolMap && parsedAmount && deadline) {
                setAttempting(true);
                const method = version < 2 ? 'stake' : 'deposit';
                const args = version < 2
                    ? [`0x${parsedAmount.raw.toString(16)}`]
                    : [poolMap[stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount.token.address], `0x${parsedAmount.raw.toString(16)}`, account];
                if (approval === ApprovalState.APPROVED) {
                    try {
                        const response = yield stakingContract[method](...args);
                        yield waitForTransaction(response, 5);
                        addTransaction(response, {
                            summary: t('earn.depositLiquidity'),
                        });
                        yield refetchMinichefSubgraph();
                        setHash(response.hash);
                    }
                    catch (err) {
                        setAttempting(false);
                        const _err = err;
                        // we only care if the error is something _other_ than the user rejected the tx
                        if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                            console.error(_err);
                        }
                    }
                }
                else if (signatureData) {
                    const permitMethod = version < 2 ? 'stakeWithPermit' : 'depositWithPermit';
                    const permitArgs = version < 2
                        ? [
                            `0x${parsedAmount.raw.toString(16)}`,
                            signatureData.deadline,
                            signatureData.v,
                            signatureData.r,
                            signatureData.s,
                        ]
                        : [
                            poolMap[stakingInfo.stakedAmount.token.address],
                            `0x${parsedAmount.raw.toString(16)}`,
                            account,
                            signatureData.deadline,
                            signatureData.v,
                            signatureData.r,
                            signatureData.s,
                        ];
                    try {
                        const response = yield stakingContract[permitMethod](...permitArgs);
                        yield waitForTransaction(response, 1);
                        addTransaction(response, {
                            summary: t('earn.depositLiquidity'),
                        });
                        setHash(response.hash);
                    }
                    catch (err) {
                        setAttempting(false);
                        const _err = err;
                        // we only care if the error is something _other_ than the user rejected the tx
                        if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                            console.error(_err);
                        }
                    }
                }
                else {
                    setAttempting(false);
                    throw new Error(t('earn.attemptingToStakeError'));
                }
            }
        });
    }
    // wrapped onUserInput to clear signatures
    const onUserInput = useCallback((_typedValue) => {
        setSignatureData(null);
        setTypedValue(_typedValue);
    }, []);
    // used for max input button
    // const maxAmountInput = maxAmountSpend(userLiquidityUnstaked)
    // const atMaxAmount = Boolean(maxAmountInput && parsedAmount?.equalTo(maxAmountInput))
    // const handleMax = useCallback(() => {
    //   maxAmountInput && onUserInput(maxAmountInput.toExact())
    // }, [maxAmountInput, onUserInput])
    function onAttemptToApprove() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!pairContract || !library || !deadline)
                throw new Error(t('earn.missingDependencies'));
            const liquidityAmount = parsedAmount;
            if (!liquidityAmount)
                throw new Error(t('earn.missingLiquidityAmount'));
            // try to gather a signature for permission
            const nonce = yield pairContract.nonces(account);
            const EIP712Domain = [
                { name: 'name', type: 'string' },
                { name: 'version', type: 'string' },
                { name: 'chainId', type: 'uint256' },
                { name: 'verifyingContract', type: 'address' },
            ];
            const domain = {
                name: 'Arcanum Liquidity',
                version: '1',
                chainId: chainId,
                verifyingContract: pairContract.address,
            };
            const Permit = [
                { name: 'owner', type: 'address' },
                { name: 'spender', type: 'address' },
                { name: 'value', type: 'uint256' },
                { name: 'nonce', type: 'uint256' },
                { name: 'deadline', type: 'uint256' },
            ];
            const message = {
                owner: account,
                spender: stakingInfo.stakingRewardAddress,
                value: liquidityAmount.raw.toString(),
                nonce: nonce.toHexString(),
                deadline: deadline.toNumber(),
            };
            const data = JSON.stringify({
                types: {
                    EIP712Domain,
                    Permit,
                },
                domain,
                primaryType: 'Permit',
                message,
            });
            try {
                const signature = yield getSignature(data);
                setSignatureData({
                    v: signature.v,
                    r: signature.r,
                    s: signature.s,
                    deadline: deadline.toNumber(),
                });
            }
            catch (err) {
                approveCallback();
            }
        });
    }
    const renderPoolDataRow = (label, value) => {
        return (jsxs(DataBox, { children: [jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: label })), jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: value }))] }, label));
    };
    const handleDismissConfirmation = useCallback(() => {
        // if there was a tx hash, we want to clear the input
        if (hash) {
            setTypedValue('');
            setStepIndex(0);
        }
        setHash('');
        setSignatureData(null);
        setAttempting(false);
        onComplete && onComplete();
    }, [setTypedValue, hash, onComplete]);
    const handleSelectPoolDrawerClose = useCallback(() => {
        setIsPoolDrawerOpen(false);
    }, [setIsPoolDrawerOpen]);
    useEffect(() => {
        if (userLiquidityUnstaked) {
            setTypedValue(userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact());
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact()]);
    const onPoolSelect = useCallback((pairSelected) => {
        setSelectedPair(pairSelected);
    }, [setSelectedPair]);
    // userLiquidityUnstaked?.toExact() -> liquidityInUSD
    // typedValue -> ?
    const finalUsd = (userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.greaterThan('0'))
        ? (Number(typedValue) * liquidityInUSD) / Number(userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact())
        : undefined;
    const getApr = () => {
        if (combinedApr) {
            return `${combinedApr}%`;
        }
        else if (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr) {
            return `${stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr}%`;
        }
        else {
            return '-';
        }
    };
    const dollerWarth = finalUsd ? `$${Number(finalUsd).toFixed(2)}` : '-';
    const balanceLabel = !!((_d = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _d === void 0 ? void 0 : _d.token) && userLiquidityUnstaked
        ? t('currencyInputPanel.balance') + (userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toSignificant(6))
        : '-';
    return (jsxs(StakeWrapper, {
        children: [!attempting && !hash && (jsxs(Fragment, {
            children: [jsxs(Box, Object.assign({ flex: 1 }, {
                children: [type === SpaceType.detail && (jsx(PoolSelectWrapper, { children: jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsx(DoubleCurrencyLogo, { size: 24, currency0: currency0, currency1: currency1 }), jsxs(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] }))] })) })), jsxs(InputWrapper, Object.assign({ type: type }, {
                    children: [jsx(TextInput, {
                        value: typedValue, addonAfter: jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsx(Text, Object.assign({ color: "text4", fontSize: [24, 18] }, { children: "ARL" })) })), onChange: (value) => {
                            onUserInput(value);
                        }, fontSize: 24, isNumeric: true, placeholder: "0.00", addonLabel: account &&
                            type === SpaceType.detail && (jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 14 }, { children: balanceLabel }))), label: type === SpaceType.card ? balanceLabel : undefined
                    }), jsx(Box, Object.assign({ mt: type === 'card' ? '25px' : '0px' }, {
                        children: jsx(NumberOptions, {
                            onChange: (value) => {
                                setStepIndex(type === 'card' ? value / 25 : value);
                                onChangePercentage(type === 'card' ? value : value * 25);
                            }, currentValue: type === 'card' ? stepIndex * 25 : stepIndex, variant: type === 'card' ? 'box' : 'step', isPercentage: true
                        })
                    }))]
                })), type === 'card' && (jsxs(CardContentBox, Object.assign({ isSuperFarm: isSuperFarm }, { children: [jsx(Stat, { title: t('migratePage.dollarWorth'), stat: dollerWarth, titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" }), !isSuperFarm && (jsx(Stat, { title: t('dashboardPage.earned_weeklyIncome'), stat: `${hypotheticalWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })} PNG`, titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" })), jsx(Stat, { title: `APR`, stat: getApr(), titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" })] }))), type === SpaceType.detail && (jsx(Box, {
                    children: jsxs(ContentBox, {
                        children: [renderPoolDataRow(t('migratePage.dollarWorth'), `${dollerWarth}`), renderPoolDataRow(`${t('dashboardPage.earned_weeklyIncome')}`, `${hypotheticalWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })} PNG`), isSuperFarm && (jsxs(ExtraRewardDataBox, {
                            children: [jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: t('earn.extraReward') })), jsx(Box, Object.assign({ textAlign: "right" }, {
                                children: rewardTokensAmount === null || rewardTokensAmount === void 0 ? void 0 : rewardTokensAmount.map((reward, index) => {
                                    var _a, _b;
                                    const tokenMultiplier = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier[index];
                                    const extraTokenWeeklyRewardRate = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getExtraTokensWeeklyRewardRate) === null || _a === void 0 ? void 0 : _a.call(stakingInfo, hypotheticalWeeklyRewardRate, reward === null || reward === void 0 ? void 0 : reward.token, tokenMultiplier);
                                    if (extraTokenWeeklyRewardRate) {
                                        return (jsxs(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: [extraTokenWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' }), ' ', (_b = reward === null || reward === void 0 ? void 0 : reward.token) === null || _b === void 0 ? void 0 : _b.symbol] }), index));
                                    }
                                    return null;
                                })
                            }))]
                        }, "extra-reward"))]
                    })
                }))]
            })), jsxs(Buttons$8, { children: [jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED || signatureData !== null ? 'confirm' : 'primary', onClick: onAttemptToApprove, isDisabled: approval !== ApprovalState.NOT_APPROVED || signatureData !== null, loading: attempting && !hash, loadingText: t('migratePage.loading') }, { children: t('earn.approve') })), jsx(Button, Object.assign({ variant: "primary", isDisabled: !!error || (signatureData === null && approval !== ApprovalState.APPROVED), onClick: onStake, loading: attempting && !hash, loadingText: t('migratePage.loading') }, { children: error !== null && error !== void 0 ? error : t('earn.deposit') }))] })]
        })), attempting && !hash && jsx(Loader, { size: 100, label: `${t('earn.depositingLiquidity')}` }), attempting && hash && (jsx(TransactionCompleted, { submitText: `${t('earn.deposited')}`, isShowButtton: type === 'card' ? false : true, onButtonClick: handleDismissConfirmation, buttonText: "Close" })), isPoolDrawerOpen && (jsx(SelectPoolDrawer, { isOpen: isPoolDrawerOpen, onClose: handleSelectPoolDrawerClose, onPoolSelect: onPoolSelect, selectedPair: selectedPair }))]
    }));
};

const FarmDrawer = ({ isOpen, onClose, backgroundColor, version, stakingInfo, combinedApr }) => {
    var _a, _b;
    const { t } = useTranslation();
    const chainId = useChainId();
    const chefType = (_b = (_a = CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef) === null || _b === void 0 ? void 0 : _b.type;
    const renderBody = () => {
        if (chefType === ChefType.PANGO_CHEF) {
            return (jsx(Stake$1, { onComplete: onClose, type: SpaceType.card, stakingInfo: stakingInfo, combinedApr: combinedApr }));
        }
        return (jsx(Stake, { version: version, onComplete: onClose, type: SpaceType.card, stakingInfo: stakingInfo, combinedApr: combinedApr }));
    };
    return (jsx(Drawer, Object.assign({ title: t('earn.deposit'), pb: 10, isOpen: isOpen, onClose: onClose, backgroundColor: backgroundColor }, { children: isOpen && renderBody() })));
};

const Wrapper$9 = styled.div`
  position: relative;
  display: flex;
  flex-direction: row;
  margin-right: ${({ sizeraw, margin }) => margin && (sizeraw / 3 + 8).toString() + 'px'};
`;
const CoveredLogo = styled(CurrencyLogo)`
  position: absolute;
  left: ${({ sizeraw }) => '-' + (sizeraw / 2).toString() + 'px'} !important;
`;
function RewardTokens({ rewardTokens = [], size = 24, margin = false }) {
    const tokens = rewardTokens || []; // add PNG as default reward
    return (jsx(Wrapper$9, Object.assign({ sizeraw: size, margin: margin }, {
        children: (tokens || []).map((token, i) => {
            return jsx(CoveredLogo, { currency: token, size: size, sizeraw: size, imageSize: 48 }, i);
        })
    })));
}

const Panel$1 = styled(Box)`
  background-color: ${({ theme }) => theme.color5};
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  padding: 20px;
  border-radius: 10px;
  height: 295px;
  * {
    box-sizing: border-box;
  }
`;
styled.div`
  display: flex;
  align-items: center;
  flex-direction: row;
  grid-column-gap: 40px;
`;
const Divider$1 = styled(Box)`
  height: 1px;
  background-color: ${({ theme }) => theme.bg7};
  margin: 10px 0px 10px 0px;
  width: 100%;
`;
const ActionButon$1 = styled(Button)`
  width: 100%;
`;
const DetailButton$1 = styled(ActionButon$1)`
  border: 1px solid !important;
  border-color: ${({ theme }) => theme.text10}!important;
`;
const InnerWrapper$4 = styled(Box)`
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-gap: 12px;
  margin-top: 10px;
`;
const StatWrapper$2 = styled(Box)`
  display: grid;
  grid-template-columns: minmax(auto, 33%) minmax(auto, 33%) minmax(auto, 33%);
  grid-gap: 12px;
  margin-top: 10px;
  flex: 1;
`;
const OptionButton = styled.div`
  font-weight: 500;
  width: fit-content;
  white-space: nowrap;
  padding: 2px 6px;
  border-radius: 6px;
  background-color: ${({ theme }) => theme.primary};
  font-size: 13px;
`;
const OptionsWrapper = styled.div`
  display: grid;
  grid-template-columns: auto auto auto auto;
  grid-gap: 10px;
`;

const PoolCardView = ({ stakingInfo, onClickViewDetail, version, combinedApr, earnedAmount, rewardTokens, }) => {
    var _a, _b, _c, _d;
    const { t } = useTranslation();
    const [isClaimDrawerVisible, setShowClaimDrawer] = useState(false);
    const [isFarmDrawerVisible, setShowFarmDrawer] = useState(false);
    const [isAddLiquidityDrawerVisible, setShowAddLiquidityDrawer] = useState(false);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const [, stakingTokenPair] = usePair(token0, token1);
    const isStaking = Boolean(stakingInfo.stakedAmount.greaterThan('0'));
    const yourStackedInUsd = ((_a = CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet)
        ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd.multiply(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount).divide(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount)
        : undefined;
    const userPgl = useTokenBalance(account !== null && account !== void 0 ? account : undefined, stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.liquidityToken);
    const isLiquidity = Boolean(userPgl === null || userPgl === void 0 ? void 0 : userPgl.greaterThan('0'));
    const isSuperFarm = version > 1 ? ((_b = (rewardTokens || [])) === null || _b === void 0 ? void 0 : _b.length) > 1 : ((_c = ((stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokensAddress) || [])) === null || _c === void 0 ? void 0 : _c.length) > 1;
    const redirectToFarmDrawer = () => {
        setShowFarmDrawer(true);
        setShowAddLiquidityDrawer(false);
    };
    const renderButton = () => {
        if (isStaking && Boolean(earnedAmount.greaterThan('0')))
            return (jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowClaimDrawer(true), backgroundColor: "bg2", color: "text1", height: "45px" }, { children: t('earnPage.claim') })));
        else if (isLiquidity) {
            return (jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowFarmDrawer(true), backgroundColor: "bg2", color: "text1", height: "45px" }, { children: t('header.farm') })));
        }
        else {
            return (jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowAddLiquidityDrawer(true), backgroundColor: "bg2", color: "text1", height: "45px" }, { children: t('pool.addLiquidity') })));
        }
    };
    return (jsxs(Panel$1, {
        children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, { children: [jsxs(Box, { children: [jsxs(Text, Object.assign({ color: "text1", fontSize: 24, fontWeight: 500 }, { children: [currency0.symbol, "-", currency1.symbol] })), isSuperFarm && (jsx(OptionsWrapper, { children: jsx(OptionButton, { children: "Super farm" }) }))] }), jsx(DoubleCurrencyLogo, { size: 48, currency0: currency0, currency1: currency1 })] })), jsx(Divider$1, {}), jsx(Box, Object.assign({ display: "flex", flex: "1", alignItems: "center" }, { children: jsxs(StatWrapper$2, { children: [isStaking ? (jsx(Stat, { title: 'Your TVL', stat: numeral(yourStackedInUsd === null || yourStackedInUsd === void 0 ? void 0 : yourStackedInUsd.toFixed(2)).format('$0.00a'), titlePosition: "top", titleFontSize: [16, 14], statFontSize: [24, 18] })) : (jsx(Stat, { title: 'TVL', stat: numeral((_d = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd) === null || _d === void 0 ? void 0 : _d.toFixed(2)).format('$0.00a'), titlePosition: "top", titleFontSize: 14, statFontSize: 18 })), jsx(Stat, { title: `APR`, stat: combinedApr ? `${numeral(combinedApr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: [16, 14], statFontSize: [24, 18] }), jsxs(Box, Object.assign({ display: "inline-block" }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: [16, 14] }, { children: t('earn.rewardsIn') })), jsx(Box, Object.assign({ display: "flex", alignItems: "center", mt: "5px" }, { children: jsx(RewardTokens, { rewardTokens: rewardTokens, size: 24 }) }))] }))] }) })), jsxs(InnerWrapper$4, { children: [jsx(Box, { children: jsx(DetailButton$1, Object.assign({ variant: "plain", onClick: onClickViewDetail, color: "text1", height: "45px" }, { children: t('pool.seeDetails') })) }), jsx(Box, { children: renderButton() })] }), isClaimDrawerVisible && (jsx(ClaimDrawer, {
            isOpen: isClaimDrawerVisible, onClose: () => {
                setShowClaimDrawer(false);
            }, stakingInfo: stakingInfo, version: version, backgroundColor: "color5"
        })), isFarmDrawerVisible && (jsx(FarmDrawer, {
            isOpen: isFarmDrawerVisible, onClose: () => {
                setShowFarmDrawer(false);
            }, version: version, backgroundColor: "color5", stakingInfo: stakingInfo, combinedApr: version > 1 ? combinedApr : undefined
        })), isAddLiquidityDrawerVisible && (jsx(AddLiquidityDrawer, {
            isOpen: isAddLiquidityDrawerVisible, onClose: () => {
                setShowAddLiquidityDrawer(false);
            }, onAddToFarm: redirectToFarmDrawer, clickedLpTokens: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens, backgroundColor: "color5"
        }))]
    }));
};

const PoolCardV1 = ({ stakingInfo, onClickViewDetail, version }) => {
    const rewardTokens = useTokens(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokensAddress);
    return (jsx(PoolCardView, { combinedApr: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr, earnedAmount: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount, rewardTokens: rewardTokens, stakingInfo: stakingInfo, onClickViewDetail: onClickViewDetail, version: version }));
};

const EarnWrapper = styled(Box)`
  width: 100%;
`;

var TradeType;
(function (TradeType) {
    TradeType["Pool"] = "Pool";
    TradeType["Farm"] = "Farm";
})(TradeType || (TradeType = {}));
const TradeOption = ({ type, setType }) => {
    const { t } = useTranslation();
    return (jsx(EarnWrapper, {
        children: jsx(Box, Object.assign({ p: 20 }, {
            children: jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, {
                children: [jsx(Text, Object.assign({ color: "text1", fontSize: [20, 16], fontWeight: 500, style: { whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' } }, { children: type === 'Pool' ? t('pool.addLiquidity') : t('header.farm') })), jsx(Box, Object.assign({ width: "120px" }, {
                    children: jsx(ToggleButtons, {
                        options: [TradeType.Pool, TradeType.Farm], value: type, onChange: (value) => {
                            setType(value);
                        }
                    })
                }))]
            }))
        }))
    }));
};

const Root$a = styled(Box)`
  width: 100%;
  background-color: ${({ theme }) => theme.bg2};
  border-radius: 10px;
  position: relative;
  display: flex;
  flex-direction: column;
  height: 500px;
  * {
    box-sizing: border-box;
  }
  overflow: hidden;
`;

const EarnWidget = ({ currencyA, currencyB, version, stakingInfo }) => {
    var _a, _b;
    const [type, setType] = useState(TradeType.Pool);
    const chainId = useChainId();
    const chefType = (_b = (_a = CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef) === null || _b === void 0 ? void 0 : _b.type;
    return (jsxs(Root$a, { children: [jsx(TradeOption, { type: type, setType: setType }), type === TradeType.Pool ? (jsx(AddLiquidity, { currencyA: currencyA, currencyB: currencyB, type: SpaceType.detail })) : chefType === ChefType.PANGO_CHEF ? (jsx(Stake$1, { type: SpaceType.detail, stakingInfo: stakingInfo })) : (jsx(Stake, { version: version, type: SpaceType.detail, stakingInfo: stakingInfo }))] }));
};

var PoolType;
(function (PoolType) {
    PoolType[PoolType["UNSET_POOL"] = 0] = "UNSET_POOL";
    PoolType[PoolType["ERC20_POOL"] = 1] = "ERC20_POOL";
    PoolType[PoolType["RELAYER_POOL"] = 2] = "RELAYER_POOL";
})(PoolType || (PoolType = {}));

/* eslint-disable max-lines */
function usePangoChefInfos() {
    var _a, _b, _c;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const pangoChefContract = usePangoChefContract();
    const png = PNG[chainId];
    // get the length of pools
    const poolLenght = (_a = useSingleCallResult(pangoChefContract, 'poolsLength').result) === null || _a === void 0 ? void 0 : _a[0];
    // create array with length of pools
    const allPoolsIds = new Array(Number(poolLenght ? poolLenght.toString() : 0))
        .fill(0)
        .map((_, index) => [index.toString()]);
    const poolsState = useSingleContractMultipleData(pangoChefContract, 'pools', allPoolsIds);
    // format the data to Pool type
    const [pools, poolsIds] = useMemo(() => {
        var _a;
        const _pools = [];
        const _poolsIds = [];
        for (let i = 0; i < poolsState.length; i++) {
            const result = (_a = poolsState[i]) === null || _a === void 0 ? void 0 : _a.result;
            if (!result) {
                continue;
            }
            const tokenOrRecipient = result.tokenOrRecipient;
            const poolType = result.poolType;
            const rewarder = result.rewarder;
            const rewardPair = result.rewardPair;
            const valueVariables = result.valueVariables;
            const rewardSummations = result.rewardSummationsStored;
            if (!tokenOrRecipient || !poolType || !rewarder || !rewardPair || !valueVariables || !rewardSummations) {
                continue;
            }
            // remove not erc20 pool and remove this pool from poolsIds
            if (poolType !== PoolType.ERC20_POOL) {
                continue;
            }
            _pools.push({
                tokenOrRecipient: tokenOrRecipient,
                poolType: poolType,
                rewarder: rewarder,
                rewardPair: rewardPair,
                valueVariables: {
                    balance: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.balance,
                    sumOfEntryTimes: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.sumOfEntryTimes,
                },
                rewardSummations: rewardSummations,
            });
            _poolsIds.push([i.toString()]);
        }
        return [_pools, _poolsIds];
    }, [poolsState]);
    // get reward rates for each pool
    const poolsRewardsRateState = useSingleContractMultipleData(pangoChefContract, 'poolRewardRate', poolsIds);
    // get total reward rate
    const totalRewardRateState = useSingleCallResult(pangoChefContract, 'rewardRate');
    const totalRewardRate = (_c = (_b = totalRewardRateState === null || totalRewardRateState === void 0 ? void 0 : totalRewardRateState.result) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : BigNumber.from(0);
    const totalRewardRatePerSecond = new TokenAmount(png, totalRewardRate.toString());
    const totalRewardRatePerWeek = new TokenAmount(png, totalRewardRate.mul(60 * 60 * 24 * 7).toString());
    // get the address of the rewarder for each pool
    const rewardsAddresses = useMemo(() => {
        if ((pools || []).length === 0)
            return [];
        return pools.map((pool) => {
            if (!!(pool === null || pool === void 0 ? void 0 : pool.rewarder) && (pool === null || pool === void 0 ? void 0 : pool.rewarder) !== ZERO_ADDRESS) {
                return pool.rewarder;
            }
            return undefined;
        });
    }, [pools]);
    const rewardsTokensState = useMultipleContractSingleData(rewardsAddresses, REWARDER_VIA_MULTIPLIER_INTERFACE, 'getRewardTokens', []);
    // get the address of lp tokens for each pool
    const lpTokens = useMemo(() => {
        if ((pools || []).length === 0)
            return [];
        return pools.map((pool) => pool === null || pool === void 0 ? void 0 : pool.tokenOrRecipient);
    }, [pools]);
    // get the tokens for each pool
    const tokens0State = useMultipleContractSingleData(lpTokens, PANGOLIN_PAIR_INTERFACE, 'token0', []);
    const tokens1State = useMultipleContractSingleData(lpTokens, PANGOLIN_PAIR_INTERFACE, 'token1', []);
    const tokens0Adrr = useMemo(() => {
        return tokens0State.map((result) => (result.result && result.result.length > 0 ? result.result[0] : null));
    }, [tokens0State]);
    const tokens1Adrr = useMemo(() => {
        return tokens1State.map((result) => (result.result && result.result.length > 0 ? result.result[0] : null));
    }, [tokens1State]);
    const tokens0 = useTokens(tokens0Adrr);
    const tokens1 = useTokens(tokens1Adrr);
    const tokensPairs = useMemo(() => {
        if (tokens0 && tokens1 && (tokens0 === null || tokens0 === void 0 ? void 0 : tokens0.length) === (tokens1 === null || tokens1 === void 0 ? void 0 : tokens1.length)) {
            const tokens = [];
            tokens0.forEach((token0, index) => {
                const token1 = tokens1[index];
                if (token0 && token1) {
                    tokens.push([token0, token1]);
                }
            });
            return tokens;
        }
        return [];
    }, [tokens0, tokens1]);
    // get the pairs for each pool
    const pairs = usePairs(tokensPairs);
    const pairAddresses = useMemo(() => {
        return pairs.map(([, pair]) => { var _a; return (_a = pair === null || pair === void 0 ? void 0 : pair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address; });
    }, [pairs]);
    const pairTotalSuppliesState = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'totalSupply');
    const userInfoInput = useMemo(() => {
        if (poolsIds.length === 0 || !account)
            return [];
        return poolsIds.map((pid) => [pid[0], account]);
    }, [poolsIds, account]); // [[pid, account], ...] [[0, account], [1, account], [2, account] ...]
    const userInfosState = useSingleContractMultipleData(pangoChefContract, 'getUser', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    // format the data to UserInfo type
    const userInfos = useMemo(() => {
        return userInfosState.map((callState) => {
            var _a, _b;
            const result = (_a = callState === null || callState === void 0 ? void 0 : callState.result) === null || _a === void 0 ? void 0 : _a[0];
            if (!result || callState.loading) {
                return {
                    valueVariables: {
                        balance: BigNumber.from(0),
                        sumOfEntryTimes: BigNumber.from(0),
                    },
                    isLockingPoolZero: false,
                };
            }
            const valueVariables = result.valueVariables;
            const rewardSummations = result.rewardSummationsPaid;
            const previousValues = result.previousValues;
            const isLockingPoolZero = (_b = result.isLockingPoolZero) !== null && _b !== void 0 ? _b : false;
            if (!valueVariables || !rewardSummations || !previousValues) {
                return {
                    valueVariables: {
                        balance: BigNumber.from(0),
                        sumOfEntryTimes: BigNumber.from(0),
                    },
                    isLockingPoolZero: false,
                };
            }
            return {
                valueVariables: {
                    balance: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.balance,
                    sumOfEntryTimes: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.sumOfEntryTimes,
                },
                rewardSummations: rewardSummations,
                previousValues: previousValues,
                isLockingPoolZero: isLockingPoolZero,
            };
        });
    }, [userInfosState]);
    // get the user pending rewards for each pool
    const userPendingRewardsState = useSingleContractMultipleData(pangoChefContract, 'userPendingRewards', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const userRewardRatesState = useSingleContractMultipleData(pangoChefContract, 'userRewardRate', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const wavax = WAVAX[chainId];
    const [avaxPngPairState, avaxPngPair] = usePair(wavax, png);
    const pairsToGetPrice = useMemo(() => {
        const _pairs = [];
        pairs.forEach(([, pair], index) => {
            var _a;
            const pairTotalSupplyState = pairTotalSuppliesState[index];
            if (pair && pairTotalSupplyState.result) {
                _pairs.push({
                    pair: pair,
                    totalSupply: new TokenAmount(pair.liquidityToken, JSBI$1.BigInt((_a = pairTotalSupplyState === null || pairTotalSupplyState === void 0 ? void 0 : pairTotalSupplyState.result) === null || _a === void 0 ? void 0 : _a[0])),
                });
            }
        });
        return _pairs;
    }, [pairs, pairTotalSuppliesState]);
    const pairPrices = usePairsCurrencyPrice(pairsToGetPrice);
    const { data: currencyPrice = 0 } = useCoinGeckoCurrencyPrice(chainId);
    return useMemo(() => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!chainId || !png || pairs.length == 0)
            return [];
        const farms = [];
        for (let index = 0; index < poolsIds.length; index++) {
            const poolState = poolsState[index];
            const poolRewardRateState = poolsRewardsRateState[index];
            const userInfoState = userInfosState[index];
            const token0State = tokens0State[index];
            const token1State = tokens1State[index];
            const rewardTokensState = rewardsTokensState[index];
            const userPendingRewardState = userPendingRewardsState[index];
            const pairTotalSupplyState = pairTotalSuppliesState[index];
            const userRewardRateState = userRewardRatesState[index];
            const [pairState, pair] = pairs[index];
            // if is loading or not exist pair continue
            if (poolState.loading ||
                poolRewardRateState.loading ||
                userInfoState.loading ||
                token0State.loading ||
                token1State.loading ||
                rewardTokensState.loading ||
                userPendingRewardState.loading ||
                userRewardRateState.loading ||
                pairTotalSupplyState.loading ||
                totalRewardRateState.loading ||
                pairState === PairState.LOADING ||
                avaxPngPairState == PairState.LOADING ||
                !pair ||
                !avaxPngPair) {
                continue;
            }
            const pid = poolsIds[index][0];
            const pool = pools[index];
            const rewardRate = (_b = (_a = poolRewardRateState.result) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : BigNumber.from(0);
            const totalStakedAmount = new TokenAmount(pair.liquidityToken, JSBI$1.BigInt(pool.valueVariables.balance.toString()));
            const userInfo = userInfos[index];
            const userTotalStakedAmount = new TokenAmount(pair.liquidityToken, JSBI$1.BigInt((_c = userInfo === null || userInfo === void 0 ? void 0 : userInfo.valueVariables.balance) !== null && _c !== void 0 ? _c : 0));
            const pendingRewards = new TokenAmount(png, JSBI$1.BigInt((_e = (_d = userPendingRewardState === null || userPendingRewardState === void 0 ? void 0 : userPendingRewardState.result) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : 0));
            const pairPrice = pairPrices[pair.liquidityToken.address];
            const pngPrice = avaxPngPair.priceOf(png, wavax);
            const _totalStakedInWavax = pairPrice.raw.multiply(totalStakedAmount.raw);
            const currencyPriceFraction = decimalToFraction(currencyPrice);
            // calculate the total staked amount in usd
            const totalStakedInUsd = new TokenAmount(USDC[chainId], currencyPriceFraction.multiply(_totalStakedInWavax).toFixed(0));
            const totalStakedInWavax = new TokenAmount(wavax, _totalStakedInWavax.toFixed(0));
            const getHypotheticalWeeklyRewardRate = (_stakedAmount, _totalStakedAmount, _totalRewardRatePerSecond) => {
                return new TokenAmount(png, JSBI$1.greaterThan(_totalStakedAmount.raw, JSBI$1.BigInt(0))
                    ? JSBI$1.divide(JSBI$1.multiply(JSBI$1.multiply(_totalRewardRatePerSecond.raw, _stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK), _totalStakedAmount.raw)
                    : JSBI$1.BigInt(0));
            };
            // poolAPR = poolRewardRate(POOL_ID) * 365 days * 100 * PNG_PRICE / (pools(POOL_ID).valueVariables.balance * STAKING_TOKEN_PRICE)
            const apr = pool.valueVariables.balance.isZero() || pairPrice.equalTo('0')
                ? 0
                : Number(pngPrice.raw
                    .multiply(rewardRate.mul(365 * 86400 * 100).toString())
                    .divide(pairPrice.raw.multiply(pool.valueVariables.balance.toString()))
                    .toSignificant(2));
            farms.push({
                pid: pid,
                tokens: [pair.token0, pair.token1],
                stakingRewardAddress: pangoChefContract === null || pangoChefContract === void 0 ? void 0 : pangoChefContract.address,
                totalStakedAmount: totalStakedAmount,
                totalStakedInUsd: totalStakedInUsd !== null && totalStakedInUsd !== void 0 ? totalStakedInUsd : new TokenAmount(USDC[chainId], BIG_INT_ZERO),
                totalStakedInWavax: totalStakedInWavax,
                multiplier: BIG_INT_ZERO,
                stakedAmount: userTotalStakedAmount,
                isPeriodFinished: rewardRate.isZero(),
                periodFinish: undefined,
                rewardsAddress: pool.rewarder,
                rewardTokensAddress: [png.address, ...(((_f = rewardTokensState === null || rewardTokensState === void 0 ? void 0 : rewardTokensState.result) === null || _f === void 0 ? void 0 : _f[0]) || [])],
                totalRewardRatePerSecond: totalRewardRatePerSecond,
                totalRewardRatePerWeek: totalRewardRatePerWeek,
                rewardRatePerWeek: new TokenAmount(png, rewardRate.mul(60 * 60 * 24 * 7).toString()),
                getHypotheticalWeeklyRewardRate: getHypotheticalWeeklyRewardRate,
                getExtraTokensWeeklyRewardRate: getExtraTokensWeeklyRewardRate,
                earnedAmount: pendingRewards,
                valueVariables: pool.valueVariables,
                userValueVariables: userInfo === null || userInfo === void 0 ? void 0 : userInfo.valueVariables,
                isLockingPoolZero: userInfo.isLockingPoolZero,
                userRewardRate: (_h = (_g = userRewardRateState.result) === null || _g === void 0 ? void 0 : _g[0]) !== null && _h !== void 0 ? _h : BigNumber.from(0),
                stakingApr: apr,
                pairPrice: pairPrice,
                poolType: pool.poolType,
                poolRewardRate: rewardRate,
            });
        }
        return farms;
    }, [
        poolsIds,
        poolsState,
        poolsRewardsRateState,
        userInfosState,
        tokens0State,
        tokens1State,
        rewardsTokensState,
        pairTotalSuppliesState,
        userPendingRewardsState,
        pairs,
    ]);
}
function useUserPangoChefAPR(stakingInfo) {
    const blockTime = useGetBlockTimestamp();
    return useMemo(() => {
        var _a;
        if (!stakingInfo)
            return '0';
        const userBalance = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.userValueVariables.balance;
        const userSumOfEntryTimes = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.userValueVariables.sumOfEntryTimes;
        const poolBalance = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.valueVariables.balance;
        const poolSumOfEntryTimes = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.valueVariables.sumOfEntryTimes;
        if (userBalance.isZero() || poolBalance.isZero() || !blockTime)
            return '0';
        const blockTimestamp = BigNumber.from(blockTime.toString());
        //userAPR = poolAPR * (blockTime - (userValueVariables.sumOfEntryTimes / userValueVariables.balance)) / (blockTime - (poolValueVariables.sumOfEntryTimes / poolValueVariables.balance))
        const a = userSumOfEntryTimes.div(userBalance);
        const b = poolSumOfEntryTimes.div(poolBalance);
        const c = blockTimestamp.sub(a);
        const d = blockTimestamp.sub(b);
        return BigNumber.from((_a = stakingInfo.stakingApr) !== null && _a !== void 0 ? _a : 0)
            .mul(c)
            .div(d)
            .toString();
    }, [blockTime, stakingInfo]);
}
function useUserPangoChefRewardRate(stakingInfo) {
    const blockTime = useGetBlockTimestamp();
    return useMemo(() => {
        const userBalance = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.userValueVariables.balance;
        const userSumOfEntryTimes = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.userValueVariables.sumOfEntryTimes;
        const poolBalance = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.valueVariables.balance;
        const poolSumOfEntryTimes = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.valueVariables.sumOfEntryTimes;
        if (userBalance.isZero() || poolBalance.isZero() || !blockTime)
            return BigNumber.from(0);
        const blockTimestamp = BigNumber.from(blockTime.toString());
        const userValue = blockTimestamp.mul(userBalance).sub(userSumOfEntryTimes);
        const poolValue = blockTimestamp.mul(poolBalance).sub(poolSumOfEntryTimes);
        return userValue.lte(0) || poolValue.lte(0)
            ? BigNumber.from(0)
            : stakingInfo.poolRewardRate.mul(userValue).div(poolValue);
    }, [blockTime, stakingInfo]);
}
function useIsLockingPoolZero() {
    const stakingInfos = usePangoChefInfos();
    const pairs = useMemo(() => {
        const _pairs = [];
        stakingInfos.forEach((stakingInfo) => {
            if (stakingInfo.isLockingPoolZero) {
                const [token0, token1] = stakingInfo.tokens;
                _pairs.push([token0, token1]);
            }
        });
        return _pairs;
    }, [stakingInfos]);
    return pairs;
}

function useBurnState() {
    return useSelector((state) => state.pburn);
}
function useDerivedBurnInfo(currencyA, currencyB) {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useTokenBalances = useTokenBalancesHook[chainId];
    const useTotalSupply = useTotalSupplyHook[chainId];
    const { t } = useTranslation();
    const { independentField, typedValue } = useBurnState();
    // pair + totalsupply
    const [, pair] = usePair(currencyA, currencyB);
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    // balances
    const relevantTokenBalances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, [pairOrToken]);
    const userLiquidity = relevantTokenBalances === null || relevantTokenBalances === void 0 ? void 0 : relevantTokenBalances[(_b = (_a = pair === null || pair === void 0 ? void 0 : pair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : ''];
    const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];
    const tokens = {
        [Field$2.CURRENCY_A]: tokenA,
        [Field$2.CURRENCY_B]: tokenB,
        [Field$2.LIQUIDITY]: pair === null || pair === void 0 ? void 0 : pair.liquidityToken,
    };
    // liquidity values
    const totalSupply = useTotalSupply(pairOrToken);
    const [liquidityValue0, liquidityValue1] = pair &&
        totalSupply &&
        userLiquidity &&
        tokenA &&
        tokenB &&
        JSBI$1.greaterThan(totalSupply.raw, BIG_INT_ZERO) &&
        JSBI$1.greaterThan(userLiquidity.raw, BIG_INT_ZERO) &&
        JSBI$1.greaterThanOrEqual(totalSupply.raw, userLiquidity.raw)
        ? pair.getLiquidityValues(totalSupply, userLiquidity, { feeOn: false })
        : [undefined, undefined];
    const liquidityValueA = tokenA && (pair === null || pair === void 0 ? void 0 : pair.token0.equals(tokenA)) ? liquidityValue0 : liquidityValue1;
    const liquidityValueB = tokenB && (pair === null || pair === void 0 ? void 0 : pair.token0.equals(tokenB)) ? liquidityValue0 : liquidityValue1;
    const liquidityValues = {
        [Field$2.CURRENCY_A]: liquidityValueA,
        [Field$2.CURRENCY_B]: liquidityValueB,
    };
    let percentToRemove = new Percent$1('0', '100');
    // user specified a %
    if (independentField === Field$2.LIQUIDITY_PERCENT) {
        percentToRemove = new Percent$1(typedValue, '100');
    }
    // user specified a specific amount of liquidity tokens
    else if (independentField === Field$2.LIQUIDITY) {
        if (pair === null || pair === void 0 ? void 0 : pair.liquidityToken) {
            const independentAmount = tryParseAmount(typedValue, pair.liquidityToken, chainId);
            if (independentAmount && userLiquidity && !independentAmount.greaterThan(userLiquidity)) {
                percentToRemove = new Percent$1(independentAmount.raw, userLiquidity.raw);
            }
        }
    }
    // user specified a specific amount of token a or b
    else {
        if (tokens[independentField]) {
            const independentAmount = tryParseAmount(typedValue, tokens[independentField], chainId);
            const liquidityValue = liquidityValues[independentField];
            if (independentAmount && liquidityValue && !independentAmount.greaterThan(liquidityValue)) {
                percentToRemove = new Percent$1(independentAmount.raw, liquidityValue.raw);
            }
        }
    }
    const parsedAmounts = {
        [Field$2.LIQUIDITY_PERCENT]: percentToRemove,
        [Field$2.LIQUIDITY]: userLiquidity && percentToRemove && percentToRemove.greaterThan('0')
            ? new TokenAmount(userLiquidity.token, percentToRemove.multiply(userLiquidity.raw).quotient)
            : undefined,
        [Field$2.CURRENCY_A]: tokenA && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueA
            ? new TokenAmount(tokenA, percentToRemove.multiply(liquidityValueA.raw).quotient)
            : undefined,
        [Field$2.CURRENCY_B]: tokenB && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueB
            ? new TokenAmount(tokenB, percentToRemove.multiply(liquidityValueB.raw).quotient)
            : undefined,
    };
    let error;
    if (!account) {
        error = t('burnHooks.connectWallet');
    }
    if (!parsedAmounts[Field$2.LIQUIDITY] || !parsedAmounts[Field$2.CURRENCY_A] || !parsedAmounts[Field$2.CURRENCY_B]) {
        error = error !== null && error !== void 0 ? error : t('burnHooks.enterAmount');
    }
    return { pair, parsedAmounts, error, userLiquidity };
}
function useBurnActionHandlers() {
    const dispatch = useDispatch();
    const onUserInput = useCallback((field, typedValue) => {
        dispatch(typeInput$2({ field, typedValue }));
    }, [dispatch]);
    return {
        onUserInput,
    };
}

const RemoveWrapper$1 = styled(Box)`
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
`;
const ButtonWrapper = styled(Box)`
  justify-content: space-between;
  width: 100%;
  display: flex;
  padding: 0;
  align-items: center;
`;

const RemoveLiquidity = ({ currencyA, currencyB, onLoadingOrComplete }) => {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const useApproveCallback = useApproveCallbackHook[chainId];
    const useRemoveLiquidity = useRemoveLiquidityHook[chainId];
    // toggle wallet when disconnected
    const toggleWalletModal = useWalletModalToggle();
    const { independentField, typedValue } = useBurnState();
    const { pair, parsedAmounts, error, userLiquidity } = useDerivedBurnInfo(currencyA !== null && currencyA !== void 0 ? currencyA : undefined, currencyB !== null && currencyB !== void 0 ? currencyB : undefined);
    const { removeLiquidity, onAttemptToApprove, signatureData, setSignatureData } = useRemoveLiquidity(pair);
    const { onUserInput: _onUserInput } = useBurnActionHandlers();
    const isValid = !error;
    // state for pending and submitted txn views
    const [attempting, setAttempting] = useState(false);
    const [hash, setHash] = useState();
    const deadline = useTransactionDeadline();
    const [allowedSlippage] = useUserSlippageTolerance();
    const formattedAmounts = {
        [Field$2.LIQUIDITY_PERCENT]: parsedAmounts[Field$2.LIQUIDITY_PERCENT].equalTo('0')
            ? '0'
            : parsedAmounts[Field$2.LIQUIDITY_PERCENT].lessThan(new Percent$1('1', '100'))
                ? '<1'
                : parsedAmounts[Field$2.LIQUIDITY_PERCENT].toFixed(0),
        [Field$2.LIQUIDITY]: independentField === Field$2.LIQUIDITY ? typedValue : (_b = (_a = parsedAmounts[Field$2.LIQUIDITY]) === null || _a === void 0 ? void 0 : _a.toExact()) !== null && _b !== void 0 ? _b : '',
    };
    // allowance handling
    // const [signatureData, setSignatureData] = useState<{ v: number; r: string; s: string; deadline: number } | null>(
    //   null,
    // );
    const [approval, approveCallback] = useApproveCallback(chainId, parsedAmounts[Field$2.LIQUIDITY], ROUTER_ADDRESS[chainId]);
    const { t } = useTranslation();
    const [percetage, setPercetage] = useState(100);
    useEffect(() => {
        _onUserInput(Field$2.LIQUIDITY_PERCENT, `100`);
    }, [_onUserInput]);
    useEffect(() => {
        if (onLoadingOrComplete) {
            if (hash || attempting) {
                onLoadingOrComplete(true);
            }
            else {
                onLoadingOrComplete(false);
            }
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [hash, attempting]);
    const onChangePercentage = (value) => {
        _onUserInput(Field$2.LIQUIDITY_PERCENT, `${value}`);
    };
    // wrapped onUserInput to clear signatures
    const onUserInput = useCallback((_typedValue) => {
        setSignatureData(null);
        _onUserInput(Field$2.LIQUIDITY, _typedValue);
        setPercetage(0);
    }, [_onUserInput]);
    useEffect(() => {
        setPercetage(Number(parsedAmounts[Field$2.LIQUIDITY_PERCENT].toFixed(0)) / 25);
    }, [parsedAmounts]);
    function onRemove() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chainId || !library || !account || !deadline)
                throw new Error(t('error.missingDependencies'));
            try {
                setAttempting(true);
                const removeData = {
                    parsedAmounts,
                    deadline,
                    allowedSlippage,
                    approval,
                };
                const response = yield removeLiquidity(removeData);
                setHash(response === null || response === void 0 ? void 0 : response.hash);
            }
            catch (err) {
                const _err = err;
                console.error(_err);
            }
            finally {
                setAttempting(false);
            }
        });
    }
    function getApproveButtonVariant() {
        if (approval === ApprovalState.APPROVED || signatureData !== null) {
            return 'confirm';
        }
        return 'primary';
    }
    function getApproveButtonText() {
        if (approval === ApprovalState.PENDING) {
            return t('removeLiquidity.approving');
        }
        else if (approval === ApprovalState.APPROVED || signatureData !== null) {
            return t('removeLiquidity.approved');
        }
        return t('removeLiquidity.approve');
    }
    return (jsxs(RemoveWrapper$1, {
        children: [!attempting && !hash && (jsxs(Fragment, {
            children: [jsx(Box, Object.assign({ flex: 1 }, {
                children: jsx(Box, {
                    children: jsxs(Box, Object.assign({ display: "flex", flexDirection: "column" }, {
                        children: [jsx(TextInput, {
                            value: formattedAmounts[Field$2.LIQUIDITY], addonAfter: jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsx(Text, Object.assign({ color: "text4", fontSize: [24, 18] }, { children: "ARL" })) })), onChange: (value) => {
                                onUserInput(value);
                            }, fontSize: 24, isNumeric: true, placeholder: "0.00", addonLabel: account && (jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 14 }, { children: !!userLiquidity ? t('currencyInputPanel.balance') + (userLiquidity === null || userLiquidity === void 0 ? void 0 : userLiquidity.toSignificant(6)) : ' -' })))
                        }), jsx(Box, Object.assign({ my: "5px" }, {
                            children: jsx(NumberOptions, {
                                onChange: (value) => {
                                    setPercetage(value);
                                    onChangePercentage(value * 25);
                                }, currentValue: percetage, variant: "step", isPercentage: true
                            })
                        }))]
                    }))
                })
            })), jsx(Box, Object.assign({ mt: 0 }, {
                children: !account ? (jsx(Button, Object.assign({ variant: "primary", onClick: toggleWalletModal, height: "46px" }, { children: t('earn.deposit') }))) : (jsxs(ButtonWrapper, {
                    children: [isEvmChain(chainId) && (jsx(Box, Object.assign({ mr: "5px", width: "100%" }, {
                        children: jsx(Button, Object.assign({
                            variant: getApproveButtonVariant(), onClick: () => {
                                onAttemptToApprove({ parsedAmounts, deadline, approveCallback });
                            }, isDisabled: approval !== ApprovalState.NOT_APPROVED || signatureData !== null, loading: attempting && !hash, loadingText: t('removeLiquidity.approving'), height: "46px"
                        }, { children: getApproveButtonText() }))
                    }))), jsx(Box, Object.assign({ width: "100%" }, { children: jsx(Button, Object.assign({ variant: "primary", isDisabled: !isValid || (signatureData === null && approval !== ApprovalState.APPROVED), onClick: onRemove, loading: attempting && !hash, loadingText: t('migratePage.loading'), height: "46px" }, { children: error || t('removeLiquidity.remove') })) }))]
                }))
            }))]
        })), attempting && !hash && jsx(Loader, { size: 100, label: `Removing Liquidity...` }), hash && jsx(TransactionCompleted, { submitText: `Removed Liquidity` })]
    }));
};

const RemoveLiquidityDrawer = ({ isOpen, onClose, clickedLpTokens, backgroundColor }) => {
    const { t } = useTranslation();
    const chainId = useChainId();
    const token0 = clickedLpTokens === null || clickedLpTokens === void 0 ? void 0 : clickedLpTokens[0];
    const token1 = clickedLpTokens === null || clickedLpTokens === void 0 ? void 0 : clickedLpTokens[1];
    const currencyA = token0 && unwrappedToken(token0, chainId);
    const currencyB = token1 && unwrappedToken(token1, chainId);
    return (jsx(Drawer, Object.assign({ title: t('navigationTabs.removeLiquidity'), isOpen: isOpen, onClose: onClose, backgroundColor: backgroundColor }, { children: isOpen && (jsx(Box, Object.assign({ padding: "10px", display: "flex", flexDirection: "column", flex: "1" }, { children: jsx(RemoveLiquidity, { currencyA: currencyA, currencyB: currencyB }) }))) })));
};

const FarmRemoveWrapper = styled(Box)`
  width: 100%;
  flex: 1;
`;
const Root$9 = styled(Box)`
  height: 100%;
  display: flex;
  flex-direction: column;
`;
const RewardWrapper = styled(Box)`
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-row-gap: 0px;
  grid-column-gap: 5px;
  justify-content: center;
  height: 100%;
`;
const StatWrapper$1 = styled(Box)`
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
`;
const Buttons$7 = styled(Box)`
  display: grid;
  grid-template-columns: 1fr ${({ chefType }) => (chefType === ChefType.PANGO_CHEF ? '1fr' : '')};
  grid-gap: 20px;
  align-self: end;
  margin-top: 10px;
`;

const RemoveFarm = ({ stakingInfo, version, onClose, onLoadingOrComplete, redirectToCompound }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { account } = usePangolinWeb3();
    const [isRemoveLiquidityDrawerVisible, setShowRemoveLiquidityDrawer] = useState(false);
    const [confirmRemove, setConfirmRemove] = useState(false);
    const { t } = useTranslation();
    // monitor call to help UI loading state
    const addTransaction = useTransactionAdder();
    const [hash, setHash] = useState();
    const [attempting, setAttempting] = useState(false);
    const poolMap = useMinichefPools();
    const stakingContract = useStakingContract(stakingInfo.stakingRewardAddress);
    const pangoChefContract = usePangoChefContract();
    const chainId = useChainId();
    const png = PNG[chainId];
    const contract = version <= 2 ? stakingContract : pangoChefContract;
    const { rewardTokensAmount } = useMinichefPendingRewards(stakingInfo);
    const refetchMinichefSubgraph = useRefetchMinichefSubgraph();
    const isSuperFarm = ((_a = (rewardTokensAmount || [])) === null || _a === void 0 ? void 0 : _a.length) > 0;
    const chefType = (_d = (_c = (_b = CHAINS[chainId].contracts) === null || _b === void 0 ? void 0 : _b.mini_chef) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : ChefType.MINI_CHEF_V2;
    useEffect(() => {
        if (onLoadingOrComplete) {
            if (hash || attempting || confirmRemove) {
                onLoadingOrComplete(true);
            }
            else {
                onLoadingOrComplete(false);
            }
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [hash, attempting, confirmRemove]);
    function wrappedOnDismiss() {
        setHash(undefined);
        setAttempting(false);
        onClose();
    }
    function onWithdraw() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!contract || (version === 2 && !poolMap))
                return;
            if (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) {
                setAttempting(true);
                const method = version === 1 ? 'exit' : version === 2 ? 'withdrawAndHarvest' : 'withdraw';
                const args = version === 1
                    ? []
                    : version === 2
                        ? [
                            poolMap[stakingInfo.stakedAmount.token.address],
                            `0x${(_a = stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.raw.toString(16)}`,
                            account,
                        ]
                        : [stakingInfo.pid, `0x${(_b = stakingInfo.stakedAmount) === null || _b === void 0 ? void 0 : _b.raw.toString(16)}`];
                try {
                    const response = yield contract[method](...args);
                    yield waitForTransaction(response, 5);
                    addTransaction(response, {
                        summary: t('earn.withdrawDepositedLiquidity'),
                    });
                    yield refetchMinichefSubgraph();
                    setHash(response.hash);
                }
                catch (err) {
                    setAttempting(false);
                    const _err = err;
                    // we only care if the error is something _other_ than the user rejected the tx
                    if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                        console.error(err);
                    }
                }
            }
        });
    }
    let error;
    if (!account) {
        error = t('earn.connectWallet');
    }
    if (!(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
        error = error !== null && error !== void 0 ? error : t('earn.enterAmount');
    }
    const { earnedAmount } = useGetEarnedAmount(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const newEarnedAmount = version !== 2 ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount : earnedAmount;
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const cheftType = (_g = (_f = (_e = CHAINS[chainId].contracts) === null || _e === void 0 ? void 0 : _e.mini_chef) === null || _f === void 0 ? void 0 : _f.type) !== null && _g !== void 0 ? _g : ChefType.MINI_CHEF_V2;
    return (jsxs(FarmRemoveWrapper, {
        children: [!attempting && !hash && (jsx(Root$9, {
            children: !confirmRemove ? (jsxs(Fragment, {
                children: [jsx(Box, Object.assign({ flex: "1" }, {
                    children: jsxs(RewardWrapper, {
                        children: [(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) && (jsx(StatWrapper$1, { children: jsx(Stat, { title: t('earn.depositedToken', { symbol: 'ARL' }), stat: (_h = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _h === void 0 ? void 0 : _h.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [20, 18], titleColor: "text1", statAlign: "center" }) })), newEarnedAmount && (jsx(StatWrapper$1, { children: jsx(Stat, { title: t('earn.unclaimedReward', { symbol: png.symbol }), stat: newEarnedAmount === null || newEarnedAmount === void 0 ? void 0 : newEarnedAmount.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [20, 18], titleColor: "text1", statAlign: "center" }) })), isSuperFarm &&
                            (rewardTokensAmount === null || rewardTokensAmount === void 0 ? void 0 : rewardTokensAmount.map((rewardAmount, i) => {
                                var _a;
                                return (jsx(StatWrapper$1, { children: jsx(Stat, { title: t('earn.unclaimedReward', { symbol: (_a = rewardAmount === null || rewardAmount === void 0 ? void 0 : rewardAmount.token) === null || _a === void 0 ? void 0 : _a.symbol }), stat: rewardAmount === null || rewardAmount === void 0 ? void 0 : rewardAmount.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [20, 18], titleColor: "text1", statAlign: "center" }) }, i));
                            }))]
                    })
                })), jsx(Box, { children: jsx(Button, Object.assign({ variant: "primary", onClick: cheftType === ChefType.PANGO_CHEF && !confirmRemove ? () => setConfirmRemove(true) : onWithdraw }, { children: error !== null && error !== void 0 ? error : t('earn.withdrawAndClaim') })) })]
            })) : (jsxs(Box, Object.assign({ display: "grid", height: "100%" }, { children: [jsx(Box, Object.assign({ bgColor: "color3", borderRadius: "8px", padding: "15px", display: "flex", flexDirection: "column", justifyContent: "center" }, { children: jsx(Text, Object.assign({ color: "text1", textAlign: "center" }, { children: t(chefType === ChefType.PANGO_CHEF ? 'pangoChef.removeWarning' : 'earn.removeWarning') })) })), jsxs(Buttons$7, Object.assign({ chefType: chefType }, { children: [chefType === ChefType.PANGO_CHEF && (jsx(Button, Object.assign({ variant: "outline", onClick: redirectToCompound }, { children: jsx(Text, Object.assign({ color: "text1" }, { children: jsx(Text, Object.assign({ color: "text1" }, { children: t('sarCompound.compound') })) })) }))), jsx(Button, Object.assign({ variant: "primary", onClick: onWithdraw }, { children: error !== null && error !== void 0 ? error : t('earn.withdrawAndClaim') }))] }))] })))
        })), attempting && !hash && jsx(Loader, { size: 100, label: "Withdrawing & Claiming..." }), hash && (jsx(TransactionCompleted, { onClose: wrappedOnDismiss, submitText: t('pool.successWithdraw'), isShowButtton: true, onButtonClick: () => setShowRemoveLiquidityDrawer(true), buttonText: t('navigationTabs.removeLiquidity') })), isRemoveLiquidityDrawerVisible && (jsx(RemoveLiquidityDrawer, {
            isOpen: isRemoveLiquidityDrawerVisible, onClose: () => {
                setShowRemoveLiquidityDrawer(false);
                wrappedOnDismiss();
            }, clickedLpTokens: [token0, token1]
        }))]
    }));
};

const RemoveWrapper = styled(Box)`
  width: 100%;
  padding: 0px 10px 10px 10px;
  flex: 1;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;

var REMOVE_TYPE;
(function (REMOVE_TYPE) {
    REMOVE_TYPE["FARM"] = "Farm";
    REMOVE_TYPE["LIQUIDITY"] = "Liquidity";
})(REMOVE_TYPE || (REMOVE_TYPE = {}));
const Remove = ({ stakingInfo, version, onClose, redirectToCompound }) => {
    var _a;
    const chainId = useChainId();
    const [removeType, setRemoveType] = useState(((_a = stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.greaterThan('0')) ? REMOVE_TYPE.FARM : REMOVE_TYPE.LIQUIDITY);
    const [showRemoveTab, setShowRemoveTab] = useState(true);
    const { t } = useTranslation();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const currencyA = unwrappedToken(token0, chainId);
    const currencyB = unwrappedToken(token1, chainId);
    const { userLiquidity } = useDerivedBurnInfo(currencyA !== null && currencyA !== void 0 ? currencyA : undefined, currencyB !== null && currencyB !== void 0 ? currencyB : undefined);
    const renderRemoveContent = () => {
        if (!!userLiquidity && Number(userLiquidity === null || userLiquidity === void 0 ? void 0 : userLiquidity.toSignificant()) > 0) {
            return (jsx(RemoveLiquidity, {
                currencyA: currencyA, currencyB: currencyB, onLoadingOrComplete: (isLoadingOrComplete) => {
                    setShowRemoveTab(!isLoadingOrComplete);
                }
            }));
        }
        else {
            return (jsx(Box, Object.assign({ display: "flex", justifyContent: "center", alignItems: "center", height: "100%" }, { children: jsx(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, textAlign: "center" }, { children: t('pool.noLiquidity') })) })));
        }
    };
    return (jsxs(RemoveWrapper, {
        children: [showRemoveTab && (jsx(Box, Object.assign({ mt: "5px", width: "100%", mb: "5px" }, {
            children: jsx(ToggleButtons, {
                options: [REMOVE_TYPE.FARM, REMOVE_TYPE.LIQUIDITY], value: removeType, onChange: (value) => {
                    setRemoveType(value);
                }
            })
        }))), removeType === REMOVE_TYPE.FARM ? (jsx(RemoveFarm, {
            stakingInfo: stakingInfo, onClose: onClose, version: version, onLoadingOrComplete: (isLoadingOrComplete) => {
                setShowRemoveTab(!isLoadingOrComplete);
            }, redirectToCompound: redirectToCompound
        })) : (renderRemoveContent())]
    }));
};

const RemoveDrawer = ({ isOpen, onClose, stakingInfo, version, redirectToCompound }) => {
    const { t } = useTranslation();
    return (jsx(Drawer, Object.assign({ title: t('removeLiquidity.remove'), isOpen: isOpen, onClose: onClose }, { children: isOpen && (jsx(Remove, { stakingInfo: stakingInfo, onClose: onClose, version: version, redirectToCompound: redirectToCompound })) })));
};

const ClaimWrapper = styled(Box)`
  width: 100%;
  height: 100%;
`;
const Root$8 = styled(Box)`
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 0px 10px;
`;
styled(Box)`
  display: grid;
  grid-template-columns: ${({ isSuperFarm }) => isSuperFarm ? 'minmax(auto, 50%) minmax(auto, 50%)' : 'minmax(auto, 100%)'};
  grid-gap: 8px;
  justify-content: center;
`;
const ErrorWrapper$2 = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ErrorBox$2 = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const Buttons$6 = styled(Box)`
  display: grid;
  grid-gap: 10px;
  grid-template-columns: 1fr 1fr;
  margin-top: 10px;
  margin-bottom: 10px;
`;

const ClaimRewardV3 = ({ stakingInfo, onClose, redirectToCompound }) => {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = useTranslation();
    const theme = useContext(ThemeContext);
    const png = PNG[chainId];
    // monitor call to help UI loading state
    const addTransaction = useTransactionAdder();
    const [hash, setHash] = useState();
    const [attempting, setAttempting] = useState(false);
    const [claimError, setClaimError] = useState();
    const pangoChefContract = usePangoChefContract();
    function wrappedOnDismiss() {
        setHash(undefined);
        setAttempting(false);
        setClaimError(undefined);
        onClose();
    }
    function onClaimReward() {
        return __awaiter(this, void 0, void 0, function* () {
            if (pangoChefContract && (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
                setAttempting(true);
                try {
                    const method = stakingInfo.poolType === PoolType.RELAYER_POOL ? 'claim' : 'harvest';
                    const response = yield pangoChefContract[method](stakingInfo.pid);
                    yield waitForTransaction(response, 1);
                    addTransaction(response, {
                        summary: t('earn.claimAccumulated', { symbol: png.symbol }),
                    });
                    setHash(response.hash);
                }
                catch (error) {
                    const err = error;
                    // we only care if the error is something _other_ than the user rejected the tx
                    if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                        setClaimError(err === null || err === void 0 ? void 0 : err.message);
                        console.error(err);
                    }
                }
                finally {
                    setAttempting(false);
                }
            }
        });
    }
    let _error;
    if (!account) {
        _error = t('earn.connectWallet');
    }
    if (!(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
        _error = _error !== null && _error !== void 0 ? _error : t('earn.enterAmount');
    }
    return (jsxs(ClaimWrapper, { children: [!attempting && !hash && !claimError && (jsxs(Root$8, { children: [jsx(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", padding: "20px", bgColor: "color3", borderRadius: "8px", margin: "auto" }, { children: jsx(Text, Object.assign({ color: "text1", textAlign: "center" }, { children: t('pangoChef.claimWarning2') })) })), jsxs(Buttons$6, { children: [jsx(Button, Object.assign({ variant: "outline", onClick: onClaimReward, color: theme.text10 }, { children: _error !== null && _error !== void 0 ? _error : t('earn.claimReward', { symbol: png.symbol }) })), jsx(Button, Object.assign({ variant: "primary", onClick: redirectToCompound }, { children: t('sarCompound.compound') }))] })] })), claimError && (jsxs(ErrorWrapper$2, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxs(ErrorBox$2, { children: [jsx(AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'red1', textAlign: "center", style: { width: '85%' } }, { children: claimError }))] }), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] }))), attempting && !hash && jsx(Loader, { size: 100, label: `${t('sarClaim.pending')}...` }), hash && jsx(TransactionCompleted, { onClose: wrappedOnDismiss, submitText: "Your rewards claimed" })] }));
};

const CompoundWrapper = styled(Box)`
  width: 100%;
  height: 100%;
`;
const Root$7 = styled(Box)`
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 0px 10px 10px 10px !important;
`;
styled(Box)`
  display: grid;
  grid-gap: 8px;
  justify-content: center;
`;
const ErrorWrapper$1 = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ErrorBox$1 = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const Buttons$5 = styled(Box)`
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 10px;
  align-self: end;
`;

const CompoundV3 = ({ stakingInfo, onClose }) => {
    var _a, _b, _c;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = useTranslation();
    const theme = useContext(ThemeContext);
    // monitor call to help UI loading state
    const addTransaction = useTransactionAdder();
    const [confirm, setConfirm] = useState(false);
    const [hash, setHash] = useState();
    const [attempting, setAttempting] = useState(false);
    const [compoundError, setCompound] = useState();
    const pangoChefContract = usePangoChefContract();
    function wrappedOnDismiss() {
        setHash(undefined);
        setAttempting(false);
        setCompound(undefined);
        onClose();
    }
    const png = PNG[chainId];
    const wrappedCurrency = WAVAX[chainId];
    const currency = CAVAX[chainId];
    const [token0, token1] = stakingInfo.tokens;
    const [, pair] = usePair(token0, token1);
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const useETHBalances = useAccountBalanceHook[chainId];
    const currencyBalance = useETHBalances(chainId, [account !== null && account !== void 0 ? account : ZERO_ADDRESS]);
    const tokensBalances = useTokenBalances(account !== null && account !== void 0 ? account : ZERO_ADDRESS, [token0, token1]);
    const isPNGPool = token0.equals(png) || token1.equals(png);
    const isWrappedCurrencyPool = token0.equals(wrappedCurrency) || token1.equals(wrappedCurrency);
    const tokensToGetPrice = [token0, token1];
    if (!isPNGPool) {
        tokensToGetPrice.push(png);
    }
    const tokensPrices = useTokensCurrencyPrice(tokensToGetPrice);
    let message = '';
    let _error;
    if (!account) {
        _error = t('earn.connectWallet');
    }
    if (!(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) || stakingInfo.stakedAmount.equalTo('0')) {
        _error = _error !== null && _error !== void 0 ? _error : t('earn.enterAmount');
    }
    const earnedAmount = stakingInfo.earnedAmount;
    const pngPrice = (_a = tokensPrices[png.address]) !== null && _a !== void 0 ? _a : new Price(png, wrappedCurrency, '1', '0');
    let amountToAdd = new TokenAmount(wrappedCurrency, '0');
    // if is png pool and not is wrapped token as second token (eg PNG/USDC, PSB/SDOOD)
    if (isPNGPool && !isWrappedCurrencyPool) {
        // need to calculate the token price in png, for this we using the token price on currency and png price on currency
        const token = token0.equals(png) ? token1 : token0;
        const tokenBalance = tokensBalances[token.address];
        const tokenPrice = (_b = tokensPrices[token.address]) !== null && _b !== void 0 ? _b : new Price(token, wrappedCurrency, '1', '0');
        const tokenPngPrice = pngPrice.equalTo('0') ? new Fraction$1('0') : pngPrice.divide(tokenPrice);
        amountToAdd = new TokenAmount(token, tokenPngPrice.multiply(earnedAmount.raw).toFixed(0));
        if (amountToAdd.greaterThan(tokenBalance !== null && tokenBalance !== void 0 ? tokenBalance : '0')) {
            _error = _error !== null && _error !== void 0 ? _error : t('stakeHooks.insufficientBalance', { symbol: token.symbol });
        }
        message += `${t('pangoChef.compoundAmountWarning', {
            amount: numeral(amountToAdd.toFixed(2)).format('0.00a'),
            symbol: token.symbol,
        })} ${t('pangoChef.compoundAmountWarning2', {
            symbol: token.symbol,
            png: png.symbol,
        })}`;
    }
    else {
        amountToAdd = CurrencyAmount.ether(pngPrice.raw.multiply(earnedAmount.raw).toFixed(0), chainId);
        if (amountToAdd.greaterThan(currencyBalance ? (_c = currencyBalance[account !== null && account !== void 0 ? account : ZERO_ADDRESS]) !== null && _c !== void 0 ? _c : '0' : '0')) {
            _error = _error !== null && _error !== void 0 ? _error : t('stakeHooks.insufficientBalance', { symbol: currency.symbol });
        }
        message += t('pangoChef.compoundAmountWarning', {
            amount: numeral(amountToAdd.toFixed(2)).format('0.00a'),
            symbol: currency.symbol,
        });
    }
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = useState(false);
    const [approval, approveCallback] = useApproveCallback(chainId, amountToAdd, pangoChefContract === null || pangoChefContract === void 0 ? void 0 : pangoChefContract.address);
    useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const showApproveFlow = !_error &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED)) &&
        amountToAdd instanceof TokenAmount;
    const handleApprove = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        yield approveCallback();
    }), [approveCallback]);
    const userRewardRate = useUserPangoChefRewardRate(stakingInfo);
    /*
    Let's say you get 1 png per sec, and 1 png equals 1 avax.
    In 10 secs you have 10 png rewards. you make a tx to send 10 avax.
    5 more seconds pass until you do the transaction, so you have 15 png rewards, and it needs to be paired with 15 avax. so tx will revert. bad for ux.
    The less pending rewards you have the more pronounced the issue. so you have to wait an hour or so, such that the rewards you receive do not so rapidly increase in proportion to your pending rewards. that's why we have to grey it out.
  
    1% slippage we have to hard code, otherwise any tx changing the reserve amounts in the pool would make it revert.
    also even after an hour or so, the rewards keep consantly increase, so 0% slippage would never work.
    */
    if (!JSBI$1.greaterThan(JSBI$1.divide(earnedAmount.raw, JSBI$1.BigInt(userRewardRate.isZero() ? '1' : userRewardRate.toString())), JSBI$1.BigInt(30 * 55))) {
        _error = _error !== null && _error !== void 0 ? _error : t('pangoChef.highVolalityWarning');
    }
    const tokenOrCurrency = amountToAdd instanceof TokenAmount ? amountToAdd.token : amountToAdd.currency;
    // Minimium amount to compound
    if (JSBI$1.LE(amountToAdd.raw, parseUnits('0.0001', tokenOrCurrency.decimals).toString())) {
        _error = _error !== null && _error !== void 0 ? _error : t('pangoChef.highVolalityWarning');
    }
    function onCompound() {
        return __awaiter(this, void 0, void 0, function* () {
            if (pangoChefContract && (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) && pair && !_error) {
                setAttempting(true);
                try {
                    const method = isPNGPool ? 'compound' : 'compoundToPoolZero';
                    const minPairAmount = JSBI$1.BigInt(ONE_FRACTION.subtract(PANGOCHEF_COMPOUND_SLIPPAGE).multiply(amountToAdd.raw).toFixed(0));
                    const maxPairAmount = JSBI$1.BigInt(ONE_FRACTION.add(PANGOCHEF_COMPOUND_SLIPPAGE).multiply(amountToAdd.raw).toFixed(0));
                    // the minPairAmount and maxPairAmount is amount of other token/currency to sent to compound with slippage tolerance
                    const slippage = {
                        minPairAmount: JSBI$1.lessThan(minPairAmount, JSBI$1.BigInt(0)) ? '0x0' : `0x${minPairAmount.toString(16)}`,
                        maxPairAmount: `0x${maxPairAmount.toString(16)}`,
                    };
                    const estimatedGas = yield pangoChefContract.estimateGas[method](Number(stakingInfo.pid).toString(16), slippage, { value: amountToAdd instanceof TokenAmount ? '0x0' : `0x${maxPairAmount.toString(16)}` });
                    const response = yield pangoChefContract[method](Number(stakingInfo.pid).toString(16), slippage, {
                        gasLimit: calculateGasMargin(estimatedGas),
                        value: amountToAdd instanceof TokenAmount ? '0x0' : `0x${maxPairAmount.toString(16)}`,
                    });
                    yield waitForTransaction(response, 1);
                    addTransaction(response, {
                        summary: t('pangoChef.compoundTransactionSummary'),
                    });
                    setHash(response.hash);
                }
                catch (error) {
                    const err = error;
                    // we only care if the error is something _other_ than the user rejected the tx
                    if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                        setCompound(err === null || err === void 0 ? void 0 : err.message);
                        console.error(err);
                    }
                }
                finally {
                    setAttempting(false);
                }
            }
        });
    }
    const renderDrawer = () => {
        if (compoundError) {
            return (jsxs(ErrorWrapper$1, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxs(ErrorBox$1, { children: [jsx(AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'red1', textAlign: "center", style: { width: '85%' } }, { children: compoundError }))] }), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] })));
        }
        if (attempting) {
            return jsx(Loader, { size: 100, label: `${t('sarCompound.pending')}...` });
        }
        if (hash) {
            return jsx(TransactionCompleted, { onClose: wrappedOnDismiss, submitText: t('pangoChef.compoundSuccess') });
        }
    };
    const confirmContent = (jsxs(Box, Object.assign({ display: "grid", padding: "10px", style: { gap: '10px' }, height: "100%" }, { children: [jsx(TextInput, { addonAfter: jsx(Box, Object.assign({ padding: "5px", bgColor: "color2", borderRadius: "8px" }, { children: jsx(Text, Object.assign({ color: "text1" }, { children: tokenOrCurrency.symbol })) })), disabled: true, value: formatUnits(amountToAdd.raw.toString(), tokenOrCurrency.decimals) }), jsx(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", padding: "20px", bgColor: "color3", borderRadius: "8px", margin: "auto", width: "100%", flexGrow: 1 }, { children: jsx(Text, Object.assign({ color: "text1", textAlign: "center", fontSize: "12px" }, { children: message })) })), jsxs(Buttons$5, { children: [showApproveFlow && (jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', isDisabled: approval !== ApprovalState.NOT_APPROVED, onClick: handleApprove, height: "46px" }, { children: t('earn.approve') }))), jsx(Button, Object.assign({ variant: "primary", isDisabled: !!_error, onClick: onCompound }, { children: _error !== null && _error !== void 0 ? _error : `${t('sarStakeMore.add')} & ${t('sarCompound.compound')}` }))] })] })));
    return (jsx(CompoundWrapper, {
        children: !confirm ? (jsxs(Root$7, {
            children: [jsx(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", padding: "10px", bgColor: "color3", borderRadius: "8px", margin: "auto", flexGrow: 1 }, {
                children: jsx(Text, Object.assign({ color: "text1", textAlign: "center" }, {
                    children: t('pangoChef.compoundWarning', {
                        token0: currency0.symbol,
                        token1: currency1.symbol,
                        currency: isPNGPool ? currency0.symbol : currency.symbol,
                        png: isPNGPool ? currency1.symbol : png.symbol,
                    })
                }))
            })), jsx(Box, Object.assign({ width: "100%", mt: "10px" }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: () => setConfirm(true) }, { children: t('sarCompound.compound') })) }))]
        })) : !compoundError && !attempting && !hash ? (confirmContent) : (renderDrawer())
    }));
};

const Wrapper$8 = styled(Box)`
  width: 100%;
  position: relative;
  overflow: hidden;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.color2};
  margin-top: 10px;
  padding: 10px;
  height: 310px;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;
const InnerWrapper$3 = styled(Box)`
  display: grid;
  grid-template-columns: 50% 50%;
  grid-gap: 12px;
  margin-top: 10px;
`;
const Container = styled(Box)`
  display: grid;
  grid-gap: 5px;
  margin-top: 10px;
  flex: 1;
  width: 100%;
`;
const Buttons$4 = styled(Box)`
  display: grid;
  grid-gap: 10px;
  grid-template-columns: 1fr 1fr;
  margin-top: 10px;
`;

const EarnedDetailV3 = ({ stakingInfo, version }) => {
    var _a;
    const chainId = useChainId();
    const { t } = useTranslation();
    const [isClaimDrawerVisible, setShowClaimDrawer] = useState(false);
    const [isCompoundDrawerVisible, setShowCompoundDrawer] = useState(false);
    const [isRemoveDrawerVisible, setShowRemoveDrawer] = useState(false);
    const { rewardTokensAmount, rewardTokensMultiplier } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_a = (rewardTokensAmount || [])) === null || _a === void 0 ? void 0 : _a.length) > 0;
    const earnedAmount = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount;
    const redirectToCompound = () => {
        setShowClaimDrawer(false);
        setShowRemoveDrawer(false);
        setShowCompoundDrawer(true);
    };
    const onClose = () => {
        setShowClaimDrawer(false);
        setShowRemoveDrawer(false);
        setShowCompoundDrawer(false);
    };
    const drawerTitle = () => {
        if (isClaimDrawerVisible) {
            return t('earn.claim');
        }
        if (isRemoveDrawerVisible) {
            return t('removeLiquidity.remove');
        }
        return t('sarCompound.compound');
    };
    const theme = useContext(ThemeContext);
    const isDisabledButtons = !(earnedAmount === null || earnedAmount === void 0 ? void 0 : earnedAmount.greaterThan(BIG_INT_ZERO));
    const png = PNG[chainId];
    const lockingPoolZeroPairs = useIsLockingPoolZero();
    const isLockingToPoolZero = lockingPoolZeroPairs.length > 0 && stakingInfo.pid === '0';
    return (jsxs(Wrapper$8, {
        children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: t('dashboardPage.earned') })), jsx(Button, Object.assign({ variant: "primary", width: "100px", height: "30px", onClick: () => setShowRemoveDrawer(true), isDisabled: isLockingToPoolZero }, { children: t('removeLiquidity.remove') }))] })), jsxs(Container, {
            children: [jsxs(Box, Object.assign({ width: "100%" }, { children: [jsx(Text, Object.assign({ fontSize: "12px", color: "text1", textAlign: "center" }, { children: t('earn.unclaimedReward', { symbol: png.symbol }) })), jsx(Tooltip, Object.assign({ id: "earnedAmount", effect: "solid", backgroundColor: theme.primary }, { children: jsxs(Text, Object.assign({ color: "eerieBlack", fontSize: "12px", fontWeight: 500, textAlign: "center" }, { children: [formatEther(earnedAmount.raw.toString()), " ", png.symbol] })) })), jsx(Text, Object.assign({ color: "text1", fontSize: "16px", fontWeight: 700, textAlign: "center", "data-tip": true, "data-for": "earnedAmount" }, { children: earnedAmount.toFixed(2) }))] })), isSuperFarm && (jsx(Fragment, {
                children: (rewardTokensAmount || []).map((reward, index) => {
                    var _a, _b, _c, _d;
                    const tokenMultiplier = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier[index];
                    const extraTokenWeeklyRewardRate = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getExtraTokensWeeklyRewardRate) === null || _a === void 0 ? void 0 : _a.call(stakingInfo, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek, reward === null || reward === void 0 ? void 0 : reward.token, tokenMultiplier);
                    return (jsxs(InnerWrapper$3, { children: [jsx(Box, { children: jsx(Stat, { stat: `${(_b = extraTokenWeeklyRewardRate === null || extraTokenWeeklyRewardRate === void 0 ? void 0 : extraTokenWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })) !== null && _b !== void 0 ? _b : '-'} `, statFontSize: [20, 18], currency: reward === null || reward === void 0 ? void 0 : reward.token }) }), jsx(Box, { children: jsx(Stat, { stat: `${(_d = reward === null || reward === void 0 ? void 0 : reward.toFixed(Math.min(6, (_c = reward.token) === null || _c === void 0 ? void 0 : _c.decimals))) !== null && _d !== void 0 ? _d : '0'}`, statFontSize: [20, 18], currency: reward === null || reward === void 0 ? void 0 : reward.token }) })] }, index));
                })
            })), jsx(Box, Object.assign({ bgColor: "color3", borderRadius: "8px", padding: "20px", justifyContent: "center", alignItems: "center", display: "flex" }, {
                children: jsx(Text, Object.assign({ fontSize: "12px", color: "text1", textAlign: "center" }, {
                    children: isLockingToPoolZero
                        ? `${t('pangoChef.lockingPoolZeroWarning')}${lockingPoolZeroPairs
                            .map((pair) => `${unwrappedToken(pair[0], chainId).symbol}-${unwrappedToken(pair[1], chainId).symbol}`)
                            .join(', ')}.`
                        : t('pangoChef.claimWarning1')
                }))
            }))]
        }), jsxs(Buttons$4, { children: [jsx(Button, Object.assign({ padding: "10px", variant: "outline", isDisabled: isDisabledButtons || isLockingToPoolZero, onClick: () => setShowClaimDrawer(true), color: !isDisabledButtons && !isLockingToPoolZero ? theme.text10 : undefined }, { children: t('earnPage.claim') })), jsx(Button, Object.assign({ padding: "10px", isDisabled: isDisabledButtons, variant: "primary", onClick: () => setShowCompoundDrawer(true) }, { children: t('sarCompound.compound') }))] }), jsxs(Drawer, Object.assign({ title: drawerTitle(), isOpen: isClaimDrawerVisible || isCompoundDrawerVisible, onClose: onClose }, { children: [isClaimDrawerVisible && (jsx(ClaimRewardV3, { onClose: () => setShowClaimDrawer(false), redirectToCompound: redirectToCompound, stakingInfo: stakingInfo })), isCompoundDrawerVisible && (jsx(CompoundV3, { onClose: () => setShowCompoundDrawer(false), stakingInfo: stakingInfo }))] })), jsx(RemoveDrawer, {
            isOpen: isRemoveDrawerVisible, onClose: () => {
                setShowRemoveDrawer(false);
            }, stakingInfo: stakingInfo, version: version, redirectToCompound: redirectToCompound
        })]
    }));
};

const StateContainer = styled.div`
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  display: grid;
  width: 100%;
  align-items: start;
  margin-top: 12px;

  @media screen and (max-width: 1024px) {
    grid-template-columns: 1fr;
    align-items: stretch;
  }

  ${({ theme }) => theme.mediaWidth.upToSmall`
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    grid-column-gap: 6px;
    grid-row-gap:6px;
  `};
`;

function StatDetail({ title, totalAmount, pair, arl, currency0, currency1, link }) {
    const totalPoolTokens = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);
    const [token0Deposited, token1Deposited] = !!pair &&
        !!totalPoolTokens &&
        !!arl &&
        JSBI$1.greaterThan(totalPoolTokens.raw, BIG_INT_ZERO) &&
        JSBI$1.greaterThan(arl.raw, BIG_INT_ZERO) &&
        // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply
        JSBI$1.greaterThanOrEqual(totalPoolTokens.raw, arl.raw)
        ? pair.getLiquidityValues(totalPoolTokens, arl, { feeOn: false })
        : [undefined, undefined];
    return (jsxs(Box, { children: [jsxs(Text, Object.assign({ color: "text1", fontSize: 24, fontWeight: 400, style: { display: 'flex', gap: '1rem' } }, { children: [title, link && (jsx(AnalyticsLink, Object.assign({ href: link, target: "_blank" }, { children: jsx("img", { src: AnalyticsIcon, alt: "analytics-icon" }) })))] })), jsxs(StateContainer, { children: [jsx(Stat, { title: title, stat: totalAmount !== null && totalAmount !== void 0 ? totalAmount : '-', titlePosition: "top", titleFontSize: 12, statFontSize: [20, 16], titleColor: "text2" }), currency0 && (jsx(Stat, { title: `Underlying ${(currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol) ? currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol : ''}`, stat: `${token0Deposited ? numeral(parseFloat(token0Deposited === null || token0Deposited === void 0 ? void 0 : token0Deposited.toSignificant(6))).format('0.00a') : '-'}`, titlePosition: "top", titleFontSize: 12, statFontSize: [20, 16], titleColor: "text2", currency: currency0, showAnalytics: true })), currency1 && (jsx(Stat, { title: `Underlying ${(currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol) ? currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol : ''}`, stat: `${token1Deposited ? numeral(parseFloat(token1Deposited === null || token1Deposited === void 0 ? void 0 : token1Deposited.toSignificant(6))).format('0.00a') : '-'}`, titlePosition: "top", titleFontSize: 12, statFontSize: [20, 16], titleColor: "text2", currency: currency1, showAnalytics: true }))] })] }));
}

const DetailsContainer = styled(Box)`
  overflow: hidden;
  width: 100%;
  background-color: ${({ theme }) => theme.bg2};
  padding: 20px;
  flex: 1;
  display: flex;
  flex-direction: column;
`;

const Details = ({ stakingInfo }) => {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const token0 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[0];
    const token1 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[1];
    const chainId = useChainId();
    const totalStakedInUsd = ((_a = CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet)
        ? numeral(stakingInfo.totalStakedInUsd.toSignificant(4)).format('$0.00a')
        : numeral(stakingInfo.totalStakedInUsd).format('$0.00a');
    const yourStakeInUsd = ((_b = CHAINS[chainId]) === null || _b === void 0 ? void 0 : _b.mainnet)
        ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd.multiply(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount).divide(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount)
        : undefined;
    const [, stakingTokenPair] = usePair(token0, token1);
    const pair = stakingTokenPair;
    const { userPgl, liquidityInUSD } = useGetPoolDollerWorth(pair);
    const isStaking = Boolean(stakingInfo.stakedAmount.greaterThan('0'));
    // if pair is available then taking tokens from pair otherwise display tokens from staking info
    // we are taking token from pair because sometime order of tokens is different
    const tokenA = (pair === null || pair === void 0 ? void 0 : pair.token0) || token0;
    const tokenB = (pair === null || pair === void 0 ? void 0 : pair.token1) || token1;
    const currency0 = tokenA ? unwrappedToken(tokenA, chainId) : undefined;
    const currency1 = tokenB ? unwrappedToken(tokenB, chainId) : undefined;
    const yourLiquidity = liquidityInUSD ? `${numeral(liquidityInUSD).format('$0.00a')}` : '-';
    return (jsx(Fragment, { children: jsxs(DetailsContainer, { children: [jsx(StatDetail, { title: `Total Stake`, currency0: currency0, currency1: currency1, pair: pair, totalAmount: `${totalStakedInUsd}`, arl: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount, link: `${ANALYTICS_PAGE}/#/pair/${pair === null || pair === void 0 ? void 0 : pair.liquidityToken.address}` }), (userPgl === null || userPgl === void 0 ? void 0 : userPgl.greaterThan('0')) && (jsx(Box, Object.assign({ mt: 25 }, { children: jsx(StatDetail, { title: `Your Liquidity`, currency0: currency0, currency1: currency1, pair: pair, totalAmount: yourLiquidity, arl: userPgl, link: `${ANALYTICS_PAGE}/#/account/${account}` }) }))), isStaking && (jsx(Box, Object.assign({ mt: 25 }, { children: jsx(StatDetail, { title: `Your Stake`, currency0: currency0, currency1: currency1, pair: pair, totalAmount: `${numeral(yourStakeInUsd === null || yourStakeInUsd === void 0 ? void 0 : yourStakeInUsd.toFixed(2)).format('$0.00a')}`, arl: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount, link: `${ANALYTICS_PAGE}/#/account/${account}` }) }))), currency0 !== CAVAX[chainId] && currency0 instanceof Token$1 && (jsx(Box, Object.assign({ mt: 20 }, { children: jsx(CoinDescription, { coin: currency0 }) }))), currency1 !== CAVAX[chainId] && currency1 instanceof Token$1 && (jsx(Box, Object.assign({ mt: 20 }, { children: jsx(CoinDescription, { coin: currency1 }) })))] }) }));
};

const Wrapper$7 = styled(Box)`
  width: 100%;
  position: relative;
  overflow: hidden;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg2};
  margin-top: 10px;
  padding: 10px;
  height: 295px;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;
const InnerWrapper$2 = styled(Box)`
  display: grid;
  grid-template-columns: 50% 50%;
  grid-gap: 12px;
  margin-top: 10px;
`;

const EarnedDetail = ({ stakingInfo, version }) => {
    var _a, _b, _c, _d;
    const { t } = useTranslation();
    const chainId = useChainId();
    const [isClaimDrawerVisible, setShowClaimDrawer] = useState(false);
    const [isRemoveDrawerVisible, setShowRemoveDrawer] = useState(false);
    const { rewardTokensAmount, rewardTokensMultiplier } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_a = (rewardTokensAmount || [])) === null || _a === void 0 ? void 0 : _a.length) > 0;
    const png = PNG[chainId]; // add PNG as default reward
    const { earnedAmount } = useGetEarnedAmount(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const newEarnedAmount = version < 2 ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount : earnedAmount;
    return (jsxs(Wrapper$7, {
        children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center" }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: t('dashboardPage.earned') })), jsx(Button, Object.assign({ variant: "primary", width: "100px", height: "30px", onClick: () => setShowRemoveDrawer(true) }, { children: t('removeLiquidity.remove') }))] })), jsxs(Box, Object.assign({ flex: "1" }, {
            children: [jsxs(InnerWrapper$2, { children: [jsx(Box, { children: jsx(Stat, { title: t('dashboardPage.earned_weeklyIncome'), stat: `${(_c = (_b = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek) === null || _b === void 0 ? void 0 : _b.toSignificant(4, { groupSeparator: ',' })) !== null && _c !== void 0 ? _c : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 18], titleColor: "text2", currency: png }) }), jsx(Box, { children: jsx(Stat, { title: t('dashboardPage.earned_totalEarned'), stat: `${(_d = newEarnedAmount === null || newEarnedAmount === void 0 ? void 0 : newEarnedAmount.toFixed(6)) !== null && _d !== void 0 ? _d : '0'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 18], titleColor: "text2", currency: png }) })] }), isSuperFarm && (jsx(Fragment, {
                children: (rewardTokensAmount || []).map((reward, index) => {
                    var _a, _b, _c, _d;
                    const tokenMultiplier = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier[index];
                    const extraTokenWeeklyRewardRate = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getExtraTokensWeeklyRewardRate) === null || _a === void 0 ? void 0 : _a.call(stakingInfo, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek, reward === null || reward === void 0 ? void 0 : reward.token, tokenMultiplier);
                    return (jsxs(InnerWrapper$2, { children: [jsx(Box, { children: jsx(Stat, { stat: `${(_b = extraTokenWeeklyRewardRate === null || extraTokenWeeklyRewardRate === void 0 ? void 0 : extraTokenWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })) !== null && _b !== void 0 ? _b : '-'} `, statFontSize: [20, 18], currency: reward === null || reward === void 0 ? void 0 : reward.token }) }), jsx(Box, { children: jsx(Stat, { stat: `${(_d = reward === null || reward === void 0 ? void 0 : reward.toFixed(Math.min(6, (_c = reward.token) === null || _c === void 0 ? void 0 : _c.decimals))) !== null && _d !== void 0 ? _d : '0'}`, statFontSize: [20, 18], currency: reward === null || reward === void 0 ? void 0 : reward.token }) })] }, index));
                })
            }))]
        })), jsx(Box, Object.assign({ mt: 10 }, { children: jsx(Button, Object.assign({ padding: "15px 18px", isDisabled: !(newEarnedAmount === null || newEarnedAmount === void 0 ? void 0 : newEarnedAmount.greaterThan(BIG_INT_ZERO)), variant: "primary", onClick: () => setShowClaimDrawer(true) }, { children: t('earnPage.claim') })) })), jsx(ClaimDrawer, {
            isOpen: isClaimDrawerVisible, onClose: () => {
                setShowClaimDrawer(false);
            }, stakingInfo: stakingInfo, version: version
        }), jsx(RemoveDrawer, {
            isOpen: isRemoveDrawerVisible, onClose: () => {
                setShowRemoveDrawer(false);
            }, stakingInfo: stakingInfo, version: version
        })]
    }));
};

const HeaderRoot = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px;
  border-bottom: 1px solid ${({ theme }) => theme.text9};

  ${({ theme }) => theme.mediaWidth.upToSmall`
    border-bottom: none;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
  `};
`;
const StatsWrapper = styled(Box)`
  display: grid;
  grid-template-columns: repeat(${({ cheftType }) => (cheftType === ChefType.PANGO_CHEF ? 6 : 5)}, auto);
  grid-gap: 20px;
  align-items: center;
  ${({ theme }) => theme.mediaWidth.upToSmall`
    width: 100%;
    grid-gap: 10px;
    margin-top: 10px;
    grid-template-columns: 50% 50%;
`};
`;
const HeaderWrapper = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: space-between;
  ${({ theme }) => theme.mediaWidth.upToSmall`
    width: 100%
  `};
`;

const Header$1 = ({ stakingInfo, version, onClose }) => {
    var _a, _b, _c;
    const theme = useContext(ThemeContext);
    const chainId = useChainId();
    const { t } = useTranslation();
    const token0 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[0];
    const token1 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[1];
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const rewardTokens = useGetRewardTokens(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokens, stakingInfo.rewardTokensAddress);
    const { swapFeeApr: _swapFeeApr, stakingApr: _stakingApr } = useGetFarmApr(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const stakingApr = version !== 2 ? (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakingApr) || 0 : _stakingApr;
    const swapFeeApr = version !== 2 ? (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.swapFeeApr) || 0 : _swapFeeApr;
    const totalApr = stakingApr + swapFeeApr;
    const cheftType = (_c = (_b = (_a = CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : ChefType.MINI_CHEF_V2;
    // old calculation, it's using if the userRewardRate is not broken
    //userApr = userRewardRate(POOL_ID, USER_ADDRESS) * 365 days * 100 * PNG_PRICE / (getUser(POOL_ID, USER_ADDRESS).valueVariables.balance * STAKING_TOKEN_PRICE)
    const userApr = useUserPangoChefAPR(cheftType === ChefType.PANGO_CHEF ? stakingInfo : undefined);
    return (jsxs(HeaderRoot, { children: [jsxs(HeaderWrapper, { children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsx(DoubleCurrencyLogo, { currency0: currency0, currency1: currency1, size: 48 }), jsxs(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500, marginLeft: 10 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] }))] })), jsx(Visible, Object.assign({ upToSmall: true }, { children: jsx(CloseIcon, { onClick: onClose, color: theme.text3 }) }))] }), jsxs(StatsWrapper, Object.assign({ cheftType: cheftType }, { children: [jsxs(Box, Object.assign({ display: "inline-block" }, { children: [jsx(Text, Object.assign({ color: "text2", fontSize: 14 }, { children: t('earn.poolRewards') })), jsx(Box, Object.assign({ display: "flex", alignItems: "center", mt: "8px" }, { children: jsx(RewardTokens, { rewardTokens: rewardTokens, size: 24 }) }))] })), cheftType === ChefType.PANGO_CHEF && stakingInfo.stakedAmount.greaterThan('0') && (jsx(Stat, { title: `Your APR:`, stat: `${numeral(userApr).format('0.00a')}%`, titlePosition: "top", titleFontSize: 14, statFontSize: [24, 18], titleColor: "text2" })), jsx(Stat, { title: `Swap fee APR:`, stat: swapFeeApr && !stakingInfo.isPeriodFinished ? `${numeral(swapFeeApr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: 14, statFontSize: [24, 18], titleColor: "text2" }), jsx(Stat, { title: `Reward APR:`, stat: !stakingInfo.isPeriodFinished ? `${numeral(stakingApr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: 14, statFontSize: [24, 18], titleColor: "text2" }), jsx(Stat, { title: `Total APR:`, stat: !stakingInfo.isPeriodFinished ? `${numeral(totalApr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: 14, statFontSize: [24, 18], titleColor: "text2" }), jsx(Hidden, Object.assign({ upToSmall: true }, { children: jsx(CloseIcon, { onClick: onClose, color: theme.text3 }) }))] }))] }));
};

const DesktopWrapper = styled(Box)`
  width: 1080px;
  overflow: auto;
  border-radius: 10px;
  ${({ theme }) => theme.mediaWidth.upToSmall`
    display: none;
  `};
  * {
    box-sizing: border-box;
  }
`;
const MobileWrapper = styled(Box)`
  width: 100%;
  height: 100%;
  display: none;
  ${({ theme }) => theme.mediaWidth.upToSmall`
  display: block;
  overflow: scroll;
`};
`;
const LeftSection = styled(Box)`
  border-right: 2px solid ${({ theme }) => theme.text9};
  display: flex;
  flex-direction: column;
`;
const DetailsWrapper = styled(Box)`
  display: grid;
  grid-template-columns: minmax(auto, 65%) minmax(auto, 35%);
  grid-gap: 0px;
`;
const Tabs$1 = styled(Box)`
  width: 100%;
  display: flex;
  align-items: center;
`;
const Tab$1 = styled(Box)`
  padding: 15px 50px;
  font-size: 18px;
  color: ${({ theme }) => theme.text10};
  background-color: ${({ theme }) => theme.bg2};

  ${({ theme }) => theme.mediaWidth.upToSmall`
    border-radius: 10px 10px 0 0;
  `};
`;
const RightSection = styled(Box)`
  padding: 20px;
`;

const DetailView = ({ stakingInfo, onDismiss, version }) => {
    var _a;
    const { height } = useWindowSize();
    const chainId = useChainId();
    const chain = CHAINS[chainId];
    const token0 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[0];
    const token1 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[1];
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const isStaking = Boolean((_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.greaterThan('0'));
    const renderEarnedDetail = () => {
        var _a, _b;
        const miniChefType = (_b = (_a = chain.contracts) === null || _a === void 0 ? void 0 : _a.mini_chef) === null || _b === void 0 ? void 0 : _b.type;
        if (miniChefType === ChefType.PANGO_CHEF) {
            return jsx(EarnedDetailV3, { stakingInfo: stakingInfo, version: version });
        }
        return jsx(EarnedDetail, { stakingInfo: stakingInfo, version: version });
    };
    return (jsxs(Fragment, { children: [jsxs(MobileWrapper, { children: [jsx(Header$1, { stakingInfo: stakingInfo, version: version, onClose: onDismiss }), jsxs(Box, Object.assign({ p: 10 }, { children: [isStaking && renderEarnedDetail(), jsx(Box, Object.assign({ mt: isStaking ? '10px' : '0px' }, { children: jsx(EarnWidget, { currencyA: currency0, currencyB: currency1, version: version, stakingInfo: stakingInfo }) })), jsxs(Box, Object.assign({ mt: 25 }, { children: [jsx(Tabs$1, { children: jsx(Tab$1, { children: "Details" }) }), jsx(Details, { stakingInfo: stakingInfo })] }))] }))] }), jsxs(DesktopWrapper, Object.assign({ style: { maxHeight: height - 150 } }, { children: [jsx(Header$1, { stakingInfo: stakingInfo, version: version, onClose: onDismiss }), jsxs(DetailsWrapper, { children: [jsxs(LeftSection, { children: [jsx(Tabs$1, { children: jsx(Tab$1, { children: "Details" }) }), jsx(Details, { stakingInfo: stakingInfo })] }), jsxs(RightSection, { children: [jsx(EarnWidget, { currencyA: currency0, currencyB: currency1, version: version, stakingInfo: stakingInfo }), isStaking && renderEarnedDetail()] })] })] }))] }));
};

const DetailModal = ({ stakingInfo, version }) => {
    const detailModalOpen = useModalOpen(ApplicationModal.POOL_DETAIL);
    const togglePoolDetailModal = usePoolDetailnModalToggle();
    const theme = useContext(ThemeContext);
    const dispatch = useDispatch();
    useEffect(() => {
        dispatch(resetMintState());
    }, [detailModalOpen, dispatch]);
    return (jsx(Modal, Object.assign({ isOpen: detailModalOpen, onDismiss: togglePoolDetailModal, overlayBG: theme.modalBG2, closeOnClickOutside: false }, { children: jsx(DetailView, { stakingInfo: stakingInfo, onDismiss: togglePoolDetailModal, version: version }) })));
};

const PoolsWrapper = styled(Box)`
  width: 100%;
  background-color: ${({ theme }) => theme.color8};
  padding: 10px;
  border-radius: 0px;
  overflow: hidden;
  color: ${({ theme }) => theme.text7};
  ${({ theme }) => theme.mediaWidth.upToSmall`
    padding-bottom : 50px;
  `};
`;
const LoadingWrapper = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
`;
const PanelWrapper$1 = styled.div`
  grid-template-columns: repeat(auto-fill, minmax(360px, 1fr));
  grid-template-rows: max-content;
  gap: 15px;
  display: inline-grid;
  width: 100%;
  align-items: start;
  padding-bottom: 65px;

  @media screen and (max-width: 1024px) {
    grid-template-columns: 1fr;
    align-items: stretch;
    > * {
      grid-column: 1 / 4;
    }

    > * {
      &:first-child {
        width: 100%;
      }
    }
  }
`;
styled(TextInput)`
  background-color: ${({ theme }) => theme.bg8};
`;
const MobileGridContainer = styled(Box)`
  display: none;
  ${({ theme }) => theme.mediaWidth.upToSmall`
    display: grid;
    grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
    grid-gap: 8px;
    margin-bottom : 10px;
  `};
`;

var SortingType;
(function (SortingType) {
    SortingType["totalStakedInUsd"] = "totalStakedInUsd";
    SortingType["totalApr"] = "totalApr";
})(SortingType || (SortingType = {}));
const SortOptions = [
    {
        label: 'Liquidity',
        value: SortingType.totalStakedInUsd,
    },
    {
        label: 'APR',
        value: SortingType.totalApr,
    },
];
const PoolCardListView = ({ version, setMenu, activeMenu, menuItems, handleSearch, sortBy, searchQuery, onChangeSortBy, isLoading, doesNotPoolExist, children, selectedPool, }) => {
    const { t } = useTranslation();
    const theme = useContext(ThemeContext);
    const renderPoolCardListView = () => {
        if (isLoading && !searchQuery)
            return (jsx(LoadingWrapper, {}));
        else if (doesNotPoolExist && !searchQuery) {
            return (jsx(Box, Object.assign({ textAlign: "center", color: "color4" }, { children: t('earnPage.noActiveRewards') })));
        }
        else {
            return (jsxs(Fragment, {
                children: [jsxs(Box, {
                    children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", mb: 10 }, {
                        children: [jsx(Box, Object.assign({ width: "100%" }, { children: jsx(TextInput, { placeholder: t('searchModal.tokenName'), onChange: handleSearch, value: searchQuery, id: "token-search-input", addonAfter: jsx(Search, { style: { marginTop: '5px' }, color: theme.text2, size: 20 }) }) })), jsx(Hidden, Object.assign({ upToSmall: true }, {
                            children: jsx(Box, Object.assign({ ml: 10 }, {
                                children: jsx(DropdownMenu, {
                                    placeHolder: "Sort by:", options: SortOptions, defaultValue: sortBy, onSelect: (value) => {
                                        onChangeSortBy(value);
                                    }, height: "54px"
                                })
                            }))
                        }))]
                    })), jsxs(MobileGridContainer, {
                        children: [jsx(DropdownMenu, {
                            options: menuItems, defaultValue: activeMenu, onSelect: (value) => {
                                setMenu(value);
                            }
                        }), jsx(DropdownMenu, {
                            placeHolder: "Sort by:", options: SortOptions, defaultValue: sortBy, onSelect: (value) => {
                                onChangeSortBy(value);
                            }
                        })]
                    })]
                }), doesNotPoolExist && searchQuery ? (jsx(Box, Object.assign({ textAlign: "center", color: "color4" }, { children: t('pool.noFarms') }))) : (jsx(Scrollbars, { children: jsx(PanelWrapper$1, { children: children }) }))]
            }));
        }
    };
    return (jsxs(PoolsWrapper, { children: [renderPoolCardListView(), jsx(DetailModal, { stakingInfo: selectedPool, version: Number(version) })] }));
};

const PoolListV1 = ({ version, stakingInfos, setMenu, activeMenu, menuItems }) => {
    const chainId = useChainId();
    const [poolCardsLoading, setPoolCardsLoading] = useState(false);
    const [poolCards, setPoolCards] = useState();
    const [filteredPoolCards, setFilteredPoolCards] = useState();
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState('');
    const debouncedSearchQuery = useDebounce(searchQuery, 250);
    const [stakingInfoData, setStakingInfoData] = useState(stakingInfos);
    const [selectedPoolIndex, setSelectedPoolIndex] = useState(-1);
    const togglePoolDetailModal = usePoolDetailnModalToggle();
    const handleSearch = useCallback((value) => {
        setSearchQuery(value.trim().toUpperCase());
    }, []);
    useEffect(() => {
        const filtered = poolCards === null || poolCards === void 0 ? void 0 : poolCards.filter((card) => {
            var _a, _b, _c, _d;
            return ((_b = (_a = card === null || card === void 0 ? void 0 : card.props) === null || _a === void 0 ? void 0 : _a.stakingInfo) === null || _b === void 0 ? void 0 : _b.tokens[0].symbol.toUpperCase().includes(debouncedSearchQuery)) ||
                ((_d = (_c = card === null || card === void 0 ? void 0 : card.props) === null || _c === void 0 ? void 0 : _c.stakingInfo) === null || _d === void 0 ? void 0 : _d.tokens[1].symbol.toUpperCase().includes(debouncedSearchQuery));
        });
        setFilteredPoolCards(filtered);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [poolCards, debouncedSearchQuery]);
    useEffect(() => {
        Promise.all(stakingInfoData.sort(function (info_a, info_b) {
            var _a, _b;
            if (sortBy === SortingType.totalStakedInUsd) {
                return ((_a = info_a.totalStakedInUsd) === null || _a === void 0 ? void 0 : _a.greaterThan((_b = info_b.totalStakedInUsd) !== null && _b !== void 0 ? _b : BIG_INT_ZERO)) ? -1 : 1;
            }
            if (sortBy === SortingType.totalApr) {
                return info_a.stakingApr + info_a.swapFeeApr > info_b.stakingApr + info_b.swapFeeApr ? -1 : 1;
            }
            return 0;
        })).then((newStakingInfoData) => {
            const newPoolCards = newStakingInfoData.map((stakingInfo, index) => {
                return (jsx(PoolCardV1, {
                    stakingInfo: stakingInfo, onClickViewDetail: () => {
                        // let container = {} as { [address: string]: { staking: StakingInfo } }
                        // container[stakingInfo.stakingRewardAddress] = stakingInfo
                        setSelectedPoolIndex(index);
                        togglePoolDetailModal();
                    }, version: Number(version)
                }, index));
            });
            setPoolCards(newPoolCards);
        });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [sortBy, stakingInfoData]);
    useEffect(() => {
        setPoolCardsLoading(true);
        if ((stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length) > 0) {
            const filteredStakingInfos = stakingInfos
                .filter(function (info) {
                    // Only include pools that are live or require a migration
                    return !info.isPeriodFinished || info.stakedAmount.greaterThan(BIG_INT_ZERO);
                })
                .sort(sortingOnAvaxStake)
                .sort(sortingOnStakedAmount);
            const pids = filteredStakingInfos.map((stakingInfo) => stakingInfo.stakingRewardAddress);
            fetchChunkedAprs(pids, chainId)
                .then((aprResponses) => {
                    return filteredStakingInfos.map((filteredStakingInfo, i) => (Object.assign(Object.assign({}, filteredStakingInfo), aprResponses[i])));
                })
                .then((updatedStakingInfos) => {
                    const sortedPoolCards = updatedStakingInfos.map((stakingInfo, index) => {
                        return (jsx(PoolCardV1, {
                            stakingInfo: stakingInfo, onClickViewDetail: () => {
                                // let container = {} as { [address: string]: { staking: StakingInfo } }
                                // container[stakingInfo.stakingRewardAddress] = { staking: stakingInfo }
                                setSelectedPoolIndex(index);
                                togglePoolDetailModal();
                            }, version: Number(version)
                        }, index));
                    });
                    setStakingInfoData(updatedStakingInfos);
                    setPoolCards(sortedPoolCards);
                })
                .finally(() => {
                    setPoolCardsLoading(false);
                });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length, chainId, version]);
    const selectedPool = selectedPoolIndex !== -1 ? stakingInfoData[selectedPoolIndex] : undefined;
    return (jsx(PoolCardListView, Object.assign({ version: version, setMenu: setMenu, activeMenu: activeMenu, menuItems: menuItems, handleSearch: handleSearch, onChangeSortBy: setSortBy, sortBy: sortBy, searchQuery: searchQuery, isLoading: (stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length) === 0 || poolCardsLoading, doesNotPoolExist: (poolCards === null || poolCards === void 0 ? void 0 : poolCards.length) === 0 && !poolCardsLoading, selectedPool: selectedPool }, { children: filteredPoolCards })));
};

const PoolV1 = ({ type, stakingInfos, setMenu, activeMenu, menuItems }) => {
    if (type === PoolType$1.own) {
        stakingInfos = (stakingInfos || []).filter((stakingInfo) => {
            return Boolean(stakingInfo.stakedAmount.greaterThan('0'));
        });
    }
    return (jsx(PoolListV1, { version: "1", stakingInfos: stakingInfos, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems }));
};

const PoolCardV2 = ({ stakingInfo, onClickViewDetail, version }) => {
    const { combinedApr } = useGetFarmApr(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const { earnedAmount } = useGetEarnedAmount(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const rewardTokens = useGetRewardTokens(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokens, stakingInfo.rewardTokensAddress);
    return (jsx(PoolCardView, { combinedApr: combinedApr, earnedAmount: earnedAmount, rewardTokens: rewardTokens, stakingInfo: stakingInfo, onClickViewDetail: onClickViewDetail, version: version }));
};

const PoolListV2 = ({ version, stakingInfos, setMenu, activeMenu, menuItems }) => {
    const [poolCardsLoading] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState('');
    const debouncedSearchQuery = useDebounce(searchQuery, 250);
    const [stakingInfoData, setStakingInfoData] = useState([]);
    const [stakingInfoByPid, setStakingInfoByPid] = useState({});
    const [selectedPoolIndex, setSelectedPoolIndex] = useState('');
    const togglePoolDetailModal = usePoolDetailnModalToggle();
    // fetch farms earned amount
    useUpdateAllFarmsEarnAmount();
    // fetch farms apr
    useFetchFarmAprs();
    const sortedFarmsApr = useSortFarmAprs();
    const handleSearch = useCallback((value) => {
        setSearchQuery(value.trim());
    }, []);
    useEffect(() => {
        if (sortBy === SortingType.totalStakedInUsd) {
            const sortedFarms = [...stakingInfoData].sort(function (info_a, info_b) {
                var _a, _b;
                return ((_a = info_a.totalStakedInUsd) === null || _a === void 0 ? void 0 : _a.greaterThan((_b = info_b.totalStakedInUsd) !== null && _b !== void 0 ? _b : BIG_INT_ZERO)) ? -1 : 1;
            });
            setStakingInfoData(sortedFarms);
        }
        else if (sortBy === SortingType.totalApr) {
            const sortedFarms = sortedFarmsApr
                .map((item) => stakingInfoData.find((infoItem) => (infoItem === null || infoItem === void 0 ? void 0 : infoItem.pid) === item.pid))
                .filter((element) => !!element);
            setStakingInfoData(sortedFarms);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [sortBy]);
    useEffect(() => {
        if ((stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length) > 0) {
            const updatedStakingInfos = stakingInfos
                // sort by total staked
                .sort(sortingOnAvaxStake)
                .sort(sortingOnStakedAmount);
            let finalArr = updatedStakingInfos;
            // if user has searched something, then filter those results
            if (debouncedSearchQuery) {
                const filtered = stakingInfos.filter(function (stakingInfo) {
                    var _a, _b, _c, _d;
                    return ((((_b = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.symbol) || '').toUpperCase().includes(debouncedSearchQuery.toUpperCase()) ||
                        (((_d = (_c = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.symbol) || '').toUpperCase().includes(debouncedSearchQuery.toUpperCase()));
                });
                finalArr = filtered;
            }
            const finalArrByPid = finalArr.reduce((acc, info) => {
                acc[info === null || info === void 0 ? void 0 : info.pid] = info;
                return acc;
            }, {});
            setStakingInfoByPid(finalArrByPid);
            setStakingInfoData(finalArr);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [stakingInfos, debouncedSearchQuery]);
    const selectedPool = !!selectedPoolIndex ? stakingInfoByPid[selectedPoolIndex] : {};
    return (jsx(PoolCardListView, Object.assign({ version: version, setMenu: setMenu, activeMenu: activeMenu, menuItems: menuItems, handleSearch: handleSearch, onChangeSortBy: setSortBy, sortBy: sortBy, searchQuery: searchQuery, isLoading: ((stakingInfoData === null || stakingInfoData === void 0 ? void 0 : stakingInfoData.length) === 0 && !searchQuery) || poolCardsLoading, doesNotPoolExist: (stakingInfoData === null || stakingInfoData === void 0 ? void 0 : stakingInfoData.length) === 0 && !poolCardsLoading, selectedPool: selectedPool }, {
        children: stakingInfoData.map((stakingInfo) => (jsx(PoolCardV2, {
            stakingInfo: stakingInfo, onClickViewDetail: () => {
                setSelectedPoolIndex(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
                togglePoolDetailModal();
            }, version: Number(version)
        }, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid)))
    })));
};
var PoolListV2$1 = memo(PoolListV2);

const PoolV2 = ({ type, setMenu, activeMenu, menuItems, miniChefStakingInfo }) => {
    const poolMap = useMinichefPools();
    if (type === PoolType$1.own) {
        miniChefStakingInfo = (miniChefStakingInfo || []).filter((stakingInfo) => {
            return Boolean(stakingInfo.stakedAmount.greaterThan('0'));
        });
    }
    if (type === PoolType$1.superFarms) {
        miniChefStakingInfo = (miniChefStakingInfo || []).filter((item) => { var _a; return (((_a = item === null || item === void 0 ? void 0 : item.rewardTokensAddress) === null || _a === void 0 ? void 0 : _a.length) || 0) > 1; });
    }
    return (jsx(PoolListV2$1, { version: "2", stakingInfos: miniChefStakingInfo, poolMap: poolMap, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems }));
};

const PoolCardViewV3 = ({ stakingInfo, onClickViewDetail, version, rewardTokens }) => {
    var _a, _b, _c, _d;
    const { t } = useTranslation();
    const [isCompoundDrawerVisible, setShowCompoundDrawer] = useState(false);
    const [isFarmDrawerVisible, setShowFarmDrawer] = useState(false);
    const [isAddLiquidityDrawerVisible, setShowAddLiquidityDrawer] = useState(false);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const [, stakingTokenPair] = usePair(token0, token1);
    const isStaking = Boolean(stakingInfo.stakedAmount.greaterThan('0'));
    const yourStackedInUsd = ((_a = CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet)
        ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd.multiply(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount).divide(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount)
        : undefined;
    const userPgl = useTokenBalance(account !== null && account !== void 0 ? account : undefined, stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.liquidityToken);
    const isLiquidity = Boolean(userPgl === null || userPgl === void 0 ? void 0 : userPgl.greaterThan('0'));
    const isSuperFarm = version > 1 ? ((_b = (rewardTokens || [])) === null || _b === void 0 ? void 0 : _b.length) > 1 : ((_c = ((stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokensAddress) || [])) === null || _c === void 0 ? void 0 : _c.length) > 1;
    const redirectToFarmDrawer = () => {
        setShowFarmDrawer(true);
        setShowAddLiquidityDrawer(false);
    };
    const farmApr = stakingInfo.stakingApr;
    const earnedAmount = stakingInfo.earnedAmount;
    const userApr = useUserPangoChefAPR(stakingInfo);
    const apr = isStaking ? userApr : farmApr;
    const renderButton = () => {
        if (isStaking && Boolean(earnedAmount.greaterThan('0')))
            return (jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowCompoundDrawer(true), backgroundColor: "color2", color: "text1", height: "45px" }, { children: t('sarCompound.compound') })));
        else if (isLiquidity) {
            return (jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowFarmDrawer(true), backgroundColor: "color2", color: "text1", height: "45px" }, { children: t('header.farm') })));
        }
        else {
            return (jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowAddLiquidityDrawer(true), backgroundColor: "color2", color: "text1", height: "45px" }, { children: t('pool.addLiquidity') })));
        }
    };
    return (jsxs(Panel$1, {
        children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, { children: [jsxs(Box, { children: [jsxs(Text, Object.assign({ color: "text1", fontSize: 24, fontWeight: 500 }, { children: [currency0.symbol, "-", currency1.symbol] })), isSuperFarm && (jsx(OptionsWrapper, { children: jsx(OptionButton, { children: "Super farm" }) }))] }), jsx(DoubleCurrencyLogo, { size: 48, currency0: currency0, currency1: currency1 })] })), jsx(Divider$1, {}), jsx(Box, Object.assign({ display: "flex", flex: "1", alignItems: "center" }, { children: jsxs(StatWrapper$2, { children: [isStaking ? (jsx(Stat, { title: 'Your TVL', stat: numeral(yourStackedInUsd === null || yourStackedInUsd === void 0 ? void 0 : yourStackedInUsd.toFixed(2)).format('$0.00a'), titlePosition: "top", titleFontSize: [16, 14], statFontSize: [24, 18] })) : (jsx(Stat, { title: 'TVL', stat: numeral((_d = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd) === null || _d === void 0 ? void 0 : _d.toFixed(2)).format('$0.00a'), titlePosition: "top", titleFontSize: 14, statFontSize: 18 })), jsx(Stat, { title: isStaking ? 'Your APR' : 'Average APR', stat: apr ? `${numeral(apr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: [16, 14], statFontSize: [24, 18] }), jsxs(Box, Object.assign({ display: "inline-block" }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: [16, 14] }, { children: t('earn.rewardsIn') })), jsx(Box, Object.assign({ display: "flex", alignItems: "center", mt: "5px" }, { children: jsx(RewardTokens, { rewardTokens: rewardTokens, size: 24 }) }))] }))] }) })), jsxs(InnerWrapper$4, { children: [jsx(Box, { children: jsx(DetailButton$1, Object.assign({ variant: "plain", onClick: onClickViewDetail, color: "text1", height: "45px" }, { children: t('pool.seeDetails') })) }), jsx(Box, { children: renderButton() })] }), isCompoundDrawerVisible && (jsx(Drawer, Object.assign({ title: t('sarCompound.compound'), isOpen: isCompoundDrawerVisible, onClose: () => setShowCompoundDrawer(false), backgroundColor: "color5" }, { children: jsx(CompoundV3, { onClose: () => setShowCompoundDrawer(false), stakingInfo: stakingInfo }) }))), isFarmDrawerVisible && (jsx(FarmDrawer, {
            isOpen: isFarmDrawerVisible, onClose: () => {
                setShowFarmDrawer(false);
            }, version: version, backgroundColor: "color5", stakingInfo: stakingInfo, combinedApr: farmApr
        })), isAddLiquidityDrawerVisible && (jsx(AddLiquidityDrawer, {
            isOpen: isAddLiquidityDrawerVisible, onClose: () => {
                setShowAddLiquidityDrawer(false);
            }, onAddToFarm: redirectToFarmDrawer, clickedLpTokens: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens, backgroundColor: "color5"
        }))]
    }));
};

const PoolCardV3 = ({ stakingInfo, onClickViewDetail, version }) => {
    const rewardTokens = useGetRewardTokens(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokens, stakingInfo.rewardTokensAddress);
    return (jsx(PoolCardViewV3, { rewardTokens: rewardTokens, stakingInfo: stakingInfo, onClickViewDetail: onClickViewDetail, version: version }));
};

const PoolListV3 = ({ version, stakingInfos, setMenu, activeMenu, menuItems }) => {
    const [poolCardsLoading] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState('');
    const debouncedSearchQuery = useDebounce(searchQuery, 250);
    const [stakingInfoData, setStakingInfoData] = useState([]);
    const [stakingInfoByPid, setStakingInfoByPid] = useState({});
    const [selectedPoolIndex, setSelectedPoolIndex] = useState('');
    const togglePoolDetailModal = usePoolDetailnModalToggle();
    const handleSearch = useCallback((value) => {
        setSearchQuery(value.trim());
    }, []);
    useEffect(() => {
        if (sortBy === SortingType.totalStakedInUsd) {
            const sortedFarms = [...stakingInfoData].sort(function (info_a, info_b) {
                var _a, _b;
                return ((_a = info_a.totalStakedInUsd) === null || _a === void 0 ? void 0 : _a.greaterThan((_b = info_b.totalStakedInUsd) !== null && _b !== void 0 ? _b : BIG_INT_ZERO)) ? -1 : 1;
            });
            setStakingInfoData(sortedFarms);
        }
        else if (sortBy === SortingType.totalApr) {
            const sortedFarms = [...stakingInfoData].sort((a, b) => { var _a, _b; return ((_a = b === null || b === void 0 ? void 0 : b.stakingApr) !== null && _a !== void 0 ? _a : 0) - ((_b = a === null || a === void 0 ? void 0 : a.stakingApr) !== null && _b !== void 0 ? _b : 0); });
            setStakingInfoData(sortedFarms);
        }
    }, [sortBy]);
    useEffect(() => {
        if ((stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length) > 0) {
            const updatedStakingInfos = stakingInfos
                // sort by total staked
                .sort(sortingOnAvaxStake)
                .sort(sortingOnStakedAmount);
            let finalArr = updatedStakingInfos;
            // if user has searched something, then filter those results
            if (debouncedSearchQuery) {
                const filtered = stakingInfos.filter(function (stakingInfo) {
                    var _a, _b, _c, _d;
                    return ((((_b = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.symbol) || '').toUpperCase().includes(debouncedSearchQuery.toUpperCase()) ||
                        (((_d = (_c = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.symbol) || '').toUpperCase().includes(debouncedSearchQuery.toUpperCase()));
                });
                finalArr = filtered;
            }
            const finalArrByPid = finalArr.reduce((acc, info) => {
                acc[info === null || info === void 0 ? void 0 : info.pid] = info;
                return acc;
            }, {});
            setStakingInfoByPid(finalArrByPid);
            setStakingInfoData(finalArr);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [stakingInfos, debouncedSearchQuery]);
    const selectedPool = !!selectedPoolIndex ? stakingInfoByPid[selectedPoolIndex] : {};
    return (jsx(PoolCardListView, Object.assign({ version: version, setMenu: setMenu, activeMenu: activeMenu, menuItems: menuItems, handleSearch: handleSearch, onChangeSortBy: setSortBy, sortBy: sortBy, searchQuery: searchQuery, isLoading: ((stakingInfoData === null || stakingInfoData === void 0 ? void 0 : stakingInfoData.length) === 0 && !searchQuery) || poolCardsLoading, doesNotPoolExist: (stakingInfoData === null || stakingInfoData === void 0 ? void 0 : stakingInfoData.length) === 0 && !poolCardsLoading, selectedPool: selectedPool }, {
        children: stakingInfoData.map((stakingInfo) => (jsx(PoolCardV3, {
            stakingInfo: stakingInfo, onClickViewDetail: () => {
                setSelectedPoolIndex(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
                togglePoolDetailModal();
            }, version: Number(version)
        }, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid)))
    })));
};
var PoolListV3$1 = memo(PoolListV3);

const PoolV3 = ({ type, setMenu, activeMenu, menuItems, pangoChefStakingInfos }) => {
    if (type === PoolType$1.own) {
        pangoChefStakingInfos = (pangoChefStakingInfos || []).filter((stakingInfo) => {
            return Boolean(stakingInfo.stakedAmount.greaterThan('0'));
        });
    }
    if (type === PoolType$1.superFarms) {
        pangoChefStakingInfos = (pangoChefStakingInfos || []).filter((item) => { var _a; return (((_a = item === null || item === void 0 ? void 0 : item.rewardTokensAddress) === null || _a === void 0 ? void 0 : _a.length) || 0) > 1; });
    }
    return (jsx(PoolListV3$1, { version: "3", stakingInfos: pangoChefStakingInfos, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems }));
};

const Pools = ({ version, type, stakingInfoV1, miniChefStakingInfo, pangoChefStakingInfo, setMenu, activeMenu, menuItems, }) => {
    if (version == 1) {
        return (jsx(PoolV1, { type: type, stakingInfos: stakingInfoV1, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems }));
    }
    else if (version === 2) {
        return (jsx(PoolV2, { type: type, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems, miniChefStakingInfo: miniChefStakingInfo }));
    }
    else if (version === 3) {
        return (jsx(PoolV3, { type: type, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems, pangoChefStakingInfos: pangoChefStakingInfo }));
    }
    return null;
};

const DropdownMenu = ({ defaultValue, onSelect, placeHolder, isMulti = false, menuPlacement, options, height, }) => {
    const theme = useContext(ThemeContext);
    const colourStyles = {
        control: (styles) => {
            var _a, _b;
            return Object.assign(Object.assign(Object.assign({}, styles), {
                color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color, backgroundColor: (_b = theme.dropdown) === null || _b === void 0 ? void 0 : _b.primaryBgColor, '&:hover': {
                    borderColor: theme.primary,
                }
            }), (height && { height: height }));
        },
        multiValue: (styles) => {
            var _a, _b, _c;
            return Object.assign(Object.assign({}, styles), { backgroundColor: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.primaryBgColor, border: `1px solid ${(_b = theme.dropdown) === null || _b === void 0 ? void 0 : _b.color}`, color: (_c = theme.dropdown) === null || _c === void 0 ? void 0 : _c.color });
        },
        multiValueLabel: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        placeholder: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        singleValue: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        input: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        indicatorsContainer: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        indicatorSeparator: (styles) => {
            return Object.assign(Object.assign({}, styles), { display: 'none' });
        },
        option: (styles, { isDisabled }) => {
            var _a, _b;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color, backgroundColor: (_b = theme.dropdown) === null || _b === void 0 ? void 0 : _b.primaryBgColor, cursor: isDisabled ? 'not-allowed' : 'default' });
        },
        menuList: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { padding: 0, color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
    };
    const { t } = useTranslation();
    return (jsx(Select, Object.assign({
        options: options, onChange: (selectedItems) => {
            onSelect((selectedItems === null || selectedItems === void 0 ? void 0 : selectedItems.value) || '');
        }
    }, (menuPlacement && { menuPlacement }), { defaultValue: defaultValue, placeholder: placeHolder || t('dropdown.select'), isMulti: isMulti, styles: colourStyles, theme: (thm) => (Object.assign(Object.assign({}, thm), { colors: Object.assign(Object.assign({}, thm.colors), { primary50: theme.primary, primary75: theme.primary, primary: theme.primary }) })) })));
};

const Panel = styled(Box)`
  background-color: ${({ theme }) => theme.bg8};
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  padding: 20px;
  border-radius: 10px;
  height: 295px;
  * {
    box-sizing: border-box;
  }
`;
const Divider = styled(Box)`
  height: 1px;
  background-color: ${({ theme }) => theme.bg7};
  margin: 10px 0px 10px 0px;
  width: 100%;
`;
const ActionButon = styled(Button)`
  width: 100%;
`;
const DetailButton = styled(ActionButon)`
  border: 1px solid !important;
  border-color: ${({ theme }) => theme.text10}!important;
`;
const StatWrapper = styled(Box)`
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-gap: 12px;
  margin-top: 10px;
  flex: 1;
  height: 100%;
  align-items: center;
`;
const InnerWrapper$1 = styled(Box)`
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-gap: 12px;
  margin-top: 10px;
`;

const WalletCard = ({ pair }) => {
    const { t } = useTranslation();
    const chainId = useChainId();
    const [isRemoveLiquidityDrawerVisible, setShowRemoveLiquidityDrawer] = useState(false);
    const [isAddLiquidityDrawerVisible, setShowAddLiquidityDrawer] = useState(false);
    const currency0 = unwrappedToken(pair.token0, chainId);
    const currency1 = unwrappedToken(pair.token1, chainId);
    const { liquidityInUSD, userPgl } = useGetPoolDollerWorth(pair);
    const yourLiquidity = liquidityInUSD ? `$${liquidityInUSD === null || liquidityInUSD === void 0 ? void 0 : liquidityInUSD.toFixed(4)}` : '-';
    return (jsxs(Panel, {
        children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, { children: [jsx(Box, { children: jsxs(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: [currency0.symbol, "-", currency1.symbol] })) }), jsx(DoubleCurrencyLogo, { size: 48, currency0: currency0, currency1: currency1 })] })), jsx(Divider, {}), jsxs(StatWrapper, { children: [jsx(Stat, { title: t('pool.yourLiquidity'), stat: yourLiquidity, titlePosition: "top", titleFontSize: 16, statFontSize: [24, 18] }), jsx(Stat, { title: t('positionCard.poolTokens'), stat: userPgl ? userPgl.toSignificant(4) : '-', titlePosition: "top", titleFontSize: 16, statFontSize: [24, 18] })] }), jsxs(InnerWrapper$1, { children: [jsx(Box, { children: jsx(DetailButton, Object.assign({ variant: "plain", onClick: () => setShowAddLiquidityDrawer(true), color: "text1", height: "45px" }, { children: t('positionCard.add') })) }), jsx(Box, { children: jsx(ActionButon, Object.assign({ variant: "plain", onClick: () => setShowRemoveLiquidityDrawer(true), backgroundColor: "bg2", color: "text1", height: "45px" }, { children: t('positionCard.remove') })) })] }), isAddLiquidityDrawerVisible && (jsx(AddLiquidityDrawer, {
            isOpen: isAddLiquidityDrawerVisible, onClose: () => {
                setShowAddLiquidityDrawer(false);
            }, clickedLpTokens: [pair === null || pair === void 0 ? void 0 : pair.token0, pair === null || pair === void 0 ? void 0 : pair.token1], backgroundColor: "color5"
        })), isRemoveLiquidityDrawerVisible && (jsx(RemoveLiquidityDrawer, {
            isOpen: isRemoveLiquidityDrawerVisible, onClose: () => {
                setShowRemoveLiquidityDrawer(false);
            }, clickedLpTokens: [pair === null || pair === void 0 ? void 0 : pair.token0, pair === null || pair === void 0 ? void 0 : pair.token1], backgroundColor: "color5"
        }))]
    }));
};

const PageWrapper$1 = styled(Box)`
  width: 100%;
  background-color: ${({ theme }) => theme.bg2};
  padding: 10px;
  border-radius: 0px 10px 10px 0px;
  overflow: hidden;
`;
const EmptyProposals = styled.div`
  border: 1px solid ${({ theme }) => theme.text4};
  padding: 16px 12px;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;
const PanelWrapper = styled.div`
  grid-template-columns: repeat(auto-fill, minmax(360px, 1fr));
  grid-template-rows: max-content;
  gap: 15px;
  display: inline-grid;
  width: 100%;
  align-items: start;
  padding-bottom: 65px;

  @media screen and (max-width: 1024px) {
    grid-template-columns: 1fr;
    align-items: stretch;
    > * {
      grid-column: 1 / 4;
    }

    > * {
      &:first-child {
        width: 100%;
      }
    }
  }
`;
const MobileContainer = styled(Box)`
  display: none;
  ${({ theme }) => theme.mediaWidth.upToSmall`
    display: block;
    width: 100%
    margin-bottom : 10px;
  `};
`;

const Wallet = ({ setMenu, activeMenu, menuItems }) => {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useGetUserLP = useGetUserLPHook[chainId];
    const { v2IsLoading, allV2PairsWithLiquidity } = useGetUserLP();
    // fetch the user's balances of all tracked V2 LP tokens
    const { t } = useTranslation();
    function getWalletCardView() {
        if (!account) {
            return (jsx(Box, Object.assign({ padding: "40px", width: "100%", borderRadius: "16px" }, { children: jsx(Text, Object.assign({ color: "text3", textAlign: "center", fontWeight: 500 }, { children: t('pool.connectWalletToView') })) })));
        }
        else if (v2IsLoading) {
            return jsx(Loader, { size: 100 });
        }
        else if ((allV2PairsWithLiquidity === null || allV2PairsWithLiquidity === void 0 ? void 0 : allV2PairsWithLiquidity.length) > 0) {
            return (jsx(Fragment, {
                children: jsx(Scrollbars, {
                    children: jsx(PanelWrapper, {
                        children: allV2PairsWithLiquidity.map((v2Pair) => {
                            var _a;
                            return (jsx(WalletCard, { pair: v2Pair }, (_a = v2Pair === null || v2Pair === void 0 ? void 0 : v2Pair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address));
                        })
                    })
                })
            }));
        }
        else {
            return (jsx(EmptyProposals, { children: jsx(Text, Object.assign({ color: "text3", textAlign: "center", fontWeight: 500 }, { children: t('pool.noLiquidity') })) }));
        }
    }
    return (jsxs(PageWrapper$1, {
        children: [jsx(MobileContainer, {
            children: jsx(DropdownMenu, {
                options: menuItems, defaultValue: activeMenu, onSelect: (value) => {
                    setMenu(value);
                }
            })
        }), getWalletCardView()]
    }));
};

const PoolImportWrapper = styled(Box)`
  width: 100%;
  position: relative;
  overflow: hidden;
`;
const ArrowWrapper$1 = styled.div`
  background-color: ${({ theme }) => theme.bg6};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;
const LightCard = styled(Box)`
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
`;
const CurrencySelectWrapper = styled(Box)`
  width: 100%;
  border-radius: 8px;
  padding: 10px;
  border: 1px solid transparent;
  display: flex;
  position: relative;
  box-sizing: border-box;
  justify-content: space-between;
  align-items: center;
  background-color: ${({ theme }) => theme.color3};
  color: ${({ theme }) => theme.text4};
  cursor: pointer;
`;
const Dots = styled.span`
  &::after {
    display: inline-block;
    animation: ellipsis 1.25s infinite;
    content: '.';
    width: 1em;
    text-align: left;
  }
  @keyframes ellipsis {
    0% {
      content: '.';
    }
    33% {
      content: '..';
    }
    66% {
      content: '...';
    }
  }
`;

const Wrapper$6 = styled.div`
  ${({ theme }) => theme.flexColumnNoWrap}
  margin: 0;
  width: 100%;
  align-items: center;
  max-width: 420px;
  min-width: 420px;
  padding: 10px;
  position: relative;
  overflow: hidden;
  * {
    box-sizing: border-box;
  }
`;
const ConfirmButton = styled.button`
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
  border: none;
  color: ${({ theme }) => theme.text1};
  font-size: 14px;
  cursor: pointer;

  :hover,
  :focus {
    opacity: 0.8;
  }
`;

var Fields$2;
(function (Fields) {
    Fields[Fields["TOKEN0"] = 0] = "TOKEN0";
    Fields[Fields["TOKEN1"] = 1] = "TOKEN1";
})(Fields$2 || (Fields$2 = {}));
var BodyState;
(function (BodyState) {
    BodyState[BodyState["SELECT_TOKENS"] = 0] = "SELECT_TOKENS";
    BodyState[BodyState["ADD_LIQUIDITY"] = 1] = "ADD_LIQUIDITY";
    BodyState[BodyState["CREATE_PAIR"] = 2] = "CREATE_PAIR";
})(BodyState || (BodyState = {}));
const SearchToken = ({ currency0, currency1, onTokenClick, onClick }) => {
    const { account } = usePangolinWeb3();
    const theme = useContext(ThemeContext);
    const { t } = useTranslation();
    const [pairState, pair] = usePair(currency0, currency1);
    function renderButton() {
        if (!account) {
            return (jsx(LightCard, { children: jsx(Text, Object.assign({ textAlign: "center", color: "color6", fontSize: [14, 12] }, { children: t('walletModal.connectToWallet') })) }));
        }
        if (!currency0 || !currency1) {
            return (jsx(LightCard, { children: jsx(Text, Object.assign({ textAlign: "center", color: "text1", fontSize: [14, 12] }, { children: t('poolFinder.selectToken') })) }));
        }
        if (pair) {
            return (jsx(ConfirmButton, Object.assign({ onClick: () => onClick(BodyState.ADD_LIQUIDITY) }, { children: t('navigationTabs.addLiquidity') })));
        }
        if (pairState === PairState.NOT_EXISTS || (currency0 && currency1 && !pair)) {
            return (jsx(ConfirmButton, Object.assign({ onClick: () => onClick(BodyState.CREATE_PAIR) }, { children: t('navigationTabs.createPair') })));
        }
        return (jsx(LightCard, { children: jsx(Text, Object.assign({ textAlign: "center", color: "text1", fontSize: [16, 12] }, { children: t('poolFinder.invalidPair') })) }));
    }
    function renderCurrency(currency) {
        if (!currency) {
            return (jsx(Text, Object.assign({ color: "text1", fontSize: [16, 12] }, { children: t('poolFinder.selectToken') })));
        }
        return (jsxs(Fragment, { children: [jsx(CurrencyLogo, { size: 24, currency: currency, imageSize: 48 }), jsx(Text, Object.assign({ color: "text2", fontSize: [16, 14], fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: currency === null || currency === void 0 ? void 0 : currency.symbol }))] }));
    }
    return (jsxs(Box, {
        children: [jsxs(CurrencySelectWrapper, Object.assign({
            onClick: () => {
                onTokenClick(Fields$2.TOKEN0);
            }
        }, { children: [jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: renderCurrency(currency0) })), jsx(ChevronDown, { size: "16", color: theme.text1 })] })), jsx(Box, Object.assign({ display: "flex", justifyContent: "center", width: "100%", my: 10 }, { children: jsx(Plus, { size: "16", color: theme.text1 }) })), jsxs(CurrencySelectWrapper, Object.assign({
            onClick: () => {
                onTokenClick(Fields$2.TOKEN1);
            }
        }, { children: [jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: renderCurrency(currency1) })), jsx(ChevronDown, { size: "16", color: theme.text1 })] })), renderButton()]
    }));
};

const AddLiquidityModal = ({ isOpen, onClose }) => {
    const theme = useContext(ThemeContext);
    const chainId = useChainId();
    const { t } = useTranslation();
    const [activeField, setActiveField] = useState(Fields$2.TOKEN0);
    const [currency0, setCurrency0] = useState(CAVAX[chainId]);
    const [currency1, setCurrency1] = useState(undefined);
    const [showSearch, setShowSearch] = useState(false);
    const [bodyState, setBodyState] = useState(BodyState.SELECT_TOKENS);
    const createPool = useNearCreatePool();
    const parsedQs = useParsedQueryString();
    // token warning stuff
    const [loadedInputCurrency, loadedOutputCurrency] = [
        useCurrency(parsedQs === null || parsedQs === void 0 ? void 0 : parsedQs.currency0),
        useCurrency(parsedQs === null || parsedQs === void 0 ? void 0 : parsedQs.currency1),
    ];
    useEffect(() => {
        if (loadedInputCurrency) {
            setCurrency0(loadedInputCurrency);
        }
        if (loadedOutputCurrency) {
            setCurrency1(loadedOutputCurrency);
        }
    }, [loadedInputCurrency, loadedOutputCurrency]);
    const onTokenClick = useCallback((field) => {
        setActiveField(field);
        setShowSearch(true);
    }, [setActiveField, setShowSearch]);
    function onButtonClick(value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chainId)
                return;
            try {
                if (isEvmChain(chainId) && value) {
                    setBodyState(value);
                }
                else if (!isEvmChain(chainId)) {
                    const tokenA = currency0 ? wrappedCurrency(currency0, chainId) : undefined;
                    const tokenB = currency1 ? wrappedCurrency(currency1, chainId) : undefined;
                    const poolId = yield nearFn.getPoolId(chainId, tokenA, tokenB);
                    if (poolId > 0 && value) {
                        setBodyState(value);
                    }
                    else {
                        const createPoolData = {
                            tokenA,
                            tokenB,
                        };
                        yield createPool(createPoolData);
                    }
                }
            }
            catch (err) {
                const _err = err;
                console.error(_err);
            }
        });
    }
    const switchCurrencies = useCallback(() => {
        const temp = currency0;
        setCurrency0(currency1);
        setCurrency1(temp);
    }, [currency0, currency1]);
    const handleCurrencySelect = useCallback((currency) => {
        setShowSearch(false);
        if (activeField === Fields$2.TOKEN0) {
            if (currency1 === currency) {
                switchCurrencies();
            }
            else {
                setCurrency0(currency);
            }
        }
        else {
            if (currency0 === currency) {
                switchCurrencies();
            }
            else {
                setCurrency1(currency);
            }
        }
    }, [activeField, switchCurrencies, currency0, currency1]);
    const handleClose = useCallback(() => {
        setShowSearch(false);
    }, [setShowSearch]);
    function renderTitle() {
        if (bodyState === BodyState.SELECT_TOKENS) {
            return t('poolFinder.selectToken');
        }
        else if (bodyState === BodyState.ADD_LIQUIDITY) {
            return t('poolFinder.addLiquidity');
        }
        else {
            return t('navigationTabs.createPair');
        }
    }
    function renderBody() {
        if (bodyState === BodyState.SELECT_TOKENS) {
            return (jsxs(Fragment, { children: [jsx(SearchToken, { currency0: currency0, currency1: currency1, onTokenClick: onTokenClick, onClick: onButtonClick }), jsx(SelectTokenDrawer$1, { isOpen: showSearch, selectedCurrency: currency0, otherSelectedCurrency: currency1, onCurrencySelect: handleCurrencySelect, onClose: handleClose })] }));
        }
        else if (currency0 && currency1) {
            return (jsx(AddLiquidity, { currencyA: currency0, currencyB: currency1, type: SpaceType.card, onComplete: () => setBodyState(0) }));
        }
        return jsx(Fragment, {});
    }
    return (jsx(Modal, Object.assign({ isOpen: isOpen, onDismiss: onClose, overlayBG: theme.modalBG2 }, {
        children: jsxs(Wrapper$6, {
            children: [jsxs(Box, Object.assign({ p: 10, display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, {
                children: [jsx(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: renderTitle() })), jsx(CloseIcon, {
                    onClick: () => {
                        if (bodyState === BodyState.SELECT_TOKENS) {
                            onClose();
                        }
                        else {
                            setBodyState(0);
                        }
                    }, color: theme.text1
                })]
            })), jsx(Box, Object.assign({ width: "100%" }, { children: renderBody() }))]
        })
    })));
};

const Wrapper$5 = styled(Box)`
  width: 100%;
  position: relative;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
`;
const InnerWrapper = styled(Box)`
  display: grid;
  grid-template-columns: 50% 50%;
  grid-gap: 12px;
  margin-top: 10px;
`;

const PositionCard = ({ pair, onManagePoolsClick }) => {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const currency0 = unwrappedToken(pair === null || pair === void 0 ? void 0 : pair.token0, chainId);
    const currency1 = unwrappedToken(pair === null || pair === void 0 ? void 0 : pair.token1, chainId);
    const { t } = useTranslation();
    const useTokenBalance = useTokenBalanceHook[chainId];
    const useTotalSupply = useTotalSupplyHook[chainId];
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    const userPoolBalance = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pairOrToken);
    const totalPoolTokens = useTotalSupply(pairOrToken);
    const poolTokenPercentage = !!userPoolBalance && !!totalPoolTokens && JSBI$1.greaterThanOrEqual(totalPoolTokens.raw, userPoolBalance.raw)
        ? new Percent$1(userPoolBalance.raw, totalPoolTokens.raw)
        : undefined;
    const [token0Deposited, token1Deposited] = !!pair &&
        !!totalPoolTokens &&
        !!userPoolBalance &&
        JSBI$1.greaterThan(totalPoolTokens.raw, BIG_INT_ZERO) &&
        JSBI$1.greaterThan(userPoolBalance.raw, BIG_INT_ZERO) &&
        // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply
        JSBI$1.greaterThanOrEqual(totalPoolTokens.raw, userPoolBalance.raw)
        ? pair.getLiquidityValues(totalPoolTokens, userPoolBalance, { feeOn: false })
        : [undefined, undefined];
    return (jsxs(Wrapper$5, { children: [jsx(Text, Object.assign({ fontSize: 16, color: "oceanBlue" }, { children: t('poolFinder.poolFound') })), jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", mt: 10 }, { children: [jsx(Text, Object.assign({ fontWeight: 500, color: "color6", fontSize: 16 }, { children: t('positionCard.yourPosition') })), jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsx(DoubleCurrencyLogo, { size: 24, currency0: currency0, currency1: currency1 }), jsx(Box, Object.assign({ marginLeft: 10 }, { children: jsxs(Text, Object.assign({ color: "text1", fontSize: 20, fontWeight: 500 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] })) }))] }))] })), jsxs(InnerWrapper, { children: [jsx(Box, { children: jsx(Stat, { title: 'ARL', stat: `${userPoolBalance ? userPoolBalance.toSignificant(4) : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 16], titleColor: "text2" }) }), jsx(Box, { children: jsx(Stat, { title: t('positionCard.poolShare'), stat: `${poolTokenPercentage ? poolTokenPercentage.toFixed(6) + '%' : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 16], titleColor: "text2" }) })] }), jsxs(InnerWrapper, { children: [jsx(Box, { children: jsx(Stat, { title: currency0.symbol, stat: `${token0Deposited ? token0Deposited === null || token0Deposited === void 0 ? void 0 : token0Deposited.toSignificant(6) : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 16], titleColor: "text2" }) }), jsx(Box, { children: jsx(Stat, { title: currency1.symbol, stat: `${token1Deposited ? token1Deposited === null || token1Deposited === void 0 ? void 0 : token1Deposited.toSignificant(6) : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 16], titleColor: "text2" }) })] }), jsx(Box, Object.assign({ mt: 10 }, { children: jsx(Box, Object.assign({ mr: "5px", width: "100%" }, { children: jsx(Button, Object.assign({ variant: 'primary', onClick: onManagePoolsClick }, { children: t('positionCard.manage') })) })) }))] }));
};

var Fields$1;
(function (Fields) {
    Fields[Fields["TOKEN0"] = 0] = "TOKEN0";
    Fields[Fields["TOKEN1"] = 1] = "TOKEN1";
})(Fields$1 || (Fields$1 = {}));
const PoolImport = ({ currency0, currency1, openTokenDrawer, setActiveField, onManagePoolsClick }) => {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = useTranslation();
    const theme = useContext(ThemeContext);
    const useTokenBalance = useTokenBalanceHook[chainId];
    const [pairState, pair] = usePair(currency0 !== null && currency0 !== void 0 ? currency0 : undefined, currency1 !== null && currency1 !== void 0 ? currency1 : undefined);
    const addPair = usePairAdder();
    useEffect(() => {
        if (pair) {
            addPair(pair);
        }
    }, [pair, addPair]);
    const validPairNoLiquidity = pairState === PairState.NOT_EXISTS ||
        Boolean(pairState === PairState.EXISTS &&
            pair &&
            JSBI$1.equal(pair.reserve0.raw, JSBI$1.BigInt(0)) &&
            JSBI$1.equal(pair.reserve1.raw, JSBI$1.BigInt(0)));
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    const position = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pairOrToken);
    const hasPosition = Boolean(position && JSBI$1.greaterThan(position.raw, JSBI$1.BigInt(0)));
    const prerequisiteMessage = (jsx(LightCard, { children: jsx(Text, Object.assign({ textAlign: "center", color: "color6", fontSize: 14 }, { children: !account ? t('poolFinder.connectToFind') : t('poolFinder.selectTokenToFind') })) }));
    function getCard() {
        if (pairState === PairState.EXISTS) {
            if (hasPosition && pair) {
                return jsx(PositionCard, { pair: pair, onManagePoolsClick: onManagePoolsClick });
            }
            return (jsx(LightCard, { children: jsx(Box, Object.assign({ display: "flex", flexDirection: "column", alignItems: "center" }, { children: jsx(Text, Object.assign({ color: "color6", fontSize: 14, textAlign: "center" }, { children: t('poolFinder.noLiquidityYet') })) })) }));
        }
        if (validPairNoLiquidity) {
            return (jsx(LightCard, { children: jsx(Box, Object.assign({ display: "flex", flexDirection: "column", alignItems: "center" }, { children: jsx(Text, Object.assign({ color: "color6", fontSize: 14, textAlign: "center" }, { children: t('poolFinder.noPoolFound') })) })) }));
        }
        if (pairState === PairState.INVALID) {
            return (jsx(LightCard, { children: jsx(Box, Object.assign({ display: "flex", flexDirection: "column", alignItems: "center" }, { children: jsx(Text, Object.assign({ color: "color6", fontSize: 14, textAlign: "center", fontWeight: 500 }, { children: t('poolFinder.invalidPair') })) })) }));
        }
        if (pairState === PairState.LOADING) {
            return (jsx(LightCard, { children: jsx(Box, Object.assign({ textAlign: "center" }, { children: jsxs(Text, Object.assign({ textAlign: "center", color: "white" }, { children: [t('poolFinder.loading'), jsx(Dots, {})] })) })) }));
        }
        return null;
    }
    return (jsxs(PoolImportWrapper, {
        children: [jsxs(CurrencySelectWrapper, Object.assign({
            onClick: () => {
                openTokenDrawer();
                setActiveField(Fields$1.TOKEN0);
            }
        }, { children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsx(CurrencyLogo, { size: 24, currency: currency0, imageSize: 48 }), jsx(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol }))] })), jsx(ChevronDown, { size: "16", color: theme.text1 })] })), jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: "flex", justifyContent: 'center', mt: 10, mb: 10 }, { children: jsx(ArrowWrapper$1, { children: jsx(Plus, { size: "16", color: theme.text1 }) }) })), jsxs(CurrencySelectWrapper, Object.assign({
            onClick: () => {
                openTokenDrawer();
                setActiveField(Fields$1.TOKEN1);
            }
        }, { children: [currency1 ? (jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsx(CurrencyLogo, { size: 24, currency: currency1, imageSize: 48 }), jsx(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol }))] }))) : (jsx(Text, Object.assign({ color: "text1", fontSize: 16, fontWeight: 500, padding: "8px 0px" }, { children: t('searchModal.selectToken') }))), jsx(ChevronDown, { size: "16", color: theme.text1 })] })), currency0 && currency1 ? getCard() : prerequisiteMessage]
    }));
};

const Wrapper$4 = styled.div`
  ${({ theme }) => theme.flexColumnNoWrap}
  margin: 0;
  width: 100%;
  align-items: center;
  max-width: 420px;
  min-width: 420px;
  padding: 10px;
  position: relative;
  overflow: hidden;
  * {
    box-sizing: border-box;
  }
`;

var Fields;
(function (Fields) {
    Fields[Fields["TOKEN0"] = 0] = "TOKEN0";
    Fields[Fields["TOKEN1"] = 1] = "TOKEN1";
})(Fields || (Fields = {}));
const PoolImportModal = ({ isOpen, onClose, onManagePoolsClick }) => {
    const theme = useContext(ThemeContext);
    const chainId = useChainId();
    const { t } = useTranslation();
    const [currency0, setCurrency0] = useState(CAVAX[chainId]);
    const [currency1, setCurrency1] = useState(undefined);
    const [activeField, setActiveField] = useState(Fields.TOKEN1);
    const [showSearch, setShowSearch] = useState(false);
    const handleCurrencySelect = useCallback((currency) => {
        if (activeField === Fields.TOKEN0) {
            setCurrency0(currency);
        }
        else {
            setCurrency1(currency);
        }
    }, [activeField]);
    const handleSearchDismiss = useCallback(() => {
        setShowSearch(false);
    }, [setShowSearch]);
    return (jsx(Modal, Object.assign({ isOpen: isOpen, onDismiss: onClose, overlayBG: theme.modalBG2 }, { children: jsxs(Wrapper$4, { children: [jsxs(Box, Object.assign({ p: 10, display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: t('navigationTabs.importPool') })), jsx(CloseIcon, { onClick: onClose, color: theme.text1 })] })), jsx(PoolImport, { onClose: onClose, currency0: currency0, currency1: currency1, openTokenDrawer: () => setShowSearch(true), setActiveField: setActiveField, onManagePoolsClick: onManagePoolsClick }), jsx(SelectTokenDrawer$1, { isOpen: showSearch, onClose: handleSearchDismiss, onCurrencySelect: handleCurrencySelect, selectedCurrency: activeField === Fields.TOKEN0 ? currency0 : currency1, otherSelectedCurrency: activeField === Fields.TOKEN0 ? currency1 : currency0 })] }) })));
};

function CoinDescription({ coin }) {
    const { data } = useCoinGeckoTokenData(coin);
    return (jsx(Fragment, { children: data && (jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: 16, fontWeight: "bold", mb: "15px" }, { children: coin === null || coin === void 0 ? void 0 : coin.name })), jsx(Text, Object.assign({ color: "text1", fontSize: 14 }, { children: ReactHtmlParser(data === null || data === void 0 ? void 0 : data.description) })), jsx(Box, Object.assign({ mt: "5px" }, { children: jsx(ExternalLink, Object.assign({ style: { color: 'white', textDecoration: 'underline' }, href: data.homePage, target: "_blank" }, { children: jsx(Text, Object.assign({ color: "text1", fontSize: 16, fontWeight: 500 }, { children: "Visit Website" })) })) }))] })) }));
}

const Root$6 = styled(Box)`
  display: flex;
  flex-direction: column;
  height: 100%;
`;
styled(Text)`
  text-decoration: none;
  color: ${({ theme }) => theme.blue1};
`;

const TransactionCompleted = ({ onClose, submitText, showCloseIcon, isShowButtton, onButtonClick, buttonText, }) => {
    const theme = useContext(ThemeContext);
    return (jsxs(Root$6, { children: [showCloseIcon && (jsx(Box, Object.assign({ display: "flex", justifyContent: "flex-end" }, { children: jsx(CloseIcon, { onClick: () => onClose && onClose(), color: theme.text4 }) }))), jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", flex: 1, paddingY: '20px' }, { children: [jsx(Box, Object.assign({ display: "flex", alignItems: "center", mb: 10 }, { children: jsx("img", { src: CircleTick, alt: "circle-tick" }) })), submitText && (jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: "text1", textAlign: "center" }, { children: submitText })))] })), isShowButtton && (jsx(Button, Object.assign({ variant: "primary", onClick: onButtonClick }, { children: buttonText })))] }));
};

const ZERO = BigNumber.from('0');
// Return the info of the sar stake
function useSarStakeInfo() {
    var _a, _b;
    const chainId = useChainId();
    const sarStakingContract = useSarStakingContract();
    const png = PNG[chainId];
    const rewardRate = (_a = useSingleCallResult(sarStakingContract, 'rewardRate').result) === null || _a === void 0 ? void 0 : _a[0];
    const totalValueVariables = (_b = useSingleCallResult(sarStakingContract, 'totalValueVariables')) === null || _b === void 0 ? void 0 : _b.result;
    return useMemo(() => {
        const apr = rewardRate && totalValueVariables && (totalValueVariables === null || totalValueVariables === void 0 ? void 0 : totalValueVariables.balance) && !totalValueVariables.balance.isZero()
            ? rewardRate.mul(86400).mul(365).mul(100).div(totalValueVariables.balance)
            : null;
        const totalStaked = new TokenAmount(png, totalValueVariables ? totalValueVariables === null || totalValueVariables === void 0 ? void 0 : totalValueVariables.balance.toString() : '0');
        const weeklyPNG = !!rewardRate ? rewardRate.mul(86400).mul(7) : ZERO;
        const sumOfEntryTimes = totalValueVariables ? totalValueVariables === null || totalValueVariables === void 0 ? void 0 : totalValueVariables.sumOfEntryTimes : ZERO;
        return { apr, totalStaked, sumOfEntryTimes, rewardRate: rewardRate !== null && rewardRate !== void 0 ? rewardRate : ZERO, weeklyPNG };
    }, [rewardRate, totalValueVariables]);
}
// Return some utils functions for stake more or create a new Position
function useDerivativeSarStake(positionId) {
    const [attempting, setAttempting] = useState(false);
    const [hash, setHash] = useState(null);
    const [typedValue, setTypedValue] = useState('');
    const [stepIndex, setStepIndex] = useState(4);
    const [stakeError, setStakeError] = useState(null);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const sarStakingContract = useSarStakingContract();
    const addTransaction = useTransactionAdder();
    const { t } = useTranslation();
    const png = PNG[chainId];
    const userPngBalance = useTokenBalance(account !== null && account !== void 0 ? account : ZERO_ADDRESS, png);
    // used for max input button
    const maxAmountInput = maxAmountSpend(chainId, userPngBalance);
    const usdcPrice = useUSDCPrice(png);
    const dollerWorth = (userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.greaterThan('0')) && usdcPrice ? Number(typedValue) * Number(usdcPrice.toFixed()) : undefined;
    const wrappedOnDismiss = useCallback(() => {
        setStakeError(null);
        setTypedValue('');
        setStepIndex(0);
        setHash(null);
        setAttempting(false);
    }, []);
    const { parsedAmount, error } = useDerivedStakeInfo(typedValue, png, userPngBalance);
    const [approval, approveCallback] = useApproveCallback(chainId, parsedAmount, sarStakingContract === null || sarStakingContract === void 0 ? void 0 : sarStakingContract.address);
    const onUserInput = useCallback((_typedValue) => {
        setTypedValue(_typedValue);
    }, []);
    const handleMax = useCallback(() => {
        maxAmountInput && onUserInput(maxAmountInput.toExact());
        setStepIndex(4);
    }, [maxAmountInput, onUserInput]);
    const onChangePercentage = (value) => {
        if (!userPngBalance) {
            setTypedValue('0');
            return;
        }
        if (value === 100) {
            setTypedValue(userPngBalance.toExact());
        }
        else if (value === 0) {
            setTypedValue('0');
        }
        else {
            const newAmount = userPngBalance
                .multiply(JSBI$1.BigInt(value))
                .divide(JSBI$1.BigInt(100));
            setTypedValue(newAmount.toSignificant(6));
        }
    };
    const onStake = () => __awaiter(this, void 0, void 0, function* () {
        if (!sarStakingContract || !parsedAmount) {
            return;
        }
        setAttempting(true);
        try {
            let response;
            if (!positionId) {
                const estimatedGas = yield sarStakingContract.estimateGas.mint(`0x${parsedAmount.raw.toString(16)}`);
                // create a new position
                response = yield sarStakingContract.mint(`0x${parsedAmount.raw.toString(16)}`, {
                    gasLimit: calculateGasMargin(estimatedGas),
                });
            }
            else {
                const estimatedGas = yield sarStakingContract.estimateGas.mint(`0x${parsedAmount.raw.toString(16)}`);
                // adding more png to an existing position
                response = yield sarStakingContract.stake(positionId.toHexString(), `0x${parsedAmount.raw.toString(16)}`, {
                    gasLimit: calculateGasMargin(estimatedGas),
                });
            }
            yield waitForTransaction(response, 3);
            addTransaction(response, {
                summary: t('sarStake.transactionSummary', { symbol: png.symbol, balance: parsedAmount.toSignificant(2) }),
            });
            setHash(response.hash);
        }
        catch (err) {
            // we only care if the error is something _other_ than the user rejected the tx
            const _err = error;
            if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                console.error(_err);
                setStakeError(_err === null || _err === void 0 ? void 0 : _err.message);
            }
        }
        finally {
            setAttempting(false);
        }
    });
    return useMemo(() => ({
        attempting,
        typedValue,
        parsedAmount,
        hash,
        stepIndex,
        dollerWorth,
        error,
        approval,
        account,
        png,
        stakeError,
        onAttemptToApprove: approveCallback,
        onUserInput,
        wrappedOnDismiss,
        handleMax,
        onStake,
        onChangePercentage,
        setStepIndex,
    }), [
        attempting,
        typedValue,
        parsedAmount,
        hash,
        stepIndex,
        dollerWorth,
        error,
        approval,
        account,
        sarStakingContract,
        approveCallback,
        onUserInput,
        handleMax,
    ]);
}
function useUnstakeParseAmount(typedValue, stakingToken, userLiquidityStaked) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = useTranslation();
    const parsedInput = tryParseAmount(typedValue, stakingToken, chainId);
    const parsedAmount = parsedInput && userLiquidityStaked && JSBI$1.lessThanOrEqual(parsedInput.raw, userLiquidityStaked.raw)
        ? parsedInput
        : undefined;
    let error;
    if (!account) {
        error = t('stakeHooks.connectWallet');
    }
    if (parsedInput && !parsedAmount) {
        error = error !== null && error !== void 0 ? error : t('stakeHooks.insufficientBalance', { symbol: stakingToken.symbol });
    }
    if (!parsedAmount) {
        error = error !== null && error !== void 0 ? error : t('stakeHooks.enterAmount');
    }
    return {
        parsedAmount,
        error,
    };
}
// Return some utils functions for unstake
function useDerivativeSarUnstake(position) {
    var _a;
    const [typedValue, setTypedValue] = useState('');
    const [stepIndex, setStepIndex] = useState(0);
    const [unstakeError, setUnstakeError] = useState(null);
    const [attempting, setAttempting] = useState(false);
    const [hash, setHash] = useState(null);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = useTranslation();
    const addTransaction = useTransactionAdder();
    const png = PNG[chainId];
    const sarStakingContract = useSarStakingContract();
    const stakedAmount = new TokenAmount(png, ((_a = position === null || position === void 0 ? void 0 : position.balance) !== null && _a !== void 0 ? _a : 0).toString());
    const { parsedAmount, error } = useUnstakeParseAmount(typedValue, png, stakedAmount);
    // used for max input button
    const maxAmountInput = maxAmountSpend(chainId, stakedAmount);
    const wrappedOnDismiss = useCallback(() => {
        setUnstakeError(null);
        setTypedValue('');
        setStepIndex(0);
        setHash(null);
        setAttempting(false);
    }, []);
    const onUserInput = useCallback((_typedValue) => {
        setTypedValue(_typedValue);
    }, []);
    const handleMax = useCallback(() => {
        maxAmountInput && onUserInput(maxAmountInput.toExact());
        setStepIndex(4);
    }, [maxAmountInput, onUserInput]);
    const onChangePercentage = (value) => {
        if (stakedAmount.lessThan('0')) {
            setTypedValue('0');
            return;
        }
        if (value === 100) {
            setTypedValue(stakedAmount.toExact());
        }
        else if (value === 0) {
            setTypedValue('0');
        }
        else {
            const newAmount = stakedAmount.multiply(JSBI$1.BigInt(value)).divide(JSBI$1.BigInt(100));
            setTypedValue(newAmount.toSignificant(6));
        }
    };
    const onUnstake = () => __awaiter(this, void 0, void 0, function* () {
        if (!sarStakingContract || !parsedAmount || !position) {
            return;
        }
        setAttempting(true);
        try {
            const estimatedGas = yield sarStakingContract.estimateGas.withdraw(position.id.toHexString(), `0x${parsedAmount.raw.toString(16)}`);
            const response = yield sarStakingContract.withdraw(position.id.toHexString(), `0x${parsedAmount.raw.toString(16)}`, {
                gasLimit: calculateGasMargin(estimatedGas),
            });
            yield waitForTransaction(response, 3);
            addTransaction(response, {
                summary: t('sarUnstake.transactionSummary', { symbol: png.symbol, balance: parsedAmount.toSignificant(2) }),
            });
            setHash(response.hash);
        }
        catch (err) {
            const _err = err;
            if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                console.error(_err);
                setUnstakeError(_err === null || _err === void 0 ? void 0 : _err.message);
            }
        }
        finally {
            setAttempting(false);
        }
    });
    return useMemo(() => ({
        attempting,
        hash,
        stepIndex,
        typedValue,
        parsedAmount,
        error,
        unstakeError,
        onUserInput,
        wrappedOnDismiss,
        handleMax,
        onUnstake,
        onChangePercentage,
        setStepIndex,
    }), [
        attempting,
        typedValue,
        parsedAmount,
        hash,
        stepIndex,
        error,
        account,
        sarStakingContract,
        onUserInput,
        handleMax,
        position,
    ]);
}
function useDerivativeSarCompound(position) {
    const [attempting, setAttempting] = useState(false);
    const [hash, setHash] = useState(null);
    const [compoundError, setCompoundError] = useState(null);
    const { account } = usePangolinWeb3();
    const sarStakingContract = useSarStakingContract();
    const { t } = useTranslation();
    const addTransaction = useTransactionAdder();
    const wrappedOnDismiss = useCallback(() => {
        setCompoundError(null);
        setHash(null);
        setAttempting(false);
    }, []);
    const onCompound = () => __awaiter(this, void 0, void 0, function* () {
        if (!sarStakingContract || !position) {
            return;
        }
        setAttempting(true);
        try {
            const estimatedGas = yield sarStakingContract.estimateGas.compound(position.id.toHexString());
            const response = yield sarStakingContract.compound(position.id.toHexString(), {
                gasLimit: calculateGasMargin(estimatedGas),
            });
            yield waitForTransaction(response, 3);
            addTransaction(response, {
                summary: t('sarCompound.transactionSummary'),
            });
            setHash(response.hash);
        }
        catch (error) {
            const err = error;
            if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                console.error(err);
                setCompoundError(err === null || err === void 0 ? void 0 : err.message);
            }
        }
        finally {
            setAttempting(false);
        }
    });
    return useMemo(() => ({
        attempting,
        hash,
        compoundError,
        wrappedOnDismiss,
        onCompound,
    }), [sarStakingContract, attempting, hash, account, position]);
}
function useDerivativeSarClaim(position) {
    const [attempting, setAttempting] = useState(false);
    const [hash, setHash] = useState(null);
    const [claimError, setClaimError] = useState(null);
    const { account } = usePangolinWeb3();
    const sarStakingContract = useSarStakingContract();
    const { t } = useTranslation();
    const addTransaction = useTransactionAdder();
    const wrappedOnDismiss = useCallback(() => {
        setClaimError(null);
        setHash(null);
        setAttempting(false);
    }, []);
    const onClaim = () => __awaiter(this, void 0, void 0, function* () {
        if (!sarStakingContract || !position) {
            return;
        }
        setAttempting(true);
        try {
            const estimatedGas = yield sarStakingContract.estimateGas.harvest(position.id.toHexString());
            const response = yield sarStakingContract.harvest(position.id.toHexString(), {
                gasLimit: calculateGasMargin(estimatedGas),
            });
            yield waitForTransaction(response, 3);
            addTransaction(response, {
                summary: t('sarClaim.transactionSummary'),
            });
            setHash(response.hash);
        }
        catch (error) {
            const err = error;
            if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                console.error(err);
                setClaimError(err === null || err === void 0 ? void 0 : err.message);
            }
        }
        finally {
            setAttempting(false);
        }
    });
    return useMemo(() => ({
        attempting,
        hash,
        claimError,
        wrappedOnDismiss,
        onClaim,
    }), [sarStakingContract, attempting, hash, account, position]);
}
// Returns a list of user positions
function useSarPositions() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const sarStakingContract = useSarStakingContract();
    const [nftsIndexes, setNftsIndexes] = useState();
    useEffect(() => {
        const getNftsIndexes = () => __awaiter(this, void 0, void 0, function* () {
            if (!sarStakingContract)
                return;
            const balance = yield sarStakingContract.balanceOf(account);
            if (balance.isZero()) {
                setNftsIndexes([]);
                return;
            }
            // get all positions ids
            const indexes = yield sarStakingContract.tokensOfOwnerByIndex(account, ZERO.toHexString(), balance.sub(1).toHexString());
            const _nftsIndexes = indexes === null || indexes === void 0 ? void 0 : indexes.map((index) => {
                return [index.toHexString()];
            });
            setNftsIndexes(_nftsIndexes);
        });
        getNftsIndexes();
    }, [sarStakingContract]);
    // get the staked amount for each position
    const positionsAmountState = useSingleContractMultipleData(sarStakingContract, 'positions', nftsIndexes !== null && nftsIndexes !== void 0 ? nftsIndexes : []);
    // get the reward rate for each position
    const positionsRewardRateState = useSingleContractMultipleData(sarStakingContract, 'positionRewardRate', nftsIndexes !== null && nftsIndexes !== void 0 ? nftsIndexes : []);
    const positionsPedingRewardsState = useSingleContractMultipleData(sarStakingContract, 'positionPendingRewards', nftsIndexes !== null && nftsIndexes !== void 0 ? nftsIndexes : []);
    //get all NFTs URIs from the positions
    const nftsURIsState = useSingleContractMultipleData(sarStakingContract, 'tokenURI', nftsIndexes !== null && nftsIndexes !== void 0 ? nftsIndexes : []);
    return useMemo(() => {
        const isAllFetchedURI = nftsURIsState.every((result) => !result.loading);
        const existErrorURI = nftsURIsState.some((result) => result.error);
        const isValidURIs = nftsURIsState.every((result) => result.valid);
        const isAllFetchedAmount = positionsAmountState.every((result) => !result.loading);
        const existErrorAmount = positionsAmountState.some((result) => result.error);
        const isValidAmounts = positionsAmountState.every((result) => result.valid);
        const isAllFetchedRewardRate = positionsRewardRateState.every((result) => !result.loading);
        const existErrorRewardRate = positionsRewardRateState.some((result) => result.error);
        const isValidRewardRates = positionsRewardRateState.every((result) => result.valid);
        const isAllFetchedPendingReward = positionsPedingRewardsState.every((result) => !result.loading);
        const existErrorPendingReward = positionsPedingRewardsState.some((result) => result.error);
        const isValidPendingRewards = positionsPedingRewardsState.every((result) => result.valid);
        const isLoading = !isAllFetchedURI || !isAllFetchedAmount || !isAllFetchedRewardRate || !isAllFetchedPendingReward;
        // first moments loading is false and valid is false then is loading the query is true
        const isValid = isValidURIs && isValidAmounts && isValidRewardRates && isValidPendingRewards;
        const error = existErrorURI || existErrorAmount || existErrorRewardRate || existErrorPendingReward;
        if (error || !account || !existSarContract(chainId) || (!!nftsIndexes && nftsIndexes.length === 0)) {
            return { positions: [], isLoading: false };
        }
        // if is loading or exist error or not exist account return empty array
        if (isLoading || !isValid || !nftsIndexes) {
            return { positions: [], isLoading: true };
        }
        // we need to decode the base64 uri to get the real uri
        const nftsURIs = nftsURIsState.map((value) => {
            if (value.result) {
                const base64 = value.result[0];
                //need to remove the data:application/json;base64, to decode the base64
                const nftUri = Buffer.from(base64.replace('data:application/json;base64,', ''), 'base64').toString();
                return JSON.parse(nftUri);
            }
            return {};
        });
        const positions = nftsURIs.map((uri, index) => {
            var _a, _b, _c, _d;
            const valueVariables = (_a = positionsAmountState[index].result) === null || _a === void 0 ? void 0 : _a.valueVariables;
            const rewardRate = (_b = positionsRewardRateState[index].result) === null || _b === void 0 ? void 0 : _b[0];
            const pendingRewards = (_c = positionsPedingRewardsState[index].result) === null || _c === void 0 ? void 0 : _c[0];
            const id = nftsIndexes[index][0];
            const balance = (_d = valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.balance) !== null && _d !== void 0 ? _d : BigNumber.from(0);
            const apr = rewardRate === null || rewardRate === void 0 ? void 0 : rewardRate.mul(86400).mul(365).mul(100).div(balance.isZero() ? 1 : balance);
            if (!valueVariables || !rewardRate || !pendingRewards || !uri) {
                return {};
            }
            return {
                id: BigNumber.from(id),
                balance: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.balance,
                sumOfEntryTimes: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.sumOfEntryTimes,
                apr: apr,
                rewardRate: rewardRate,
                uri: uri,
                pendingRewards: pendingRewards,
            };
        });
        // remove the empty positions
        return { positions: positions.filter((position) => !!position), isLoading: false };
    }, [account, positionsAmountState, positionsRewardRateState, nftsURIsState, nftsIndexes]);
}

styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
  padding: 20px;
`;
const ErrorWrapper = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ErrorBox = styled(Box)`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const SubmittedWrapper = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const Link = styled(Text)`
  text-decoration: none;
  color: ${({ theme }) => theme.blue1};
`;
const Header = styled(Box)`
  padding: 0px 10px;
  display: grid;
  grid-gap: 10px;
`;
const TokenRow = styled(Box)`
  display: grid;
  grid-template-columns: max-content max-content;
  align-items: center;
`;
const Footer = styled(Box)`
  padding: 0px 10px;
`;

const ConfirmDrawer = (props) => {
    const { isOpen, attemptingTxn, title, errorMessage, pendingMessage, successMessage, txHash, confirmContent, onClose, } = props;
    const { chainId } = usePangolinWeb3();
    const theme = useContext(ThemeContext);
    const { t } = useTranslation();
    const PendingContent = jsx(Loader, { size: 100, label: pendingMessage });
    const ErroContent = (jsxs(ErrorWrapper, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxs(ErrorBox, { children: [jsx(AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'red1', textAlign: "center", style: { width: '85%' } }, { children: errorMessage }))] }), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] })));
    const SubmittedContent = (jsxs(SubmittedWrapper, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", paddingY: '20px' }, { children: [jsx(Box, Object.assign({ flex: "1", display: "flex", alignItems: "center" }, { children: jsx("img", { src: CircleTick, alt: "circle-tick" }) })), jsxs(Text, Object.assign({ fontSize: 16, color: "text1", textAlign: "center" }, { children: [successMessage, jsx("br", {}), t('sarStake.yourAprRecalculated')] })), chainId && txHash && (jsx(Link, Object.assign({ as: "a", fontWeight: 500, fontSize: 14, color: 'primary', href: getEtherscanLink(chainId, txHash, 'transaction'), target: "_blank" }, { children: t('transactionConfirmation.viewExplorer') })))] })), jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.close') }))] })));
    const renderBody = () => {
        if (errorMessage) {
            return ErroContent;
        }
        if (txHash) {
            return SubmittedContent;
        }
        if (attemptingTxn) {
            return PendingContent;
        }
        return confirmContent;
    };
    return (jsx(Drawer, Object.assign({ isOpen: isOpen, onClose: onClose, title: title }, { children: renderBody() })));
};

var Options;
(function (Options) {
    Options["UNSTAKE"] = "Unstake";
    Options["CLAIM"] = "Claim";
    Options["COMPOUND"] = "Compound";
    Options["ADD"] = "Add";
})(Options || (Options = {}));

function Title({ selectPosition, selectedOption, onChange }) {
    const { t } = useTranslation();
    const renderTitle = () => {
        switch (selectedOption) {
            case Options.ADD:
                return t('sarTitle.addMore');
            case Options.UNSTAKE:
                return t('sarTitle.unstake');
            case Options.COMPOUND:
                return t('sarTitle.compound');
            case Options.CLAIM:
                return t('sarTitle.claim');
            default:
                return '';
        }
    };
    return (jsxs(Box, Object.assign({ display: "flex", flexDirection: "column" }, { children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: selectPosition ? 'space-between' : 'start', alignItems: "center" }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: "15.75px", fontWeight: 700 }, { children: renderTitle() })), selectPosition && (jsx(Text, Object.assign({ color: "text8", fontSize: "10px" }, { children: t('sarTitle.interactingID', { id: selectPosition === null || selectPosition === void 0 ? void 0 : selectPosition.id.toString() }) })))] })), jsx(ToggleButtons, { options: [Options.COMPOUND, Options.ADD, Options.UNSTAKE, Options.CLAIM], value: selectedOption, onChange: onChange })] })));
}

const Root$5 = styled(Box)`
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;
const Buttons$3 = styled(Box)`
  display: grid;
  grid-auto-flow: ${({ isStaked }) => (isStaked ? 'column' : 'row')};
  grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 10px;
  margin-top: 5px;
`;
const Wrapper$3 = styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;

// Add more png on existing position
function AddStake({ selectedOption, selectedPosition, onChange }) {
    var _a, _b, _c, _d, _e;
    const [openDrawer, setOpenDrawer] = useState(false);
    const chainId = useChainId();
    const { account } = usePangolinWeb3();
    const png = PNG[chainId];
    const userPngBalance = useTokenBalance(account !== null && account !== void 0 ? account : ZERO_ADDRESS, png);
    const { t } = useTranslation();
    const { apr } = useSarStakeInfo();
    const toggleWalletModal = useWalletModalToggle();
    const { attempting, typedValue, parsedAmount, hash, dollerWorth, error, approval, stakeError, onAttemptToApprove, onUserInput, wrappedOnDismiss, handleMax, onStake, } = useDerivativeSarStake(selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.id);
    const oldBalance = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.balance;
    const newBalance = oldBalance === null || oldBalance === void 0 ? void 0 : oldBalance.add(((_a = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.raw) !== null && _a !== void 0 ? _a : 0).toString()).add((_b = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.pendingRewards) !== null && _b !== void 0 ? _b : 0);
    // if new balance is zero return 1, if not exist position return 1 , if exist position return new balance
    const _newBalance = (newBalance === null || newBalance === void 0 ? void 0 : newBalance.isZero()) ? 1 : newBalance !== null && newBalance !== void 0 ? newBalance : 1;
    const newAPR = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.rewardRate.mul(86400).mul(365).mul(100).div(_newBalance);
    const weeklyPNG = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.rewardRate.mul(86400).mul(7);
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = useState(false);
    // mark when a user has submitted an approval, reset onTokenSelection for input field
    useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const handleConfirmDismiss = useCallback(() => {
        setOpenDrawer(false);
        // if there was a tx hash, we want to clear the input
        if (hash) {
            onUserInput('');
        }
        wrappedOnDismiss();
    }, [onUserInput]);
    const showApproveFlow = !error &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED));
    const renderButtons = () => {
        if (!account) {
            return (jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", onClick: toggleWalletModal }, { children: t('earn.connectWallet') })));
        }
        else if (!(userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.greaterThan('0'))) {
            return (jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", as: "a", href: getBuyUrl(png, chainId) }, { children: t('sarStake.buy', { symbol: png.symbol }) })));
        }
        else {
            return (jsxs(Buttons$3, { children: [showApproveFlow && (jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', isDisabled: approval !== ApprovalState.NOT_APPROVED, onClick: onAttemptToApprove, height: "46px" }, { children: t('earn.approve') }))), jsx(Button, Object.assign({ variant: 'primary', isDisabled: !selectedPosition || !!error || approval !== ApprovalState.APPROVED, onClick: () => setOpenDrawer(true), height: "46px" }, { children: !selectedPosition ? t('sarStakeMore.choosePosition') : error !== null && error !== void 0 ? error : t('sarStakeMore.add') }))] }));
        }
    };
    const ConfirmContent = (jsxs(Wrapper$3, Object.assign({ paddingX: "20px", paddingBottom: "20px" }, { children: [jsxs(Header, { children: [jsxs(TokenRow, { children: [jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: "text1", style: { marginRight: '12px' } }, { children: (_c = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toSignificant(6)) !== null && _c !== void 0 ? _c : 0 })), jsx(CurrencyLogo, { currency: png, size: 24, imageSize: 48 })] }), jsxs(Box, Object.assign({ display: "inline-grid", style: { gridGap: '10px', gridTemplateColumns: 'auto auto' } }, { children: [jsx(Stat, { title: t('sarStake.dollarValue'), titlePosition: "top", stat: `$${dollerWorth !== null && dollerWorth !== void 0 ? dollerWorth : 0}`, titleColor: "text2" }), jsx(Stat, { title: t('sarStakeMore.newAPR'), titlePosition: "top", stat: `${newAPR}%`, titleColor: "text2" })] })), jsxs(Box, Object.assign({ display: "flex", flexDirection: "row", justifyContent: "space-between" }, { children: [jsx(Text, Object.assign({ color: "text1" }, { children: t('sarStake.weeklyDistributed', { symbol: png.symbol }) })), jsx(Text, Object.assign({ color: "text1" }, { children: numeral(formatEther(weeklyPNG !== null && weeklyPNG !== void 0 ? weeklyPNG : 0)).format('0.00a') }))] })), jsxs(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: [t('sarStake.confirmDescription', { symbol: png.symbol }), jsx("br", {}), jsx("br", {}), t('sarStakeMore.confirmDescription', { symbol: png.symbol })] }))] }), jsx(Footer, { children: jsx(Box, Object.assign({ my: '10px' }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: onStake }, { children: t('sarStakeMore.add') })) })) })] })));
    return (jsxs(Box, {
        children: [jsxs(Root$5, {
            children: [jsx(Title, { selectPosition: selectedPosition, selectedOption: selectedOption, onChange: onChange }), jsxs(Box, {
                children: [jsxs(Box, Object.assign({ justifyContent: "space-between", display: "flex" }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: "18px", fontWeight: 500 }, { children: t('sarStakeMore.stakeMore') })), jsx(Text, Object.assign({ color: "text4" }, { children: t('sarStake.walletBalance', { symbol: png.symbol, balance: (_d = userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.toFixed(2)) !== null && _d !== void 0 ? _d : 0 }) }))] })), jsx(TextInput, {
                    value: typedValue, isNumeric: true, placeholder: "0.00", onChange: (value) => {
                        onUserInput(value);
                    }, addonAfter: jsx(Button, Object.assign({ variant: "plain", backgroundColor: "color2", padding: "6px", height: "auto", onClick: handleMax }, { children: jsx(Text, Object.assign({ color: "text1" }, { children: "MAX" })) }))
                })]
            }), jsxs(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.dollarValue') })), jsxs(Text, Object.assign({ color: "text1" }, { children: ["$", dollerWorth !== null && dollerWorth !== void 0 ? dollerWorth : '0'] }))] }), jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.averageAPR') })), jsx(Text, Object.assign({ color: "text1" }, { children: `${(apr !== null && apr !== void 0 ? apr : '-').toString()}%` }))] })] })), jsxs(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: [t('sarStake.confirmDescription', { symbol: png.symbol }), jsx("br", {}), jsx("br", {}), t('sarStakeMore.confirmDescription', { symbol: png.symbol })] }))] })), renderButtons()]
        }), jsx(ConfirmDrawer, { title: stakeError || hash || attempting ? '' : t('sarStake.summary'), isOpen: openDrawer && !!selectedPosition, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: stakeError, pendingMessage: t('sarStakeMore.pending', { balance: (_e = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toFixed(2)) !== null && _e !== void 0 ? _e : 0, symbol: png.symbol }), successMessage: t('sarStake.successSubmit'), confirmContent: ConfirmContent })]
    }));
}

function RewardsInfo({ selectedOption, selectedPosition, pendingRewards, onChange }) {
    const { t } = useTranslation();
    const chainId = useChainId();
    const png = PNG[chainId];
    const theme = useContext(ThemeContext);
    const formattedPedingRewards = numeral(pendingRewards).format('0.00a');
    return (jsxs(Fragment, { children: [jsx(Title, { selectPosition: selectedPosition, selectedOption: selectedOption, onChange: onChange }), !selectedPosition ? (jsx(Box, { children: jsx(Text, Object.assign({ color: "text1", fontSize: "24px", fontWeight: 500, textAlign: "center" }, { children: t('sarStakeMore.choosePosition') })) })) : (jsxs(Box, { children: [jsxs(Text, Object.assign({ color: "text1", fontSize: "16px", fontWeight: 500, textAlign: "center" }, { children: [t('sarCompound.reward'), ":"] })), jsx(Tooltip, Object.assign({ id: "pendingRewards", effect: "solid", backgroundColor: theme.primary }, { children: jsxs(Text, Object.assign({ color: "eerieBlack", fontSize: "12px", fontWeight: 500, textAlign: "center" }, { children: [pendingRewards, " ", png.symbol] })) })), jsxs(Text, Object.assign({ color: "text1", fontSize: "36px", fontWeight: 500, textAlign: "center", "data-tip": true, "data-for": "pendingRewards" }, { children: [formattedPedingRewards === 'NaN' ? '0.00' : formattedPedingRewards, jsx(CurrencyLogo, { currency: png })] }))] }))] }));
}

const Root$4 = styled(Box)`
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;
const Buttons$2 = styled(Box)`
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-gap: 20px;
`;

function Claim({ selectedOption, selectedPosition, onChange }) {
    var _a;
    const [openDrawer, setOpenDrawer] = useState(false);
    const { attempting, hash, claimError, wrappedOnDismiss, onClaim } = useDerivativeSarClaim(selectedPosition);
    const { t } = useTranslation();
    const apr = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.apr;
    const handleConfirmDismiss = useCallback(() => {
        setOpenDrawer(false);
        wrappedOnDismiss();
    }, []);
    const handleConfirm = useCallback(() => {
        onClaim();
    }, [onClaim]);
    useEffect(() => {
        if (openDrawer && !attempting && !hash && !claimError) {
            handleConfirmDismiss();
        }
        if (!openDrawer && attempting) {
            setOpenDrawer(true);
        }
    }, [attempting]);
    const pendingRewards = (_a = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.pendingRewards) !== null && _a !== void 0 ? _a : BigNumber.from('0');
    const renderButton = () => {
        let error;
        if (!selectedPosition) {
            error = t('sarStakeMore.choosePosition');
        }
        else if (pendingRewards.isZero()) {
            error = t('sarClaim.noRewards');
        }
        return (jsxs(Buttons$2, { children: [jsx(Button, Object.assign({ variant: "primary", onClick: () => onChange(Options.COMPOUND) }, { children: t('sarCompound.compound') })), jsx(Button, Object.assign({ variant: "primary", onClick: handleConfirm, isDisabled: !!error }, { children: error !== null && error !== void 0 ? error : t('sarClaim.claim') }))] }));
    };
    return (jsxs(Box, { children: [jsxs(Root$4, { children: [jsx(RewardsInfo, { selectedOption: selectedOption, onChange: onChange, pendingRewards: formatEther(pendingRewards), selectedPosition: selectedPosition }), jsxs(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarUnstake.currentAPR') })), jsxs(Text, Object.assign({ color: "text1" }, { children: [(apr !== null && apr !== void 0 ? apr : '-').toString(), "%"] }))] }), jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarClaim.aprAfter') })), jsx(Text, Object.assign({ color: "text1" }, { children: "0%" }))] })] })), jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: "Due to the nature of SAR staking system claiming your rewards will drop your APR to 0. You can instead compound your rewards without losing your APR." }))] })), renderButton()] }), jsx(ConfirmDrawer, { isOpen: openDrawer && !!selectedPosition, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: claimError, pendingMessage: t('sarClaim.pending'), successMessage: t('sarClaim.successSubmit'), confirmContent: null })] }));
}

const Root$3 = styled(Box)`
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;

function Compound({ selectedOption, selectedPosition, onChange }) {
    var _a, _b, _c;
    const [openDrawer, setOpenDrawer] = useState(false);
    const { attempting, hash, compoundError, wrappedOnDismiss, onCompound } = useDerivativeSarCompound(selectedPosition);
    const { apr } = useSarStakeInfo();
    const oldBalance = (_a = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.balance) !== null && _a !== void 0 ? _a : BigNumber.from('0');
    const pendingRewards = (_b = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.pendingRewards) !== null && _b !== void 0 ? _b : BigNumber.from('0');
    const chainId = useChainId();
    const png = PNG[chainId];
    const useUSDPrice = useUSDCPriceHook[chainId];
    const pngPrice = useUSDPrice(png);
    const dollarValue = parseFloat(formatEther(oldBalance.add(pendingRewards))) * Number((_c = pngPrice === null || pngPrice === void 0 ? void 0 : pngPrice.toFixed()) !== null && _c !== void 0 ? _c : 0);
    const { t } = useTranslation();
    const handleConfirmDismiss = useCallback(() => {
        setOpenDrawer(false);
        wrappedOnDismiss();
    }, []);
    useEffect(() => {
        if (openDrawer && !attempting && !hash && !compoundError) {
            handleConfirmDismiss();
        }
        if (!openDrawer && attempting) {
            setOpenDrawer(true);
        }
    }, [attempting]);
    const renderButton = () => {
        let error;
        if (!selectedPosition) {
            error = t('sarStakeMore.choosePosition');
        }
        else if (oldBalance === null || oldBalance === void 0 ? void 0 : oldBalance.isZero()) {
            error = t('sarCompound.noRewards');
        }
        return (jsx(Button, Object.assign({ variant: "primary", onClick: onCompound, isDisabled: !!error }, { children: error !== null && error !== void 0 ? error : t('sarCompound.compound') })));
    };
    return (jsxs(Box, { children: [jsxs(Root$3, { children: [jsx(RewardsInfo, { selectedOption: selectedOption, onChange: onChange, pendingRewards: formatEther(pendingRewards.toString()), selectedPosition: selectedPosition }), jsxs(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.dollarValue') })), jsxs(Text, Object.assign({ color: "text1" }, { children: ["$", dollarValue] }))] }), jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.averageAPR') })), jsxs(Text, Object.assign({ color: "text1" }, { children: [(apr !== null && apr !== void 0 ? apr : '-').toString(), "%"] }))] })] })), jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: t('sarCompound.description') }))] })), renderButton()] }), jsx(ConfirmDrawer, { isOpen: openDrawer && !!selectedPosition, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: compoundError, pendingMessage: t('sarCompound.pending'), successMessage: t('sarCompound.successSubmit'), confirmContent: null })] }));
}

const Wrapper$2 = styled(Box)`
  border-radius: 10px;
  width: 100%;
  background-color: ${({ theme }) => theme.color2};
  position: relative;
  overflow: hidden;
  padding: 30px;
  box-sizing: border-box;
`;

const Root$2 = styled(Box)`
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;
styled(Box)`
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;

function Unstake({ selectedOption, selectedPosition, onChange }) {
    var _a, _b, _c, _d, _e;
    const [openDrawer, setOpenDrawer] = useState(false);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const png = PNG[chainId];
    const stakedAmount = (_a = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.balance) !== null && _a !== void 0 ? _a : 0;
    const { t } = useTranslation();
    const { attempting, hash, typedValue, parsedAmount, error, unstakeError, onUserInput, wrappedOnDismiss, handleMax, onUnstake, } = useDerivativeSarUnstake(selectedPosition);
    const toggleWalletModal = useWalletModalToggle();
    const handleConfirmDismiss = useCallback(() => {
        setOpenDrawer(false);
        // if there was a tx hash, we want to clear the input
        if (hash) {
            onUserInput('');
        }
        wrappedOnDismiss();
    }, [onUserInput]);
    const renderButton = () => {
        if (!account) {
            return (jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", onClick: toggleWalletModal }, { children: t('removeLiquidity.connectWallet') })));
        }
        else {
            return (jsx(Button, Object.assign({ variant: 'primary', isDisabled: !selectedPosition || !!error, onClick: () => setOpenDrawer(true), height: "46px" }, { children: !selectedPosition ? t('sarStakeMore.choosePosition') : error !== null && error !== void 0 ? error : t('sarUnstake.unstake') })));
        }
    };
    const ConfirmContent = (jsxs(Wrapper$2, Object.assign({ paddingX: "20px", paddingBottom: "20px" }, { children: [jsxs(Header, { children: [jsxs(TokenRow, { children: [jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: "text1", style: { marginRight: '12px' } }, { children: t('sarUnstake.unstaking', { balance: (_b = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toSignificant(6)) !== null && _b !== void 0 ? _b : 0 }) })), jsx(CurrencyLogo, { currency: png, size: 24, imageSize: 48 })] }), jsxs(Box, Object.assign({ display: "inline-grid", style: { gridGap: '10px', gridTemplateColumns: 'auto auto' } }, { children: [jsx(Stat, { title: t('sarUnstake.currentAPR'), titlePosition: "top", stat: `${((_c = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.apr) !== null && _c !== void 0 ? _c : '-').toString()}%`, titleColor: "text2" }), jsx(Stat, { title: t('sarStakeMore.newAPR'), titlePosition: "top", stat: '0%', titleColor: "text2" })] })), jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: t('sarUnstake.confirmDescription') }))] }), jsx(Footer, { children: jsx(Box, Object.assign({ my: '10px' }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: onUnstake }, { children: t('sarUnstake.unstake') })) })) })] })));
    return (jsxs(Box, {
        children: [jsxs(Root$2, {
            children: [jsx(Title, { selectPosition: selectedPosition, selectedOption: selectedOption, onChange: onChange }), jsxs(Box, {
                children: [jsxs(Box, Object.assign({ justifyContent: "space-between", display: "flex" }, {
                    children: [jsx(Text, Object.assign({ color: "text1", fontSize: "18px", fontWeight: 500 }, { children: t('sarUnstake.unstake') })), jsx(Text, Object.assign({ color: "text4" }, {
                        children: t('sarUnstake.stakedBalance', {
                            symbol: png.symbol,
                            balance: numeral(formatEther(stakedAmount)).format('0.00a'),
                        })
                    }))]
                })), jsx(TextInput, {
                    value: typedValue, isNumeric: true, placeholder: "0.00", addonAfter: jsx(Button, Object.assign({ variant: "plain", backgroundColor: "color2", padding: "6px", height: "auto", onClick: handleMax }, { children: jsx(Text, Object.assign({ color: "text1" }, { children: t('sarStake.max') })) })), onChange: (value) => {
                        onUserInput(value);
                    }
                })]
            }), jsxs(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarUnstake.currentAPR') })), jsxs(Text, Object.assign({ color: "text1" }, { children: [((_d = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.apr) !== null && _d !== void 0 ? _d : '-').toString(), "%"] }))] }), jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarUnstake.aprAfter') })), jsx(Text, Object.assign({ color: "text1" }, { children: "0%" }))] })] })), jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: t('sarUnstake.unstakeWarning') }))] })), renderButton()]
        }), jsx(ConfirmDrawer, { title: unstakeError || hash || attempting ? '' : t('sarStake.summary'), isOpen: openDrawer && !!selectedPosition, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: unstakeError, pendingMessage: t('sarUnstake.pending', { balance: (_e = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toSignificant(2)) !== null && _e !== void 0 ? _e : 0, symbol: png.symbol }), successMessage: t('sarUnstake.successSubmit'), confirmContent: ConfirmContent })]
    }));
}

function SarMangePortfolio({ selectedPosition }) {
    const [type, setType] = useState(Options.ADD);
    const handleChange = (value) => {
        setType(value);
    };
    const renderBody = () => {
        switch (type) {
            case Options.ADD:
                return jsx(AddStake, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
            case Options.UNSTAKE:
                return jsx(Unstake, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
            case Options.CLAIM:
                return jsx(Claim, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
            case Options.COMPOUND:
                return jsx(Compound, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
            default:
                return jsx(AddStake, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
        }
    };
    return jsx(Wrapper$2, Object.assign({ id: "sar-manage-widget" }, { children: renderBody() }));
}

const Paginate = styled(ReactPaginate)`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  list-style-type: none;
  padding: 0 5rem;

  li a {
    border-radius: 7px;
    padding: 0.1rem 1rem;
    cursor: pointer;
    color: ${({ theme }) => theme.text1};
  }

  li.previous a,
  li.next a,
  li.break a {
    border-color: transparent;
  }

  li.active a {
    background-color: ${({ theme }) => theme.primary};
    border-color: transparent;
    color: black;
    min-width: 32px;
  }

  li.disabled a {
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.disable) === null || _b === void 0 ? void 0 : _b.background; }};
    cursor: default;
  }
`;

function Pagination({ pageCount, forcePage, onPageChange }) {
    return (jsx(Box, Object.assign({ display: "flex", justifyContent: "center", alignItems: "center" }, { children: jsx(Paginate, { onPageChange: onPageChange, pageRangeDisplayed: 3, marginPagesDisplayed: 2, pageCount: pageCount, previousLabel: jsx(ChevronLeft, { size: 20 }), nextLabel: jsx(ChevronRight, { size: 20 }), breakLabel: "...", activeClassName: "active", forcePage: forcePage }) })));
}

const Root$1 = styled(Box)`
  display: flex;
  width: 100%;
  height: 100%;
`;
styled(Box)`
  display: inline-grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
`;
const Frame = styled(Box)`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  flex-grow: 1;
  grid-gap: 16px;
`;
const StyledSVG = styled(Box)`
  svg {
    width: 100%;
    height: auto;
  }
`;
const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(35, 35, 35);
  opacity: 0.8;
  display: none;
  z-index: 99;
`;

function Portfolio({ positions, onSelectPosition }) {
    const [itemsPerPage, setItemsPerPage] = useState(12);
    const [pageCount, setPageCount] = useState(0);
    const [itemOffset, setItemOffset] = useState(0);
    const [currentItems, setCurrentItems] = useState(positions.slice(0, itemsPerPage));
    const [selectedOption, setSelectedOption] = useState('');
    const [selectedPositonId, setSelectedPositionId] = useState(null);
    const [page, setPage] = useState();
    const node = useRef(null);
    const imageRef = useRef(null);
    const { t } = useTranslation();
    const isMobile = useMedia(`(max-width: ${MEDIA_WIDTHS.upToMedium}px)`);
    function sortItems(itemOffset, endOffset, sortOption) {
        if (sortOption === 'apr') {
            setCurrentItems([...positions].sort((a, b) => b.apr.sub(a.apr).toNumber()).slice(itemOffset, endOffset));
        }
        else if (sortOption === 'amount') {
            setCurrentItems([...positions]
                .sort((a, b) => {
                    return parseFloat(formatEther(b.balance.sub(a.balance)));
                })
                .slice(itemOffset, endOffset));
        }
        else if (sortOption === 'newest') {
            setCurrentItems([...positions].sort((a, b) => b.id.sub(a.id).toNumber()).slice(itemOffset, endOffset));
        }
        else if (sortOption === 'oldest') {
            setCurrentItems([...positions].sort((a, b) => a.id.sub(b.id).toNumber()).slice(itemOffset, endOffset));
        }
        else {
            setCurrentItems(positions.slice(itemOffset, endOffset));
        }
    }
    const onSelect = (value) => {
        setSelectedOption(value);
        sortItems(0, itemsPerPage, value);
        setPage(0);
        setItemOffset(0);
    };
    const { width, height } = useWindowSize();
    useEffect(() => {
        const endOffset = itemOffset + itemsPerPage;
        sortItems(itemOffset, endOffset, selectedOption || '');
        setPageCount(Math.ceil(positions.length / itemsPerPage));
        setPage(undefined);
    }, [positions, itemOffset, itemsPerPage]);
    // calcule items per page based on node size and image size
    useEffect(() => {
        if (node.current && imageRef.current) {
            const nodeWidth = node.current.offsetWidth;
            const nodeHeight = node.current.offsetHeight;
            const imageWidth = imageRef.current.offsetWidth;
            const imageHeight = imageRef.current.offsetHeight;
            // number of columns = node width  / image width
            // number of rows = node height / image height
            // items per page = number of columns * number of rows
            let _itemsPerPage = Math.floor(nodeWidth / imageWidth); // calculate number of columns
            _itemsPerPage = _itemsPerPage * Math.floor(nodeHeight / imageHeight); // calculate number of rows
            setItemsPerPage(_itemsPerPage);
        }
        else {
            setItemsPerPage(12); // fallback to show 12 items per page
        }
        setPage(undefined);
    }, [width, height]);
    const handlePageClick = (event) => {
        const newOffset = (event.selected * itemsPerPage) % positions.length;
        setItemOffset(newOffset);
    };
    const renderItems = () => {
        return currentItems.map((position, index) => {
            const svg = Buffer.from(position === null || position === void 0 ? void 0 : position.uri.image.replace('data:image/svg+xml;base64,', ''), 'base64').toString(); // decode base64
            const isSelected = !!selectedPositonId && (position === null || position === void 0 ? void 0 : position.id.eq(selectedPositonId));
            return (jsxs(Box, Object.assign({
                width: "100%", height: "max-content", bgColor: isSelected ? 'primary' : undefined, borderRadius: "5px", paddingX: "5px", paddingBottom: "5px", style: { cursor: 'pointer', boxSizing: 'border-box' }, onClick: () => {
                    if (isMobile) {
                        const element = document.getElementById('sar-manage-widget');
                        scrollElementIntoView(element, 'smooth');
                    }
                    setSelectedPositionId(isSelected ? null : position.id);
                    onSelectPosition(isSelected ? null : position);
                }, ref: imageRef
            }, { children: [jsx(StyledSVG, { dangerouslySetInnerHTML: { __html: svg }, width: "100%" }, svg), jsxs(Text, Object.assign({ color: isSelected ? 'black' : 'text1', textAlign: "center", fontWeight: 500 }, { children: [t('sarPortfolio.positionId'), ": ", position === null || position === void 0 ? void 0 : position.id.toString()] }))] }), index));
        });
    };
    return (jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", width: "100%" }, {
        children: [jsx(Box, Object.assign({ display: "flex", justifyContent: "end", mb: "20px" }, {
            children: jsx(DropdownMenu, {
                placeHolder: `${t('sarPortfolio.sortBy')}:`, onSelect: onSelect, defaultValue: selectedOption, isMulti: false, options: [
                    { label: t('sarPortfolio.apr'), value: 'apr' },
                    { label: t('sarPortfolio.amount'), value: 'amount' },
                    { label: t('sarPortfolio.newest'), value: 'newest' },
                    { label: t('sarPortfolio.oldest'), value: 'oldest' },
                ]
            })
        })), jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", flexGrow: 1 }, { children: [jsx(Frame, Object.assign({ ref: node }, { children: renderItems() })), jsx(Pagination, { pageCount: pageCount, onPageChange: handlePageClick, forcePage: page })] }))]
    })));
}

function SarNFTPortfolio({ onSelectPosition }) {
    const { account } = usePangolinWeb3();
    const { positions, isLoading } = useSarPositions();
    // sort by balance
    const filteredPositions = positions === null || positions === void 0 ? void 0 : positions.filter((position) => !position.balance.isZero()).sort((a, b) => Number(b.balance.sub(a.balance).toString())); // remove zero balances and sort by balance
    const toggleWalletModal = useWalletModalToggle();
    const { t } = useTranslation();
    const sarOverlayElement = document.getElementById('sar-portfolio-overlay');
    const displayOverlay = () => {
        if (sarOverlayElement) {
            sarOverlayElement.style.display = 'block';
        }
    };
    const hideOverlay = () => {
        if (sarOverlayElement) {
            sarOverlayElement.style.display = 'none';
        }
    };
    const focusCreatePosition = () => {
        var _a;
        const element = document.getElementById('create-sar-position-widget');
        scrollElementIntoView(element, 'smooth');
        (_a = document.getElementById('sar-stake-input')) === null || _a === void 0 ? void 0 : _a.focus();
        displayOverlay();
    };
    // remove overlay when user change the account
    useEffect(() => {
        hideOverlay();
    }, [account]);
    const renderBody = () => {
        if (isLoading || !filteredPositions) {
            return (jsx(Box, Object.assign({ justifyContent: "center", alignItems: "center", width: "100%", height: "100%" }, { children: jsx(Loader, { size: 100 }) })));
        }
        else if (filteredPositions.length === 0) {
            return (jsxs(Box, Object.assign({ display: "grid", justifyItems: "center", alignContent: "center", width: "100%", height: "100%", style: { gridGap: '30px' } }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: "18px", fontWeight: 500, textAlign: "center" }, { children: t('sarPortfolio.noPositions') })), !account ? (jsx(Button, Object.assign({ variant: "primary", width: "250px", onClick: toggleWalletModal }, { children: t('removeLiquidity.connectWallet') }))) : (jsx(Button, Object.assign({ variant: "primary", width: "250px", onClick: focusCreatePosition }, { children: t('sarPortfolio.start') })))] })));
        }
        return jsx(Portfolio, { positions: filteredPositions, onSelectPosition: onSelectPosition });
    };
    return (jsxs(Root$1, { children: [renderBody(), jsx(Overlay, { id: "sar-portfolio-overlay", onClick: hideOverlay })] }));
}

const Root = styled(Box)`
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;
const Wrapper$1 = styled(Box)`
  border-radius: 10px;
  width: 100%;
  background-color: ${({ theme }) => theme.color2};
  position: relative;
  overflow-x: hidden;
  box-sizing: border-box;
`;
const Buttons$1 = styled(Box)`
  display: grid;
  grid-auto-flow: ${({ isStaked }) => (isStaked ? 'column' : 'row')};
  grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 10px;
  margin-top: 5px;
`;

function SarManageWidget() {
    var _a, _b, _c;
    const [openDrawer, setOpenDrawer] = useState(false);
    const chainId = useChainId();
    const { account } = usePangolinWeb3();
    const png = PNG[chainId];
    const userPngBalance = useTokenBalance(account !== null && account !== void 0 ? account : ZERO_ADDRESS, png);
    const { t } = useTranslation();
    const { apr, weeklyPNG } = useSarStakeInfo();
    const toggleWalletModal = useWalletModalToggle();
    const { positions, isLoading } = useSarPositions();
    // get fist position with balance 0
    const position = positions === null || positions === void 0 ? void 0 : positions.find((value) => value.balance.isZero());
    const { attempting, typedValue, parsedAmount, hash, dollerWorth, error, approval, stakeError, onAttemptToApprove, onUserInput, wrappedOnDismiss, handleMax, onStake, } = useDerivativeSarStake(position === null || position === void 0 ? void 0 : position.id);
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = useState(false);
    // mark when a user has submitted an approval, reset onTokenSelection for input field
    useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const handleConfirmDismiss = useCallback(() => {
        setOpenDrawer(false);
        // if there was a tx hash, we want to clear the input
        if (hash) {
            onUserInput('');
        }
        wrappedOnDismiss();
    }, [onUserInput]);
    const desativeOverlay = () => {
        const sarOverlayElement = document.getElementById('sar-portfolio-overlay');
        if (sarOverlayElement) {
            sarOverlayElement.style.display = 'none';
        }
    };
    const showApproveFlow = !error &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED));
    const renderButtons = () => {
        if (!account) {
            return (jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", onClick: toggleWalletModal }, { children: t('removeLiquidity.connectWallet') })));
        }
        else if (!(userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.greaterThan('0'))) {
            return (jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", as: "a", href: getBuyUrl(png, chainId), onClick: desativeOverlay }, { children: t('sarStake.buy', { symbol: png.symbol }) })));
        }
        else {
            return (jsxs(Buttons$1, {
                children: [showApproveFlow && (jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', isDisabled: approval !== ApprovalState.NOT_APPROVED || isLoading || !positions, onClick: onAttemptToApprove, height: "46px" }, { children: t('earn.approve') }))), jsx(Button, Object.assign({
                    variant: 'primary', isDisabled: !!error || approval !== ApprovalState.APPROVED || isLoading || !positions, onClick: () => {
                        setOpenDrawer(true);
                        desativeOverlay();
                    }, height: "46px"
                }, { children: error !== null && error !== void 0 ? error : t('sarStake.stake') }))]
            }));
        }
    };
    const handleInput = useCallback((value) => {
        onUserInput(value);
    }, [onUserInput]);
    const ConfirmContent = (jsxs(Box, Object.assign({ width: "100%", height: "100%", paddingX: "20px", paddingBottom: "20px" }, { children: [jsxs(Header, { children: [jsxs(TokenRow, { children: [jsx(Text, Object.assign({ fontSize: 20, fontWeight: 500, color: "text1", style: { marginRight: '12px' } }, { children: (_a = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toSignificant(6)) !== null && _a !== void 0 ? _a : 0 })), jsx(CurrencyLogo, { currency: png, size: 24, imageSize: 48 })] }), jsxs(Box, Object.assign({ display: "inline-grid", style: { gridGap: '10px', gridTemplateColumns: '1fr 1fr' } }, { children: [jsx(Stat, { title: t('sarStake.dollarValue'), titlePosition: "top", titleFontSize: 16, statFontSize: 12, stat: `$${dollerWorth !== null && dollerWorth !== void 0 ? dollerWorth : 0}`, titleColor: "text2" }), jsx(Stat, { title: t('sarStake.startingApr'), titlePosition: "top", stat: '0%', titleColor: "text2", titleFontSize: 16, statFontSize: 12 })] })), jsxs(Box, Object.assign({ display: "flex", flexDirection: "row", justifyContent: "space-between" }, { children: [jsx(Text, Object.assign({ color: "text1" }, { children: t('sarStake.weeklyDistributed', { symbol: png.symbol }) })), jsx(Text, Object.assign({ color: "text1" }, { children: numeral(formatEther(weeklyPNG)).format('0.00a') }))] })), jsx(Box, Object.assign({ bgColor: "color3", borderRadius: "8px", padding: "10px" }, { children: jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "12px", textAlign: "center" }, { children: t('sarStake.confirmDescription', { symbol: png.symbol }) })) }))] }), jsx(Footer, { children: jsx(Box, Object.assign({ my: '10px' }, { children: jsx(Button, Object.assign({ variant: "primary", onClick: onStake }, { children: t('sarStake.stake') })) })) })] })));
    return (jsxs(Wrapper$1, Object.assign({ id: "create-sar-position-widget", zIndex: 100 }, {
        children: [jsxs(Root, Object.assign({ padding: "30px" }, {
            children: [jsxs(Box, {
                children: [jsx(Box, Object.assign({ mb: 18 }, { children: jsx(Text, Object.assign({ color: "text1", fontSize: "21px", fontWeight: 700 }, { children: t('sarStake.createNewPosition') })) })), jsxs(Box, Object.assign({ justifyContent: "space-between", display: "flex" }, { children: [jsx(Text, Object.assign({ color: "text1", fontSize: "18px", fontWeight: 500 }, { children: t('sarStake.stake') })), jsx(Text, Object.assign({ color: "text4" }, { children: t('sarStake.walletBalance', { symbol: png.symbol, balance: (_b = userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.toFixed(2)) !== null && _b !== void 0 ? _b : 0 }) }))] })), jsx(TextInput, {
                    id: "sar-stake-input", value: typedValue, placeholder: "0.00", isNumeric: true, onChange: (value) => {
                        handleInput(value);
                    }, addonAfter: jsx(Button, Object.assign({ variant: "plain", backgroundColor: "color2", padding: "6px", height: "auto", onClick: handleMax }, { children: jsx(Text, Object.assign({ color: "text1" }, { children: t('sarStake.max') })) }))
                })]
            }), jsx(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.dollarValue') })), jsxs(Text, Object.assign({ color: "text1" }, { children: ["$", dollerWorth !== null && dollerWorth !== void 0 ? dollerWorth : '0'] }))] }), jsxs(Box, { children: [jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.averageAPR') })), jsx(Text, Object.assign({ color: "text1" }, { children: `${apr !== null && apr !== void 0 ? apr : '-'.toString()}%` }))] })] })) })), renderButtons()]
        })), jsx(ConfirmDrawer, { title: stakeError || hash || attempting ? '' : t('sarStake.summary'), isOpen: openDrawer, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: stakeError, pendingMessage: t('sarStake.pending', { balance: (_c = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toFixed(2)) !== null && _c !== void 0 ? _c : 0, symbol: png.symbol }), successMessage: t('sarStake.successSubmit'), confirmContent: ConfirmContent })]
    })));
}

const STabs = styled(Tabs$2)`
  font-style: normal;
  font-weight: 500;
  font-size: 18px;
`;
const STabPanel = styled(TabPanel$1)`
  display: none;
  min-height: 40vh;
  border-top: 1px solid ${({ theme }) => { var _a; return (_a = theme.tabs) === null || _a === void 0 ? void 0 : _a.tabPanelBorderColor; }};
  padding: 4px;
  margin-top: -5px;

  &.is-selected {
    display: block;
  }
`;
const STabList = styled(TabList$1)`
  color: ${({ theme }) => { var _a; return (_a = theme.tabs) === null || _a === void 0 ? void 0 : _a.tabListColor; }};
  list-style-type: none;
  padding-bottom: 5px;
  padding-left: 0px;
  display: flex;
  justify-content: flex-start;
  gap: 2.5rem;
  margin: 0;
  ${({ theme }) => theme.mediaWidth.upToSmall`
    overflow: auto;
    white-space: nowrap;
  `};
  &::-webkit-scrollbar {
    display: none !important;
  }
  -ms-overflow-style: none;
  scrollbar-width: none;
`;
const STab = styled(Tab$2)`
  padding: 4px;
  user-select: none;
  cursor: arrow;

  &:hover {
    color: ${({ theme }) => theme.primary};
    cursor: pointer;
  }

  &.react-tabs__tab--disabled {
    color: ${({ theme }) => { var _a; return (_a = theme.tabs) === null || _a === void 0 ? void 0 : _a.tabColor; }};
    cursor: not-allowed;
    &:hover {
      color: ${({ theme }) => { var _a; return (_a = theme.tabs) === null || _a === void 0 ? void 0 : _a.tabColor; }};
      cursor: default;
    }
  }

  &.is-selected {
    border-bottom: 3px solid ${({ theme }) => theme.primary};
  }

  &:focus {
    outline: none;
  }
`;

const Tabs = (props) => {
    return jsx(STabs, Object.assign({ selectedTabClassName: "is-selected", selectedTabPanelClassName: "is-selected" }, props));
};

const Tab = (props) => {
    return jsx(STab, Object.assign({}, props));
};
Tab.tabsRole = 'Tab';

const TabList = (props) => {
    return jsx(STabList, Object.assign({}, props));
};
TabList.tabsRole = 'TabList';

const TabPanel = (props) => {
    return jsx(STabPanel, Object.assign({}, props));
};
TabPanel.tabsRole = 'TabPanel';

const Currencies = styled(Box)`
  display: grid;
  grid-template-columns: 0.5fr 0.5fr;
  grid-gap: 5px;
  padding-bottom: 20px;
`;

const BridgeInputsWidget = (props) => {
    var _a, _b, _c;
    const { onChangeTokenDrawerStatus, title, inputDisabled } = props;
    const theme = useContext(ThemeContext);
    const { t } = useTranslation();
    const currency = new Token$1(ChainId.AVALANCHE, CHAINS[ChainId.AVALANCHE].contracts.png, 18, CHAINS[ChainId.AVALANCHE].png_symbol, 'Arcanum');
    return (jsxs(Box, {
        children: [jsx(Text, Object.assign({ fontSize: 18, fontWeight: 500, pb: '4px', color: 'bridge.text' }, { children: title })), jsxs(Currencies, {
            children: [jsx(CurrencyInput
                // value={formattedAmounts[LimitField.INPUT]}
                , {
                    // value={formattedAmounts[LimitField.INPUT]}
                    onChange: (value) => {
                        console.log('onChange', value);
                    }, buttonStyle: {
                        backgroundColor: (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.primaryBgColor,
                        padding: '1rem 1.1rem',
                        width: '100%',
                    }, onTokenClick: onChangeTokenDrawerStatus, isShowTextInput: false, currency: currency, fontSize: 24, id: "swap-currency-input"
                }), jsx(CurrencyInput
                    // value={formattedAmounts[LimitField.INPUT]}
                    , {
                        // value={formattedAmounts[LimitField.INPUT]}
                        onChange: (value) => {
                            console.log('onChange', value);
                        }, buttonStyle: {
                            backgroundColor: (_b = theme.bridge) === null || _b === void 0 ? void 0 : _b.primaryBgColor,
                            padding: '1rem 1.1rem',
                            width: '100%',
                        }, onTokenClick: onChangeTokenDrawerStatus, isShowTextInput: false, currency: currency, fontSize: 24, id: "swap-currency-input"
                    })]
        }), jsx(Tooltip, { effect: "solid" }), jsx(TextInput, {
            value: '', isNumeric: true, disabled: inputDisabled, placeholder: "0.00", addonAfter: inputDisabled ? (jsx(Info, { size: 16, color: (_c = theme.bridge) === null || _c === void 0 ? void 0 : _c.infoIconColor, "data-tip": t('bridge.bridgeInputsWidget.tooltip', { amount: 10.3, currency: 'USDC' }) })) : (jsx(Button, Object.assign({
                variant: "plain", backgroundColor: "bridge.secondaryBgColor", padding: "6px", height: "auto", onClick: () => {
                    console.log('onclick');
                }
            }, { children: jsx(Text, Object.assign({ color: 'bridge.text' }, { children: t('bridge.bridgeInputsWidget.max') })) }))), onChange: (value) => {
                console.log(value);
            }
        })]
    }));
};

const Wrapper = styled(Box)`
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.secondaryBgColor; }};
  border-radius: 10px;
  padding: 30px;
  margin-top: 30px;
  margin-bottom: 30px;
  position: relative;
  overflow: hidden;
  max-width: 30%;
  min-width: 30%;
  height: fit-content;
  ${({ theme }) => theme.mediaWidth.upToMedium`
    min-width: 90%;
    max-width: 90%;
  `};
`;
const FilterBox = styled(Box)`
  display: flex;
  flex-direction: column;
  margin-bottom: 20px;
`;
const FilterInputHeader = styled(Text)`
  font-size: 16px;
  font-weight: 500;
  color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.text; }};
  margin-bottom: 10px;
`;
const LoaderWrapper = styled(Box)`
  flex: 1;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  z-index: 999;
  position: absolute;
  align-items: center;
  pointer-events: all;
  justify-content: center;
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.secondaryBgColor; }};
  margin: -30px;
`;
const CloseCircle$1 = styled.div`
  position: absolute;
  top: 30px;
  right: 30px;
  cursor: pointer;
  background-color: ${({ theme }) => theme.closeCircleBG};
  padding: 2.5px 8px;
  -moz-border-radius: 50px;
  -webkit-border-radius: 50px;
  border-radius: 50px;
`;
const BottomText = styled(Text)`
  font-size: 13px;
  font-weight: 400;
  color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.text; }};
  position: absolute;
  bottom: 0;
  padding: 30px;
  text-align: center;
`;
const ArrowWrapper = styled.div`
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.primaryBgColor; }};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;

const BridgeCard = () => {
    var _a, _b, _c, _d;
    const { account } = usePangolinWeb3();
    const toggleWalletModal = useWalletModalToggle();
    const theme = useContext(ThemeContext);
    const [isTokenDrawerOpen, setIsTokenDrawerOpen] = useState(false);
    const [activeBridgePrioritization, setActiveBridgePrioritization] = useState('');
    const [activeBridges, setActiveBridges] = useState(['']);
    const [activeExchanges, setActiveExchanges] = useState(['']);
    const [userslippage] = useUserSlippageTolerance();
    const [slippageTolerance, setSlippageTolerance] = useState((userslippage / 100).toString());
    const [isLoading, setIsLoading] = useState(false);
    const { t } = useTranslation();
    const BridgePrioritizationItems = [
        {
            label: t('bridge.bridgePrioritizations.recommended'),
            value: 'recommended',
        },
        {
            label: t('bridge.bridgePrioritizations.fast'),
            value: 'fast',
        },
        {
            label: t('bridge.bridgePrioritizations.normal'),
            value: 'normal',
        },
    ];
    const Bridges = [
        {
            label: 'Thorchain',
            value: 'thorchain',
        },
        {
            label: 'DeFiChain',
            value: 'defichain',
        },
    ];
    const Exchanges = [
        {
            label: 'Arcanum',
            value: 'pangolin',
        },
        {
            label: 'Uniswap',
            value: 'uniswap',
        },
        {
            label: '1Inch',
            value: '1inch',
        },
        {
            label: 'Quickswap',
            value: 'quickswap',
        },
    ];
    const onChangeTokenDrawerStatus = useCallback(() => {
        setIsTokenDrawerOpen(!isTokenDrawerOpen);
    }, [isTokenDrawerOpen]);
    return (jsxs(Wrapper, {
        children: [isLoading && (jsxs(LoaderWrapper, {
            children: [jsx(CloseCircle$1, Object.assign({
                onClick: () => {
                    setIsLoading(!isLoading);
                }
            }, { children: jsx(X, { color: (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.loaderCloseIconColor, size: 10 }) })), jsx(Loader, { height: 'auto', label: t('bridge.bridgeCard.loader.labels.waitingReceivingChain'), size: 100 }), jsx(BottomText, { children: t('bridge.bridgeCard.loader.bottomText') })]
        })), jsx(Text, Object.assign({ fontSize: 24, fontWeight: 700, color: 'bridge.text', pb: 30 }, { children: t('bridge.bridgeCard.title') })), jsx(BridgeInputsWidget, { isTokenDrawerOpen: true, onChangeTokenDrawerStatus: onChangeTokenDrawerStatus, title: "From", inputDisabled: false }), jsx(Box, Object.assign({ display: 'flex', justifyContent: 'center', alignContent: 'center', marginY: 20 }, { children: jsx(ArrowWrapper, { children: jsx(RefreshCcw, { size: "16", color: (_b = theme.bridge) === null || _b === void 0 ? void 0 : _b.text }) }) })), jsx(BridgeInputsWidget, { title: "To", inputDisabled: true }), jsx(Box, Object.assign({ marginY: 30 }, {
            children: !account ? (jsx(Button, Object.assign({ variant: "primary", onClick: toggleWalletModal }, { children: "Connect Wallet" }))) : (jsx(Button, Object.assign({
                variant: "primary", onClick: () => {
                    setIsLoading(true);
                }
            }, { children: t('bridge.bridgeCard.swap') })))
        })), jsx(Box, Object.assign({ display: 'flex', flexDirection: 'column', justifyContent: 'center' }, {
            children: jsxs(Collapsed, Object.assign({ collapse: jsxs(Box, Object.assign({ display: 'flex', flexDirection: 'row', justifyContent: 'center', alignItems: 'center' }, { children: [jsx(Text, Object.assign({ fontSize: 16, fontWeight: 500, color: 'bridge.text' }, { children: t('bridge.bridgeCard.advanceOptions') })), jsx(ChevronDown, { size: 16, color: (_c = theme.bridge) === null || _c === void 0 ? void 0 : _c.text })] })), expand: jsxs(Box, Object.assign({ display: 'flex', flexDirection: 'row', justifyContent: 'center', alignItems: 'center' }, { children: [jsx(Text, Object.assign({ fontSize: 16, fontWeight: 500, color: 'bridge.text' }, { children: t('bridge.bridgeCard.advanceOptions') })), jsx(ChevronRight, { size: 16, color: (_d = theme.bridge) === null || _d === void 0 ? void 0 : _d.text })] })) }, {
                children: [jsxs(FilterBox, Object.assign({ pt: '3.75rem' }, {
                    children: [jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.bridgePrioritization') }), jsx(DropdownMenu, {
                        options: BridgePrioritizationItems, defaultValue: activeBridgePrioritization, onSelect: (value) => {
                            setActiveBridgePrioritization(value);
                        }
                    })]
                })), jsxs(FilterBox, { children: [jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.slippage') }), jsx(SlippageInput, { showTitle: false, expertMode: false, slippageTolerance: slippageTolerance, setSlippageTolerance: setSlippageTolerance })] }), jsxs(FilterBox, { children: [jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.infiniteApproval') }), jsx(Checkbox, { labelColor: 'bridge.text', label: t('bridge.bridgeCard.filter.activeInfiniteApproval') })] }), jsxs(FilterBox, {
                    children: [jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.bridges') }), jsx(DropdownMenu, {
                        options: Bridges, defaultValue: activeBridges, isMulti: true, menuPlacement: 'top', onSelect: (value) => {
                            setActiveBridges(value);
                        }
                    })]
                }), jsxs(FilterBox, {
                    children: [jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.exchanges') }), jsx(DropdownMenu, {
                        options: Exchanges, defaultValue: activeExchanges, isMulti: true, menuPlacement: 'top', onSelect: (value) => {
                            setActiveExchanges(value);
                        }
                    })]
                })]
            }))
        })), isTokenDrawerOpen && (jsx(SelectTokenDrawer$1, {
            isOpen: isTokenDrawerOpen, onClose: onChangeTokenDrawerStatus, onCurrencySelect: () => {
                console.log('onCurrencySelect');
            }
        }))]
    }));
};

const Route = styled(Box)`
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.primaryBgColor; }};
  border-radius: 10px;
  padding: 30px;
  border: ${({ theme, selected }) => (selected ? `1px solid ${theme.primary}` : 'none')};
`;
const Informations = styled(Box)`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 10px;
`;
const Information = styled(Box)`
  padding: 9px 13px;
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.informationBoxesBackgroundColor; }};
  border-radius: 10px;
`;
const StepDetail = styled(Box)`
  min-height: 10vh;
  padding-left: 27px;
  margin-left: 10px;
  margin-bottom: 0.5rem;
  border-left: ${({ theme, lastItem }) => (lastItem ? 'none' : `1px solid ${theme.primary}`)};
`;

const BridgeRoute = (props) => {
    const { t } = useTranslation();
    const theme = useContext(ThemeContext);
    const { selected, steps, transactionType, estimatedToken, estimatedResult, min, gasCost } = props;
    return (jsxs(Route, Object.assign({ selected: selected }, {
        children: [jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", pb: 30 }, { children: [jsx(Text, Object.assign({ color: 'bridge.text', fontSize: [24, 20], fontWeight: 600 }, { children: t(`bridge.bridgePrioritizations.${BridgePrioritizations[transactionType]}`).toLocaleUpperCase() })), jsx(Button, Object.assign({ variant: "primary", width: 'fit-content', padding: '8px', height: "30px", isDisabled: selected }, { children: selected ? t('bridge.bridgeRoute.selected') : t('bridge.bridgeRoute.clickToSelect') }))] })), jsx("div", {
            children: steps.map((step, index) => {
                var _a, _b;
                return (jsxs(Box, {
                    children: [jsxs(Box, Object.assign({ display: 'flex', flexDirection: 'row', alignItems: "center", pb: '0.5rem' }, { children: [jsx(Anchor, { size: 20, color: (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.text }), jsx(Text, Object.assign({ pl: 18, color: 'bridge.text', fontSize: [16, 14], fontWeight: 600 }, { children: step.contractType }))] })), jsxs(StepDetail, Object.assign({ lastItem: index === steps.length - 1 }, {
                        children: [jsx(Text, Object.assign({ color: 'bridge.text', fontSize: [16, 14], fontWeight: 400, pb: '0.2rem' }, { children: t('bridge.bridgeRoute.singleTransaction') })), (_b = step.subSteps) === null || _b === void 0 ? void 0 : _b.map((subStep, index) => {
                            return (jsx(Text, Object.assign({ pl: 24, color: 'bridge.text', fontSize: [16, 14], fontWeight: 400, pb: '0.2rem' }, { children: subStep }), index));
                        })]
                    }))]
                }, index));
            })
        }), jsxs(Box, Object.assign({ pb: 10 }, { children: [jsx(Text, Object.assign({ color: 'bridge.text', fontSize: [16, 14], fontWeight: 600, pb: '0.2rem' }, { children: t('bridge.bridgeRoute.estimatedToken', { token: estimatedToken }) })), jsx(Text, Object.assign({ color: 'bridge.text', fontSize: [16, 14], fontWeight: 600 }, { children: t('bridge.bridgeRoute.estimatedResult', { result: estimatedResult }) }))] })), jsxs(Informations, { children: [jsx(Information, { children: jsx(Text, Object.assign({ color: "bridge.routeInfoColor", fontSize: [16, 14], fontWeight: 400 }, { children: t('bridge.bridgeRoute.min', { minute: min }) })) }), jsx(Information, { children: jsx(Text, Object.assign({ color: "bridge.routeInfoColor", fontSize: [16, 14], fontWeight: 400 }, { children: t('bridge.bridgeRoute.gasCost', { gasCost: gasCost }) })) })] })]
    })));
};

const Transfer = styled.tr`
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.primaryBgColor; }};
  border-radius: 10px;
  padding: 30px;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  width: max-content;
`;
const Data = styled.div`
  display: flex;
  flex-direction: column;
  padding-right: 30px;
`;
const ResumeLayout = styled(Box)`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 0.6rem;
`;
const Buttons = styled(Box)`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 1rem;
`;

var BridgeState;
(function (BridgeState) {
    BridgeState["PENDING"] = "PENDING";
    BridgeState["FAILED"] = "FAILED";
    BridgeState["SUCCESS"] = "SUCCESS";
})(BridgeState || (BridgeState = {}));

const BridgeTransfer = (props) => {
    var _a, _b;
    const keys = ['date', 'from', 'to', 'via', 'state'];
    const theme = useContext(ThemeContext);
    const { t } = useTranslation();
    const { state } = props;
    const generateData = (key) => {
        if (key === 'from' || key === 'to') {
            const chain = props[`${key.toLowerCase()}Chain`];
            const coin = props[`${key.toLowerCase()}Coin`];
            return (jsxs(Box, Object.assign({ display: 'flex', flexDirection: 'row' }, { children: [jsx(DoubleCurrencyLogo, { margin: false, currency0: chain, currency1: coin }), jsx(Text, Object.assign({ pl: '0.7rem', fontSize: [16, 14], fontWeight: 400, color: 'bridge.text' }, { children: props[key.toLowerCase()] }))] })));
        }
        else {
            return (jsx(Text, Object.assign({ fontSize: [16, 14], fontWeight: 400, color: 'bridge.text' }, { children: props[key.toLowerCase()] })));
        }
    };
    return (jsxs(Transfer, { children: [jsx(Box, Object.assign({ display: 'flex', flexDirection: 'row' }, { children: keys.map((key, index) => (jsxs(Data, { children: [jsx(Text, Object.assign({ fontSize: [16, 14], fontWeight: 500, color: 'bridge.transferKeyColor' }, { children: t(`bridge.bridgeTransfer.${key}`) })), generateData(key)] }, index))) })), state === BridgeState.PENDING && (jsxs(Buttons, { children: [jsx(Button, Object.assign({ backgroundColor: "bridge.secondaryBgColor", variant: "secondary", width: 'fit-content', borderRadius: '4px', padding: '7px 15px', minHeight: "32px" }, { children: jsxs(ResumeLayout, { children: [jsx(Play, { size: 18, color: (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.text }), jsx(Text, Object.assign({ fontSize: [16, 14], fontWeight: 400, color: 'bridge.text' }, { children: t('bridge.bridgeTransfer.resumeSwap') }))] }) })), jsx(Button, Object.assign({ backgroundColor: "bridge.secondaryBgColor", variant: "secondary", width: 'fit-content', borderRadius: '4px', padding: '0.5rem 1rem', minHeight: "32px" }, { children: jsx(Trash, { size: 16, color: (_b = theme.bridge) === null || _b === void 0 ? void 0 : _b.text }) }))] }))] }));
};

const PageWrapper = styled(Box)`
  width: 100%;
  display: flex;
  justify-content: start;
  gap: 30px;
  ${({ theme }) => theme.mediaWidth.upToMedium`
    flex-direction: column;
    align-items: center;
    justify-content: center;
  `};
`;
const Transactions = styled(Box)`
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.secondaryBgColor; }};
  min-width: 70%;
  max-width: 70%;
  border-radius: 16px;
  height: fit-content;
  padding: 30px;
  margin-top: 30px;
  margin-bottom: 30px;
  ${({ theme }) => theme.mediaWidth.upToMedium`
    min-width: 90%;
    max-width: 90%;
  `};
`;
const Routes = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-gap: 30px;
  margin-top: 50px;
  ${({ theme }) => theme.mediaWidth.upToMedium`
    display: flex;
    flex-direction: column;
  `};
`;
const Transfers = styled.table`
  display: flex;
  flex-direction: column;
  gap: 30px;
  padding-top: 50px;
  padding-bottom: 30px;
  overflow-y: auto;
  white-space: nowrap;
  width: 100%;
`;

var BridgePrioritizations;
(function (BridgePrioritizations) {
    BridgePrioritizations[BridgePrioritizations["recommended"] = 0] = "recommended";
    BridgePrioritizations[BridgePrioritizations["fast"] = 1] = "fast";
    BridgePrioritizations[BridgePrioritizations["normal"] = 2] = "normal";
})(BridgePrioritizations || (BridgePrioritizations = {}));
const Bridge = () => {
    const [tabIndex, setTabIndex] = useState(0);
    const steps = [
        {
            contractType: 'LI.FI Contract',
            subSteps: ['1. Swap to 0.0538 USDT via ARCANUM', '2. Transfer to 0.0522 USDT via ARCANUM'],
        },
        {
            contractType: 'LI.FI Contract',
            subSteps: ['1. Swap to 0.0538 USDT via DODO'],
        },
    ];
    const { t } = useTranslation();
    const currency0 = new Token$1(ChainId.AVALANCHE, CHAINS[ChainId.AVALANCHE].contracts.png, 18, CHAINS[ChainId.AVALANCHE].png_symbol, 'Arcanum');
    const currency1 = new Token$1(ChainId.AVALANCHE, CHAINS[ChainId.AVALANCHE].contracts.png, 18, CHAINS[ChainId.AVALANCHE].png_symbol, 'Arcanum');
    return (jsxs(PageWrapper, { children: [jsx(BridgeCard, {}), jsx(Transactions, { children: jsxs(Tabs, Object.assign({ selectedIndex: tabIndex, onSelect: (index) => setTabIndex(index) }, { children: [jsxs(TabList, { children: [jsx(Tab, { children: t('bridge.availableRoutes', { number: 0 }) }), jsx(Tab, { children: t('bridge.activeTransfers', { number: 0 }) }), jsx(Tab, Object.assign({ disabled: true }, { children: t('bridge.historicalTransfers', { number: 0 }) }))] }), jsx(TabPanel, { children: jsxs(Routes, { children: [jsx(BridgeRoute, { steps: steps, transactionType: BridgePrioritizations.recommended, selected: true, estimatedToken: '0.0522 FRAX', estimatedResult: '$0.05 USD', min: '9:00', gasCost: '95.30 USD' }), jsx(BridgeRoute, { steps: steps, transactionType: BridgePrioritizations.fast, selected: false, estimatedToken: '0.0520 FRAX', estimatedResult: '$0.0495 USD', min: '2:00', gasCost: '105.30 USD' }), jsx(BridgeRoute, { steps: steps, transactionType: BridgePrioritizations.normal, selected: false, estimatedToken: '0.0529 FRAX', estimatedResult: '$0.0503 USD', min: '8:00', gasCost: '100.30 USD' })] }) }), jsx(TabPanel, { children: jsxs(Transfers, { children: [jsx(BridgeTransfer, { date: '9/10/2022, 7:53:00 AM', from: '1.0000', fromChain: currency0, fromCoin: currency1, to: '22.3615', toChain: currency0, toCoin: currency1, via: 'ARCANUM > DODO', state: BridgeState.PENDING }), jsx(BridgeTransfer, { date: '9/10/2022, 7:50:00 AM', from: '1.0000', fromChain: currency0, fromCoin: currency1, to: '0.1564', toChain: currency0, toCoin: currency1, via: 'ARCANUM > DODO', state: BridgeState.PENDING })] }) }), jsx(TabPanel, { children: "Panel 3" })] })) })] }));
};

const DrawerRoot = styled.div`
  overflow: hidden;
  position: absolute;
  z-index: 99;
  transition: all 350ms ease;
  background-color: ${({ theme, backgroundColor }) => { var _a; return backgroundColor ? get(theme, backgroundColor) : (_a = theme.drawer) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  transform: ${({ isOpen }) => (!isOpen ? 'translate(100%, 0px)' : 'translate(0px, 0px)')};
  width: 100%;
  display: flex;
  flex-direction: column;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 10px;
  height: 100%;

  /* ${({ theme, isOpen }) => theme.mediaWidth.upToSmall`
    display: ${isOpen ? 'none' : 'flex'};
    width: 100%;
    height: 100%
  `}; */
`;
const DrawerContent = styled.div`
  flex: 1;
  height: 100%;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
`;
const CloseCircle = styled.div`
  cursor: pointer;
  background-color: ${({ theme }) => theme.closeCircleBG};
  padding: 2.5px 8px;
  -moz-border-radius: 50px;
  -webkit-border-radius: 50px;
  border-radius: 50px;
`;

function Drawer({ isOpen, onClose, children, title, pb, backgroundColor }) {
    const theme = useContext(ThemeContext);
    return (jsxs(DrawerRoot, Object.assign({ isOpen: isOpen, backgroundColor: backgroundColor }, { children: [title && (jsx(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", pb: pb || 20, pt: 20, px: 20 }, { children: jsx(Text, Object.assign({ color: "drawer.text", fontSize: 21, fontWeight: 800 }, { children: title })) }))), jsx(Box, Object.assign({ position: "absolute", right: 20, top: 20 }, { children: jsx(CloseCircle, Object.assign({ onClick: onClose }, { children: jsx(X, { color: theme.mustardYellow, size: 10 }) })) })), jsx(DrawerContent, { children: children })] })));
}

function filterTokens(tokens, search) {
    if (search.length === 0)
        return tokens;
    const searchingAddress = isAddress(search);
    if (searchingAddress) {
        return tokens.filter((token) => token.address === searchingAddress);
    }
    const lowerSearchParts = search
        .toLowerCase()
        .split(/\s+/)
        .filter((s) => s.length > 0);
    if (lowerSearchParts.length === 0) {
        return tokens;
    }
    const matchesSearch = (s) => {
        const sParts = s
            .toLowerCase()
            .split(/\s+/)
            .filter((s) => s.length > 0);
        return lowerSearchParts.every((p) => p.length === 0 || sParts.some((sp) => sp.startsWith(p) || sp.endsWith(p)));
    };
    return tokens.filter((token) => {
        const { symbol, name } = token;
        return (symbol && matchesSearch(symbol)) || (name && matchesSearch(name));
    });
}

// compare two token amounts with highest one coming first
function balanceComparator(balanceA, balanceB) {
    if (balanceA && balanceB) {
        return balanceA.greaterThan(balanceB) ? -1 : balanceA.equalTo(balanceB) ? 0 : 1;
    }
    else if (balanceA && balanceA.greaterThan('0')) {
        return -1;
    }
    else if (balanceB && balanceB.greaterThan('0')) {
        return 1;
    }
    return 0;
}
function getTokenComparator(balances) {
    return function sortTokens(tokenA, tokenB) {
        // -1 = a is first
        // 1 = b is first
        // sort by balances
        const balanceA = balances[tokenA.address];
        const balanceB = balances[tokenB.address];
        const balanceComp = balanceComparator(balanceA, balanceB);
        if (balanceComp !== 0)
            return balanceComp;
        if (tokenA.symbol && tokenB.symbol) {
            // sort by symbol
            return tokenA.symbol.toLowerCase() < tokenB.symbol.toLowerCase() ? -1 : 1;
        }
        else {
            return tokenA.symbol ? -1 : tokenB.symbol ? -1 : 0;
        }
    };
}
function useTokenComparator(inverted) {
    const balances = useAllTokenBalances();
    const comparator = useMemo(() => getTokenComparator(balances !== null && balances !== void 0 ? balances : {}), [balances]);
    return useMemo(() => {
        if (inverted) {
            return (tokenA, tokenB) => comparator(tokenA, tokenB) * -1;
        }
        else {
            return comparator;
        }
    }, [inverted, comparator]);
}

/**
 * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content
 * @param uri to convert to fetch-able http url
 */
function uriToHttp(uri) {
    var _a, _b;
    const protocol = uri.split(':')[0].toLowerCase();
    switch (protocol) {
        case 'https':
            return [uri];
        case 'http':
            return ['https' + uri.substr(4), uri];
        case 'ipfs':
            const hash = (_a = uri.match(/^ipfs:(\/\/)?(.*)$/i)) === null || _a === void 0 ? void 0 : _a[2];
            return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`];
        case 'ipns':
            const name = (_b = uri.match(/^ipns:(\/\/)?(.*)$/i)) === null || _b === void 0 ? void 0 : _b[2];
            return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`];
        default:
            return [];
    }
}

const tokenListValidator = new Ajv({ allErrors: true }).compile(schema);
/**
 * Contains the logic for resolving a list URL to a validated token list
 * @param listUrl list url
 * @param resolveENSContentHash resolves an ens name to a contenthash
 */
function getTokenList(listUrl, resolveENSContentHash) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const urls = uriToHttp(listUrl);
        for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            const isLast = i === urls.length - 1;
            let response;
            try {
                response = yield fetch(url);
            }
            catch (error) {
                console.debug('Failed to fetch list', listUrl, error);
                if (isLast)
                    throw new Error(`Failed to download list ${listUrl}`);
                continue;
            }
            if (!response.ok) {
                if (isLast)
                    throw new Error(`Failed to download list ${listUrl}`);
                continue;
            }
            const json = yield response.json();
            if (!tokenListValidator(json)) {
                const validationErrors = (_b = (_a = tokenListValidator.errors) === null || _a === void 0 ? void 0 : _a.reduce((memo, error) => {
                    var _a;
                    const add = `${error.dataPath} ${(_a = error.message) !== null && _a !== void 0 ? _a : ''}`;
                    return memo.length > 0 ? `${memo}; ${add}` : `${add}`;
                }, '')) !== null && _b !== void 0 ? _b : 'unknown error';
                throw new Error(`Token list failed validation: ${validationErrors}`);
            }
            return json;
        }
        throw new Error('Unrecognized list URL protocol.');
    });
}

function useFetchListCallback() {
    const dispatch = useDispatch();
    const ensResolver = useCallback(() => {
        throw new Error('Could not construct mainnet ENS resolver');
    }, []);
    return useCallback((listUrl) => __awaiter(this, void 0, void 0, function* () {
        const requestId = nanoid();
        dispatch(fetchTokenList.pending({ requestId, url: listUrl }));
        return getTokenList(listUrl)
            .then((tokenList) => {
                dispatch(fetchTokenList.fulfilled({ url: listUrl, tokenList, requestId }));
                return tokenList;
            })
            .catch((error) => {
                console.debug(`Failed to get list at url ${listUrl}`, error);
                dispatch(fetchTokenList.rejected({ url: listUrl, requestId, errorMessage: error.message }));
                throw error;
            });
    }), [dispatch, ensResolver]);
}

const ENS_NAME_REGEX = /^(([a-zA-Z0-9]+\.)+)eth(\/.*)?$/;
function parseENSAddress(ensAddress) {
    const match = ensAddress.match(ENS_NAME_REGEX);
    if (!match)
        return undefined;
    return { ensName: `${match[1].toLowerCase()}eth`, ensPath: match[3] };
}

function listVersionLabel(version) {
    return `v${version.major}.${version.minor}.${version.patch}`;
}

function TokenListOrigin({ listUrl }) {
    const ensName = useMemo(() => { var _a; return (_a = parseENSAddress(listUrl)) === null || _a === void 0 ? void 0 : _a.ensName; }, [listUrl]);
    const host = useMemo(() => {
        if (ensName)
            return undefined;
        const lowerListUrl = listUrl.toLowerCase();
        if (lowerListUrl.startsWith('ipfs://') || lowerListUrl.startsWith('ipns://')) {
            return listUrl;
        }
        try {
            const url = new URL(listUrl);
            return url.host;
        }
        catch (error) {
            return undefined;
        }
    }, [listUrl, ensName]);
    return jsx(Fragment, { children: ensName !== null && ensName !== void 0 ? ensName : host });
}

styled(Box)`
  padding: 10px 20px;
`;
const List = styled(Box)`
  padding: 10px 20px;
`;
const AddInputWrapper = styled(Box)`
  display: grid;
  grid-template-columns: auto 100px;
  grid-gap: 10px;
`;
const RowRoot = styled(Box)`
  display: grid;
  grid-template-columns: max-content auto max-content max-content;
  grid-gap: 10px;
  padding: 15px 0px;
  align-items: center;
  border-bottom-width: 1px;
  border-bottom-style: solid;
  border-bottom-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary; }};

  &:last-child {
    border-bottom: 0px solid;
  }
`;
const ListLogo$1 = styled.img`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
`;
const DownArrow = styled.div`
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveBgColor; }};
  color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveColor; }};
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
`;
const PopoverContainer = styled.div`
  z-index: 100;
  background: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  border: 1px solid ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary; }};
  box-shadow: 0px 0px 1px rgba(0, 0, 0, 0.01), 0px 4px 8px rgba(0, 0, 0, 0.04), 0px 16px 24px rgba(0, 0, 0, 0.04),
    0px 24px 32px rgba(0, 0, 0, 0.01);
  color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary; }};
  border-radius: 0.5rem;
  padding: 5px;
  display: grid;
  grid-template-rows: 1fr;
  grid-gap: 8px;
  font-size: 1rem;
  text-align: left;
  position: absolute;
`;
const Separator = styled.div`
  width: 100%;
  height: 1px;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary; }};
`;
const ViewLink = styled(Text)`
  text-decoration: none;
  cursor: pointer;
  pointer-events: ${({ disabled }) => disabled && 'none'};
`;

const TokenListRow = ({ listUrl }) => {
    const lists = useSelector((state) => state.plists.byUrl);
    const { current: list } = lists[listUrl];
    const dispatch = useDispatch();
    const selectedListUrl = useSelectedListUrl();
    const isSelected = (selectedListUrl || []).includes(listUrl);
    const [open, setOpen] = useState(false);
    const node = useRef();
    const handleClose = useCallback(() => {
        setOpen(false);
    }, [setOpen]);
    useOnClickOutside(node, open ? handleClose : undefined);
    const selectThisList = useCallback(() => {
        // eslint-disable-next-line import/no-named-as-default-member
        ReactGA.event({
            category: 'Lists',
            action: 'Select List',
            label: listUrl,
        });
        dispatch(selectList({ url: listUrl, shouldSelect: !isSelected }));
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [dispatch, isSelected, listUrl]);
    const handleRemoveList = useCallback(() => {
        // eslint-disable-next-line import/no-named-as-default-member
        ReactGA.event({
            category: 'Lists',
            action: 'Start Remove List',
            label: listUrl,
        });
        const answer = window.prompt('Please confirm you would like to remove this list by typing "remove"');
        if ((answer === null || answer === void 0 ? void 0 : answer.toLocaleLowerCase()) === 'remove') {
            // eslint-disable-next-line import/no-named-as-default-member
            ReactGA.event({
                category: 'Lists',
                action: 'Confirm Remove List',
                label: listUrl,
            });
            dispatch(removeList(listUrl));
        }
    }, [dispatch, listUrl]);
    if (!list)
        return null;
    return (jsxs(RowRoot, { children: [(list === null || list === void 0 ? void 0 : list.logoURI) ? jsx(ListLogo$1, { size: 24, src: list === null || list === void 0 ? void 0 : list.logoURI }) : jsx(ListLogo$1, { as: "div", size: 24 }), jsxs(Box, { children: [jsx(Text, Object.assign({ fontSize: 16, color: "swapWidget.primary", style: { overflow: 'hidden', textOverflow: 'ellipsis' } }, { children: list === null || list === void 0 ? void 0 : list.name })), jsx(Text, Object.assign({ fontSize: 12, color: "swapWidget.secondary", style: { overflow: 'hidden', textOverflow: 'ellipsis' }, title: listUrl }, { children: jsx(TokenListOrigin, { listUrl: listUrl }) }))] }), jsxs(Box, Object.assign({ ref: node }, { children: [jsx(DownArrow, Object.assign({ onClick: () => setOpen(!open) }, { children: jsx(ChevronDown, {}) })), open && (jsxs(PopoverContainer, { children: [jsx("div", { children: list && listVersionLabel(list.version) }), jsx(Separator, {}), jsx(ViewLink, Object.assign({ fontSize: 13, as: "a", color: "swapWidget.primary", href: `https://tokenlists.org/token-list?url=${listUrl}`, target: "_blank" }, { children: "View list" })), jsx(ViewLink, Object.assign({ fontSize: 13, color: "swapWidget.primary", onClick: handleRemoveList, disabled: Object.keys(lists).length === 1 }, { children: "Remove list" }))] }))] })), jsx(Switch, { checked: isSelected, onChange: () => selectThisList() })] }));
};

const TokenListDrawer = ({ isOpen, onClose }) => {
    var _a;
    const [listUrlInput, setListUrlInput] = useState('');
    const dispatch = useDispatch();
    const lists = useSelector((state) => state.plists.byUrl);
    const adding = Boolean((_a = lists[listUrlInput]) === null || _a === void 0 ? void 0 : _a.loadingRequestId);
    const [addError, setAddError] = useState(null);
    const fetchList = useFetchListCallback();
    const handleAddList = useCallback(() => {
        if (adding)
            return;
        setAddError(null);
        fetchList(listUrlInput)
            .then(() => {
                setListUrlInput('');
                // eslint-disable-next-line import/no-named-as-default-member
                ReactGA.event({
                    category: 'Lists',
                    action: 'Add List',
                    label: listUrlInput,
                });
            })
            .catch((error) => {
                // eslint-disable-next-line import/no-named-as-default-member
                ReactGA.event({
                    category: 'Lists',
                    action: 'Add List Failed',
                    label: listUrlInput,
                });
                setAddError(error.message);
                dispatch(removeList(listUrlInput));
            });
    }, [adding, dispatch, fetchList, listUrlInput]);
    const validUrl = useMemo(() => {
        return uriToHttp(listUrlInput).length > 0 || Boolean(parseENSAddress(listUrlInput));
    }, [listUrlInput]);
    const handleEnterKey = useCallback((e) => {
        if (validUrl && e.key === 'Enter') {
            handleAddList();
        }
    }, [handleAddList, validUrl]);
    const sortedLists = useMemo(() => {
        const listUrls = Object.keys(lists);
        return listUrls
            .filter((listUrl) => {
                return Boolean(lists[listUrl].current);
            })
            .sort((u1, u2) => {
                const { current: l1 } = lists[u1];
                const { current: l2 } = lists[u2];
                if (l1 && l2) {
                    return l1.name.toLowerCase() < l2.name.toLowerCase()
                        ? -1
                        : l1.name.toLowerCase() === l2.name.toLowerCase()
                            ? 0
                            : 1;
                }
                if (l1)
                    return -1;
                if (l2)
                    return 1;
                return 0;
            });
    }, [lists]);
    return (jsxs(Drawer, Object.assign({ title: "Manage Lists", isOpen: isOpen, onClose: onClose }, {
        children: [jsxs(Box, Object.assign({ padding: "0px 20px" }, {
            children: [jsxs(AddInputWrapper, {
                children: [jsx(TextInput, {
                    placeholder: "https:// or ipfs://", onChange: (value) => {
                        setListUrlInput(value);
                        setAddError(null);
                    }, onKeyDown: handleEnterKey, value: listUrlInput
                }), jsx(Button, Object.assign({ variant: "primary", padding: '0px', isDisabled: !validUrl, onClick: handleAddList, height: "50px" }, { children: "Add" }))]
            }), addError ? (jsx(Text, Object.assign({ title: addError, color: "error", fontSize: 12 }, { children: addError }))) : null]
        })), jsx(Scrollbars, { children: jsx(List, { children: sortedLists.map((url) => (jsx(TokenListRow, { listUrl: url }, url))) }) })]
    })));
};

const CurrencyList = styled.div`
  display: flex;
  flex: 1;
  flex-direction: column;
  overflow-y: auto;
  &::-webkit-scrollbar {
    display: none !important;
  }
  -ms-overflow-style: none;
  scrollbar-width: none;
`;
const CurrencyRowRoot = styled.div`
  min-height: 56px;
  font-size: 16px;
  cursor: ${({ disabled }) => !disabled && 'pointer'};
  pointer-events: ${({ disabled }) => disabled && 'none'};
  display: grid;
  grid-template-columns: auto minmax(auto, 1fr) minmax(0, 72px);
  grid-gap: 16px;
  align-items: center;
  padding: 10px 20px;

  &:hover {
    background-color: ${({ theme, disabled }) => { var _a; return !disabled && opacify(0.9, (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground); }};
  }

  opacity: ${({ disabled, selected }) => (disabled || selected ? 0.5 : 1)};
`;
const Balance = styled(Text)`
  justify-self: flex-end;
  white-space: nowrap;
`;
const ManageList = styled.div`
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  padding: 10px 20px;
  cursor: pointer;
`;
const ListLogo = styled.img`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  margin-right: 10px;
`;

const CurrencyRow = (props) => {
    const { currency, style, onSelect, isSelected, otherSelected } = props;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const balance = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, currency);
    const handleSelect = useCallback(() => {
        onSelect(currency);
    }, [onSelect, currency]);
    return (jsxs(CurrencyRowRoot, Object.assign({ style: style, onClick: handleSelect, disabled: isSelected, selected: otherSelected }, { children: [jsx(CurrencyLogo, { currency: currency, size: 24, imageSize: 48 }), jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 14, title: currency === null || currency === void 0 ? void 0 : currency.name }, { children: currency === null || currency === void 0 ? void 0 : currency.symbol })), jsx(Balance, Object.assign({ color: "swapWidget.primary", fontSize: 14 }, { children: balance ? balance.toSignificant(4) : account ? jsx(LoaderIcon, {}) : null }))] })));
};

const currencyKey = (currency, chainId) => {
    var _a, _b;
    return currency instanceof Token$1
        ? currency.address
        : currency === CAVAX[chainId] && ((_a = CAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.symbol)
            ? (_b = CAVAX[chainId]) === null || _b === void 0 ? void 0 : _b.symbol
            : '';
};
const SelectTokenDrawer = (props) => {
    var _a, _b, _c;
    const { isOpen, onClose, onCurrencySelect, otherSelectedCurrency, selectedCurrency } = props;
    const [searchQuery, setSearchQuery] = useState('');
    const [isTokenListOpen, setIsTokenListOpen] = useState(false);
    const [invertSearchOrder] = useState(false);
    const inputRef = useRef(null);
    const lastOpen = usePrevious(isOpen);
    useEffect(() => {
        if (isOpen && !lastOpen) {
            setSearchQuery('');
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen]);
    useEffect(() => {
        if (isOpen && inputRef.current) {
            setTimeout(() => {
                var _a;
                (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }, 500);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen]);
    const allTokens = useAllTokens();
    const selectedListInfo = useSelectedListInfo();
    const chainId = useChainId();
    const isAddressSearch = isAddress(searchQuery);
    const searchToken = useToken(searchQuery);
    const tokenComparator = useTokenComparator(invertSearchOrder);
    const filteredTokens = useMemo(() => {
        if (isAddressSearch)
            return searchToken ? [searchToken] : [];
        const tokens = Object.values(allTokens);
        tokens.unshift(CAVAX[chainId]);
        return filterTokens(tokens, searchQuery);
    }, [isAddressSearch, searchToken, allTokens, searchQuery]);
    const filteredSortedTokens = useMemo(() => {
        if (searchToken)
            return [searchToken];
        const sorted = filteredTokens.sort(tokenComparator);
        const symbolMatch = searchQuery
            .toLowerCase()
            .split(/\s+/)
            .filter((s) => s.length > 0);
        if (symbolMatch.length > 1)
            return sorted;
        return [
            ...(searchToken ? [searchToken] : []),
            // sort any exact symbol matches first
            ...sorted.filter((token) => { var _a; return ((_a = token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === symbolMatch[0]; }),
            ...sorted.filter((token) => { var _a; return ((_a = token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== symbolMatch[0]; }),
        ];
    }, [filteredTokens, searchQuery, searchToken, tokenComparator]);
    const currencies = useMemo(() => {
        var _a;
        if (searchQuery === '') {
            // remove Currency from array and add in first position
            const _tokens = filteredSortedTokens.filter((token) => token !== CAVAX[chainId]);
            return ((_a = CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.evm) ? [CAVAX[chainId], ..._tokens] : [..._tokens];
        }
        return filteredSortedTokens;
    }, [filteredSortedTokens, chainId]);
    //const currencies = useMemo(() => [Currency.CAVAX, ...filteredSortedTokens], [filteredSortedTokens]);
    const onSelect = useCallback((currency) => {
        onCurrencySelect(currency);
        onClose();
    }, [onCurrencySelect, onClose]);
    const Row = useCallback(({ data, index, style }) => {
        const currency = data === null || data === void 0 ? void 0 : data[index];
        const isSelected = Boolean(selectedCurrency && currencyEquals(selectedCurrency, currency));
        const otherSelected = Boolean(otherSelectedCurrency && currencyEquals(otherSelectedCurrency, currency));
        return currency ? (jsx(CurrencyRow, { style: style, currency: currency, isSelected: isSelected, onSelect: onSelect, otherSelected: otherSelected })) : null;
    },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [selectedCurrency, otherSelectedCurrency, onCurrencySelect, onClose]);
    return (jsxs(Drawer, Object.assign({ title: "Select a token", isOpen: isOpen, onClose: onClose }, {
        children: [jsx(Box, Object.assign({ padding: "0px 20px" }, {
            children: jsx(TextInput, {
                placeholder: "Search", onChange: (value) => {
                    setSearchQuery(value);
                }, value: searchQuery, getRef: (ref) => (inputRef.current = ref), onClick: () => {
                    var _a;
                    if (isMobile) {
                        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ behavior: 'smooth' });
                    }
                }
            })
        })), jsx(CurrencyList, { children: jsx(AutoSizer, Object.assign({ disableWidth: true }, { children: ({ height }) => (jsx(FixedSizeList, Object.assign({ height: height, width: "100%", itemCount: currencies.length, itemSize: 56, itemData: currencies, itemKey: (index, data) => currencyKey(data[index], chainId) }, { children: Row }))) })) }), jsx(ManageList, Object.assign({ onClick: () => setIsTokenListOpen(true) }, { children: selectedListInfo.multipleSelected ? (jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, { children: [jsxs(Text, Object.assign({ fontSize: 14, color: "swapWidget.primary" }, { children: [selectedListInfo.selectedCount, " lists selected"] })), jsx(Text, Object.assign({ fontSize: 12, color: "swapWidget.primary" }, { children: "Change" }))] }))) : (jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, { children: [jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "100%" }, { children: [jsx(ListLogo, { size: 24, src: (_a = selectedListInfo === null || selectedListInfo === void 0 ? void 0 : selectedListInfo.current) === null || _a === void 0 ? void 0 : _a.logoURI, alt: `${(_b = selectedListInfo === null || selectedListInfo === void 0 ? void 0 : selectedListInfo.current) === null || _b === void 0 ? void 0 : _b.name} list logo` }), jsx(Text, Object.assign({ fontSize: 14, color: "swapWidget.primary" }, { children: (_c = selectedListInfo === null || selectedListInfo === void 0 ? void 0 : selectedListInfo.current) === null || _c === void 0 ? void 0 : _c.name }))] })), jsx(Text, Object.assign({ fontSize: 12, color: "swapWidget.primary" }, { children: "Change" }))] }))) })), jsx(TokenListDrawer, { isOpen: isTokenListOpen, onClose: () => setIsTokenListOpen(false) })]
    })));
};
var SelectTokenDrawer$1 = memo(SelectTokenDrawer, (prevProps, nextProps) => {
    const isEqual = prevProps.isOpen === nextProps.isOpen &&
        prevProps.onClose === nextProps.onClose &&
        prevProps.onCurrencySelect === nextProps.onCurrencySelect &&
        (!!prevProps.selectedCurrency && !!nextProps.selectedCurrency
            ? prevProps.selectedCurrency.symbol === nextProps.selectedCurrency.symbol
            : true) &&
        (!!prevProps.otherSelectedCurrency && !!nextProps.otherSelectedCurrency
            ? prevProps.otherSelectedCurrency.symbol === nextProps.otherSelectedCurrency.symbol
            : true);
    return isEqual;
});

const VISIBILITY_STATE_SUPPORTED = 'visibilityState' in document;
function isWindowVisible() {
    return !VISIBILITY_STATE_SUPPORTED || document.visibilityState !== 'hidden';
}
/**
 * Returns whether the window is currently visible to the user.
 */
function useIsWindowVisible() {
    const [focused, setFocused] = useState(isWindowVisible());
    const listener = useCallback(() => {
        setFocused(isWindowVisible());
    }, [setFocused]);
    useEffect(() => {
        if (!VISIBILITY_STATE_SUPPORTED)
            return undefined;
        document.addEventListener('visibilitychange', listener);
        return () => {
            document.removeEventListener('visibilitychange', listener);
        };
    }, [listener]);
    return focused;
}

const NearApplicationUpdater = () => {
    const chainId = useChainId();
    const { provider } = useLibrary();
    const dispatch = useDispatch();
    const { data: blockNumber } = useQuery('get-block', () => {
        return provider === null || provider === void 0 ? void 0 : provider.getBlockNumber();
    }, { enabled: !!provider, refetchInterval: 60 * 1000 * 2 });
    useEffect(() => {
        if (blockNumber) {
            dispatch(updateBlockNumber({ chainId, blockNumber }));
        }
    }, [blockNumber]);
    return null;
};
const EvmApplicationUpdater = () => {
    const { chainId } = usePangolinWeb3();
    const { library, provider } = useLibrary();
    const dispatch = useDispatch();
    const windowVisible = useIsWindowVisible();
    const [state, setState] = useState({
        chainId,
        blockNumber: null,
    });
    const blockNumberCallback = useCallback((blockNumber) => {
        setState((_state) => {
            if (chainId === _state.chainId) {
                if (typeof _state.blockNumber !== 'number')
                    return { chainId, blockNumber };
                return { chainId, blockNumber: Math.max(blockNumber, _state.blockNumber) };
            }
            return _state;
        });
    }, [chainId, setState]);
    // attach/detach listeners
    useEffect(() => {
        if (!library || !chainId || !windowVisible)
            return undefined;
        setState({ chainId, blockNumber: null });
        provider === null || provider === void 0 ? void 0 : provider.getBlockNumber().then(blockNumberCallback).catch((error) => console.error(`Failed to get block number for chainId: ${chainId}`, error));
        library.on && library.on('block', blockNumberCallback);
        return () => {
            library.removeListener && library.removeListener('block', blockNumberCallback);
        };
    }, [dispatch, chainId, library, blockNumberCallback, windowVisible]);
    const debouncedState = useDebounce(state, 100);
    useEffect(() => {
        if (!debouncedState.chainId || !(debouncedState === null || debouncedState === void 0 ? void 0 : debouncedState.blockNumber) || !windowVisible)
            return;
        dispatch(updateBlockNumber({ chainId: debouncedState.chainId, blockNumber: debouncedState === null || debouncedState === void 0 ? void 0 : debouncedState.blockNumber }));
    }, [windowVisible, dispatch, debouncedState === null || debouncedState === void 0 ? void 0 : debouncedState.blockNumber, debouncedState.chainId]);
    return null;
};
const updaterMapping = {
    [ChainId.AVALANCHE]: EvmApplicationUpdater,
    [ChainId.FUJI]: EvmApplicationUpdater,
    [ChainId.COSTON]: EvmApplicationUpdater,
    [ChainId.SONGBIRD]: EvmApplicationUpdater,
    [ChainId.WAGMI]: EvmApplicationUpdater,
    [ChainId.NEAR_MAINNET]: NearApplicationUpdater,
    [ChainId.NEAR_TESTNET]: NearApplicationUpdater,
};
function ApplicationUpdater() {
    const chainId = useChainId();
    const Updater = updaterMapping[chainId];
    return jsx(Updater, {});
}

function useInterval(callback, delay, leading = true) {
    const savedCallback = useRef();
    // Remember the latest callback.
    useEffect(() => {
        savedCallback.current = callback;
    }, [callback]);
    // Set up the interval.
    useEffect(() => {
        function tick() {
            const current = savedCallback.current;
            current && current();
        }
        if (delay !== null) {
            if (leading)
                tick();
            const id = setInterval(tick, delay);
            return () => clearInterval(id);
        }
        return undefined;
    }, [delay, leading]);
}

function Updater$3() {
    const { library } = useLibrary();
    const dispatch = useDispatch();
    const lists = useSelector((state) => state.plists.byUrl);
    const isWindowVisible = useIsWindowVisible();
    const fetchList = useFetchListCallback();
    const fetchAllListsCallback = useCallback(() => {
        if (!isWindowVisible)
            return;
        Object.keys(lists).forEach((url) => fetchList(url).catch((error) => console.debug('interval list fetching error', error)));
    }, [fetchList, isWindowVisible, lists]);
    // fetch all lists every 10 minutes, but only after we initialize library
    useInterval(fetchAllListsCallback, library ? 1000 * 60 * 10 : null);
    // whenever a list is not loaded and not loading, try again to load it
    useEffect(() => {
        Object.keys(lists).forEach((listUrl) => {
            const list = lists[listUrl];
            if (!list.current && !list.loadingRequestId && !list.error) {
                fetchList(listUrl).catch((error) => console.debug('list added fetching error', error));
            }
        });
    }, [dispatch, fetchList, library, lists]);
    // automatically update lists if versions are minor/patch
    useEffect(() => {
        Object.keys(lists).forEach((listUrl) => {
            const list = lists[listUrl];
            if (list.current && list.pendingUpdate) {
                const bump = getVersionUpgrade(list.current.version, list.pendingUpdate.version);
                const isDefaultList = DEFAULT_TOKEN_LISTS.includes(listUrl);
                switch (bump) {
                    case VersionUpgrade.NONE:
                        throw new Error('unexpected no version bump');
                    case VersionUpgrade.PATCH:
                    case VersionUpgrade.MINOR:
                        const min = minVersionBump(list.current.tokens, list.pendingUpdate.tokens);
                        // automatically update minor/patch as long as bump matches the min update
                        if (bump >= min) {
                            if (isDefaultList) {
                                //if its pangolin hosted token list then we will autoupdate it
                                // eslint-disable-next-line import/no-named-as-default-member
                                ReactGA.event({
                                    category: 'Lists',
                                    action: 'Update List from Popup',
                                    label: listUrl,
                                });
                                dispatch(acceptListUpdate(listUrl));
                            }
                        }
                        else {
                            console.error(`List at url ${listUrl} could not automatically update because the version bump was only PATCH/MINOR while the update had breaking changes and should have been MAJOR`);
                        }
                        break;
                    case VersionUpgrade.MAJOR:
                        if (isDefaultList) {
                            // if its pangolin hosted token list then we will autoupdate it
                            // eslint-disable-next-line import/no-named-as-default-member
                            ReactGA.event({
                                category: 'Lists',
                                action: 'Update List from Popup',
                                label: listUrl,
                            });
                            dispatch(acceptListUpdate(listUrl));
                        }
                }
            }
        });
    }, [dispatch, lists]);
    return null;
}

// chunks array into chunks of maximum size
// evenly distributes items among the chunks
function chunkArray(items, maxChunkSize) {
    if (maxChunkSize < 1)
        throw new Error('maxChunkSize must be gte 1');
    if (items.length <= maxChunkSize)
        return [items];
    const numChunks = Math.ceil(items.length / maxChunkSize);
    const chunkSize = Math.ceil(items.length / numChunks);
    return [...Array(numChunks).keys()].map((ix) => items.slice(ix * chunkSize, ix * chunkSize + chunkSize));
}

// chunk calls so we do not exceed the gas limit
const CALL_CHUNK_SIZE = 500;
/**
 * Fetches a chunk of calls, enforcing a minimum block number constraint
 * @param multicallContract multicall contract to fetch against
 * @param chunk chunk of calls to make
 * @param minBlockNumber minimum block number of the result set
 */
function fetchChunk(multicallContract, chunk, minBlockNumber) {
    return __awaiter(this, void 0, void 0, function* () {
        console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber);
        let resultsBlockNumber, returnData;
        try {
            [resultsBlockNumber, returnData] = yield multicallContract.aggregate(chunk.map((obj) => [obj.address, obj.callData]));
        }
        catch (error) {
            console.debug('Failed to fetch chunk inside retry', error);
            throw error;
        }
        if (resultsBlockNumber.toNumber() < minBlockNumber) {
            throw new RetryableError('Fetched for old block number');
        }
        return { results: returnData, blockNumber: resultsBlockNumber.toNumber() };
    });
}
/**
 * From the current all listeners state, return each call key mapped to the
 * minimum number of blocks per fetch. This is how often each key must be fetched.
 * @param allListeners the all listeners state
 * @param chainId the current chain id
 */
function activeListeningKeys(allListeners, chainId) {
    if (!allListeners || !chainId)
        return {};
    const listeners = allListeners[chainId];
    if (!listeners)
        return {};
    return Object.keys(listeners).reduce((memo, callKey) => {
        const keyListeners = listeners[callKey];
        memo[callKey] = Object.keys(keyListeners)
            .filter((key) => {
                const blocksPerFetch = parseInt(key);
                if (blocksPerFetch <= 0)
                    return false;
                return keyListeners[blocksPerFetch] > 0;
            })
            .reduce((previousMin, current) => {
                return Math.min(previousMin, parseInt(current));
            }, Infinity);
        return memo;
    }, {});
}
/**
 * Return the keys that need to be refetched
 * @param callResults current call result state
 * @param listeningKeys each call key mapped to how old the data can be in blocks
 * @param chainId the current chain id
 * @param latestBlockNumber the latest block number
 */
function outdatedListeningKeys(callResults, listeningKeys, chainId, latestBlockNumber) {
    if (!chainId || !latestBlockNumber)
        return [];
    const results = callResults[chainId];
    // no results at all, load everything
    if (!results)
        return Object.keys(listeningKeys);
    return Object.keys(listeningKeys).filter((callKey) => {
        const blocksPerFetch = listeningKeys[callKey];
        const data = callResults[chainId][callKey];
        // no data, must fetch
        if (!data)
            return true;
        const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1);
        // already fetching it for a recent enough block, don't refetch it
        if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber)
            return false;
        // if data is older than minDataBlockNumber, fetch it
        return !(data === null || data === void 0 ? void 0 : data.blockNumber) || (data === null || data === void 0 ? void 0 : data.blockNumber) < minDataBlockNumber;
    });
}
function Updater$2() {
    const dispatch = useDispatch();
    const state = useSelector((state) => state.pmulticall);
    // wait for listeners to settle before triggering updates
    const debouncedListeners = useDebounce(state.callListeners, 100);
    const latestBlockNumber = useBlockNumber();
    const { chainId } = usePangolinWeb3();
    const multicallContract = useMulticallContract();
    const cancellations = useRef();
    const listeningKeys = useMemo(() => {
        return activeListeningKeys(debouncedListeners, chainId);
    }, [debouncedListeners, chainId]);
    const unserializedOutdatedCallKeys = useMemo(() => {
        return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber);
    }, [chainId, state.callResults, listeningKeys, latestBlockNumber]);
    const serializedOutdatedCallKeys = useMemo(() => JSON.stringify(unserializedOutdatedCallKeys.sort()), [unserializedOutdatedCallKeys]);
    useEffect(() => {
        var _a, _b, _c;
        if (!latestBlockNumber || !chainId || !multicallContract)
            return;
        const outdatedCallKeys = JSON.parse(serializedOutdatedCallKeys);
        if (outdatedCallKeys.length === 0)
            return;
        const calls = outdatedCallKeys.map((key) => parseCallKey(key));
        const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE);
        if (((_a = cancellations.current) === null || _a === void 0 ? void 0 : _a.blockNumber) !== latestBlockNumber) {
            (_c = (_b = cancellations.current) === null || _b === void 0 ? void 0 : _b.cancellations) === null || _c === void 0 ? void 0 : _c.forEach((c) => c());
        }
        dispatch(fetchingMulticallResults({
            calls,
            chainId,
            fetchingBlockNumber: latestBlockNumber,
        }));
        cancellations.current = {
            blockNumber: latestBlockNumber,
            cancellations: chunkedCalls.map((chunk, index) => {
                const { cancel, promise } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {
                    n: Infinity,
                    minWait: 2500,
                    maxWait: 3500,
                });
                promise
                    .then(({ results: returnData, blockNumber: fetchBlockNumber }) => {
                        cancellations.current = { cancellations: [], blockNumber: latestBlockNumber };
                        // accumulates the length of all previous indices
                        const firstCallKeyIndex = chunkedCalls
                            .slice(0, index)
                            .reduce((memo, curr) => memo + curr.length, 0);
                        const lastCallKeyIndex = firstCallKeyIndex + returnData.length;
                        dispatch(updateMulticallResults({
                            chainId,
                            results: outdatedCallKeys
                                .slice(firstCallKeyIndex, lastCallKeyIndex)
                                .reduce((memo, callKey, i) => {
                                    var _a;
                                    memo[callKey] = (_a = returnData[i]) !== null && _a !== void 0 ? _a : null;
                                    return memo;
                                }, {}),
                            blockNumber: fetchBlockNumber,
                        }));
                    })
                    .catch((error) => {
                        if (error instanceof CancelledError) {
                            console.debug('Cancelled fetch for blockNumber', latestBlockNumber);
                            return;
                        }
                        console.error('Failed to fetch multicall chunk', chunk, chainId, error);
                        dispatch(errorFetchingMulticallResults({
                            calls: chunk,
                            chainId,
                            fetchingBlockNumber: latestBlockNumber,
                        }));
                    });
                return cancel;
            }),
        };
    }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber]);
    return null;
}

const useMinichefStakingInfosHook = {
    [ChainId.FUJI]: useMinichefStakingInfos,
    [ChainId.AVALANCHE]: useMinichefStakingInfos,
    [ChainId.WAGMI]: useMinichefStakingInfos,
    [ChainId.COSTON]: useDummyMinichefHook,
    [ChainId.SONGBIRD]: useDummyMinichefHook,
    [ChainId.NEAR_MAINNET]: useDummyMinichefHook,
    [ChainId.NEAR_TESTNET]: useDummyMinichefHook,
};
const useGetMinichefStakingInfosViaSubgraphHook = {
    [ChainId.FUJI]: useGetMinichefStakingInfosViaSubgraph,
    [ChainId.AVALANCHE]: useGetMinichefStakingInfosViaSubgraph,
    [ChainId.WAGMI]: useGetMinichefStakingInfosViaSubgraph,
    [ChainId.COSTON]: useGetMinichefStakingInfosViaSubgraph,
    [ChainId.SONGBIRD]: useGetMinichefStakingInfosViaSubgraph,
    [ChainId.NEAR_MAINNET]: useDummyMinichefStakingInfosViaSubgraph,
    [ChainId.NEAR_TESTNET]: useDummyMinichefStakingInfosViaSubgraph,
};
const useGetAllFarmDataHook = {
    [ChainId.FUJI]: useGetAllFarmData,
    [ChainId.AVALANCHE]: useGetAllFarmData,
    [ChainId.WAGMI]: useGetAllFarmData,
    [ChainId.COSTON]: useGetAllFarmData,
    [ChainId.SONGBIRD]: useGetAllFarmData,
    [ChainId.NEAR_MAINNET]: useGetDummyAllFarmData,
    [ChainId.NEAR_TESTNET]: useGetDummyAllFarmData,
};

function shouldCheck(lastBlockNumber, tx) {
    if (tx.receipt)
        return false;
    if (!tx.lastCheckedBlockNumber)
        return true;
    const blocksSinceCheck = lastBlockNumber - tx.lastCheckedBlockNumber;
    if (blocksSinceCheck < 1)
        return false;
    const minutesPending = (new Date().getTime() - tx.addedTime) / 1000 / 60;
    if (minutesPending > 60) {
        // every 10 blocks if pending for longer than an hour
        return blocksSinceCheck > 9;
    }
    else if (minutesPending > 5) {
        // every 3 blocks if pending more than 5 minutes
        return blocksSinceCheck > 2;
    }
    else {
        // otherwise every block
        return true;
    }
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const txChecker = (_params) => {
    // This is intentional as this is just dummy function to support for evm chains
};
const NEAR_TX_HASH_PARAM = 'transactionHashes';
/**
 * this method is used to check transaction hashes in url and if found then get summary of that transaction and add it to the reducer
 * @returns txChecker function
 */
const nearTxChecker = ({ transactions, dispatch, chainId }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const search = window.location.search;
    // get transactionHashes from url
    const txHashes = ((_a = new URLSearchParams(search).get(NEAR_TX_HASH_PARAM)) === null || _a === void 0 ? void 0 : _a.split(',')) || [];
    const txHash = (txHashes === null || txHashes === void 0 ? void 0 : txHashes.length) > 0 ? txHashes === null || txHashes === void 0 ? void 0 : txHashes[(txHashes === null || txHashes === void 0 ? void 0 : txHashes.length) - 1] : '';
    if (txHash) {
        // get tx details using near sdk
        const tx = yield (nearFn === null || nearFn === void 0 ? void 0 : nearFn.getTransaction(txHash));
        if (tx) {
            // get tx summary
            const summary = nearFn.getTranctionSummary(tx);
            const exists = !!transactions[txHash];
            // if hash doesn't exist then only add it to redux
            if (!exists) {
                dispatch(addTransaction({ hash: txHash, from: nearFn.getAccountId(), chainId, summary }));
            }
        }
        // remove transactionHashes from url without refreshing page
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.delete(NEAR_TX_HASH_PARAM);
        window.history.replaceState({}, document.title, currentUrl.toString());
    }
});
const txCheckerMapping = {
    [ChainId.AVALANCHE]: txChecker,
    [ChainId.FUJI]: txChecker,
    [ChainId.COSTON]: txChecker,
    [ChainId.SONGBIRD]: txChecker,
    [ChainId.WAGMI]: txChecker,
    [ChainId.NEAR_MAINNET]: nearTxChecker,
    [ChainId.NEAR_TESTNET]: nearTxChecker,
};
function Updater$1() {
    var _a;
    const chainId = useChainId();
    const { library, provider } = useLibrary();
    const lastBlockNumber = useBlockNumber();
    const dispatch = useDispatch();
    const state = useSelector((state) => state.ptransactions);
    const transactions = chainId ? (_a = state[chainId]) !== null && _a !== void 0 ? _a : {} : {}; // eslint-disable-line react-hooks/exhaustive-deps
    const txCheckerFn = txCheckerMapping[chainId];
    // as of now this is specific to Near chain, we are checking user is coming to pangolin after completing tx or not
    useEffect(() => {
        if (txCheckerFn) {
            txCheckerFn({ transactions, chainId, dispatch });
        }
    }, [transactions, chainId, dispatch]);
    // show popup on confirm
    const addPopup = useAddPopup();
    useEffect(() => {
        if (!chainId || !library || !lastBlockNumber)
            return;
        Object.keys(transactions)
            .filter((hash) => shouldCheck(lastBlockNumber, transactions[hash]))
            .forEach((hash) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                try {
                    const receipt = yield provider.getTransactionReceipt(hash);
                    const status = receipt.status;
                    if (receipt) {
                        dispatch(finalizeTransaction({
                            chainId,
                            hash,
                            receipt: {
                                blockHash: receipt.blockHash,
                                blockNumber: receipt === null || receipt === void 0 ? void 0 : receipt.blockNumber,
                                // contractAddress: receipt.contractAddress,
                                contractAddress: '',
                                from: receipt.from,
                                status,
                                to: receipt.to,
                                // transactionHash: receipt.transactionHash,
                                transactionHash: receipt.hash,
                                transactionIndex: receipt.transactionIndex,
                            },
                        }));
                        addPopup({
                            txn: {
                                hash,
                                success: status === 1,
                                summary: (_a = transactions[hash]) === null || _a === void 0 ? void 0 : _a.summary,
                            },
                        }, hash);
                    }
                    else {
                        dispatch(checkedTransaction({ chainId, hash, blockNumber: lastBlockNumber }));
                    }
                }
                catch (error) {
                    console.error(`failed to check transaction hash: ${hash}`, error);
                }
            }));
    }, [chainId, library, transactions, lastBlockNumber, dispatch, addPopup]);
    return null;
}

var header$7 = {
    dashboard: "Dashboard",
    swap: "Tauschen",
    buy: "Kaufen",
    pool: "Pool",
    farm: "Farm",
    version1: "Ausfhrung 1",
    version2: "Ausfhrung 2",
    stake: "Stake",
    newPng: "Neues {{ pngSymbol }}",
    oldPng: "Altes {{ pngSymbol }}",
    vote: "Abstimmen",
    ido: "IDO",
    charts: "Diagramme",
    forum: "Forum",
    pngBreakDown: "Deine {{ symbol }}-bersicht",
    balance: "Kontostand: ",
    unclaimed: "Nicht beansprucht: ",
    pngPrice: "{{ symbol }}-Preis:",
    pngCirculation: "{{ symbol }} im Umlauf:",
    totalSupply: "Gesamtmenge",
    makeSureURLWarning: "Gehe sicher, dass die URL folgende ist:",
    alwaysMakeSureWarning: "Gehe immer sicher, dass die URL folgende ist:",
    bookmarkIt: "Fge sie deinen Favoriten hinzu, um dich abzusichern.",
    addMetamask: "{{ symbol }} zu MetaMask hinzufgen",
    bridge: "Brcke",
    ourPartners: "Unsere Partner",
    usefulLinks: "NTZLICHE LINKS",
    comeAndJoinUs: "Komm, schliee dich uns an",
    tryOurNewBetaSite: "Testen Sie unsere neue Beta-Site",
    returnToLegacySite: "Zurck zur alten Website",
    switchToNewUI: "Wechseln Sie zur neuen Benutzeroberflche "
};
var accountDetails$7 = {
    connectedWith: "Verbunden mit ",
    account: "Konto",
    disconnect: "Trennen",
    change: "ndern",
    copy: "Adresse kopieren",
    viewExplorer: "Im Explorer anzeigen",
    clearAll: "(alle lschen)",
    transactionAppear: "Deine Transaktionen werden hier erscheinen...",
    recentTransactions: "Jngste Transaktionen",
    copied: "Kopiert"
};
var addressInputPanel$7 = {
    recipient: "Empfnger",
    viewExplorer: "(Im Explorer anzeigen)",
    walletAddress: "Wallet-Adresse"
};
var currencyInputPanel$7 = {
    selectToken: "Whle einen Token",
    balance: "Kontostand: ",
    max: "MAX",
    to: "Fr"
};
var earn$7 = {
    claimAccumulated: "Ausstehende {{ symbol }}-Vergtung beanspruchen",
    connectWallet: "Mit Wallet verbinden",
    enterAmount: "Gib einen Betrag ein",
    unclaimedReward: "Unbeanspruchte {{ symbol }}",
    claim: "Beanspruchen",
    claimReward: "{{ symbol }} Beanspruchen",
    liquidityRemainsPool: "Wenn du deine Vergtung ohne abzubuchen beanspruchst, wird deine Liquiditt im Pool verbleiben.",
    withdrawingLiquidity: "{{ amount }} {{ symbol }} opnemen",
    claimingReward: "Wird beansprucht {{ amount }} {{ symbol }}",
    claimedReward: "{{ symbol }} beansprucht!",
    manage: "Verwalten",
    deposit: "Einzahlen",
    poolRate: "Pool-Rate",
    currentReward: "Momentane Vergtung",
    pngPerAvax: "{{ pngSymbol }} / Woche pro AVAX",
    rewardPerWeek: "{{ symbol }} / Woche",
    earnUpTo: "Verdiene jhrlich bis zu",
    yourRate: "Deine Rate",
    totalDeposited: "Gesamte Einlage",
    totalStaked: "Insgesamt gestakt",
    depositLiquidity: "Liquiditt hinzufgen",
    attemptingToStakeError: "Es wurde versucht, ohne Besttigung oder Unterschrift zu staken. Bitte setze dich mit dem Support in Verbindung.",
    transactionSubmitted: "Transaktion eingereicht",
    depositingLiquidity: "Fge Liquiditt hinzu",
    depositingToken: "Depositing {{ symbol }}",
    depositedToken: "Deposited {{ symbol }}",
    availableToDeposit: "Zum Hinzufgen verfgbar ",
    weeklyRewards: "Wchentliche Vergtung",
    missingLiquidityAmount: "Liquidittsbetrag nicht angegeben",
    missingDependencies: "Fehlende Abhngigkeiten",
    deposited: "Eingezahlt",
    withdrawDepositedLiquidity: "Eingezahlte Liquiditt abbuchen",
    depositedPglLiquidity: "Eingezahlte ARL-Liquiditt:",
    whenYouWithdrawWarning: "Wenn du abbuchst, wird deine ausstehenden {{ symbol }}-Vergtung beansprucht. Deine Arcanum-Liquidittstoken, ARL, werden an dich zurckgegeben und du wirst keine {{ symbol }}-Vergtungen mehr auf diese Liquidittsposition erhalten. Deine ursprngliche Liquiditt wird im Liquidittspool verbleiben.",
    whenYouWithdrawSingleSideWarning: "When you withdraw, your {{ symbol }} is claimed and your {{ pngSymbol}} is returned to you. You will no longer earn {{ symbol }} rewards on this {{ pngSymbol}}.",
    withdrawAndClaim: "Abbuchen & Beanspruchen",
    withdrewStakingToken: "{{ symbol }} abgebucht!",
    approve: "Besttigen",
    poolWeight: "Beckengewicht",
    withdraw: "Abheben",
    extraReward: "Zustzliche Belohnung",
    poolRewards: "Pool-Belohnungen",
    rewardsIn: "Belohnungen ein",
    removeWarning: "Sie entfernen Liquiditt aus diesem Pool. Diese Aktion gibt Ihnen Ihre Token zurck. Alternativ knnen Sie sich dafr entscheiden, Ihre Token zu farmen, um Belohnungen zu verdienen."
};
var menu$7 = {
    code: "Code",
    twitter: "Twitter",
    discord: "Discord",
    telegram: "Telegram",
    tutorials: "Tutorials",
    idos: "IDOs",
    about: "Info"
};
var modalView$7 = {
    confirmTransaction: "Diese Transaktion in deiner Wallet berprfen",
    viewTransaction: "Sehen Sie sich die Transaktion im Explorer an"
};
var navigationTabs$7 = {
    useThisTool: "Benutze dieses Werkzeug, um dir Paare anzeigen zu lassen, die nicht in der Schnittstelle auftauchen.",
    swap: "Tauschen",
    pool: "Pool",
    importPool: "Pool importieren",
    createPair: "Erstelle ein Paar",
    addLiquidity: "Fge Liquiditt hinzu",
    removeLiquidity: "Entferne Liquiditt",
    whenYouAddLiquidityInfo: "Wenn du Liquiditt hinzufgst, erhltst du Pool-Token, die Deine Position im Pool reprsentieren. Diese Token schtten automatisch Vergtungen aus, die abhngig von deinem Anteil am Pool sind. Du kannst deine Pool-Token knnen jederzeit einlsen!",
    removingPoolTokensInfo: "Wenn du deine Pool-Token einlst, erhltst du deine ursprnglich eingezahlten Token im momentanen Verhltnis zurck, abhngig von deinem Anteil am Pool. Von dir verdiente Transaktionsgebhren sind im Betrag inbegriffen."
};
var popups$7 = {
    tokenListUpdated: "Die Token-Liste \" {{oldList}} \" wurde aktualisiert zu ",
    updateAvailable: "Fr die Token-Liste ist ein Update verfgbar \" {{oldList}} \"",
    viewExplorer: "Im Explorer anzeigen",
    hash: "Hash: ",
    added: "hinzugefgt",
    removed: "entfernt",
    tokensUpdated: "Token aktualisiert",
    acceptUpdate: "Update besttigen",
    dismiss: "Abbruch"
};
var positionCard$7 = {
    add: "Hinzufgen",
    remove: "Entfernen",
    poolShare: "Dein Anteil am Pool:",
    pooled: "gepoolt",
    poolTokens: "Deine Pool-Token:",
    manage: "Verwalten",
    loading: "Ldt",
    yourPosition: "Deine Position",
    byAddingLiquidityInfo: "Durch das Bereitstellen von Liquiditt verdienst du 0,25% an allen Trades auf diesem Paar, proportional zu deinem Anteil am Pool. \n Gebhren werden dem Pool hinzugefgt, fallen in Echtzeit an und knnen beansprucht werden, indem die Liquiditt abgebucht wird."
};
var searchModal$7 = {
    commonBases: "bliche Basis-Token",
    tokensPairsHelper: "Diese Token werden hufig im Paar mit anderen Token hinzugefgt.",
    addedByUser: "Hinzugefgt durch",
    foundByAddress: "Gefunden ber Adresse",
    remove: "entfernen",
    add: "Hinzufgen",
    findToken: "Finde einen Token, indem du nach seinem Namen oder Symbol suchst oder seine Adresse unten einfgst.",
    selectToken: "Whle einen Token aus",
    tokenSearchPlaceholder: "Suche nach Name oder Adresse",
    tokenName: "Token-Name",
    change: "ndern",
    selectList: "Whle eine Liste aus",
    confirmListRemovalPrompt: "Bitte besttige, dass du diese Liste entfernen mchtest, indem du \"entfernen\" eingibst.",
    addList: "Eine Liste hinzufgen ",
    tokenListHelper: "Token-Listen sind offene Spezifikationen fr Listen von ERC20-Token. Du kannst eine beliebige Token-Liste eingeben, indem du die zugehrige URL unten eingibst. Beachte, dass Listen von Drittanbietern Fake-Token oder Token, die in bser Absicht erstellt worden sind enthalten knnen.",
    httpsPlaceholder: "https:// oder ipfs://",
    manageLists: "Listen verwalten",
    viewList: "Liste ansehen",
    updateList: "Liste aktualisieren",
    removeList: "Liste entfernen",
    selected: "ausgewhlt",
    select: "auswhlen",
    manageTokenLists: "Tokenlisten verwalten"
};
var settings$7 = {
    areYouSure: "Bist du dir sicher?",
    expertInfo: "Der Expertenmodus deaktiviert die Aufforderung zur Transaktionsbesttigung und erlaubt Trades mit hoher Slippage, welche oft zu schlechten Tauschraten und unwiderruflich verlorenen Mitteln fhren.",
    expertWarningCAPS: "BENUTZE DIESEN MODUS NUR, WENN DU GENAU WEISST, WAS DU TUST.",
    confirm: "besttige",
    confirmExpertMode: "Bitte gib das Wort \"besttige\" ein, um den Expertenmodus zu aktivieren.",
    turnOnExpertMode: "Aktiviere Expertenmodus",
    transactionSettings: "Transaktionseinstellungen",
    interfaceSettings: "Schnittstelleneinstellungen",
    toggleExpertMode: "Expertenmodus",
    expertModeHelper: "Umgeht Besttigungsaufforderungen und ermglicht Trades mit hoher Slippage. Verwendung auf eigene Gefahr.",
    toggleDarkMode: "Nachtmodus",
    slippage: "Slippage",
    percent: "Percent"
};
var swap$7 = {
    priceImpact: "Preisauswirkungen",
    priceImpactHelper: "Unterschied zwischen Marktpreis und dem durch die Gre des Trades beeinflusstem, geschtzten Preis.",
    liquidityProviderFee: "Gebhren an Liquiditts-Provider",
    liquidityProviderHelper: "Ein Anteil jedes Trades (0,3%) geht an Liquiditts-Provider als Anreiz zum Bereitstellen von Liquiditt.",
    route: "Tauschpfad",
    routingHelper: "Dieser Tauschpfad ergab den besten Preis fr deinen Trade.",
    confirmSwap: "Tausch besttigen",
    swapAnyway: "Trotzdem tauschen",
    confirm: "besttige",
    price: "Preis",
    accept: "Besttigen",
    minimumReceived: "Du erhltst mindestens",
    maximumSold: "Du verkaufst hchstens",
    transactionRevertHelper: "Deine Transaktion wird storniert, wenn es eine groe, ungnstige Preisbewegung gibt, bevor sie besttigt wird.",
    priceUpdated: "Preis aktualisiert",
    outputEstimated: "Die Kaufmenge ist geschtzt. Du erhltst mindestens <strong>{{amount}} {{currencySymbol}}</strong> oder die Transaktion wird storniert.",
    inputEstimated: "Die Verkaufsmenge ist geschtzt. Du verkaufst hchstens <strong>{{amount}} {{currencySymbol}}</strong> oder die Transaktion wird storniert.",
    outputSentTo: "Die Verkaufsmenge wird gesendet an ",
    priceImpactMinPrompt: "Dieser Tausch hat eine Preisauswirkung von mindestens {{ priceImpact }}%. Bitte gib das Wort \"besttige\" ein, um mit dem Tausch fortzufahren.",
    priceImpactHighPrompt: "Dieser Tausch hat eine Preisauswirkung von mindestens {{ priceImpact }}%. Bitte gib das Wort \"besttige\" ein, um mit dem Tausch fortzufahren."
};
var toggle$7 = {
    on: "Ein",
    off: "Aus"
};
var tokenWarningModal$7 = {
    tokenImported: "Token importiert",
    anyoneCanCreateWarning: "Jeder kann einen ERC-20-Token auf Avalanche mit <em>beliebigem</em> Namen erstellen, einschlielich der Erstellung von gefakten Versionen bestehender Token und Token, die den Anschein haben, Projekte zu reprsentieren, fr die es keinen Token gibt.",
    loadArbitraryWarning: "Mit dieser Schnittstelle kannst du beliebige Token ber ihre Token-Adresse laden. Bitte sei besonders vorsichtig und recherchiere grndlich, wenn du beliebige ERC-20 ldst.",
    purchaseArbitraryWarning: "Wenn du einen beliebigen Token kaufst, <strong>kannst du ihn unter Umstnden nicht zurckverkaufen.</strong>",
    understand: "Ich verstehe",
    "continue": "Weiter",
    viewExplorer: "Im Explorer anzeigen"
};
var transactionConfirmation$7 = {
    waitingConfirmation: "Warte auf Besttigung",
    confirmTransaction: "Diese Transaktion in deiner Wallet berprfen",
    transactionSubmitted: "Transaktion eingereicht",
    viewExplorer: "Im Explorer anzeigen",
    close: "Schlieen",
    error: "Fehler",
    dismiss: "Abbruch",
    addToFarm: "Zur Farm hinzufgen"
};
var transactionSettings$7 = {
    slippageTolerance: "Slippage-Toleranz",
    transactionRevertSlippageHelper: "Deine Transaktion wird storniert, wenn sich der Preis um mehr als diesen Prozentsatz zu deinen Ungunsten verndert.",
    transactionDeadline: "Transaktionsfrist",
    transactionRevertDeadlineHelper: "Deine Transaktion wird storniert, wenn sie nach dieser Frist nicht besttigt wurde.",
    enterValidSlippage: "Gib eine gltige Slippage-Toleranz ein",
    transactionMayFail: "Deine Transaktion kann fehlschlagen",
    transactionMayFrontrun: "Deine Transaktion kann eventell gefrontrunnt werden",
    transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
    minutes: "Minuten"
};
var vote$7 = {
    earnedPng: "Verdiente {{ pngSymbol }}-Token stellen stimmberechtigte Anteile bei Arcanum-Abstimmungen dar.",
    canEitherVote: "Du kannst entweder ber jeden Antrag selbst abstimmen oder deine Stimmen an einen Dritten delegieren.",
    delegateVotes: "Stimmen delegieren",
    selfDelegate: "An dich selbst delegieren",
    remove: "Entfernen",
    add: "Hinzufgen",
    delegate: "Delegieren",
    delegatingVotes: "Stimmen werden delegiert",
    unlockingVotes: "Stimmen werden freigeschaltet",
    transactionSubmitted: "Transaktion eingereicht",
    "for": "dafr",
    against: "dagegen",
    vote: "Stimme",
    proposal: "Antrag",
    votes: "Stimmen",
    submittingVote: "Stimme wird abgegeben",
    confirmTransaction: "Diese Transaktion in deiner Wallet berprfen",
    viewExplorer: "Im Explorer anzeigen"
};
var walletModal$7 = {
    wrongNetwork: "Falsches Netzwerk",
    errorConnecting: "Fehler beim Verbinden",
    pleaseConnectAvalanche: "Bitte verbinde dich mit dem entsprechenden Avalanche-Netzwerk.",
    switchAvalanche: "Zur Avalanche-Chain wechseln",
    errorConnectingRefresh: "Fehler beim Verbinden. Versuch es mit einem Neuladen der Seite.",
    connectToWallet: "Mit einer Wallet verbinden",
    newToAvalanche: "Neu bei Avalanche? ",
    learnMoreWallet: "Erfahre mehr ber das Einrichten einer Wallet",
    initializing: "Initialisiere...",
    tryAgain: "Versuch es erneut"
};
var web3ReactManager$7 = {
    unknownError: "Ups! Ein unbekannter Fehler ist aufgetreten. Bitte aktualisiere die Seite, oder ruf die Seite von einem anderen Browser oder Gert auf."
};
var web3Status$7 = {
    pending: "ausstehend",
    wrongNetwork: "Falsches Netzwerk",
    error: "Fehler",
    connectToWallet: "Mit Wallet verbinden"
};
var gasFeeAlert$7 = {
    gasFeeReduction: "!!! Gasgebhren-Reduzierung !!!",
    transactionsNotAccept: "Transaktionen werden nicht entgegengenommen, wenn die Gasgebhr nicht auf mindestens {{ gasPrice }} eingestellt wird."
};
var addLiquidity$7 = {
    deposited: "Eingezahlt",
    shareOfPool: "Anteil am Pool",
    createPoolSupply: "Pool erstellen & hinzufgen",
    confirmSupply: "Einzahlung besttigen",
    giveOrder: "GIVE ORDER",
    outputEstimated: "Die Kaufmenge ist geschtzt. Sollte sich der Preis um mehr als {{ allowedSlippage }}% verndern, wird die Transaktion storniert.",
    creatingPool: "Du erstellst einen Pool",
    willReceive: "Du erhltst",
    firstLP: "Du bist der erste Liquiditts-Provider.",
    ratioTokens: "Das Verhltnis, in dem du diesem Pool Token hinzufgst, wird den Preis fr diesen Pool bestimmen.",
    happyRate: "Wenn du mit dem Verhltnis zufrieden bist, klicke auf Hinzufgen, um eine bersicht zu erhalten.",
    initialPrices: "Ursprngliche Preise",
    prices: "Preise",
    poolShare: "und Anteil am Pool",
    connectWallet: "Mit Wallet verbinden",
    approve: "Besttigen ",
    supply: "Hinzufgen",
    per: " pro ",
    rates: "Raten",
    poolTokens: " Pool-Token"
};
var airdrop$7 = {
    claimPngAirdrop: "{{ pngSymbol }} aus Airdrop beanspruchen",
    claimPeriodEnded: "Der Zeitraum fr das Beanspruchen von Airdrops ist abgelaufen.",
    connectWalletViewLiquidity: "Verbinde mit einer Wallet, um deine Liquiditt zu sehen.",
    noAvailableClaim: "Dir stehen keine zum Beanspruchen zu.",
    noUniNoSushi: "Du hast keine UNI- oder SUSHI Token. Bitte folge diesem Tutorial, um deiner Wallet UNI- oder SUSHI-Token hinzuzufgen.",
    youHave: "Du hast ",
    pngAvailableClaim: " {{ pngSymbol }} verfgbar zum Beanspruchen",
    loading: "Ldt",
    welcomeToTeamPangolin: "Willkommen im Arcanum-Team",
    claim: "Beanspruchen "
};
var earnPage$7 = {
    pangolinLiquidityMining: "Arcanum Liquidity-Mining",
    pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
    depositPangolinLiquidity: "Zahle deine Arcanum Liquidittsprovider-Token (ARL) ein, um {{ pngSymbol }}, den Governance-Token des Arcanum-Protokolls zu erhalten.",
    depositPangolinStaking: "Deposit and stake your {{ pngSymbol }} tokens to earn more tokens.",
    currentOpportunities: "Current opportunities",
    readMoreAboutPng: "Erfahre mehr ber {{ pngSymbol }}",
    getInsuranceCoverage: "Versichern Sie sich auf InsurAce.io",
    getCoverNexusMutual: "Schtzen Sie sich bei Nexus Mutual",
    importantUpdate: "WICHTIGES UPDATE",
    pangolinGovernanceProposalResult: "Als Ergebnis des Arcanum-Governance-Antrags 1 ndert Arcanum die Staking-Smart Contracts! Nach ca. 09:59 MEZ am 19.4. werden alle Staking-Vergtungen auf die neuen Staking-Smart Contracts verteilt. Vor der Umstellung werden alle Vergtungen noch auf die alten Vertrge verteilt. Um Unterbrechungen bei den Yield Farming-Vergtungen zu vermeiden, musst du deine Liquiditt aus den alten Smart Contracts herausnehmen und in den neuen Smart Contracts staken. Du musst weder Liquiditt aus deinen Pools entfernen noch deine Positionen ndern.",
    oldPngPools: "Alte {{ pngSymbol }}-Pools",
    newPngPools: "Neue {{ pngSymbol }}-Pools",
    participatingPools: "Pools, an denen du beteiligt bist",
    rewardsNeverEnd: "Die Vergtungen enden nie!",
    noActiveRewards: "Keine Vergtungen aktiv",
    liquidityMining: "Liquidity Mining",
    pngStaking: "{{ pngSymbol }} Staking",
    totalStaked: "Insgesamt gestakt",
    poolRate: "Pool-Rate",
    step1: "Schritt 1. Hole dir Arcanum Liquidity-Token (ARL)",
    pglTokenRequired: "Es sind ARL-Token erforderlich. Sobald du Liquiditt zu dem {{ poolHandle }} Pool hinzugefgt hast, kannst du deine Liquidittsprovider-Token auf dieser Seite staken.",
    addPoolLiquidity: "Fge {{ poolHandle }} Liquiditt hinzu",
    liquidityDeposits: "Deine Liquidittseinzahlungen",
    yourStakedToken: "Your staked {{ symbol }}",
    unclaimedReward: "Deine unbeanspruchten {{ symbol }}",
    claim: "Beanspruchen",
    rewardPerWeek: " {{ symbol }} / Woche",
    automagically: "Wenn du abbuchst, wird der Smart Contract automagisch {{ pngSymbol }} fr dich beanspruchen!",
    deposit: "Einzahlen",
    depositStakingTokens: "Zahle {{ symbol }}-Token ein",
    stake: "Stake",
    stakeStakingTokens: "Stake {{ symbol }} Tokens",
    unstake: "Unstake",
    stakingTokensAvailable: "{{ symbol }}-Token verfgbar",
    getToken: "Get {{ symbol }}",
    migrateTitle: "Migrieren Sie Ihre gestapelte ARL",
    migrateDescription: "Arcanum hat die Tokenomik gendert. Sie mssen Ihre gestapelte ARL auf einen neuen Vertrag migrieren",
    migrate: "Wandern"
};
var pool$7 = {
    liquidityProviderRewards: "Liquidittsprovider-Vergtungen",
    liquidityProvidersEarn: "Durch das Bereitstellen von Liquiditt verdienen Liquidittsprovider 0,25% an allen Trades auf diesem Paar, proportional zu ihren Anteil am Pool. Gebhren werden dem Pool hinzugefgt, fallen in Echtzeit an und knnen beansprucht werden, indem die Liquiditt abgebucht wird.",
    readMoreProviding: "Erfahre mehr ber das Bereitstellen von Liquiditt",
    viewStakedLiquidity: "Lass dir deine gestakte Liquiditt anzeigen",
    yourLiquidity: "Deine Liquiditt",
    createPair: "Erstelle ein Paar",
    addLiquidity: "Fge Liquiditt hinzu",
    connectWalletToView: "Verbinde mit einer Wallet, um deine Liquiditt zu sehen.",
    loading: "Ldt",
    noLiquidity: "Keine Liquiditt gefunden.",
    uniswapV1Found: "Uniswap V1-Liquiditt gefunden!",
    noSeePoolJoined: "Siehst du den Pool, dem Du beigetreten bist nicht?",
    migrateNow: "Jetzt migrieren.",
    importIt: "Importiere ihn.",
    seeDetails: "SIEHE EINZELHEITEN",
    totalLockedValue: "Gesperrter Gesamtwert",
    yourLockedValue: "Ihr gesperrter Wert",
    allFarms: "Alle Bauernhfe",
    yourFarms: "Ihre Hfe",
    yourPools: "Ihre Pools",
    noFarms: "Keine Hfe gefunden.",
    successWithdraw: "Ihre Liquiditt wurde aus der Farm entfernt und aufgelaufene Prmien eingefordert!"
};
var poolFinder$7 = {
    connectToFind: "Verbinde mit einer Wallet, um Pools zu finden",
    selectTokenToFind: "Whle einen Token, um deine Liquiditt zu finden.",
    selectToken: "Whle einen Token aus",
    poolFound: "Pool gefunden!",
    managePool: "Diesen Pool verwalten.",
    noLiquidityYet: "Du hast noch keine Liquiditt in diesem Pool.",
    noPoolFound: "Kein Pool gefunden.",
    addLiquidity: "Liquiditt hinzufgen.",
    createPool: "Pool erstellen.",
    invalidPair: "Ungltiges Paar.",
    loading: "Ldt"
};
var removeLiquidity$7 = {
    youWillReceive: "Du erhltst",
    simple: "Vereinfacht",
    detailed: "Detailliert",
    receiveAvax: "Erhalte {{ symbol }}",
    receiveWavax: "Erhalte {{ symbol }}",
    price: "Preis:",
    connectWallet: "Mit Wallet verbinden",
    approving: "Besttige",
    approve: "Besttigen",
    approved: "Besttigt",
    remove: "Entferne",
    output: "Auszahlung",
    amount: "Anzahl"
};
var swapPage$7 = {
    addSend: "+ Empfngerwallet hinzufgen (optional)",
    toEstimated: "fr (geschtzt)",
    to: "fr",
    removeSend: "- Empfngerwallet entfernen",
    price: "Preis",
    slippageTolerance: "Slippage-Toleranz",
    connectWallet: "Mit Wallet verbinden",
    insufficientLiquidity: "Fr diesen Trade ist nicht gengend Liquiditt vorhanden.",
    wrap: "Wrappen",
    unwrap: "Entwrappen",
    approving: "Besttige",
    approve: "Besttigen ",
    approved: "Besttigt",
    priceImpactHigh: "Hohe Preisauswirkung",
    swap: "Tauschen",
    anyway: " Trotzdem",
    from: "Tausche",
    fromEstimated: "Tausche (geschtzt)",
    velox: "Setzen Sie eine Limit-Order auf <1>Velox</1>",
    marginSwap: "Traden Sie mit Leverage auf <1>MarginSwap</1>",
    wowSwap: " oder <1>WOWswap</1>",
    veeFinance: " oder <1>Vee Finance</1>",
    gelatoFee: "Gelato-Gebhr",
    placeOrder: "Bestellung aufgeben",
    confirmOrder: "Bestellung besttigen",
    "for": "Pro",
    submittingOrderToSwap: "Bestellung zum Tausch aufgeben",
    limitPrice: "Limitpreis",
    outputWillBeSentTo: "Ausgabe wird gesendet an",
    sell: "verkaufen",
    buy: "Kaufen",
    betaRelease: "Dies ist eine BETA-Version und sollte auf eigene Gefahr verwendet werden!",
    trade: "Handeln",
    watchList: "Beobachtungsliste",
    yourPortFolio: "Ihr Portfolio",
    comingSoon: "Kommt bald",
    connectWalletViewPortFolio: "Stellen Sie eine Verbindung zu einem Wallet her, um Ihr Portfolio anzuzeigen.",
    limitOrders: "Limitauftrge",
    cancelOrder: "Bestellung stornieren",
    all: "ALLE",
    open: "OFFEN",
    executed: "HINGERICHTET",
    cancelled: "STORNIERT",
    inputAmount: "Betrag eingeben",
    outputAmount: "Ausgabebetrag",
    status: "Status",
    noLimitOrder: "Nein {{ orderType }} Befehl",
    cancellingOrder: "Bestellung stornieren...",
    cancelLimitOrder: "Besorgen {{ outputCurrency }} mit {{ inputCurrency }}",
    executionPrice: "Ausfhrungspreis",
    seeMore: "Mehr sehen",
    seeLess: "Siehe Weniger"
};
var buyPage$7 = {
    buyAvaxInfo: "Kaufen Sie AVAX mit Fiatgeld von unserem Partner Wyre.",
    privacyInfo: "Arcanum speichert keine Kaufhistorie und persnliche Daten.",
    firstName: "Vorname",
    lastName: "Nachname",
    email: "E-Mail-Adresse",
    buyAvax: "Kaufen Sie AVAX"
};
var votePage$7 = {
    unlockVotes: "Stimmen freischalten",
    updateDelegation: "Delegierung aktualisieren",
    pangolinGovernance: "Arcanum-Governance",
    earnedPngTokens: "{{ pngSymbol }}-Token reprsentieren Stimmgewichte in der Arcanum Governance. Du kannst entweder ber jeden Vorschlag selbst abstimmen oder deine Stimmen an einen Dritten delegieren.",
    eligibleToVote: "Um stimmberechtigt zu sein, musst du {{ pngSymbol }} in deiner Wallet haben und diese zu Beginn der Abstimmung delegieren. Nachdem die Abstimmung begonnen hat, kannst du deine {{ pngSymbol }} einem Pool hinzufgen oder ausgeben.",
    governanceVotes: "Abstimmungen zur Governance werden mit einfacher Mehrheit entschieden. Es gibt keine Mindestwahlbeteiligung.",
    proposals: "Antrge",
    allProposals: "Alle Antrge",
    backToProposals: "Zurck zu Vorschlge",
    unlockVoting: "Stimmabgabe freischalten",
    votes: " Stimmen",
    delegatedTo: "Delegiert an:",
    edit: "bearbeiten",
    noProposalsFound: "Keine Antrge gefunden.",
    proposalCommunityMembers: "Von Community-Mitgliedern eingereichte Vorschlge werden hier erscheinen.",
    minimumThreshold: "Zum Einreichen von Antrgen ist eine Mindestmenge von 1,000,000 {{ pngSymbol }} erforderlich",
    votingStarted: "Die Abstimmung hat begonnen ",
    votingStarts: "Die Abstimmung beginnt ",
    votingEnded: "Die Abstimmung ist beendet ",
    votingEnds: "Die Abstimmung endet ",
    voteFor: "Dafr abstimmen",
    voteAgainst: "Dagegen abstimmen",
    against: "dagegen",
    "for": "dafr",
    details: "Details",
    overview: "bersicht",
    proposer: "Antragsteller",
    about: "Etwa",
    vote: "Abstimmung",
    executed: "Hingerichtet",
    rejected: "Abgelehnt",
    notSupported: "Wird auf dieser Kette nicht untersttzt"
};
var IDOPage$7 = {
    pangolinIDOs: "Initial DEX Offering (IDO)",
    pangolinIDODescription: "Initial DEX Offerings (IDO) ermglichen es Projekten, ihre nativen Token an dezentralen Brsen zu finanzieren. Wir haben uns mit groartigen Teams zusammengetan, um groartige Projekte in die Avalanche-Community zu bringen",
    upcomingIDOs: "Bevorstehende",
    endedIDOs: "Beendet",
    allIDOs: "Alle IDOs",
    noIDOsFound: "Keine IDOs gefunden",
    IDOAnnounced: "ffentlich angekndigte IDOs erscheinen hier."
};
var swapHooks$7 = {
    connectWallet: "Mit Wallet verbinden",
    enterAmount: "Gib einen Betrag ein",
    selectToken: "Whle einen Token aus",
    enterRecipient: "Gib einen Empfnger ein",
    invalidRecipient: "Ungltiger Empfnger",
    insufficient: "Unzureichendes ",
    balance: " Guthaben"
};
var mintHooks$7 = {
    connectWallet: "Mit Wallet verbinden",
    insufficientInputAmount: "Unzureichende Eingangsmenge",
    invalidPair: "Ungltiges Paar",
    enterAmount: "Gib einen Betrag ein",
    insufficient: "Unzureichendes ",
    balance: " Guthaben"
};
var stakeHooks$7 = {
    connectWallet: "Mit Wallet verbinden",
    enterAmount: "Gib einen Betrag ein"
};
var burnHooks$7 = {
    connectWallet: "Mit Wallet verbinden",
    enterAmount: "Gib einen Betrag ein"
};
var migratePage$7 = {
    stake: "STAPEL",
    unstake: "ENTSTEHUNG",
    add: "HINZUFGEN",
    remove: "LSCHEN",
    startMigratingNow: "STARTEN SIE JETZT MIT DER MIGRATION",
    startMigratingNowDescription: "Unten finden Sie alle Farmen, die Sie fr die Migration zu Pangolins V2-Vertrgen bentigen",
    seeMore: "MEHR SEHEN",
    migrateWithEase: "MIT EINFACHEM MIGRIEREN",
    migrateWithDescription: "Wir haben einen eleganten Assistenten entwickelt, der Sie durch den Migrationsprozess Ihrer Farmen fhrt",
    alreadyMigrate: "bereits migriert",
    walletMigrate: "Brieftasche migriert",
    alreadyEarned: "Bereits verdienen",
    migrateNow: "JETZT MIGIEREN",
    learn: "LERNEN",
    moveYourTokensToNewContracts: "Migrieren Sie Ihre Farmen zu Arcanum V2",
    readyToMigrate: "Bereit zur Migration",
    apr: "APR:",
    totalValueLocked: "Gesamtwert gesperrt",
    lowVolatility: "Geringe Volatilitt",
    compoundable: "Compoundierbar",
    migrate: "Wandern",
    migrationModalDescription: "Wir haben festgestellt, dass Sie diese Pools haben Whlen Sie einen aus oder fgen Sie einen hinzu.",
    choosePool: "Whlen Sie Pool",
    pool: "Pool",
    availableToDeposit: "Einzahlung mglich: ",
    poolInfoDescription: "Jetzt haben Sie Ihren Pool ausgewhlt und knnen Sie von dort abheben.",
    dollarWorth: "Dollarwert: ",
    usd: "USD",
    yourRate: "Ihr Tarif: ",
    unclaimedPng: "Nicht beanspruchtes {{ pngSymbol }}: ",
    shareOfPool: "Poolanteil: ",
    choose: "WHLEN",
    selectAll: "Whlen Sie Alle",
    loading: "Wird geladen",
    back: "Zurck",
    availableToUnstake: "Verfgbar zum Abnehmen: ",
    submittingTransaction: "bermittlung der Transaktion",
    moveYourTokensToNewContractsDescription: "Als Teil der Einfhrung von Arcanum zu neuen verbesserten Vertrgen mssen Sie Ihre Farmen migrieren. Wenn Sie Hilfe oder Anleitung bentigen, klicken Sie bitte auf die Schaltflche Lernen.",
    migrateModalHeading: "Migration {{ current }} der {{ total }} Farm"
};
var dashboardPage$7 = {
    dashboard: "Dashboard",
    greetings: "Greetings kind guests! Lets ape in today",
    portfolioValue: "Portfolio Value",
    earned: "Earned",
    coins: "Coins",
    followedWallets: "Followed Wallets",
    earned_dailyIncome: "Daily Income",
    earned_weeklyIncome: "Weekly Income",
    earned_totalEarned: "Total Earned",
    earned_claim: "Claim",
    earned_customizePools: "Customize Pools",
    followed_address: "Address",
    followed_worth: "Worth",
    followed_interact: "Interact"
};
var stakePage$7 = {
    totalStaked: "Total Staked",
    apr: "Annual Percentage Rate",
    seeDetails: "SEE DETAILS",
    stake: "STAKE",
    earn: "Earn {{symbol}}",
    stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$7 = {
    missingCurrencyAmounts: "Fehlende Whrungsbetrge",
    missingTokens: "Fehlende Token",
    missingDependencies: "Fehlende Abhngigkeiten",
    missingLiquidityAmount: "Fehlender Liquidittsbetrag",
    couldNotWrap: "Konnte nicht umbrechen",
    attemptingToConfirmApproval: "Besttigungsversuch ohne Genehmigung oder Unterschrift. Bitte kontaktieren Sie den Support."
};
var sarTitle$7 = {
    addMore: "MEHR HINZUFGEN",
    unstake: "EINE POSITION ABSETZEN",
    compound: "VERBUNDENE BELOHNUNGEN",
    claim: "BELOHNUNG ENTGEGENNEHMEN",
    interactingID: "Interaktion mit ID: {{ id }}"
};
var sarStake$7 = {
    createNewPosition: "Erstellen Sie eine neue Position",
    stake: "Anteil",
    staking: "Wettend",
    walletBalance: "Im Portemonnaie {{ Guthaben }} {{ symbol }}",
    max: "Max",
    dollarValue: "Dollar-Wert",
    buy: "{{ symbol }} kaufen",
    averageAPR: "Durchschnittlich Apr",
    startingApr: "Starten des effektiven Jahreszeitraums",
    weeklyDistributed: "Wchentlich {{ symbol }} Verteilt",
    confirmDescription: "Durch eine Pfahlaktion wird ein SAR-Nft fr Sie erstellt. Mit diesem NFT knnen Sie Ihren {{ symbol }} Einsatz verwalten.",
    successSubmit: "Sie haben Ihr Token erfolgreich abgesteckt.",
    yourAprRecalculated: "Ihr effektiver Jahreszins wird neu berechnet.",
    summary: "Zusammenfassung",
    pending: "Abstecken {{ balance }} {{ symbol }}",
    transactionSummary: "Abgesteckt {{ balance }} {{ symbol }}"
};
var sarStakeMore$7 = {
    stakeMore: "Mehr setzen",
    choosePosition: "Whlen Sie eine Position",
    confirmDescription: "Dies fgt Ihrer SAR NFT Position {{ symbol }} hinzu. Ihr ursprngliches Guthaben wird ab demselben effektiven Jahreszins fortgesetzt. Der effektive Jahreszins Ihrer neu hinzugefgten Token beginnt bei 0 % und ndert sich je nach Lnge des Einsatzes. Ihr NFT zeigt den Durchschnitt an.",
    newAPR: "Neuer effektiver Jahreszins",
    add: "Hinzufgen",
    pending: "Hinzufgen von {{ balance }} {{ symbol }}"
};
var sarUnstake$7 = {
    unstake: "Abstand",
    unstaking: "Abstecken {{ balance }} {{ symbol }}",
    stakedBalance: "Abgesteckt {{ balance }} {{ symbol }}",
    confirmDescription: "Es lohnt sich zu wissen, dass das Abstecken Ihrer Belohnungen Ihren effektiven Jahreszins fr diese Position auf 0% erhht. \nAnstatt sich zu lsen, knnen Sie auch in Betracht ziehen, Ihren NFT zu verkaufen.",
    successSubmit: "Sie haben Ihre Token erfolgreich abgesetzt.",
    pending: "Abstecken {{ balance }} {{ symbol }}",
    transactionSummary: "Nicht abgesteckt {{ balance }} {{ symbol }}",
    currentAPR: "Aktueller effektiver Jahreszins",
    unstakeWarning: "Wenn Sie den Einsatz aufheben, sinkt Ihr durchschnittlicher effektiver Jahreszins auf 0%.",
    aprAfter: "effektiver Jahreszins nach dem Einsatz"
};
var sarCompound$7 = {
    compound: "Verbindung",
    compounding: "Aufzinsung",
    successSubmit: "Sie haben Ihre Position erfolgreich gefestigt.",
    pending: "Aufzinsung",
    transactionSummary: "Zusammengesetzte Position",
    aprAfter: "APR nach Aufzinsung",
    reward: "Gesammelte Prmien",
    description: "Bitte beachten Sie, dass die Aufzinsung Ihrer Prmien Ihren durchschnittlichen effektiven Jahreszins verringern kann. Neu abgesteckte Token beginnen bei 0, whrend die alten Token mit dem gleichen effektiven Jahreszins weiterlaufen. Dadurch entsteht der Durchschnitt, der Ihnen angezeigt wird.",
    noRewards: "Keine Belohnungen zum Komponieren"
};
var sarClaim$7 = {
    claim: "Anspruch",
    claiming: "Fordernd",
    description: "Aufgrund der Natur des SAR-Einsatzsystems, das behauptet, dass Ihre Belohnungen Ihren effektiven Jahreszins auf 0 senken. Sie knnen stattdessen Ihre Belohnungen zusammensetzen, ohne Ihren effektiven Jahreszins zu verlieren.",
    successSubmit: "Sie haben Ihre Prmien erfolgreich beansprucht",
    pending: "Fordernd",
    transactionSummary: "Beanspruchte Positionsprmien",
    aprAfter: "effektiver Jahreszins nach der Reklamation",
    noRewards: "Keine Prmien zu beanspruchen"
};
var sarPortfolio$7 = {
    noPositions: "Sie haben kein PANGUARDIAN NFT.\nLASS UNS DIR EINEN BESORGEN",
    start: "ANFANGEN",
    positionId: "Positions-ID",
    apr: "APR",
    amount: "Menge",
    newest: "Neuest",
    oldest: "lteste",
    sortBy: "Sortieren nach"
};
var pangoChef$7 = {
    claimWarning1: "Wenn Sie einen Anspruch geltend machen, ohne abzuheben, bleibt Ihre Liquiditt im Mining-Pool.",
    claimWarning2: "Wenn Sie Ihre Prmien beanspruchen, sinkt Ihr effektiver Jahreszins auf 0. Stattdessen knnen Sie sich fr eine Aufzinsung entscheiden.",
    compoundWarning: "Wenn Sie Ihre Belohnungen fr die {{ token0 }}-{{ token1 }}-Farm zusammensetzen, werden Ihre Belohnungen in die {{ currency }}-{{ png }} farm eingesetzt. Sie mssen den gleichen Wert von {{ currency }}Token fr Ihre angesammelten {{ png }} Prmien.",
    compoundAmountWarning: "Sie mssen {{ amount }} {{ symbol }} zur Verbindung hinzufgen.",
    compoundAmountWarning2: "Zum Zusammensetzen. Seien Sie vorsichtig, dass Sie Ihren {{ symbol }} {{ png }} pool sperren, bis Sie die Belohnungen dieses Pools beanspruchen.",
    highVolalityWarning: "Zu frh, versuchen Sie es in ein paar Stunden",
    compoundSuccess: "Sie haben Ihre Farm erfolgreich zusammengestellt.",
    compoundTransactionSummary: "Zusammengesetzte Farm.",
    removeWarning: "Wenn Sie einen beliebigen Betrag von der Farm entfernen, wird Ihr effektiver Jahreszins auf 0 gesetzt. Sie knnen stattdessen Ihre Belohnungen aufstocken, ohne Ihren effektiven Jahreszins zu verlieren.",
    lockingPoolZeroWarning: "Sie knnen Ihre Liquiditt nicht entfernen oder Ihre Belohnungen von dieser Farm einfordern. Dazu mssen Sie zuerst entweder Ihren Anteil von diesen Farmen beanspruchen: "
};
var bridge$7 = {
    availableRoutes: "Available Routes ({{ number }})",
    activeTransfers: "Active Transfers ({{ number }})",
    historicalTransfers: "Historical Transfers ({{ number }})",
    bridgeCard: {
        advanceOptions: "Advance Options",
        title: "Cross Chain",
        swap: "Swap",
        loader: {
            labels: {
                waitingReceivingChain: "Waiting for receiving chain..."
            },
            bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
        },
        filter: {
            bridgePrioritization: "Bridge Prioritization",
            slippage: "Slippage",
            infiniteApproval: "Infinite Approval",
            activeInfiniteApproval: "Active Infinite Approval",
            bridges: "Bridges",
            exchanges: "Exchanges"
        }
    },
    bridgeInputsWidget: {
        tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
        max: "MAX"
    },
    bridgeRoute: {
        selected: "Selected",
        clickToSelect: "Click to select",
        singleTransaction: "Single transaction including",
        estimatedToken: "Estimated Token: {{ token }}",
        estimatedResult: "Estimated Result: {{ result }}",
        min: "{{ minute }} min",
        gasCost: "{{ gasCost }} Gas Cost"
    },
    bridgeTransfer: {
        date: "Date",
        from: "From",
        to: "To",
        via: "Via",
        state: "State",
        resumeSwap: "Resume Swap"
    },
    bridgePrioritizations: {
        recommended: "Recommended",
        fast: "Fast",
        normal: "Normal"
    }
};
var dropdown$7 = {
    select: "Select"
};
var deTranslation = {
    header: header$7,
    accountDetails: accountDetails$7,
    addressInputPanel: addressInputPanel$7,
    currencyInputPanel: currencyInputPanel$7,
    earn: earn$7,
    menu: menu$7,
    modalView: modalView$7,
    navigationTabs: navigationTabs$7,
    popups: popups$7,
    positionCard: positionCard$7,
    searchModal: searchModal$7,
    settings: settings$7,
    swap: swap$7,
    toggle: toggle$7,
    tokenWarningModal: tokenWarningModal$7,
    transactionConfirmation: transactionConfirmation$7,
    transactionSettings: transactionSettings$7,
    vote: vote$7,
    walletModal: walletModal$7,
    web3ReactManager: web3ReactManager$7,
    web3Status: web3Status$7,
    gasFeeAlert: gasFeeAlert$7,
    addLiquidity: addLiquidity$7,
    airdrop: airdrop$7,
    earnPage: earnPage$7,
    pool: pool$7,
    poolFinder: poolFinder$7,
    removeLiquidity: removeLiquidity$7,
    swapPage: swapPage$7,
    buyPage: buyPage$7,
    votePage: votePage$7,
    IDOPage: IDOPage$7,
    swapHooks: swapHooks$7,
    mintHooks: mintHooks$7,
    stakeHooks: stakeHooks$7,
    burnHooks: burnHooks$7,
    migratePage: migratePage$7,
    dashboardPage: dashboardPage$7,
    stakePage: stakePage$7,
    error: error$7,
    sarTitle: sarTitle$7,
    sarStake: sarStake$7,
    sarStakeMore: sarStakeMore$7,
    sarUnstake: sarUnstake$7,
    sarCompound: sarCompound$7,
    sarClaim: sarClaim$7,
    sarPortfolio: sarPortfolio$7,
    pangoChef: pangoChef$7,
    bridge: bridge$7,
    dropdown: dropdown$7
};

var header$6 = {
    dashboard: "Dashboard",
    swap: "Swap",
    buy: "Buy",
    pool: "Pool",
    farm: "Farm",
    version1: "Version 1",
    version2: "Version 2",
    stake: "Stake",
    newPng: "New {{ pngSymbol }}",
    oldPng: "Old {{ pngSymbol }}",
    vote: "Vote",
    ido: "IDO",
    charts: "Charts",
    forum: "Forum",
    pngBreakDown: "Your {{ symbol }} Breakdown",
    balance: "Balance: ",
    unclaimed: "Unclaimed: ",
    pngPrice: "{{ symbol }} price:",
    pngCirculation: "{{ symbol }} in circulation:",
    totalSupply: "Total Supply",
    makeSureURLWarning: "Make sure the URL is",
    alwaysMakeSureWarning: "Always make sure the URL is",
    bookmarkIt: "bookmark it to be safe.",
    addMetamask: "Add {{ symbol }} to MetaMask",
    bridge: "Bridge",
    ourPartners: "Our Partners",
    usefulLinks: "USEFUL LINKS",
    comeAndJoinUs: "Come & Join Us",
    tryOurNewBetaSite: "Try our new beta site",
    returnToLegacySite: "Return to legacy site",
    switchToNewUI: "Switch to beta UI"
};
var accountDetails$6 = {
    connectedWith: "Connected with ",
    account: "Account",
    disconnect: "Disconnect",
    change: "Change",
    copy: "Copy Address",
    viewExplorer: "View on explorer",
    clearAll: "(clear all)",
    transactionAppear: "Your transactions will appear here...",
    recentTransactions: "Recent Transactions",
    copied: "Copied"
};
var addressInputPanel$6 = {
    recipient: "Recipient",
    viewExplorer: "(View on explorer)",
    walletAddress: "Wallet Address"
};
var currencyInputPanel$6 = {
    selectToken: "Select a token",
    balance: "Balance: ",
    max: "MAX",
    to: "To"
};
var earn$6 = {
    claimAccumulated: "Claim accumulated {{ symbol }} rewards",
    connectWallet: "Connect Wallet",
    enterAmount: "Enter an amount",
    unclaimedReward: "Unclaimed {{ symbol }}",
    claim: "Claim",
    claimReward: "Claim {{ symbol }}",
    liquidityRemainsPool: "When you claim without withdrawing your liquidity remains in the mining pool.",
    withdrawingLiquidity: "Withdrawing {{ amount }} {{ symbol }}",
    claimingReward: "Claiming {{ amount }} {{ symbol }}",
    claimedReward: "Claimed {{ symbol }}!",
    manage: "Manage",
    deposit: "Deposit",
    poolRate: "Pool rate",
    currentReward: "Current reward",
    pngPerAvax: "{{ pngSymbol }} / Week per AVAX",
    rewardPerWeek: "{{ symbol }} / Week",
    earnUpTo: "Earn up to (yearly)",
    yourRate: "Your rate",
    totalDeposited: "Total deposited",
    totalStaked: "Total staked",
    depositLiquidity: "Deposit liquidity",
    attemptingToStakeError: "Attempting to stake without approval or a signature. Please contact support.",
    transactionSubmitted: "Transaction Submitted",
    depositingLiquidity: "Depositing Liquidity",
    depositingToken: "Depositing {{ symbol }}",
    depositedToken: "Deposited {{ symbol }}",
    availableToDeposit: "Available to deposit: ",
    weeklyRewards: "Weekly Rewards",
    missingLiquidityAmount: "missing liquidity amount",
    missingDependencies: "missing dependencies",
    deposited: "Deposited",
    withdrawDepositedLiquidity: "Withdraw deposited liquidity",
    depositedPglLiquidity: "Deposited ARL liquidity:",
    whenYouWithdrawWarning: "When you withdraw, your {{ symbol }} is claimed and your Arcanum Liquidity tokens, ARL, are returned to you. You will no longer earn {{ symbol }} rewards on this liquidity. Your original token liquidity will remain in its liquidity pool.",
    whenYouWithdrawSingleSideWarning: "When you withdraw, your {{ symbol }} is claimed and your {{ pngSymbol}} is returned to you. You will no longer earn {{ symbol }} rewards on this {{ pngSymbol}}.",
    withdrawAndClaim: "Withdraw & Claim",
    withdrewStakingToken: "Withdrew {{ symbol }}!",
    approve: "Approve",
    poolWeight: "Pool Weight",
    withdraw: "Withdraw",
    extraReward: "Extra Reward",
    poolRewards: "Pool Rewards",
    rewardsIn: "Rewards in",
    removeWarning: "You are removing liquidity from this pool. This action will give you back your tokens. Alternatively you can choose to stake your tokens to farm to earn rewards."
};
var menu$6 = {
    code: "Code",
    twitter: "Twitter",
    discord: "Discord",
    telegram: "Telegram",
    tutorials: "Tutorials",
    idos: "IDOs",
    about: "About"
};
var modalView$6 = {
    confirmTransaction: "Confirm this transaction in your wallet",
    viewTransaction: "View transaction on the Explorer"
};
var navigationTabs$6 = {
    useThisTool: "Use this tool to find pairs that don't automatically appear in the interface.",
    swap: "Swap",
    pool: "Pool",
    importPool: "Import Pool",
    createPair: "Create a pair",
    addLiquidity: "Add Liquidity",
    removeLiquidity: "Remove Liquidity",
    whenYouAddLiquidityInfo: "When you add liquidity, you are given pool tokens representing your position. These tokens automatically earn fees proportional to your share of the pool, and can be redeemed at any time.",
    removingPoolTokensInfo: "Removing pool tokens converts your position back into underlying tokens at the current rate, proportional to your share of the pool. Accrued fees are included in the amounts you receive."
};
var popups$6 = {
    tokenListUpdated: "The token list \" {{oldList}} \" has been updated to ",
    updateAvailable: "An update is available for the token list \" {{oldList}} \"",
    viewExplorer: "View on explorer",
    hash: "Hash: ",
    added: "added",
    removed: "removed",
    tokensUpdated: "tokens updated",
    acceptUpdate: "Accept update",
    dismiss: "Dismiss"
};
var positionCard$6 = {
    add: "Add",
    remove: "Remove",
    poolShare: "Your pool share:",
    pooled: "Pooled",
    poolTokens: "Your pool tokens",
    manage: "Manage",
    loading: "Loading",
    yourPosition: "Your position",
    byAddingLiquidityInfo: "By adding liquidity you'll earn 0.25% of all trades on this pair proportional to your share of the pool.\n Fees are added to the pool, accrue in real time and can be claimed by withdrawing your liquidity."
};
var searchModal$6 = {
    commonBases: "Common bases",
    tokensPairsHelper: "These tokens are commonly paired with other tokens.",
    addedByUser: "Added by user",
    foundByAddress: "Found by address",
    remove: "remove",
    add: "Add",
    findToken: "Find a token by searching for its name or symbol or by pasting its address below.",
    selectToken: "Select a token",
    tokenSearchPlaceholder: "Search name or paste address",
    tokenName: "Token Name",
    change: "Change",
    selectList: "Select a list",
    confirmListRemovalPrompt: "Please confirm you would like to remove this list by typing REMOVE",
    addList: "Add a List ",
    tokenListHelper: "Token lists are an open specification for lists of ERC20 tokens. You can use any token list by entering its URL below. Beware that third party token lists can contain fake or malicious ERC20 tokens.",
    httpsPlaceholder: "https:// or ipfs://",
    manageLists: "Manage Lists",
    viewList: "View list",
    updateList: "Update list",
    removeList: "Remove list",
    selected: "Selected",
    select: "Select",
    manageTokenLists: "Manage Token Lists"
};
var settings$6 = {
    areYouSure: "Are you sure?",
    expertInfo: "Expert mode turns off the confirm transaction prompt and allows high slippage trades that often result in bad rates and lost funds.",
    expertWarningCAPS: "ONLY USE THIS MODE IF YOU KNOW WHAT YOU ARE DOING.",
    confirm: "confirm",
    confirmExpertMode: "Please type the word \"confirm\" to enable expert mode.",
    turnOnExpertMode: "Turn On Expert Mode",
    transactionSettings: "Transaction Settings",
    interfaceSettings: "Interface Settings",
    toggleExpertMode: "Toggle Expert Mode",
    expertModeHelper: "Bypasses confirmation modals and allows high slippage trades. Use at your own risk.",
    toggleDarkMode: "Toggle Dark Mode",
    slippage: "Slippage",
    percent: "Percent"
};
var swap$6 = {
    priceImpact: "Price Impact",
    priceImpactHelper: "The difference between the market price and estimated price due to trade size.",
    liquidityProviderFee: "Liquidity Provider Fee",
    liquidityProviderHelper: "A portion of each trade (0.30%) goes to liquidity providers as a protocol incentive.",
    route: "Route",
    routingHelper: "Routing through these tokens resulted in the best price for your trade.",
    confirmSwap: "Confirm Swap",
    swapAnyway: "Swap Anyway",
    confirm: "confirm",
    price: "Price",
    accept: "Accept",
    minimumReceived: "Minimum Received",
    maximumSold: "Maximum Sold",
    transactionRevertHelper: "Your transaction will revert if there is a large, unfavorable price movement before it is confirmed.",
    priceUpdated: "Price Updated",
    outputEstimated: "Output is estimated. You will receive at least <strong>{{amount}} {{currencySymbol}}</strong> or the transaction will revert.",
    inputEstimated: "Input is estimated. You will sell at most <strong>{{amount}} {{currencySymbol}}</strong> or the transaction will revert.",
    outputSentTo: "Output will be sent to ",
    priceImpactMinPrompt: "This swap has a price impact of at least {{ priceImpact }}%. Please type the word \"confirm\" to continue with this swap.",
    priceImpactHighPrompt: "This swap has a price impact of at least {{ priceImpact }}%. Please confirm that you would like to continue with this swap."
};
var toggle$6 = {
    on: "On",
    off: "Off"
};
var tokenWarningModal$6 = {
    tokenImported: "Token imported",
    anyoneCanCreateWarning: "Anyone can create an ERC-20 token on Avalanche with <em>any</em> name, including creating fake versions of existing tokens and tokens that claim to represent projects that do not have a token.",
    loadArbitraryWarning: "This interface can load arbitrary tokens by token addresses. Please take extra caution and do your research when interacting with arbitrary ERC-20 tokens.",
    purchaseArbitraryWarning: "If you purchase an arbitrary token, <strong>you may be unable to sell it back.</strong>",
    understand: "I understand",
    "continue": "Continue",
    viewExplorer: "View on explorer"
};
var transactionConfirmation$6 = {
    waitingConfirmation: "Waiting For Confirmation",
    confirmTransaction: "Confirm this transaction in your wallet",
    transactionSubmitted: "Transaction Submitted",
    viewExplorer: "View on explorer",
    close: "Close",
    error: "Error",
    dismiss: "Dismiss",
    addToFarm: "Add to Farm"
};
var transactionSettings$6 = {
    slippageTolerance: "Slippage tolerance",
    transactionRevertSlippageHelper: "Your transaction will revert if the price changes unfavorably by more than this percentage.",
    transactionDeadline: "Transaction deadline",
    transactionRevertDeadlineHelper: "Your transaction will revert if it is pending for more than this long.",
    enterValidSlippage: "Enter a valid slippage percentage",
    transactionMayFail: "Your transaction may fail",
    transactionMayFrontrun: "Your transaction may be frontrun",
    transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
    minutes: "minutes"
};
var vote$6 = {
    earnedPng: "Earned {{ pngSymbol }} tokens represent voting shares in Arcanum governance.",
    canEitherVote: "You can either vote on each proposal yourself or delegate your votes to a third party.",
    delegateVotes: "Delegate Votes",
    selfDelegate: "Self Delegate",
    remove: "Remove",
    add: "Add",
    delegate: "Delegate",
    delegatingVotes: "Delegating votes",
    unlockingVotes: "Unlocking Votes",
    transactionSubmitted: "Transaction Submitted",
    "for": "for",
    against: "against",
    vote: "Vote",
    proposal: "proposal",
    votes: "Votes",
    submittingVote: "Submitting Vote",
    confirmTransaction: "Confirm this transaction in your wallet",
    viewExplorer: "View on explorer"
};
var walletModal$6 = {
    wrongNetwork: "Wrong Network",
    errorConnecting: "Error connecting",
    pleaseConnectAvalanche: "Please connect to the appropriate Avalanche network.",
    switchAvalanche: "Switch to Avalanche Chain",
    errorConnectingRefresh: "Error connecting. Try refreshing the page.",
    connectToWallet: "Connect to a wallet",
    newToAvalanche: "New to Avalanche? ",
    learnMoreWallet: "Learn more about setting up a wallet",
    initializing: "Initializing...",
    tryAgain: "Try Again"
};
var web3ReactManager$6 = {
    unknownError: "Oops! An unknown error occurred. Please refresh the page, or visit from another browser or device."
};
var web3Status$6 = {
    pending: "Pending",
    wrongNetwork: "Wrong Network",
    error: "Error",
    connectToWallet: "Connect to a wallet"
};
var gasFeeAlert$6 = {
    gasFeeReduction: "!!! Gas Fee Reduction !!!",
    transactionsNotAccept: "Transactions will not be accepted unless the gas fee is set to {{ gasPrice }} gwei."
};
var addLiquidity$6 = {
    deposited: "Deposited",
    shareOfPool: "Share of Pool",
    createPoolSupply: "Create Pool & Supply",
    confirmSupply: "Confirm Supply",
    giveOrder: "GIVE ORDER",
    outputEstimated: "Output is estimated. If the price changes by more than {{ allowedSlippage }}% your transaction will revert.",
    creatingPool: "You are creating a pool",
    willReceive: "You will receive",
    firstLP: "You are the first liquidity provider.",
    ratioTokens: "The ratio of tokens you add will set the price of this pool.",
    happyRate: "Once you are happy with the rate click supply to review.",
    initialPrices: "Initial Prices",
    prices: "Prices",
    poolShare: "and pool share",
    connectWallet: "Connect Wallet",
    approve: "Approve ",
    supply: "Supply",
    per: " per ",
    rates: "Rates",
    poolTokens: " Pool Tokens"
};
var airdrop$6 = {
    claimPngAirdrop: "Claim {{ pngSymbol }} from Airdrop",
    claimPeriodEnded: "The airdrop claim period has ended.",
    connectWalletViewLiquidity: "Connect to a wallet to view your liquidity.",
    noAvailableClaim: "You have no {{ pngSymbol }} available claim.",
    noUniNoSushi: "You have no UNI or SUSHI tokens. Please follow the tutorial here to add UNI or SUSHI tokens to your wallet.",
    youHave: "You have ",
    pngAvailableClaim: " {{ pngSymbol }} available to claim",
    loading: "Loading",
    welcomeToTeamPangolin: "Welcome to team Arcanum",
    claim: "Claim "
};
var earnPage$6 = {
    pangolinLiquidityMining: "Arcanum Liquidity mining",
    pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
    depositPangolinLiquidity: "Deposit your Arcanum Liquidity Provider ARL tokens to receive {{ pngSymbol }}, the Arcanum protocol governance token.",
    depositPangolinStaking: "Deposit and stake your {{ pngSymbol }} tokens to earn more tokens.",
    currentOpportunities: "Current opportunities",
    readMoreAboutPng: "Read more about {{ pngSymbol }}",
    getInsuranceCoverage: "Get cover on InsurAce.io",
    getCoverNexusMutual: "Get cover on Nexus Mutual",
    importantUpdate: "IMPORTANT UPDATE",
    pangolinGovernanceProposalResult: "As a result of Arcanum governance proposal 1, Arcanum is changing staking contracts! After approximately 08:59 UTC on 4/19, all staking rewards will be distributed to the new staking contracts. Before the switch, all rewards will still be distributed to the old contracts. To avoid interruptions to yield farming rewards, you need to unstake your liquidity from the old contracts and restake in the new contracts. You do not need to remove liquidity from your pools or alter your positions.",
    oldPngPools: "Old {{ pngSymbol }} pools",
    newPngPools: "New {{ pngSymbol }} pools",
    participatingPools: "Participating pools",
    rewardsNeverEnd: "The Rewards Never End!",
    noActiveRewards: "No active rewards",
    liquidityMining: "Liquidity Mining",
    pngStaking: "{{ pngSymbol }} Staking",
    totalStaked: "Total Staked",
    poolRate: "Pool Rate",
    step1: "Step 1. Get Arcanum Liquidity tokens (ARL)",
    pglTokenRequired: "ARL tokens are required. Once you've added liquidity to the {{ poolHandle }} pool you can stake your liquidity tokens on this page.",
    addPoolLiquidity: "Add {{ poolHandle }} liquidity",
    liquidityDeposits: "Your liquidity deposits",
    yourStakedToken: "Your staked {{ symbol }}",
    unclaimedReward: "Your unclaimed {{ symbol }}",
    claim: "Claim",
    rewardPerWeek: " {{ symbol }} / week",
    automagically: "When you withdraw, the contract will automagically claim {{ pngSymbol }} on your behalf!",
    deposit: "Deposit",
    depositStakingTokens: "Deposit {{ symbol }} Tokens",
    stake: "Stake",
    stakeStakingTokens: "Stake {{ symbol }} Tokens",
    unstake: "Unstake",
    stakingTokensAvailable: "{{ symbol }} tokens available",
    getToken: "Get {{ symbol }}",
    migrateTitle: "Migrate your staked ARL",
    migrateDescription: "Arcanum has changed tokonomics. You will need to migrate your staked ARL to new contract",
    migrate: "Migrate"
};
var pool$6 = {
    liquidityProviderRewards: "Liquidity provider rewards",
    liquidityProvidersEarn: "Liquidity providers earn a 0.25% fee on all trades proportional to their share of the pool. Fees are added to the pool, accrue in real time and can be claimed by withdrawing your liquidity.",
    readMoreProviding: "Read more about providing liquidity",
    viewStakedLiquidity: "View your staked liquidity",
    yourLiquidity: "Your liquidity",
    createPair: "Create a pair",
    addLiquidity: "Add liquidity",
    connectWalletToView: "Connect to a wallet to view your liquidity.",
    loading: "Loading",
    noLiquidity: "No liquidity found.",
    uniswapV1Found: "Uniswap V1 liquidity found!",
    noSeePoolJoined: "Don't see a pool you joined?",
    migrateNow: "Migrate now.",
    importIt: "Import it.",
    seeDetails: "SEE DETAILS",
    totalLockedValue: "Total Locked Value",
    yourLockedValue: "Your Locked Value",
    allFarms: "All Farms",
    yourFarms: "Your Farms",
    yourPools: "Your Pools",
    noFarms: "No farms found.",
    successWithdraw: "Your liquidity removed from farm, And accrued rewards claimed!"
};
var poolFinder$6 = {
    connectToFind: "Connect to a wallet to find pools",
    selectTokenToFind: "Select a token to find your liquidity.",
    selectToken: "Select a Token",
    poolFound: "Pool Found!",
    managePool: "Manage this pool.",
    noLiquidityYet: "You don't have liquidity in this pool yet.",
    noPoolFound: "No pool found.",
    addLiquidity: "Add liquidity",
    createPool: "Create pool.",
    invalidPair: "Invalid pair.",
    loading: "Loading"
};
var removeLiquidity$6 = {
    youWillReceive: "You will receive",
    simple: "Simple",
    detailed: "Detailed",
    receiveAvax: "Receive {{ symbol }}",
    receiveWavax: "Receive {{ symbol }}",
    price: "Price:",
    connectWallet: "Connect Wallet",
    approving: "Approving",
    approve: "Approve",
    approved: "Approved",
    remove: "Remove",
    output: "Output",
    amount: "Amount"
};
var swapPage$6 = {
    addSend: "+ Add a send (optional)",
    toEstimated: "To (estimated)",
    to: "To",
    removeSend: "- Remove send",
    price: "Price",
    slippageTolerance: "Slippage Tolerance",
    connectWallet: "Connect Wallet",
    insufficientLiquidity: "Insufficient liquidity for this trade.",
    wrap: "Wrap",
    unwrap: "Unwrap",
    approving: "Approving",
    approve: "Approve ",
    approved: "Approved",
    priceImpactHigh: "Price Impact High",
    swap: "Swap",
    anyway: " Anyway",
    from: "From",
    fromEstimated: "From (estimated)",
    velox: "Set a limit order on <1>Velox</1>",
    marginSwap: "Trade with leverage on <1>MarginSwap</1>",
    wowSwap: " or <1>WOWswap</1>",
    veeFinance: " or <1>Vee Finance</1>",
    gelatoFee: "Gelato Fee",
    placeOrder: "Place Order",
    confirmOrder: "Confirm Order",
    "for": "for",
    submittingOrderToSwap: "Submitting order to swap",
    limitPrice: "Limit Price",
    outputWillBeSentTo: "Output will be sent to",
    sell: "SELL",
    buy: "BUY",
    betaRelease: "This is a BETA release and should be used at your own risk!",
    trade: "Trade",
    watchList: "WatchList",
    yourPortFolio: "Your Portfolio",
    comingSoon: "Coming Soon",
    connectWalletViewPortFolio: "Connect to a wallet to check your portfolio.",
    limitOrders: "Limit Orders",
    cancelOrder: "Cancel Order",
    all: "ALL",
    open: "OPEN",
    executed: "EXECUTED",
    cancelled: "CANCELLED",
    inputAmount: "Input Amount",
    outputAmount: "Output Amount",
    status: "Status",
    noLimitOrder: "No {{ orderType }} Order",
    cancellingOrder: "Cancelling order...",
    cancelLimitOrder: "Buy {{ outputCurrency }} with {{ inputCurrency }}",
    executionPrice: "Execution Price",
    seeMore: "See More",
    seeLess: "See Less"
};
var buyPage$6 = {
    buyAvaxInfo: "Buy AVAX with fiat from our partner Wyre.",
    privacyInfo: "Arcanum does not store your purchase history or any personal data.",
    firstName: "First Name",
    lastName: "Last Name",
    email: "Email",
    buyAvax: "Buy AVAX"
};
var votePage$6 = {
    unlockVotes: "Unlock Votes",
    updateDelegation: "Update Delegation",
    pangolinGovernance: "Arcanum Governance",
    earnedPngTokens: "{{ pngSymbol }} tokens represent voting shares in Arcanum governance. You can vote on each proposal yourself or delegate your votes to a third party.",
    eligibleToVote: "To be eligible to vote, you must hold {{ pngSymbol }} in your wallet and delegate it at the start of voting. After voting has begun, you may pool or spend your {{ pngSymbol }}.",
    governanceVotes: "Governance votes are decided by simple majority. There is no quorum threshold.",
    proposals: "Proposals",
    allProposals: "All Proposals",
    backToProposals: "Back to Proposals",
    unlockVoting: "Unlock voting",
    votes: " Votes",
    delegatedTo: "Delegated to:",
    edit: "edit",
    noProposalsFound: "No proposals found.",
    proposalCommunityMembers: "Proposals submitted by community members will appear here.",
    minimumThreshold: "A minimum threshold of 1,000,000 {{ pngSymbol }} is required to submit proposals",
    votingStarted: "Voting started ",
    votingStarts: "Voting starts ",
    votingEnded: "Voting ended ",
    votingEnds: "Voting ends ",
    voteFor: "Vote For",
    voteAgainst: "Vote Against",
    against: "Against",
    "for": "For",
    details: "Details",
    overview: "Overview",
    proposer: "Proposer",
    about: "About",
    vote: "Vote",
    executed: "Executed",
    rejected: "Rejected",
    notSupported: "Not supported on this chain"
};
var IDOPage$6 = {
    pangolinIDOs: "Initial DEX Offering (IDO)",
    pangolinIDODescription: "Initial DEX Offerings (IDO) allows projects to crowdfund their native tokens on decentralized exchanges. We've partnered with amazing teams to bring great projects to the Avalanche community.",
    upcomingIDOs: "Upcoming",
    endedIDOs: "Ended",
    allIDOs: "All IDOs",
    noIDOsFound: "No IDOs found",
    IDOAnnounced: "IDOs publicly announced will appear here."
};
var swapHooks$6 = {
    connectWallet: "Connect Wallet",
    enterAmount: "Enter an amount",
    selectToken: "Select a token",
    enterRecipient: "Enter a recipient",
    invalidRecipient: "Invalid recipient",
    insufficient: "Insufficient ",
    balance: " balance"
};
var mintHooks$6 = {
    connectWallet: "Connect Wallet",
    insufficientInputAmount: "Insufficient input amount",
    invalidPair: "Invalid pair",
    enterAmount: "Enter an amount",
    insufficient: "Insufficient ",
    balance: " balance"
};
var stakeHooks$6 = {
    connectWallet: "Connect Wallet",
    enterAmount: "Enter an amount",
    insufficientBalance: "Insufficient {{ symbol }} balance"
};
var burnHooks$6 = {
    connectWallet: "Connect Wallet",
    enterAmount: "Enter an amount"
};
var migratePage$6 = {
    stake: "STAKE",
    unstake: "UNSTAKE",
    add: "ADD",
    remove: "REMOVE",
    startMigratingNow: "START MIGRATING NOW",
    startMigratingNowDescription: "Below you will find all the Farms you will need to migrate to Arcanum's V2 Contracts",
    seeMore: "SEE MORE",
    migrateWithEase: "MIGRATE WITH EASE",
    migrateWithDescription: "We have designed an elegant wizard, which will help guide you through the process of migrating your Farms",
    alreadyMigrate: "already migrated",
    walletMigrate: "wallet migrated",
    alreadyEarned: "already earned",
    migrateNow: "MIGRATE NOW",
    learn: "LEARN",
    moveYourTokensToNewContracts: "Migrate your Farms to Arcanum V2",
    readyToMigrate: "Ready to migrate",
    apr: "APR:",
    totalValueLocked: "Total Value Locked",
    lowVolatility: "Low Volatility",
    compoundable: "Compoundable",
    migrate: "Migrate",
    migrationModalDescription: "Select the pools you wish to migrate",
    choosePool: "Choose Pool",
    pool: "Pool",
    availableToDeposit: "Available to deposit: ",
    poolInfoDescription: "Select the amount you wish to migrate",
    dollarWorth: "Dollar Worth: ",
    usd: "USD",
    yourRate: "Your rate: ",
    unclaimedPng: "Unclaimed {{ pngSymbol }}: ",
    shareOfPool: "Share of Pool: ",
    choose: "CHOOSE",
    selectAll: "Select all",
    loading: "Loading",
    back: "Back",
    availableToUnstake: "Available to unstake: ",
    submittingTransaction: "Submitting transaction",
    moveYourTokensToNewContractsDescription: "As part of Arcanum's roll out to new improved contracts, you will need to migrate your Farms. If you need any help or guidance, please click on the Learn button.",
    migrateModalHeading: "Migrate {{ current }} of {{ total }} Farms"
};
var dashboardPage$6 = {
    dashboard: "Dashboard",
    greetings: "Greetings kind guests! Let's ape in today",
    portfolioValue: "Portfolio Value",
    earned: "Earned",
    coins: "Coins",
    followedWallets: "Followed Wallets",
    earned_dailyIncome: "Daily Income",
    earned_weeklyIncome: "Weekly Income",
    earned_totalEarned: "Total Earned",
    earned_claim: "Claim",
    earned_customizePools: "Customize Pools",
    followed_address: "Address",
    followed_worth: "Worth",
    followed_interact: "Interact"
};
var stakePage$6 = {
    totalStaked: "Total Staked",
    apr: "Annual Percentage Rate",
    seeDetails: "SEE DETAILS",
    stake: "STAKE",
    earn: "Earn {{symbol}}",
    stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$6 = {
    missingCurrencyAmounts: "Missing currency amounts",
    missingTokens: "Missing tokens",
    missingDependencies: "Missing dependencies",
    missingLiquidityAmount: "Missing liquidity amount",
    couldNotWrap: "Could not wrap",
    attemptingToConfirmApproval: "Attempting to confirm without approval or a signature. Please contact support."
};
var sarTitle$6 = {
    addMore: "STAKE",
    unstake: "UNSTAKE",
    compound: "COMPOUND REWARDS",
    claim: "CLAIM REWARDS",
    interactingID: "Interacting with ID: {{ id }}"
};
var sarStake$6 = {
    createNewPosition: "Create a new position",
    stake: "Stake",
    staking: "Staking",
    walletBalance: "In Wallet {{ balance }} {{ symbol }}",
    max: "MAX",
    dollarValue: "Dollar Value",
    buy: "Buy {{ symbol }}",
    averageAPR: "Average APR",
    startingApr: "Starting APR",
    weeklyDistributed: "Weekly {{ symbol }} Distributed",
    confirmDescription: "Staking creates a SAR NFT position. This NFT manages your {{ symbol }} tokens and APR. Your APR will change based on the length of stake.",
    successSubmit: "You've successfully staked.",
    yourAprRecalculated: "Your APR will be recalculated.",
    summary: "Summary",
    pending: "Staking {{ balance }} {{ symbol }}",
    transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore$6 = {
    stakeMore: "Stake More",
    choosePosition: "Choose a Position",
    confirmDescription: "This adds {{ symbol }} to your SAR NFT position. Your original balance continues from the same APR. The APR of your newly added tokens starts from 0% and changes based on the length of stake. Your NFT will show the average.",
    newAPR: "New APR",
    add: "Stake",
    pending: "Staking {{ balance }} {{ symbol }}"
};
var sarUnstake$6 = {
    unstake: "Unstake",
    unstaking: "Unstaking {{ balance }} {{ symbol }}",
    stakedBalance: "Staked {{ balance }} {{ symbol }}",
    confirmDescription: "Youre about to unstake your NFT position which restarts the APR of the remaining balance from 0%. Is that what you want to do?",
    successSubmit: "You've successfully unstaked your tokens.",
    pending: "Unstaking {{ balance }} {{ symbol }}",
    transactionSummary: "Unstaked {{ balance }} {{ symbol }}",
    currentAPR: "Current APR",
    unstakeWarning: "Unstaking restarts the APR of this position from 0%. Instead of unstaking, you can also sell your NFT position on a secondary market.",
    aprAfter: "APR After Unstake"
};
var sarCompound$6 = {
    compound: "Compound",
    compounding: "Compounding",
    successSubmit: "You have successfully compounded your position.",
    pending: "Compounding",
    transactionSummary: "Compounded position",
    aprAfter: "APR After Compounding",
    reward: "Rewards accrued",
    description: "Please be aware that compounding your rewards may decrease your average APR. Newly staked tokens start from 0, while the old tokens will continue with the same APR. This creates the average that is displayed to you.",
    noRewards: "No rewards to compound"
};
var sarClaim$6 = {
    claim: "Claim",
    claiming: "Claiming",
    description: "Claiming your rewards will restart the APR of your position from 0%. Instead of claiming, you can also compound your rewards.",
    successSubmit: "You have successfully claimed your rewards",
    pending: "Claiming",
    transactionSummary: "Claimed position rewards",
    aprAfter: "APR After Claim",
    noRewards: "No rewards to claim"
};
var sarPortfolio$6 = {
    noPositions: "You don't have a staking position NFT.\nLET'S GET YOU ONE!",
    start: "START",
    positionId: "Position ID",
    apr: "APR",
    amount: "Amount",
    newest: "Newest",
    oldest: "Oldest",
    sortBy: "Sort By"
};
var pangoChef$6 = {
    claimWarning1: "When you claim without withdrawing, your liquidity remains in the farm.",
    claimWarning2: "Claiming rewards restarts your APR from 0%. Instead you may choose to compound.",
    compoundWarning: "Compounding your rewards for {{ token0 }}-{{ token1 }} farm will get your rewards staked into {{ currency }}-{{ png }} farm. You need to add equal value of {{ currency }} token to your accrued {{ png }} rewards.",
    compoundAmountWarning: "You need to add {{ amount }} {{ symbol }} to compound.",
    compoundAmountWarning2: "Be careful that you will be locking your {{ symbol }} {{ png }} pool till you claim the rewards of this pool.",
    highVolalityWarning: "Too early, try in few hours",
    compoundSuccess: "You have successfully composed your farm.",
    compoundTransactionSummary: "Compounded farm",
    removeWarning: "Removing any amount from farm will get your APR to 0. You can instead compound your rewards without losing your APR.",
    lockingPoolZeroWarning: "You cant remove your liquidity or claim your rewards from this farm. To do this you first need to either claim your stake from this farms: "
};
var bridge$6 = {
    availableRoutes: "Available Routes ({{ number }})",
    activeTransfers: "Active Transfers ({{ number }})",
    historicalTransfers: "Historical Transfers ({{ number }})",
    bridgeCard: {
        advanceOptions: "Advance Options",
        title: "Cross Chain",
        swap: "Swap",
        loader: {
            labels: {
                waitingReceivingChain: "Waiting for receiving chain..."
            },
            bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
        },
        filter: {
            bridgePrioritization: "Bridge Prioritization",
            slippage: "Slippage",
            infiniteApproval: "Infinite Approval",
            activeInfiniteApproval: "Active Infinite Approval",
            bridges: "Bridges",
            exchanges: "Exchanges"
        }
    },
    bridgeInputsWidget: {
        tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
        max: "MAX"
    },
    bridgeRoute: {
        selected: "Selected",
        clickToSelect: "Click to select",
        singleTransaction: "Single transaction including",
        estimatedToken: "Estimated Token: {{ token }}",
        estimatedResult: "Estimated Result: {{ result }}",
        min: "{{ minute }} min",
        gasCost: "{{ gasCost }} Gas Cost"
    },
    bridgeTransfer: {
        date: "Date",
        from: "From",
        to: "To",
        via: "Via",
        state: "State",
        resumeSwap: "Resume Swap"
    },
    bridgePrioritizations: {
        recommended: "Recommended",
        fast: "Fast",
        normal: "Normal"
    }
};
var dropdown$6 = {
    select: "Select"
};
var enTranslation = {
    header: header$6,
    accountDetails: accountDetails$6,
    addressInputPanel: addressInputPanel$6,
    currencyInputPanel: currencyInputPanel$6,
    earn: earn$6,
    menu: menu$6,
    modalView: modalView$6,
    navigationTabs: navigationTabs$6,
    popups: popups$6,
    positionCard: positionCard$6,
    searchModal: searchModal$6,
    settings: settings$6,
    swap: swap$6,
    toggle: toggle$6,
    tokenWarningModal: tokenWarningModal$6,
    transactionConfirmation: transactionConfirmation$6,
    transactionSettings: transactionSettings$6,
    vote: vote$6,
    walletModal: walletModal$6,
    web3ReactManager: web3ReactManager$6,
    web3Status: web3Status$6,
    gasFeeAlert: gasFeeAlert$6,
    addLiquidity: addLiquidity$6,
    airdrop: airdrop$6,
    earnPage: earnPage$6,
    pool: pool$6,
    poolFinder: poolFinder$6,
    removeLiquidity: removeLiquidity$6,
    swapPage: swapPage$6,
    buyPage: buyPage$6,
    votePage: votePage$6,
    IDOPage: IDOPage$6,
    swapHooks: swapHooks$6,
    mintHooks: mintHooks$6,
    stakeHooks: stakeHooks$6,
    burnHooks: burnHooks$6,
    migratePage: migratePage$6,
    dashboardPage: dashboardPage$6,
    stakePage: stakePage$6,
    error: error$6,
    sarTitle: sarTitle$6,
    sarStake: sarStake$6,
    sarStakeMore: sarStakeMore$6,
    sarUnstake: sarUnstake$6,
    sarCompound: sarCompound$6,
    sarClaim: sarClaim$6,
    sarPortfolio: sarPortfolio$6,
    pangoChef: pangoChef$6,
    bridge: bridge$6,
    dropdown: dropdown$6
};

var header$5 = {
    dashboard: "Dashboard",
    swap: "Intercambio",
    buy: "Comprar",
    pool: "Pool",
    farm: "Farm",
    version1: "Versin 1",
    version2: "Versin 2",
    stake: "Stake",
    newPng: "Nuevo {{ pngSymbol }}",
    oldPng: "Viejo {{ pngSymbol }}",
    vote: "Votar",
    ido: "IDO",
    charts: "Grficas",
    forum: "Foro",
    pngBreakDown: "Desglose de tu {{ symbol }}",
    balance: "Balance: ",
    unclaimed: "Sin reclamar: ",
    pngPrice: "Precio {{ symbol }}:",
    pngCirculation: "{{ symbol }} en circulacin:",
    totalSupply: "Suministro total",
    makeSureURLWarning: "Asegrese de que el URL es",
    alwaysMakeSureWarning: "Asegrese siempre de que la URL sea",
    bookmarkIt: "marcarla para estar seguro.",
    addMetamask: "Agregar {{ symbol }} a MetaMask",
    bridge: "Puente",
    ourPartners: "Nuestros compaeros",
    usefulLinks: "ENLACES TILES",
    comeAndJoinUs: "Ven y nete a nosotras",
    tryOurNewBetaSite: "Prueba nuestro nuevo sitio beta",
    returnToLegacySite: "Regresar al sitio heredado",
    switchToNewUI: "Cambiar a la nueva IU"
};
var accountDetails$5 = {
    connectedWith: "Connectado con ",
    account: "Cuenta",
    disconnect: "Desconectar",
    change: "Cambiar",
    copy: "Copiar direccin",
    viewExplorer: "Ver en el explorador",
    clearAll: "(borrar todo)",
    transactionAppear: "Tus transacciones aparecern aqu...",
    recentTransactions: "Transacciones recientes",
    copied: "Copiado"
};
var addressInputPanel$5 = {
    recipient: "Recipient",
    viewExplorer: "(Ver en el explorador)",
    walletAddress: "Direccin de la cartera"
};
var currencyInputPanel$5 = {
    selectToken: "Selecciona un token",
    balance: "Balance: ",
    max: "MAX",
    to: "A"
};
var earn$5 = {
    claimAccumulated: "Reclama las recompensas accumulatadas de {{ symbol }}",
    connectWallet: "Connectar cartera",
    enterAmount: "Introduce una cantidad",
    unclaimedReward: "{{ symbol }} sin reclamar",
    claim: "Reclamar",
    claimReward: "{{ symbol }} Reclamar",
    liquidityRemainsPool: "Cuando reclamas sin retirar, tu liquidez permanece en la pool de minera.",
    withdrawingLiquidity: "Retirar {{ amount }} {{ symbol }}",
    claimingReward: "Reclamando {{ amount }} {{ symbol }}",
    claimedReward: "{{ symbol }} reclamados!",
    manage: "Gestionar",
    deposit: "Depositar",
    poolRate: "Ratio de la pool",
    currentReward: "Recompensa actual",
    pngPerAvax: "{{ pngSymbol }} / Semana por AVAX",
    rewardPerWeek: "{{ symbol }} / Semana",
    earnUpTo: "Gana hasta (anualmente)",
    yourRate: "Tu ritmo",
    totalDeposited: "Total depositado",
    totalStaked: "Total depositado",
    depositLiquidity: "Depositar liquidez",
    attemptingToStakeError: "Attempting to stake without approval or a signature. Por favor contacta con el soporte.",
    transactionSubmitted: "Transaccin Enviada",
    depositingLiquidity: "depositando Liquidez",
    depositingToken: "Depositing {{ symbol }}",
    depositedToken: "Deposited {{ symbol }}",
    availableToDeposit: "Disponible para depositar: ",
    weeklyRewards: "Recompensas semanales",
    missingLiquidityAmount: "falta liquidez",
    missingDependencies: "faltan dependencias",
    deposited: "Depositado",
    withdrawDepositedLiquidity: "Retirar liquidez depositada",
    depositedPglLiquidity: "Liquidez ARL depositados:",
    whenYouWithdrawWarning: "Cuando retiras, sus {{ symbol }} son reclamados y tus Arcanum Liquidity tokens, ARL, le son devueltos. Usted no ganar {{ symbol }} de recompensa por esta liquidez. Tu token original de liquidez permanecer en su pool de liquidez.",
    whenYouWithdrawSingleSideWarning: "When you withdraw, your {{ symbol }} is claimed and your {{ pngSymbol }} is returned to you. You will no longer earn {{ symbol }} rewards on this {{ pngSymbol }}.",
    withdrawAndClaim: "Retirar y reclamar",
    withdrewStakingToken: "{{ symbol }} retirados!",
    approve: "Aprobar",
    poolWeight: "Peso de la piscina",
    withdraw: "Retirar",
    extraReward: "Recompensa adicional",
    poolRewards: "Recompensas de la piscina",
    rewardsIn: "Recompensas en",
    removeWarning: "Est eliminando liquidez de este grupo. Esta accin te devolver tus tokens. Alternativamente, puede optar por apostar sus tokens en la granja para ganar recompensas."
};
var menu$5 = {
    code: "Cdigo",
    twitter: "Twitter",
    discord: "Discord",
    telegram: "Telegram",
    tutorials: "Tutoriales",
    idos: "IDOs",
    about: "Acerca de"
};
var modalView$5 = {
    confirmTransaction: "Confirma esta transaccin en tu cartera",
    viewTransaction: "Ver transaccin en el Explorador"
};
var navigationTabs$5 = {
    useThisTool: "Usa esta herramienta para encontrar parejas que no aparecen automticamente en la interfaz.",
    swap: "Intercambiar",
    pool: "Pool",
    importPool: "Importar Pool",
    createPair: "Crear una pareja",
    addLiquidity: "Aadir Liquidez",
    removeLiquidity: "Retirar Liquidez",
    whenYouAddLiquidityInfo: "Cuando aade liquidez, se le dan pool tokens que represenan su posicin. Estos tokens recolectan las tasas automticamente de forma proporcional a su parte total de la pool, y pueden ser reclamados en cualquier momento.",
    removingPoolTokensInfo: "Retirar pool tokens revierte su posicin a los tokens subyacentes al ratio actual, proporcionalmente a su parte de la pool. Las tasas acumuladas se incluyen en las cantidades que recibe."
};
var popups$5 = {
    tokenListUpdated: "la lista de Tokens \" {{oldList}} \" se ha actualizado a ",
    updateAvailable: "Hay una actualizacin disponible para la lista de Tokens \" {{oldList}} \"",
    viewExplorer: "Ver en el explorador",
    hash: "Hash: ",
    added: "aadido",
    removed: "retirado",
    tokensUpdated: "tokens actualizados",
    acceptUpdate: "Aceptar actualizacin",
    dismiss: "Descartar"
};
var positionCard$5 = {
    add: "Aadir",
    remove: "Retirar",
    poolShare: "Tu parte de la pool:",
    pooled: "En la Pool",
    poolTokens: "Tus Pool tokens:",
    manage: "Gestionar",
    loading: "Cargando",
    yourPosition: "Tu posicin",
    byAddingLiquidityInfo: "Aadiendo liquidez ganar el 0.25% de todos los intercambios en la pareja de forma proporcional a su parte de la Pool.\n Las tasas se aaden a la Pool, se acumulan en tiempo real y pueden ser reclamadas retirando su liquidez."
};
var searchModal$5 = {
    commonBases: "Bases comunes",
    tokensPairsHelper: "Estos tokens se emparejan comunmente con otros tokens.",
    addedByUser: "Aadido por el usuario",
    foundByAddress: "Encontrado por la direccin",
    remove: "borrar",
    add: "Aadir",
    findToken: "Encuentra un token buscndolo por su nombre, smbolo o pegando su direccin.",
    selectToken: "Selecciona un token",
    tokenSearchPlaceholder: "Busca un nombre o pega una direccin",
    tokenName: "Nombre del token",
    change: "Cambiar",
    selectList: "Selecciona una lista",
    confirmListRemovalPrompt: "Por favor, confirme que quiere borrar esta lista escribiendo: \"borrar\"",
    addList: "Aadir una Lista ",
    tokenListHelper: "Las listas de tokens son an especificaciones abiertas para listas de tokens ERC20. Puede usar cualquier lista introduciendo su URL. Tenga en cuenta que las listas de tokens de terceros pueden contener tokens ERC20 falsos o maliciosos.",
    httpsPlaceholder: "https:// o ipfs://",
    manageLists: "Gestionar listas",
    viewList: "Ver lista",
    updateList: "Actualizar lista",
    removeList: "Borrar lista",
    selected: "Seleccionado",
    select: "Seleccionar",
    manageTokenLists: "Administrar listas de tokens"
};
var settings$5 = {
    areYouSure: "Estas seguro?",
    expertInfo: "El modo experto deshabilita el aviso de confirmar transaccin y permite altos deslizamientos en intercambios que suelen causar malos ratios y fondos perdidos.",
    expertWarningCAPS: "USA ESTE MODO SOLO SI SABES LO QUE ESTS HACIENDO.",
    confirm: "confirmar",
    confirmExpertMode: "Por favor introduce la palabra \"confirmar\" para habilitar el modo experto.",
    turnOnExpertMode: "Habilitar modo experto",
    transactionSettings: "Ajustes de transaccin",
    interfaceSettings: "Ajustes de la interfaz",
    toggleExpertMode: "Avticar modo experto",
    expertModeHelper: "Sobrepasa los avisos de confirmacin y permite intercambios con altos deslizamientos. selo bajo su propio riesgo.",
    toggleDarkMode: "Activar modo oscuro",
    slippage: "Slippage",
    percent: "Percent"
};
var swap$5 = {
    priceImpact: "Impacto en el precio",
    priceImpactHelper: "La diferencia entre el precio de merkado y el precio estimado debido al tamao del intercambio.",
    liquidityProviderFee: "Tasa de proveedor de liquidez",
    liquidityProviderHelper: "Una parte de cada intercambio (0.30%) va a los proveedores de liquidez como un incentivo protocolario.",
    route: "Ruta",
    routingHelper: "Enrutando estos tokens produce el mejor precio para su intercambio.",
    confirmSwap: "Confirmar intercambio",
    swapAnyway: "Intercambiar de todos modos",
    confirm: "confirmar",
    price: "Precio",
    accept: "Aceptar",
    minimumReceived: "Mnimo recibido",
    maximumSold: "Mximo vendido",
    transactionRevertHelper: "Tu transaccin se revertir si hay un gran movimiento de precio desfavorable antes de ser confirmada..",
    priceUpdated: "Precio actualiazdo",
    outputEstimated: "El resultado es estimado. Recibir por lo menos <strong>{{amount}} {{currencySymbol}}</strong> o la transaccin se revertir.",
    inputEstimated: "El resultado es estimado. Vender como mucho <strong>{{amount}} {{currencySymbol}}</strong> o la transaccin se revertir.",
    outputSentTo: "La salida se mandar a ",
    priceImpactMinPrompt: "Este intercambio tiene un impacto en el precio de por lo menos {{ priceImpact }}%. Por favor, escriba la palabra \"confirmar\" para continuar con este intercambio.",
    priceImpactHighPrompt: "Este intercambio tiene un impacto en el precio de por lo menos {{ priceImpact }}%. Por favor, confirme que quiere continuar con este intercambio."
};
var toggle$5 = {
    on: "Encendido",
    off: "Apagado"
};
var tokenWarningModal$5 = {
    tokenImported: "Token importado",
    anyoneCanCreateWarning: "Cualquiera puede crear un token ERC-20 en Avalanche con <em>cualquier</em> nombre, incluso creaer versiones falsas de tokens ya existentes y tokens que dicen representar a proyectos que no tienen un token.",
    loadArbitraryWarning: "Esta interfaz puede cargar tokens arbitrariamente por su direccin. Por favor tenga suma precaucin y haga su propiar investigacin al interactuar con tokens ERC-20 de forma arbitraria.",
    purchaseArbitraryWarning: "Si compras un token arbitrario, <strong>puede que no pueda venderlo devuelta.</strong>",
    understand: "Lo entiendo",
    "continue": "Continuar",
    viewExplorer: "Ver en el explorador"
};
var transactionConfirmation$5 = {
    waitingConfirmation: "Esperando confirmacin",
    confirmTransaction: "Confirme esta transaccin en su cartera",
    transactionSubmitted: "Transaccin enviada",
    viewExplorer: "Ver en el explorador",
    close: "Cerrar",
    error: "Error",
    dismiss: "Descartar",
    addToFarm: "Agregar a la Farm"
};
var transactionSettings$5 = {
    slippageTolerance: "Tolerancia del deslizamiento",
    transactionRevertSlippageHelper: "Su transaccin se revertir si el precio cambia desfavorablemente ms de este porcentaje.",
    transactionDeadline: "Plazo de la transaccin",
    transactionRevertDeadlineHelper: "Su transaccin se revertir si permanece pendiente por ms de este plazo.",
    enterValidSlippage: "Introduce un porcentaje de deslizamieinto vlido",
    transactionMayFail: "Tu transaccin puede fallar",
    transactionMayFrontrun: "Tu transaccin puede sufrir inversin ventajista",
    transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
    minutes: "minutos"
};
var vote$5 = {
    earnedPng: "Earned {{ pngSymbol }} tokens represent voting shares in Arcanum governance.",
    canEitherVote: "You can either vote on each proposal yourself or delegate your votes to a third party.",
    delegateVotes: "Delegar votos",
    selfDelegate: "Autodelegar",
    remove: "Quitar",
    add: "Aadir",
    delegate: "Delegar",
    delegatingVotes: "Delegando votos",
    unlockingVotes: "Desbloqueando votos",
    transactionSubmitted: "Transaccin enviada",
    "for": "a favor",
    against: "en contra",
    vote: "Votar",
    proposal: "proposicin",
    votes: "Votos",
    submittingVote: "Enviando voto",
    confirmTransaction: "Confirme esta transaccin en su cartera",
    viewExplorer: "Ver en el explorador"
};
var walletModal$5 = {
    wrongNetwork: "Red errnea",
    errorConnecting: "Error al conectar",
    pleaseConnectAvalanche: "Por favor, conctese a la red de Avalanche correcta.",
    switchAvalanche: "Cambie a la Avalanche Chain",
    errorConnectingRefresh: "Error conectando. Pruebe a recargar la pgina.",
    connectToWallet: "Connect to a wallet",
    newToAvalanche: "Nuevo en Avalanche? ",
    learnMoreWallet: "Descubre ms sobre como configurar una cartera",
    initializing: "Inicializanddo...",
    tryAgain: "Prueba otra vez"
};
var web3ReactManager$5 = {
    unknownError: "Oops! Ha ocurrido un error desconocido. Por favor, recarga la pgina, o utilice otro navegador o dispositivo."
};
var web3Status$5 = {
    pending: "Pendiente",
    wrongNetwork: "Red errnea",
    error: "Error",
    connectToWallet: "Conectar a la cartera"
};
var gasFeeAlert$5 = {
    gasFeeReduction: "!!! Reduccin de la tasa de gas !!!",
    transactionsNotAccept: "Las transacciones no sern aceptadas si la tasa de gas no es de {{ gasPrice }} gwei."
};
var addLiquidity$5 = {
    deposited: "Depositado",
    shareOfPool: "Parte de la Pool",
    createPoolSupply: "Crear pool y suministrar",
    confirmSupply: "Confirmar suministro",
    giveOrder: "GIVE ORDER",
    outputEstimated: "El resultado es estimado. Si el precio cambia ms de {{ allowedSlippage }}% su transaccin ser revertida.",
    creatingPool: "Est creando una pool",
    willReceive: "Recibir",
    firstLP: "Es el primer proveedor de liquidez.",
    ratioTokens: "El ratio de tokens que aada determinar el precio de esta pool.",
    happyRate: "Una vez estea contento con el ratio haga click en suministrar.",
    initialPrices: "Precios iniciales",
    prices: "Precios",
    poolShare: "y parte de la pool",
    connectWallet: "Conectar cartera",
    approve: "Aprobar ",
    supply: "Suministrar",
    per: " por ",
    rates: "Ratios",
    poolTokens: " Pool Tokens"
};
var airdrop$5 = {
    claimPngAirdrop: "Reclamar {{ pngSymbol }} del Airdrop",
    claimPeriodEnded: "El perodo de reclamacin del airdrop ha termindado.",
    connectWalletViewLiquidity: "Conecte la cartera para ver su liquidez.",
    noAvailableClaim: "No tiene recompensa disponible.",
    noUniNoSushi: "No tiene tokens UNI ni SUSHI. Por favor, siga el tutorial aqu para aadir tokens UNI o SUSHI a su cartera.",
    youHave: "Tiene ",
    pngAvailableClaim: " {{ pngSymbol }} disponible para reclamar",
    loading: "Cargando",
    welcomeToTeamPangolin: "Bienvenido al equipo Arcanum",
    claim: "reclamar "
};
var earnPage$5 = {
    pangolinLiquidityMining: "Minera de liquidez Arcanum",
    pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
    depositPangolinLiquidity: "Deposite sus tokens Arcanum Liquidity Provider ARL para recivir {{ pngSymbol }}, el token del protocolo de governanza de Arcanum.",
    depositPangolinStaking: "Deposit and stake your {{ pngSymbol }} tokens to earn more tokens.",
    currentOpportunities: "Current opportunities",
    readMoreAboutPng: "Leer ms sobre {{ pngSymbol }}",
    getInsuranceCoverage: "Obtenga cobertura en InsurAce.io",
    getCoverNexusMutual: "Ponte a cubierto en Nexus Mutual",
    importantUpdate: "ACTUALIZACIN IMPORTANTE",
    pangolinGovernanceProposalResult: "Como resultado de la primera proposicin de governanza de Arcanum, este est cambiando sus contratos de staking! Despus de aproximadamente 08:59 UTC el 4/19, todas las recompensas sern distribuidas a los nuevos contratos. Antes del cambio, todas las recompensas sern distribuidas a los viejos contratos. para evitar interrupciones en las recompensas, necesita retirar su liquidez de los viejos contratos y depositarla en los nuevos. No necesita retirar su liquidez de sus pools ni alterar sus posiciones.",
    oldPngPools: "Viejas pools {{ pngSymbol }}",
    newPngPools: "Nuevas pools {{ pngSymbol }}",
    participatingPools: "Participating pools",
    rewardsNeverEnd: "Las recompensas nunca terminan!",
    noActiveRewards: "No hay recompensas activas",
    liquidityMining: "Minera de liquidez",
    pngStaking: "{{ pngSymbol }} Staking",
    totalStaked: "Total depositado",
    poolRate: "Ratio de la Pool",
    step1: "Step 1. Get Arcanum Liquidity tokens (ARL)",
    pglTokenRequired: "ARL tokens are required. Once you've added liquidity to the {{ poolHandle }} pool you can stake your liquidity tokens on this page.",
    addPoolLiquidity: "Add {{ poolHandle }} liquidity",
    liquidityDeposits: "Sus depsitods de liquidez",
    yourStakedToken: "Your staked {{ symbol }}",
    unclaimedReward: "Sus {{ symbol }} sin reclamar",
    claim: "Reclamar",
    rewardPerWeek: " {{ symbol }} / week",
    automagically: "Cuando retira, el contrato reclama los {{ pngSymbol }} por usted automticamente",
    deposit: "Depositar",
    depositStakingTokens: "Depositar tokens {{ symbol }}",
    stake: "Stake",
    stakeStakingTokens: "Stake {{ symbol }} Tokens",
    unstake: "Unstake",
    stakingTokensAvailable: "Toens {{ symbol }} disponibles",
    getToken: "Get {{ symbol }}",
    migrateTitle: "Migre su ARL apilado",
    migrateDescription: "Arcanum ha cambiado la tokenmica. Deber migrar su ARL apilado a un nuevo contrato",
    migrate: "Emigrar"
};
var pool$5 = {
    liquidityProviderRewards: "Recompensas a proveedores de liquidez",
    liquidityProvidersEarn: "Los proveedores de liquiez ganan una tasa del 0.25% de todos los intercambios de forma proporcional a su parte de la pool. Las tasas se aaden a la pool, se acumulan en tiempo real y pueden ser reclamadas retirando su liquidez.",
    readMoreProviding: "Leer ms sobre la provisin de liquidez",
    viewStakedLiquidity: "Ver su liquidez depositada",
    yourLiquidity: "Su liquidez",
    createPair: "Crear una pareja",
    addLiquidity: "Aadir liquidez",
    connectWalletToView: "Conecte la cartera para ver su liquidez.",
    loading: "Cargando",
    noLiquidity: "No se ha encontrado liquidez.",
    uniswapV1Found: "Liquidez Uniswap V1 encontrada!",
    noSeePoolJoined: "No ves un pool a la que te has unido?",
    migrateNow: "Mirgrar ahora.",
    importIt: "Importar.",
    seeDetails: "VER DETALLES",
    totalLockedValue: "Valor bloqueado total",
    yourLockedValue: "Su valor bloqueado",
    allPools: "Todas las Farms",
    yourFars: "Tus Farms",
    yourPools: "Tus Pools",
    noFarms: "No se encontraron farms.",
    successWithdraw: "Su liquidez eliminada de la granja y las recompensas acumuladas reclamadas!"
};
var poolFinder$5 = {
    connectToFind: "Conecte la cartera para encontrar pools",
    selectTokenToFind: "Seleccione un token para encontrar su liquidez.",
    selectToken: "Selecionar un token",
    poolFound: "Pool encontrada!",
    managePool: "Gestionar esta pool.",
    noLiquidityYet: "Todava no tiene liquidez en la pool.",
    noPoolFound: "No se ha encontrado la pool.",
    addLiquidity: "Aadir liquidez.",
    createPool: "Crear pool.",
    invalidPair: "Pareja no vlida.",
    loading: "Cargando"
};
var removeLiquidity$5 = {
    youWillReceive: "Recivir",
    simple: "Simple",
    detailed: "Detallado",
    receiveAvax: "Recibir {{ symbol }}",
    receiveWavax: "Recibir {{ symbol }}",
    price: "Precio:",
    connectWallet: "Conectar cartera",
    approving: "Aprobando",
    approve: "Aprobar",
    approved: "Aprobado",
    remove: "Remove",
    output: "Resultado",
    amount: "Cantida"
};
var swapPage$5 = {
    addSend: "+ Aadir un envo (opcional)",
    toEstimated: "A (estimado)",
    to: "A",
    removeSend: "- Quitar envio",
    price: "Precio",
    slippageTolerance: "Tolerancia de deslizamiento",
    connectWallet: "Conectar cartera",
    insufficientLiquidity: "Liquidez insuficiente para el intercambio.",
    wrap: "Envolver",
    unwrap: "Desenvolver",
    approving: "Aprobando",
    approve: "Aprobar ",
    approved: "Aprobado",
    priceImpactHigh: "Alto impacto en el precio",
    swap: "Intercambiar",
    anyway: " De todos modos",
    from: "Desde",
    fromEstimated: "Desde (estimado)",
    velox: "Pon una orden lmite en <1>Velox</1>",
    marginSwap: "Opere con apalancamiento en <1>MarginSwap</1>",
    wowSwap: " o <1>WOWswap</1>",
    veeFinance: " o <1>Vee Finance</1>",
    gelatoFee: "Gelato Tarifa",
    placeOrder: "Realizar pedido",
    confirmOrder: "Confirmar pedido",
    "for": "por",
    submittingOrderToSwap: "Enviando orden para canje",
    limitPrice: "Precio lmite",
    outputWillBeSentTo: "La salida se enviar a",
    sell: "vender",
    buy: "comprar",
    betaRelease: "Esta es una versin BETA y debe usarse bajo su propio riesgo.",
    trade: "Comercio",
    watchList: "WatchList",
    yourPortFolio: "Su portafolio",
    comingSoon: "Prximamente",
    connectWalletViewPortFolio: "Conctese a una cartera para ver su portafolio .",
    limitOrders: "Lmite de rdenes",
    cancelOrder: "Cancelar orden",
    all: "TODA",
    open: "ABIERTA",
    executed: "EJECUTADA",
    cancelled: "CANCELADA",
    inputAmount: "Importe de entrada",
    outputAmount: "Cantidad de salida",
    status: "Estado",
    noLimitOrder: "No {{ orderType }} Pedido",
    cancellingOrder: "Cancelando pedido...",
    cancelLimitOrder: "Comprar {{ outputCurrency }} con {{ inputCurrency }}",
    executionPrice: "Precio de ejecucin",
    seeMore: "Ver ms",
    seeLess: "Ver menos"
};
var buyPage$5 = {
    buyAvaxInfo: "Compre AVAX con fiat de nuestro socio Wyre.",
    privacyInfo: "Arcanum no almacena su historial de compras ni ningn dato personal.",
    firstName: "Nombre",
    lastName: "Apellido",
    email: "Email",
    buyAvax: "Compre AVAX"
};
var votePage$5 = {
    unlockVotes: "Desbloquear votos",
    updateDelegation: "Actualizar delegacin",
    pangolinGovernance: "Governanza Arcanum",
    earnedPngTokens: "los tokens {{ pngSymbol }} representan participaciones en la governanza de Arcanum Puede votar en cada proposicin usted mismo o delegar sus votos a un tercero.",
    eligibleToVote: "Para ser elegible para votar, debe tener {{ pngSymbol }} en su cartera y delegarlos al comienzo de la votacin. Una vez la votacin haya empezado, puede depositar en una pool o gastar sus {{ pngSymbol }}.",
    governanceVotes: "Los votos de la governanza se deciden por mayora. No hay un lmite de quorum.",
    proposals: "Proposiciones",
    allProposals: "Todas las proposiciones",
    backToProposals: "Volver a Propuestas",
    unlockVoting: "Desbloquear votacin",
    votes: " Votos",
    delegatedTo: "Delegados a:",
    edit: "editar",
    noProposalsFound: "No se encontraron proposiciones.",
    proposalCommunityMembers: "Las proposiciones presentadas por miembros de la comunidad aparecern aqu.",
    minimumThreshold: "Se requieren un mnimo de 1,000,000 {{ pngSymbol }} para presentar proposiciones",
    votingStarted: "La votacin empez ",
    votingStarts: "La votacin empieza ",
    votingEnded: "La votacin termin ",
    votingEnds: "La votacin termina ",
    voteFor: "Votar a favor",
    voteAgainst: "Votar en contra",
    against: "En contra",
    "for": "A favor",
    details: "Detalles",
    overview: "Resumen",
    proposer: "Proponente",
    about: "Acerca de",
    vote: "Votar",
    executed: "Ejecutado",
    rejected: "Rechazado",
    notSupported: "No compatible con esta cadena"
};
var IDOPage$5 = {
    pangolinIDOs: "Initial DEX Offering (IDO)",
    pangolinIDODescription: "Las Ofertas Iniciales DEX (IDO) permiten a los proyectos financiar en forma colectiva sus tokens nativos en plataformas de intercambio descentralizados. Nos hemos asociado con equipos increbles para llevar grandes proyectos a la comunidad de Avalanche.",
    upcomingIDOs: "Prximos",
    endedIDOs: "Terminados",
    allIDOs: "Todos los IDOs",
    noIDOsFound: "No se encontraron IDOs",
    IDOAnnounced: "Los IDOs publicamente anunciados aparecern aqu."
};
var swapHooks$5 = {
    connectWallet: "Conectar cartera",
    enterAmount: "Introduzca una cantidad",
    selectToken: "Select a token",
    enterRecipient: "Introduzca un destinatario",
    invalidRecipient: "Destinatario no vlido",
    insufficient: "Insuficiente ",
    balance: " balance"
};
var mintHooks$5 = {
    connectWallet: "Conectar cartera",
    insufficientInputAmount: "Cantidad de aporte insuficiente",
    invalidPair: "Pareja no vlida",
    enterAmount: "Introduzca una cantidad",
    insufficient: "Insufciciente ",
    balance: " balance"
};
var stakeHooks$5 = {
    connectWallet: "Conectar cartera",
    enterAmount: "Introduzca una cantidad"
};
var burnHooks$5 = {
    connectWallet: "Conectar cartera",
    enterAmount: "Introduzca una cantidad"
};
var migratePage$5 = {
    stake: "APOSTAR",
    unstake: "DESPRENDIMIENTO",
    add: "AGREGAR",
    remove: "RETIRAR",
    startMigratingNow: "EMPIECE A MIGRAR AHORA",
    startMigratingNowDescription: "A continuacin encontrar todas las granjas que necesitar para migrar a los contratos V2 de Arcanum",
    seeMore: "VER MS",
    migrateWithEase: "MIGRA CON FACILIDAD",
    migrateWithDescription: "Hemos diseado un asistente elegante, que lo guiar a travs del proceso de migracin de sus Fincas.",
    alreadyMigrate: "Ya migrada",
    walletMigrate: "billetera migrada",
    alreadyEarned: "ya gana",
    migrateNow: "MIGRA AHORA",
    learn: "APRENDER",
    moveYourTokensToNewContracts: "Migre sus granjas a Arcanum V2",
    readyToMigrate: "Lista para migrar",
    apr: "APR:",
    totalValueLocked: "Valor total bloqueado",
    lowVolatility: "Baja volatilidad",
    compoundable: "Compuesta",
    migrate: "Emigrar",
    migrationModalDescription: "Nos hemos dado cuenta de que tiene estas piscinas ... Elija una o agregue una.",
    choosePool: "Elige piscina",
    pool: "Pool",
    availableToDeposit: "Disponible para depositar: ",
    poolInfoDescription: "Ahora que ha elegido su grupo, dejemos de apostar desde all.",
    dollarWorth: "Valor del dlar: ",
    usd: "USD",
    yourRate: "Tu tarifa: ",
    unclaimedPng: "{{ pngSymbol }} no reclamada: ",
    shareOfPool: "Participacin de la piscina: ",
    choose: "ESCOGER",
    selectAll: "Seleccionar todo",
    loading: "Cargando",
    back: "atrs",
    availableToUnstake: "Disponible para desaplicar: ",
    submittingTransaction: "Enviar transaccin",
    moveYourTokensToNewContractsDescription: "Como parte del lanzamiento de Arcanum a nuevos contratos mejorados, deber migrar sus granjas. Si necesita ayuda u orientacin, haga clic en el botn 'Aprender'",
    migrateModalHeading: "Migrar {{ current }} de {{ total }} granja"
};
var dashboardPage$5 = {
    dashboard: "Dashboard",
    greetings: "Greetings kind guests! Lets ape in today",
    portfolioValue: "Portfolio Value",
    earned: "Earned",
    coins: "Coins",
    followedWallets: "Followed Wallets",
    earned_dailyIncome: "Daily Income",
    earned_weeklyIncome: "Weekly Income",
    earned_totalEarned: "Total Earned",
    earned_claim: "Claim",
    earned_customizePools: "Customize Pools",
    followed_address: "Address",
    followed_worth: "Worth",
    followed_interact: "Interact"
};
var stakePage$5 = {
    totalStaked: "Total Staked",
    apr: "Annual Percentage Rate",
    seeDetails: "SEE DETAILS",
    stake: "STAKE",
    earn: "Earn {{symbol}}",
    stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$5 = {
    missingCurrencyAmounts: "Cantidades de moneda faltantes",
    missingTokens: "Fichas faltantes",
    missingDependencies: "Dependencias faltantes",
    missingLiquidityAmount: "Cantidad de liquidez faltante",
    couldNotWrap: "No se pudo envolver",
    attemptingToConfirmApproval: "Intentando confirmar sin aprobacin o firma. Comunquese con soporte."
};
var sarTitle$5 = {
    addMore: "AADIR MS",
    unstake: "QUITAR UNA POSICIN",
    compound: "RECOMPENSAS COMPUESTAS",
    claim: "RECLAMAR PREMIOS",
    interactingID: "Interactuando con ID: {{ id }}"
};
var sarStake$5 = {
    createNewPosition: "Crear un nuevo puesto",
    stake: "Apostar",
    staking: "Staking",
    walletBalance: "En Wallet {{ balance }} {{ symbol }}",
    max: "Mximo",
    dollarValue: "Valor en dlares",
    buy: "Comprar {{ symbol }}",
    averageAPR: "APR medio",
    startingApr: "APR inicial",
    weeklyDistributed: "Semanal {{ symbol }} Distribuido",
    confirmDescription: "Una accin de estaca crear un SAR Nft para usted. Con este NFT puede administrar su apuesta de {{ smbolo }}.",
    successSubmit: "Ha apostado con xito su token.",
    yourAprRecalculated: "Su APR ser recalculada.",
    summary: "Resumen",
    pending: "Staking {{ balance }} {{ symbol }}",
    transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore$5 = {
    stakeMore: "Apuesta Ms",
    choosePosition: "Elija una posicin",
    confirmDescription: "Esto agrega {{ symbol }} a su posicin SAR NFT. Su saldo original contina desde la misma APR. La APR de sus tokens recin agregados comienza desde 0% y cambia segn la duracin de la apuesta. Su NFT mostrar el promedio.",
    newAPR: "Nueva TAE",
    add: "Agregar",
    pending: "Agregar {{ balance }} {{ symbol }}"
};
var sarUnstake$5 = {
    unstake: "No tomar",
    unstaking: "Destamando {{ balance }} {{ symbol }}",
    stakedBalance: "Staked {{ balance }} {{ symbol }}",
    confirmDescription: "Vale la pena ser consciente de que desvincular sus recompensas har que su APR sea del 0% para esta posicin. \nEn lugar de destamar, tambin puede considerar vender su NFT.",
    successSubmit: "Ha desatado con xito sus tokens.",
    pending: "Destamando {{ balance }} {{ symbol }}",
    transactionSummary: "No tomado {{ balance }} {{ symbol }}",
    currentAPR: "APR actual",
    unstakeWarning: "Cuando no tome, su APR promedio caer a 0%.",
    aprAfter: "APR despus de unstake"
};
var sarCompound$5 = {
    compound: "Compuesto",
    compounding: "Composicin",
    successSubmit: "Ha compuesto con xito su posicin.",
    pending: "Composicin",
    transactionSummary: "Posicin compuesta",
    aprAfter: "APR despus de la capitalizacin",
    reward: "Recompensas acumuladas",
    description: "Tenga en cuenta que la capitalizacin de sus recompensas puede disminuir su APR promedio. Los tokens recin apostados comienzan desde 0, mientras que los tokens antiguos continuarn con la misma APR. Esto crea el promedio que se muestra a usted.",
    noRewards: "No hay recompensas para componer"
};
var sarClaim$5 = {
    claim: "Reclamacin",
    claiming: "Reclamando",
    description: "Debido a la naturaleza del sistema de apuesta SAR, reclamar sus recompensas reducir su APR a 0. En su lugar, puede aumentar sus recompensas sin perder su APR.",
    successSubmit: "Has reclamado con xito tus recompensas",
    pending: "Reclamando",
    transactionSummary: "Recompensas por posicin reclamada",
    aprAfter: "APR despus de la reclamacin",
    noRewards: "No hay recompensas que reclamar"
};
var sarPortfolio$5 = {
    noPositions: "No tienes ningn PANGUARDIAN NFT.\nVAMOS A CONSEGUIRTE UNO",
    start: "EMPEZAR",
    positionId: "ID de posicin",
    apr: "Apr",
    amount: "Importe",
    newest: "Nuevo",
    oldest: "Mayor",
    sortBy: "Ordenar por"
};
var pangoChef$5 = {
    claimWarning1: "Cuando reclamas sin retirar tu liquidez permanece en el pool de minera.",
    claimWarning2: "Reclamar sus recompensas reducir su APR a 0. En su lugar, puede optar por capitalizar.",
    compoundWarning: "Combinar sus recompensas para {{ token0 }}-{{ token1 }} har que sus recompensas se apuesten en {{ currency }}-{{ png }} granja. Debe agregar el mismo valor de {{ currency }} token a sus {{ png }} recompensas acumuladas.",
    compoundAmountWarning: "Necesitas agregar {{ amount }} {{ symbol }} al compuesto.",
    compoundAmountWarning2: "Tenga cuidado de bloquear su fondo de {{ symbol }} {{ png }} hasta que reclame las recompensas de este fondo.",
    highVolalityWarning: "Demasiado pronto, intente en unas pocas horas",
    compoundSuccess: "Ha compuesto correctamente su granja",
    compoundTransactionSummary: "Granja compuesta",
    removeWarning: "Eliminar cualquier cantidad de la granja har que su APR sea 0. En su lugar, puede combinar sus recompensas sin perder su APR.",
    lockingPoolZeroWarning: "No puede eliminar su liquidez o reclamar sus recompensas de esta granja. Para hacer esto, primero debe reclamar su participacin de estas granjas: "
};
var bridge$5 = {
    availableRoutes: "Available Routes ({{ number }})",
    activeTransfers: "Active Transfers ({{ number }})",
    historicalTransfers: "Historical Transfers ({{ number }})",
    bridgeCard: {
        advanceOptions: "Advance Options",
        title: "Cross Chain",
        swap: "Swap",
        loader: {
            labels: {
                waitingReceivingChain: "Waiting for receiving chain..."
            },
            bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
        },
        filter: {
            bridgePrioritization: "Bridge Prioritization",
            slippage: "Slippage",
            infiniteApproval: "Infinite Approval",
            activeInfiniteApproval: "Active Infinite Approval",
            bridges: "Bridges",
            exchanges: "Exchanges"
        }
    },
    bridgeInputsWidget: {
        tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
        max: "MAX"
    },
    bridgeRoute: {
        selected: "Selected",
        clickToSelect: "Click to select",
        singleTransaction: "Single transaction including",
        estimatedToken: "Estimated Token: {{ token }}",
        estimatedResult: "Estimated Result: {{ result }}",
        min: "{{ minute }} min",
        gasCost: "{{ gasCost }} Gas Cost"
    },
    bridgeTransfer: {
        date: "Date",
        from: "From",
        to: "To",
        via: "Via",
        state: "State",
        resumeSwap: "Resume Swap"
    },
    bridgePrioritizations: {
        recommended: "Recommended",
        fast: "Fast",
        normal: "Normal"
    }
};
var dropdown$5 = {
    select: "Select"
};
var esTranslation = {
    header: header$5,
    accountDetails: accountDetails$5,
    addressInputPanel: addressInputPanel$5,
    currencyInputPanel: currencyInputPanel$5,
    earn: earn$5,
    menu: menu$5,
    modalView: modalView$5,
    navigationTabs: navigationTabs$5,
    popups: popups$5,
    positionCard: positionCard$5,
    searchModal: searchModal$5,
    settings: settings$5,
    swap: swap$5,
    toggle: toggle$5,
    tokenWarningModal: tokenWarningModal$5,
    transactionConfirmation: transactionConfirmation$5,
    transactionSettings: transactionSettings$5,
    vote: vote$5,
    walletModal: walletModal$5,
    web3ReactManager: web3ReactManager$5,
    web3Status: web3Status$5,
    gasFeeAlert: gasFeeAlert$5,
    addLiquidity: addLiquidity$5,
    airdrop: airdrop$5,
    earnPage: earnPage$5,
    pool: pool$5,
    poolFinder: poolFinder$5,
    removeLiquidity: removeLiquidity$5,
    swapPage: swapPage$5,
    buyPage: buyPage$5,
    votePage: votePage$5,
    IDOPage: IDOPage$5,
    swapHooks: swapHooks$5,
    mintHooks: mintHooks$5,
    stakeHooks: stakeHooks$5,
    burnHooks: burnHooks$5,
    migratePage: migratePage$5,
    dashboardPage: dashboardPage$5,
    stakePage: stakePage$5,
    error: error$5,
    sarTitle: sarTitle$5,
    sarStake: sarStake$5,
    sarStakeMore: sarStakeMore$5,
    sarUnstake: sarUnstake$5,
    sarCompound: sarCompound$5,
    sarClaim: sarClaim$5,
    sarPortfolio: sarPortfolio$5,
    pangoChef: pangoChef$5,
    bridge: bridge$5,
    dropdown: dropdown$5
};

var header$4 = {
    dashboard: "Dashboard",
    swap: "changer",
    buy: "Acheter",
    pool: "Pool",
    farm: "Farm",
    version1: "Version 1",
    version2: "Version 2",
    stake: "Stake",
    newPng: "Nouveau {{ pngSymbol }}",
    oldPng: "Ancien {{ pngSymbol }}",
    vote: "Vote",
    ido: "IDO",
    charts: "Graphiques",
    forum: "Forum",
    pngBreakDown: "Votre rpartition {{ symbol }}",
    balance: "Balance: ",
    unclaimed: "Non rclam: ",
    pngPrice: "Prix {{ symbol }}",
    pngCirculation: "{{ symbol }} en circulation:",
    totalSupply: "Offre Totale",
    makeSureURLWarning: "Assurez-vous que l'URL est",
    alwaysMakeSureWarning: "Assurez-vous toujours que l'URL est",
    bookmarkIt: "mettez-le en favori pour tre sr.",
    addMetamask: "Ajouter {{ symbol }}  MetaMask",
    bridge: "Pont",
    ourPartners: "Nos partenaires",
    usefulLinks: "LIENS UTILES",
    comeAndJoinUs: "Venez nous rejoindre",
    tryOurNewBetaSite: "Essayez notre nouveau site bta",
    returnToLegacySite: "Retour  l'ancien site",
    switchToNewUI: "Passer  la nouvelle interface utilisateur"
};
var accountDetails$4 = {
    connectedWith: "Connect avec ",
    account: "Compte",
    disconnect: "Dconnexion",
    change: "Changer",
    copy: "Copie de l'adresse",
    viewExplorer: "Voir sur l'explorateur",
    clearAll: "(Effacer tout)",
    transactionAppear: "Vos transactions apparatront ici...",
    recentTransactions: "Transactions rcentes",
    copied: "Copi"
};
var addressInputPanel$4 = {
    recipient: "Bnficiaire",
    viewExplorer: "(Voir sur l'explorateur)",
    walletAddress: "Adresse du portefeuille"
};
var currencyInputPanel$4 = {
    selectToken: "Choisissez un jeton",
    balance: "Balance: ",
    max: "MAX",
    to: "Vers"
};
var earn$4 = {
    claimAccumulated: "Rclamer les rcompenses {{ symbol }} accumules",
    connectWallet: "Connecter le portefeuille",
    enterAmount: "Entrer un montant",
    unclaimedReward: "{{ symbol }} non rclam",
    claim: "Rclamer",
    claimReward: "{{ symbol }} Rclamer",
    liquidityRemainsPool: "Lorsque vous rclamez sans retirer, vos liquidits restent dans la pool de minage.",
    withdrawingLiquidity: "Retirer {{ amount }} {{ symbol }}",
    claimingReward: "Rclamation en cours {{ amount }} {{ symbol }}",
    claimedReward: "{{ symbol }} Rclam!",
    manage: "Grer",
    deposit: "Dpt",
    poolRate: "Taux de la pool",
    currentReward: "Rcompense actuelle",
    pngPerAvax: "{{ symbol }} / Semaine par AVAX",
    rewardPerWeek: "{{ symbol }} / Semaine",
    earnUpTo: "Gagnez jusqu' (par an)",
    yourRate: "Votre taux",
    totalDeposited: "Total dpos",
    totalStaked: "Total stak",
    depositLiquidity: "Liquidit des dpts",
    attemptingToStakeError: "Tentative de staking sans autorisation ni signature. Veuillez contacter le support.",
    transactionSubmitted: "Transaction Soumise",
    depositingLiquidity: "Dpt de liquidits",
    depositingToken: "Dpt de {{ symbol }}",
    depositedToken: "Dpos: {{ symbol }}",
    availableToDeposit: "Disponible pour le dpt: ",
    weeklyRewards: "Rcompenses hebdomadaires",
    missingLiquidityAmount: "montant de liquidit manquant",
    missingDependencies: "dpendances manquantes",
    deposited: "Dpos",
    withdrawDepositedLiquidity: "Retirer les liquidits dposes",
    depositedPglLiquidity: "Liquidit ARL dpose :",
    whenYouWithdrawWarning: "Lorsque vous effectuez un retrait, votre {{ symbol }} est rclam et vos jetons de liquidit Arcanum, ARL, vous sont rendus. Vous ne gagnerez plus de rcompenses en {{ symbol }} sur cette liquidit. Votre jeton de liquidit original restera dans sa pool de liquidit.",
    whenYouWithdrawSingleSideWarning: "Lorsque vous retirez, vos {{ symbol }} sont rclams et vous rcuprez vos {{ pngSymbol }}. Vous ne gagnerez plus de rcompenses en  {{ symbol }} sur ces {{ pngSymbol}}.",
    withdrawAndClaim: "Retirer & rclamer",
    withdrewStakingToken: "{{ symbol }} Retir!",
    approve: "Approuver",
    poolWeight: "Poids de la piscine",
    withdraw: "Retirer",
    extraReward: "Rcompense supplmentaire",
    poolRewards: "Rcompenses de pool",
    rewardsIn: "Rcompenses en",
    removeWarning: "Vous retirez des liquidits de ce pool. Cette action vous rendra vos jetons. Alternativement, vous pouvez choisir de miser vos jetons sur la ferme pour gagner des rcompenses."
};
var menu$4 = {
    code: "Code",
    twitter: "Twitter",
    discord: "Discord",
    telegram: "Telegram",
    tutorials: "Tutoriels",
    idos: "IDOs",
    about: " propos"
};
var modalView$4 = {
    confirmTransaction: "Confirmez cette transaction dans votre portefeuille",
    viewTransaction: "Afficher la transaction sur l'explorateur"
};
var navigationTabs$4 = {
    useThisTool: "Utilisez cet outil pour trouver les paires qui n'apparaissent pas automatiquement dans l'interface.",
    swap: "changer",
    pool: "Pool",
    importPool: "Importer une Pool",
    createPair: "Crer une paire",
    addLiquidity: "Ajouter de la liquidit",
    removeLiquidity: "Supprimer la liquidit",
    whenYouAddLiquidityInfo: "Lorsque vous ajoutez des liquidits, vous recevez des jetons de pool reprsentant votre position. Ces jetons rapportent automatiquement des frais proportionnels  votre part du pool, et peuvent tre changs  tout moment.",
    removingPoolTokensInfo: "En retirant des jetons du pool, votre position est reconvertie en jetons sous-jacents au taux actuel, proportionnellement  votre part du pool. Les frais accumuls sont inclus dans les montants que vous recevez."
};
var popups$4 = {
    tokenListUpdated: "La liste de jetons \" {{oldList}} \" a t mise  jour en ",
    updateAvailable: "Une mise  jour est disponible pour la liste de jetons \" {{oldList}} \"",
    viewExplorer: "Voir sur l'explorateur",
    hash: "Hash: ",
    added: "ajout",
    removed: "supprim",
    tokensUpdated: "jetons mis  jour",
    acceptUpdate: "Accepter la mise  jour",
    dismiss: "Rejeter"
};
var positionCard$4 = {
    add: "Ajouter",
    remove: "Retirer",
    poolShare: "Votre part de la pool:",
    pooled: "Mis en commun",
    poolTokens: "Les jetons de votre pool:",
    manage: "Grer",
    loading: "Chargement",
    yourPosition: "Votre position",
    byAddingLiquidityInfo: "En ajoutant de la liquidit, vous gagnerez 0,25 % de toutes les transactions sur cette paire, proportionnellement  votre part de la pool.\n Les frais sont ajouts au pool, s'accumulent en temps rel et peuvent tre rclams en retirant votre liquidit."
};
var searchModal$4 = {
    commonBases: "Bases communes",
    tokensPairsHelper: "Ces jetons sont gnralement associs  d'autres jetons.",
    addedByUser: "Ajout par l'utilisateur",
    foundByAddress: "Trouv par l'adresse",
    remove: "supprimer",
    add: "Ajouter",
    findToken: "Trouvez un jeton en recherchant son nom ou son symbole ou en collant son adresse ci-dessous.",
    selectToken: "Slectionnez un jeton",
    tokenSearchPlaceholder: "Rechercher le nom ou coller l'adresse",
    tokenName: "Nom du jeton",
    change: "Changer",
    selectList: "Slectionnez une liste",
    confirmListRemovalPrompt: "Veuillez confirmer que vous souhaitez supprimer cette liste en tapant \"supprimer\".",
    addList: "Ajouter une liste ",
    tokenListHelper: "Les listes de jetons sont une spcification ouverte pour les listes de jetons ERC20. Vous pouvez utiliser n'importe quelle liste de jetons en saisissant son URL ci-dessous. Attention, les listes de jetons de tiers peuvent contenir des jetons ERC20 faux ou malveillants.",
    httpsPlaceholder: "https:// ou ipfs://",
    manageLists: "Grer les listes",
    viewList: "Voir la liste",
    updateList: "Mise  jour de la liste",
    removeList: "Supprimer la liste",
    selected: "Slectionn",
    select: "Slectionner",
    manageTokenLists: "Grer les listes de jetons"
};
var settings$4 = {
    areYouSure: "Vous tes sr ?",
    expertInfo: "Le mode expert dsactive l'invite de confirmation de la transaction et autorise les transactions  fort slippage qui entranent souvent de mauvais taux et des pertes de fonds.",
    expertWarningCAPS: "N'UTILISEZ CE MODE QUE SI VOUS SAVEZ CE QUE VOUS FAITES.",
    confirm: "confirmer",
    confirmExpertMode: "Veuillez taper le mot \"confirmer\" pour activer le mode expert.",
    turnOnExpertMode: "Activer le mode expert",
    transactionSettings: "Paramtres de transaction",
    interfaceSettings: "Paramtres de l'interface",
    toggleExpertMode: "Passer en mode expert",
    expertModeHelper: "Contourne les modales de confirmation et permet des transactions  fort slippage.  utiliser  vos risques et prils.",
    toggleDarkMode: "Basculer en mode sombre",
    slippage: "Slippage",
    percent: "Percent"
};
var swap$4 = {
    priceImpact: "Impact du prix",
    priceImpactHelper: "La diffrence entre le prix du march et le prix estim en raison de la taille de la transaction.",
    liquidityProviderFee: "Commission du fournisseur de liquidit",
    liquidityProviderHelper: "Une partie de chaque transaction (0,30 %) est reverse aux fournisseurs de liquidits  titre d'incitation protocolaire.",
    route: "Route",
    routingHelper: "En passant par ces jetons, vous obtenez le meilleur prix pour votre transaction.",
    confirmSwap: "Confirmer l'change",
    swapAnyway: "changer quand mme",
    confirm: "confirmer",
    price: "Prix",
    accept: "Accepter",
    minimumReceived: "Minimum Reu",
    maximumSold: "Maximum vendu",
    transactionRevertHelper: "Votre transaction sera annule si un mouvement de prix important et dfavorable se produit avant sa confirmation.",
    priceUpdated: "Prix actualis",
    outputEstimated: "La quantit produite est estime. Vous recevrez au moins <strong>{{amount}} {{currencySymbol}}</strong> ou la transaction sera annule.",
    inputEstimated: "La quantit produite est estime. Vous vendrez au maximum <strong>{{amount}} {{currencySymbol}}</strong> ou la transaction sera annule.",
    outputSentTo: "La production sera envoye  ",
    priceImpactMinPrompt: "Cet change a un impact sur les prix d'au moins {{ priceImpact }}%. Veuillez taper le mot \"confirmer\" pour poursuivre cet change.",
    priceImpactHighPrompt: "Cet change a un impact sur les prix d'au moins {{ priceImpact }}%. Veuillez confirmer que vous souhaitez poursuivre cet change."
};
var toggle$4 = {
    on: "On",
    off: "Off"
};
var tokenWarningModal$4 = {
    tokenImported: "Jeton import",
    anyoneCanCreateWarning: "N'importe qui peut crer un jeton ERC-20 sur Avalanche avec <em>any</em> nom, y compris crer de fausses versions de jetons existants et des jetons qui prtendent reprsenter des projets qui n'ont pas de jeton.",
    loadArbitraryWarning: "Cette interface peut charger des jetons arbitraires par des adresses de jetons. Veuillez prendre des prcautions supplmentaires et faire des recherches lorsque vous interagissez avec des jetons ERC-20 arbitraires.",
    purchaseArbitraryWarning: "Si vous achetez un jeton arbitraire, <strong>vous ne pourrez peut-tre pas le revendre.</strong>",
    understand: "Je comprends",
    "continue": "Continuer",
    viewExplorer: "Voir sur l'explorateur"
};
var transactionConfirmation$4 = {
    waitingConfirmation: "En attente de confirmation",
    confirmTransaction: "Confirmez cette transaction dans votre portefeuille",
    transactionSubmitted: "Transaction soumise",
    viewExplorer: "Voir sur l'explorateur",
    close: "Fermer",
    error: "Erreur",
    dismiss: "Rejeter",
    addToFarm: "Ajouter  la ferme"
};
var transactionSettings$4 = {
    slippageTolerance: "Tolrance du slippage",
    transactionRevertSlippageHelper: "Votre transaction sera annule si le prix volue dfavorablement par plus que ce pourcentage.",
    transactionDeadline: "Dlai de transaction",
    transactionRevertDeadlineHelper: "Votre transaction sera annule si elle reste en attente plus que le temps imparti.",
    enterValidSlippage: "Entrez un pourcentage de slippage valide",
    transactionMayFail: "Votre transaction peut chouer",
    transactionMayFrontrun: "Votre transaction peut tre devance.",
    transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
    minutes: "minutes"
};
var vote$4 = {
    earnedPng: "Les jetons {{ pngSymbol }} gagns reprsentent des parts de vote dans la gouvernance de Arcanum.",
    canEitherVote: "Vous pouvez soit voter vous-mme sur chaque proposition, soit dlguer vos votes  un tiers.",
    delegateVotes: "Votes dlgus",
    selfDelegate: "Autodlgu",
    remove: "Retirer",
    add: "Ajouter",
    delegate: "Dlgu",
    delegatingVotes: "Dlgation de votes",
    unlockingVotes: "Dverrouillage des votes",
    transactionSubmitted: "Transaction soumise",
    "for": "pour",
    against: "contre",
    vote: "Vote",
    proposal: "proposition",
    votes: "Votes",
    submittingVote: "Soumission du vote",
    confirmTransaction: "Confirmez cette transaction dans votre portefeuille",
    viewExplorer: "Voir sur l'explorateur"
};
var walletModal$4 = {
    wrongNetwork: "Mauvais rseau",
    errorConnecting: "Erreur de connexion",
    pleaseConnectAvalanche: "Veuillez vous connecter au rseau Avalanche appropri.",
    switchAvalanche: "Passer  la chane Avalanche",
    errorConnectingRefresh: "Erreur de connexion. Essayez de rafrachir la page.",
    connectToWallet: "Se connecter  un portefeuille",
    newToAvalanche: "Nouveau sur Avalanche ? ",
    learnMoreWallet: "En savoir plus sur la cration d'un portefeuille",
    initializing: "Initialisation...",
    tryAgain: "Essayez  nouveau"
};
var web3ReactManager$4 = {
    unknownError: "Oups ! Une erreur inconnue s'est produite. Veuillez rafrachir la page ou la visiter  partir d'un autre navigateur ou appareil."
};
var web3Status$4 = {
    pending: "En attente",
    wrongNetwork: "Mauvais rseau",
    error: "Erreur",
    connectToWallet: "Se connecter  un portefeuille"
};
var gasFeeAlert$4 = {
    gasFeeReduction: "!!! Diminution de la taxe sur le gaz !!!",
    transactionsNotAccept: "Les transactions ne seront pas acceptes  moins que les frais de gaz ne soient rgls sur {{ gasPrice }} gwei."
};
var addLiquidity$4 = {
    deposited: "Dpos",
    shareOfPool: "Part de la Pool",
    createPoolSupply: "Crer la Pool & la Rserve",
    confirmSupply: "Confirmer l'approvisionnement",
    giveOrder: "GIVE ORDER",
    outputEstimated: "La quantit produite est estime. Si le prix varie de plus de {{ allowedSlippage }}% votre transaction sera annule.",
    creatingPool: "Vous tes en train de crer une pool",
    willReceive: "Vous recevrez",
    firstLP: "Vous tes le premier fournisseur de liquidits.",
    ratioTokens: "Le ratio de jetons que vous ajoutez dterminera le prix de cette pool.",
    happyRate: "Une fois que vous tes satisfait du taux, cliquez sur l'approvisionnement pour le vrifier.",
    initialPrices: "Prix initiaux",
    prices: "Prix",
    poolShare: "et le partage de la pool",
    connectWallet: "Connecter le Portefeuille",
    approve: "Approuver ",
    supply: "Approvisionner",
    per: " par ",
    rates: "Taux",
    poolTokens: " Jetons de la pool"
};
var airdrop$4 = {
    claimPngAirdrop: "Rclamer {{ pngSymbol }} de l'Airdrop",
    claimPeriodEnded: "La priode de rclamation de l'airdrop est termine.",
    connectWalletViewLiquidity: "Connectez-vous  un portefeuille pour consulter vos liquidits.",
    noAvailableClaim: "Vous n'avez pas de rclamation disponible.",
    noUniNoSushi: "Vous n'avez pas de jetons UNI ou SUSHI. Veuillez suivre le tutoriel ici pour ajouter des jetons UNI ou SUSHI  votre portefeuille.",
    youHave: "Vous avez ",
    pngAvailableClaim: " {{ pngSymbol }} disponible  rclamer",
    loading: "Chargement",
    welcomeToTeamPangolin: "Bienvenue dans l'quipe Arcanum",
    claim: "Rclamer "
};
var earnPage$4 = {
    pangolinLiquidityMining: "Minage de la liquidit de Arcanum",
    pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
    depositPangolinLiquidity: "Dposez vos jetons ARL (Arcanum Liquidity Provider) pour recevoir {{ pngSymbol }}, le jeton de gouvernance du protocole Arcanum.",
    depositPangolinStaking: "Dposez vos {{ pngSymbol }} pour gagner plus de tokens parmi les opportunits prsentes.",
    currentOpportunities: "Opportunits actuelles",
    readMoreAboutPng: "En savoir plus sur {{ pngSymbol }}",
    getInsuranceCoverage: "Obtenez une couverture sur InsurAce.io",
    getCoverNexusMutual: "Obtenez une couverture sur Nexus Mutual",
    importantUpdate: "IMPORTANTE MISE  JOUR",
    pangolinGovernanceProposalResult: "Suite  la proposition de gouvernance 1 de Arcanum, Arcanum change de contrat de staking ! Aprs environ 08:59 UTC le 19 avril, toutes les rcompenses de staking seront distribues aux nouveaux contrats de staking. Avant le changement, toutes les rcompenses seront encore distribues aux anciens contrats. Pour viter toute interruption des rcompenses du yield farming, vous devez retirer vos liquidits des anciens contrats et les remettre dans les nouveaux contrats. Vous n'avez pas besoin de retirer des liquidits de vos pools ou de modifier vos positions.",
    oldPngPools: "Anciennes Pools {{ pngSymbol }}",
    newPngPools: "Nouvelles Pools {{ pngSymbol }}",
    participatingPools: "Pools participantes",
    rewardsNeverEnd: "Les rcompenses ne s'arrtent jamais !",
    noActiveRewards: "Pas de rcompenses actives",
    liquidityMining: "Mining des liquidits",
    pngStaking: "{{ pngSymbol }} Staking",
    totalStaked: "Total Stak",
    poolRate: "Taux de la pool",
    step1: "Etape 1. Obtenez des jetons de liquidit Arcanum (ARL)",
    pglTokenRequired: "Les jetons ARL sont ncessaires. Une fois que vous avez ajout des liquidits  la {{ poolHandle }} pool vous pouvez stake vos jetons de liquidit sur cette page.",
    addPoolLiquidity: "Ajouter {{ poolHandle }} liquidit",
    liquidityDeposits: "Vos dpts de liquidits",
    yourStakedToken: "Votre dpt de {{ symbol }}",
    unclaimedReward: "Vos {{ symbol }} non rclams",
    claim: "Rclamer",
    rewardPerWeek: " {{ symbol }} / semaine",
    automagically: "Lorsque vous vous retirez, le contrat rclame automatiquement le {{ pngSymbol }} en votre nom !",
    deposit: "Dpt",
    depositStakingTokens: "Dposer des jetons {{ symbol }}",
    stake: "Dpt",
    stakeStakingTokens: "Dposez vos tokens {{ symbol }}",
    unstake: "Retrait",
    stakingTokensAvailable: "Jetons {{ symbol }} disponibles",
    getToken: "Obtenir des {{ symbol }}",
    migrateTitle: "Migrez votre ARL empil",
    migrateDescription: "Arcanum a chang de tokenomics. Vous devrez migrer votre ARL empil vers un nouveau contrat",
    migrate: "migrer"
};
var pool$4 = {
    liquidityProviderRewards: "Rmunration du fournisseur de liquidits",
    liquidityProvidersEarn: "Les fournisseurs de liquidits peroivent une commission de 0,25 % sur toutes les transactions, proportionnellement  leur part du pool. Les commissions sont ajoutes au pool, s'accumulent en temps rel et peuvent tre rclames en retirant vos liquidits.",
    readMoreProviding: "En savoir plus sur la fourniture de liquidits",
    viewStakedLiquidity: "Visualisez votre liquidit stak",
    yourLiquidity: "Vos liquidits",
    createPair: "Crer une paire",
    addLiquidity: "Ajouter de la liquidit",
    connectWalletToView: "Connectez-vous  un portefeuille pour voir vos liquidits.",
    loading: "Chargement",
    noLiquidity: "Aucune liquidit trouve.",
    uniswapV1Found: "Liquidit Uniswap V1 trouv !",
    noSeePoolJoined: "Vous ne voyez pas une pool que vous avez rejointe ?",
    migrateNow: "Migrer maintenant.",
    importIt: "Importez-le.",
    seeDetails: "VOIR LES DTAILS",
    totalLockedValue: "Valeur totale verrouille",
    yourLockedValue: "Votre valeur verrouille",
    allFarms: "Toutes les Farms",
    yourFarms: "Voos Farms",
    yourPools: "Vos Pools",
    noFarms: "Aucune ferme trouve.",
    successWithdraw: "Vos liquidits retires de la ferme, et les rcompenses accumules rclames !"
};
var poolFinder$4 = {
    connectToFind: "Se connecter  un portefeuille pour trouver des pools",
    selectTokenToFind: "Slectionnez un jeton pour trouver votre liquidit.",
    selectToken: "Slectionnez un jeton",
    poolFound: "Pool Trouve!",
    managePool: "Grer cette pool.",
    noLiquidityYet: "ous n'avez pas encore de liquidits dans cette pool.",
    noPoolFound: "Aucune pool trouve.",
    addLiquidity: "Ajouter de la liquidit.",
    createPool: "Crer une pool.",
    invalidPair: "Paire non valide.",
    loading: "Chargement"
};
var removeLiquidity$4 = {
    youWillReceive: "Vous recevrez",
    simple: "Simple",
    detailed: "Dtaill",
    receiveAvax: "Recevoir {{ symbol }}",
    receiveWavax: "Recevoir {{ symbol }}",
    price: "Prix:",
    connectWallet: "Connecter le Portefeuille",
    approving: "Approbation",
    approve: "Approuver",
    approved: "Approuv",
    remove: "Retirer",
    output: "Sortie",
    amount: "Montant"
};
var swapPage$4 = {
    addSend: "+ Ajouter un envoi (facultatif)",
    toEstimated: "Vers (estimation)",
    to: "Vers",
    removeSend: "- Supprimer l'envoi",
    price: "Prix",
    slippageTolerance: "Tolrance du slippage",
    connectWallet: "Connecter le Portefeuille",
    insufficientLiquidity: "Liquidit insuffisante pour cette transaction.",
    wrap: "Wrap",
    unwrap: "Unwrap",
    approving: "Approbation",
    approve: "Approuver ",
    approved: "Approuv",
    priceImpactHigh: "Impact du prix lev",
    swap: "changer",
    anyway: " Peu importe",
    from: "De",
    fromEstimated: "De (estimation)",
    velox: "Dfinissez un ordre limit sur <1>Velox</1>",
    marginSwap: "Tradez avec levier sur <1>MarginSwap</1>",
    wowSwap: " ou <1>WOWswap</1>",
    veeFinance: " ou <1>Vee Finance</1>",
    gelatoFee: "Gelato Frais",
    placeOrder: "Passer la commande",
    confirmOrder: "Confirmer la commande",
    "for": "pour",
    submittingOrderToSwap: "Soumission de la commande pour changer",
    limitPrice: "Prix limite",
    outputWillBeSentTo: "La sortie sera envoye ",
    sell: "vendre",
    buy: "acheter",
    betaRelease: "Ceci est une version BETA et doit tre utilis  vos risques et prils !",
    trade: "changer",
    watchList: "Liste de surveillance",
    yourPortFolio: "Votre portefeuille",
    comingSoon: " venir",
    connectWalletViewPortFolio: "Connectez-vous  un portefeuille pour afficher votre portefeuille .",
    limitOrders: "Ordres  cours limit",
    cancelOrder: "annuler la commande",
    all: "TOUTE",
    open: "OUVERTE",
    executed: "RALIS",
    cancelled: "ANNUL",
    inputAmount: "Montant d'entre",
    outputAmount: "Montant de sortie",
    status: "Statut",
    noLimitOrder: "Non {{ orderType }} Commander",
    cancellingOrder: "Annuler la commande...",
    cancelLimitOrder: "Acheter {{ outputCurrency }} avec {{ inputCurrency }}",
    executionPrice: "Prix d'excution",
    seeMore: "Voir plus",
    seeLess: "Voir moins"
};
var buyPage$4 = {
    buyAvaxInfo: "Achetez AVAX avec monnaie fiat chez notre partenaire Wyre.",
    privacyInfo: "Arcanum ne stocke pas votre historique d'achat ni aucune donne personnelle.",
    firstName: "Prnom",
    lastName: "Nom de Famille",
    email: "Email",
    buyAvax: "Achetez AVAX"
};
var votePage$4 = {
    unlockVotes: "Dverrouiller les votes",
    updateDelegation: "Mise  jour de la dlgation",
    pangolinGovernance: "Gouvernance de Arcanum",
    earnedPngTokens: "Les jetons {{ pngSymbol }} reprsentent des actions de vote dans la gouvernance de Arcanum. Vous pouvez voter vous-mme sur chaque proposition ou dlguer vos votes  une tierce partie.",
    eligibleToVote: "Pour pouvoir voter, vous devez dtenir des {{ pngSymbol }} dans votre portefeuille et les dlguer au dbut du vote. Aprs le dbut du vote, vous pouvez mettre en commun ou dpenser vos {{ pngSymbol }}.",
    governanceVotes: "Les votes de gouvernance sont dcids  la majorit simple. Il n'y a pas de seuil de quorum.",
    proposals: "Propositions",
    allProposals: "Toutes les propositions",
    backToProposals: "Retour aux propositions",
    unlockVoting: "Dverrouiller le vote",
    votes: " Votes",
    delegatedTo: "Dlgu :",
    edit: "modifier",
    noProposalsFound: "Aucune proposition trouve.",
    proposalCommunityMembers: "Les propositions soumises par les membres de la communaut apparatront ici.",
    minimumThreshold: "Un seuil minimum de 1 000 000 {{ pngSymbol }} est requis pour soumettre des propositions.",
    votingStarted: "Le vote a commenc ",
    votingStarts: "Le vote commence ",
    votingEnded: "Fin du vote ",
    votingEnds: "Fin du vote ",
    voteFor: "Voter pour",
    voteAgainst: "Voter contre",
    against: "Contre",
    "for": "Pour",
    details: "Dtails",
    overview: "Vue d'ensemble",
    proposer: "Auteur",
    about: "Sur",
    vote: "Voter",
    executed: "Ralis",
    rejected: "Rejet",
    notSupported: "Non pris en charge sur cette chane"
};
var IDOPage$4 = {
    pangolinIDOs: "Initial DEX Offering (IDO)",
    pangolinIDODescription: "Les offres DEX initiales (IDO) permettent aux projets de financer participatif leurs jetons natifs sur des changes dcentraliss. Nous nous sommes associs  des quipes incroyables pour apporter de grands projets  la communaut Avalanche.",
    upcomingIDOs: "A venir",
    endedIDOs: "Termin",
    allIDOs: "Tous les IDO",
    noIDOsFound: "Aucun IDO trouv",
    IDOAnnounced: "Les IDO annoncs publiquement apparatront ici."
};
var swapHooks$4 = {
    connectWallet: "Connecter un Portefeuille",
    enterAmount: "Entrer un montant",
    selectToken: "Selectionner un jeton",
    enterRecipient: "Saisir un destinataire",
    invalidRecipient: "Destinataire non valide",
    insufficient: "Insuffisant ",
    balance: " balance"
};
var mintHooks$4 = {
    connectWallet: "Connecter un Portefeuille",
    insufficientInputAmount: "Quantit d'entre insuffisante",
    invalidPair: "Paire non valide",
    enterAmount: "Entrer un montant",
    insufficient: "Insuffisant ",
    balance: " balance"
};
var stakeHooks$4 = {
    connectWallet: "Connecter un Portefeuille",
    enterAmount: "Entrer un montant"
};
var burnHooks$4 = {
    connectWallet: "Connecter un Portefeuille",
    enterAmount: "Entrer un montant"
};
var migratePage$4 = {
    stake: "PIEU",
    unstake: "DGAGER",
    add: "AJOUTER",
    remove: "SUPPRIMER",
    startMigratingNow: "COMMENCER  MIGRER MAINTENANT",
    startMigratingNowDescription: "Vous trouverez ci-dessous toutes les fermes dont vous aurez besoin pour migrer vers les contrats V2 de Arcanum",
    seeMore: "VOIR PLUS",
    migrateWithEase: "MIGRER FACILEMENT",
    migrateWithDescription: "Nous avons conu un assistant lgant qui vous guidera tout au long du processus de migration de vos fermes.",
    alreadyMigrate: "dj migr",
    walletMigrate: "portefeuille migr",
    alreadyEarned: "dj gagn",
    migrateNow: "MIGRER MAINTENANT",
    learn: "APPRENDRE",
    moveYourTokensToNewContracts: "Migrer vos fermes vers Arcanum V2",
    readyToMigrate: "Prt  migrer",
    apr: "APR:",
    totalValueLocked: "Valeur totale verrouille",
    lowVolatility: "Faible volatilit",
    compoundable: "Compoundable",
    migrate: "migrer",
    migrationModalDescription: "Nous avons ralis que vous avez ces piscines Choisissez-en une ou ajoutez-en une.",
    choosePool: "Choisissez la piscine",
    pool: "Pool",
    availableToDeposit: "Disponible en dpt: ",
    poolInfoDescription: "Maintenant que vous avez choisi votre piscine, laissez-vous en dpareiller.",
    dollarWorth: "Valeur en dollars : ",
    usd: "USD",
    yourRate: "Votre tarif : ",
    unclaimedPng: "{{ pngSymbol }} non rclam : ",
    shareOfPool: "Part du pool : ",
    choose: "CHOISIR",
    selectAll: "Tout slectionner",
    loading: "Chargement",
    back: "Arrire",
    availableToUnstake: "Disponible  dmler: ",
    submittingTransaction: "Soumission de la transaction",
    moveYourTokensToNewContractsDescription: "Dans le cadre du dploiement de Arcanum vers de nouveaux contrats amliors, vous devrez migrer vos fermes. Si vous avez besoin d'aide ou de conseils, veuillez cliquer sur le bouton  Apprendre .",
    migrateModalHeading: "Migration {{ current }} de la {{ total }} ferme"
};
var dashboardPage$4 = {
    dashboard: "Dashboard",
    greetings: "Greetings kind guests! Lets ape in today",
    portfolioValue: "Portfolio Value",
    earned: "Earned",
    coins: "Coins",
    followedWallets: "Followed Wallets",
    earned_dailyIncome: "Daily Income",
    earned_weeklyIncome: "Weekly Income",
    earned_totalEarned: "Total Earned",
    earned_claim: "Claim",
    earned_customizePools: "Customize Pools",
    followed_address: "Address",
    followed_worth: "Worth",
    followed_interact: "Interact"
};
var stakePage$4 = {
    totalStaked: "Total Staked",
    apr: "Annual Percentage Rate",
    seeDetails: "SEE DETAILS",
    stake: "STAKE",
    earn: "Earn {{symbol}}",
    stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$4 = {
    missingCurrencyAmounts: "Montants en devise manquants",
    missingTokens: "Jetons manquants",
    missingDependencies: "Dpendances manquantes",
    missingLiquidityAmount: "Montant de liquidit manquant",
    couldNotWrap: "Impossible d'envelopper",
    attemptingToConfirmApproval: "Tentative de confirmation sans approbation ni signature. Veuillez contacter le support."
};
var sarTitle$4 = {
    addMore: "AJOUTER PLUS",
    unstake: "ANNULER UNE POSITION",
    compound: "RCOMPENSES COMPOSES",
    claim: "RCLAMER DES RCOMPENSES",
    interactingID: "Interagir avec l'ID: {{ id }}"
};
var sarStake$4 = {
    createNewPosition: "Crer un nouveau poste",
    stake: "Pieu",
    staking: "Jalonnement",
    walletBalance: "Dans wallet {{ balance }} {{ symbol }}",
    max: "Max",
    dollarValue: "Valeur en dollars",
    buy: "Acheter {{ symbol }}",
    averageAPR: "TAEG moyen",
    startingApr: "Dmarrage de lAPR",
    weeklyDistributed: "Hebdomadaire {{ symbol }} Distribu",
    confirmDescription: "Une action de mise crera un Nft SAR pour vous. Avec ce NFT, vous pouvez grer votre mise {{ symbol }}.",
    successSubmit: "Vous avez russi  miser votre jeton.",
    yourAprRecalculated: "Votre TAEG sera recalcul.",
    summary: "Rsum",
    pending: "Jalonnement {{ balance }} {{ symbol }}",
    transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore$4 = {
    stakeMore: "En jeu plus",
    choosePosition: "Choisir un poste",
    confirmDescription: "Cela ajoute {{ symbol }}  votre position SAR NFT. Votre solde initial continue  partir du mme APR. L'APR de vos jetons nouvellement ajouts commence  0% et change en fonction de la dure de la mise. Votre NFT affichera la moyenne.",
    newAPR: "Nouveau TAEG",
    add: "Ajouter",
    pending: "Ajout de {{ balance }} {{ symbol }}"
};
var sarUnstake$4 = {
    unstake: "Non prendre",
    unstaking: "Annulation de {{ balance }} {{ symbol }}",
    stakedBalance: "Staked {{ balance }} {{ symbol }}",
    confirmDescription: "Il convient de savoir que le fait de ne pas prendre vos rcompenses fera passer votre TAEG  0% pour ce poste. \nAu lieu de vous dtendre, vous pouvez galement envisager de vendre votre NFT.",
    successSubmit: "Vous avez russi  annuler vos jetons.",
    pending: "Annulation de {{ balance }} {{ symbol }}",
    transactionSummary: "Non pris {{ balance }} {{ symbol }}",
    currentAPR: "APR actuel",
    unstakeWarning: "Lorsque vous vous dsengagez, votre TAEG moyen tombera  0%.",
    aprAfter: "APR aprs lenlvement"
};
var sarCompound$4 = {
    compound: "Compos",
    compounding: "Compoundage",
    successSubmit: "Vous avez russi  aggraver votre position.",
    pending: "Compoundage",
    transactionSummary: "Position compose",
    aprAfter: "APR aprs composition",
    reward: "Rcompenses accumules",
    description: "Veuillez noter que l'accumulation de vos rcompenses peut diminuer votre APR moyen. Les jetons nouvellement miss commencent  partir de 0, tandis que les anciens jetons continueront avec le mme APR. Cela cre la moyenne qui vous est affiche.",
    noRewards: "Aucune rcompense  composer"
};
var sarClaim$4 = {
    claim: "Revendication",
    claiming: "Prtendant",
    description: "En raison de la nature du systme de jalonnement SAR, rclamer vos rcompenses rduira votre TAEG  0. Vous pouvez plutt composer vos rcompenses sans perdre votre APR.",
    successSubmit: "Vous avez rclam vos rcompenses avec succs",
    pending: "Prtendant",
    transactionSummary: "Rcompenses de position rclames",
    aprAfter: "APR aprs rclamation",
    noRewards: "Aucune rcompense  rclamer"
};
var sarPortfolio$4 = {
    noPositions: "Vous navez pas de NFT PANGUARDIAN.\nPERMET DE VOUS EN PROCURER UN",
    start: "COMMENCER",
    positionId: "ID de poste",
    apr: "APR",
    amount: "Quantit",
    newest: "Nouveau",
    oldest: "An",
    sortBy: "Trier par"
};
var pangoChef$4 = {
    claimWarning1: "Lorsque vous rclamez sans retirer votre liquidit reste dans le pool de minage.",
    claimWarning2: "Rclamer vos rcompenses fera tomber votre APR  0.  la place, vous pouvez choisir de composer.",
    compoundWarning: "En combinant vos rcompenses pour la ferme {{ token0 }}-{{ token1 }}, vos rcompenses seront mises en jeu dans la ferme {{ currency }}-{{ png }}. Vous devez ajouter une valeur gale de {{ currency }}token  vos rcompenses {{ png }} accumules.",
    compoundAmountWarning: "Vous devez ajouter {{ amount }} {{ symbol }} au compos.",
    compoundAmountWarning2: "Faites attention que vous verrouillerez votre pool de {{ symbol }} {{ png }} jusqu' ce que vous rclamiez les rcompenses de ce pool.",
    highVolalityWarning: "Trop tt, essayez dans quelques heures",
    compoundSuccess: "Vous avez russi  composer votre ferme.",
    compoundTransactionSummary: "Ferme compose.",
    removeWarning: "En retirant n'importe quel montant de la ferme, vous obtiendrez votre APR  0. Vous pouvez  la place accumuler vos rcompenses sans perdre votre APR.",
    lockingPoolZeroWarning: "Vous ne pouvez pas retirer vos liquidits ou rclamer vos rcompenses de cette ferme. Pour ce faire, vous devez d'abord rclamer votre participation  ces fermes: "
};
var bridge$4 = {
    availableRoutes: "Available Routes ({{ number }})",
    activeTransfers: "Active Transfers ({{ number }})",
    historicalTransfers: "Historical Transfers ({{ number }})",
    bridgeCard: {
        advanceOptions: "Advance Options",
        title: "Cross Chain",
        swap: "Swap",
        loader: {
            labels: {
                waitingReceivingChain: "Waiting for receiving chain..."
            },
            bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
        },
        filter: {
            bridgePrioritization: "Bridge Prioritization",
            slippage: "Slippage",
            infiniteApproval: "Infinite Approval",
            activeInfiniteApproval: "Active Infinite Approval",
            bridges: "Bridges",
            exchanges: "Exchanges"
        }
    },
    bridgeInputsWidget: {
        tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
        max: "MAX"
    },
    bridgeRoute: {
        selected: "Selected",
        clickToSelect: "Click to select",
        singleTransaction: "Single transaction including",
        estimatedToken: "Estimated Token: {{ token }}",
        estimatedResult: "Estimated Result: {{ result }}",
        min: "{{ minute }} min",
        gasCost: "{{ gasCost }} Gas Cost"
    },
    bridgeTransfer: {
        date: "Date",
        from: "From",
        to: "To",
        via: "Via",
        state: "State",
        resumeSwap: "Resume Swap"
    },
    bridgePrioritizations: {
        recommended: "Recommended",
        fast: "Fast",
        normal: "Normal"
    }
};
var dropdown$4 = {
    select: "Select"
};
var frTranslation = {
    header: header$4,
    accountDetails: accountDetails$4,
    addressInputPanel: addressInputPanel$4,
    currencyInputPanel: currencyInputPanel$4,
    earn: earn$4,
    menu: menu$4,
    modalView: modalView$4,
    navigationTabs: navigationTabs$4,
    popups: popups$4,
    positionCard: positionCard$4,
    searchModal: searchModal$4,
    settings: settings$4,
    swap: swap$4,
    toggle: toggle$4,
    tokenWarningModal: tokenWarningModal$4,
    transactionConfirmation: transactionConfirmation$4,
    transactionSettings: transactionSettings$4,
    vote: vote$4,
    walletModal: walletModal$4,
    web3ReactManager: web3ReactManager$4,
    web3Status: web3Status$4,
    gasFeeAlert: gasFeeAlert$4,
    addLiquidity: addLiquidity$4,
    airdrop: airdrop$4,
    earnPage: earnPage$4,
    pool: pool$4,
    poolFinder: poolFinder$4,
    removeLiquidity: removeLiquidity$4,
    swapPage: swapPage$4,
    buyPage: buyPage$4,
    votePage: votePage$4,
    IDOPage: IDOPage$4,
    swapHooks: swapHooks$4,
    mintHooks: mintHooks$4,
    stakeHooks: stakeHooks$4,
    burnHooks: burnHooks$4,
    migratePage: migratePage$4,
    dashboardPage: dashboardPage$4,
    stakePage: stakePage$4,
    error: error$4,
    sarTitle: sarTitle$4,
    sarStake: sarStake$4,
    sarStakeMore: sarStakeMore$4,
    sarUnstake: sarUnstake$4,
    sarCompound: sarCompound$4,
    sarClaim: sarClaim$4,
    sarPortfolio: sarPortfolio$4,
    pangoChef: pangoChef$4,
    bridge: bridge$4,
    dropdown: dropdown$4
};

var header$3 = {
    dashboard: "Dashboard",
    swap: "Swap",
    buy: "Comprar",
    pool: "Pool",
    farm: "Farm",
    version1: "Verso 1",
    version2: "Verso 2",
    stake: "Stake",
    newPng: "Novo {{ pngSymbol }}",
    oldPng: "Antigo {{ pngSymbol }}",
    vote: "Votar",
    ido: "IDO",
    charts: "Grficos",
    forum: "Frum",
    pngBreakDown: "Sua anlise de {{ symbol }}",
    balance: "Saldo: ",
    unclaimed: "No resgatado: ",
    pngPrice: "Preo do {{ symbol }}:",
    pngCirculation: "{{ symbol }} em circulao:",
    totalSupply: "Suprimento total",
    makeSureURLWarning: "Certifique-se que a URL seja",
    alwaysMakeSureWarning: "Certifique-se sempre que a URL seja",
    bookmarkIt: "marque para ser seguro.",
    addMetamask: "Adicionar {{ symbol }} no MetaMask",
    bridge: "Ponte",
    ourPartners: "Nossos Parceiros",
    usefulLinks: "LINKS TEIS",
    comeAndJoinUs: "Junte-se a ns",
    tryOurNewBetaSite: "Experimente nosso novo site beta",
    returnToLegacySite: "Retornar ao site legado",
    switchToNewUI: "Mudar para nova UI"
};
var accountDetails$3 = {
    connectedWith: "Conectado com ",
    account: "Conta",
    disconnect: "Desconectar",
    change: "Trocar",
    copy: "Copiar endereo",
    viewExplorer: "Ver no explorador",
    clearAll: "(limpar tudo)",
    transactionAppear: "Suas transaes aparecero aqui ... ",
    recentTransactions: "Transaes recentes",
    copied: "Copiado"
};
var addressInputPanel$3 = {
    recipient: "Recebedor",
    viewExplorer: "(Ver no explorador)",
    walletAddress: "Endereo da carteira"
};
var currencyInputPanel$3 = {
    selectToken: "Selecione um token",
    balance: "Saldo: ",
    max: "MAX",
    to: "Para"
};
var earn$3 = {
    claimAccumulated: "Resgate {{ symbol }} acumulados",
    connectWallet: "Conectar a uma carteira",
    enterAmount: "Insira um valor",
    unclaimedReward: "{{ symbol }} no resgatado",
    claim: "Reivindicar",
    claimReward: "Reivindicar {{ symbol }}",
    liquidityRemainsPool: "Quando voc resgata sem retirar sua liquidez ela permanece na pool de minerao.",
    withdrawingLiquidity: "Retirado {{ amount }} {{ symbol }}",
    claimingReward: "Reivindicando {{ amount }} {{ symbol }}",
    claimedReward: "{{ symbol }} resgatado!",
    manage: "Gerenciar",
    deposit: "Deposite",
    poolRate: "Ganhos da pool",
    currentReward: "Recompensa atual",
    pngPerAvax: "{{ pngSymbol }} / Semana por AVAX",
    rewardPerWeek: "{{ symbol }} / Semana",
    earnUpTo: "Ganhe at (anual)",
    yourRate: "Sua taxa",
    totalDeposited: "Total depositado",
    totalStaked: "Total depositado",
    depositLiquidity: "Deposite Liquidez",
    attemptingToStakeError: "Tentando depositar sem aprovao ou assinatura. Entre em contato com o suporte.",
    transactionSubmitted: "Transao enviada",
    depositingLiquidity: "Depositando liquidez",
    depositingToken: "Depositing {{ symbol }}",
    depositedToken: "Deposited {{ symbol }}",
    availableToDeposit: "Disponvel para desposito: ",
    weeklyRewards: "Recompensa semanal",
    missingLiquidityAmount: "Quantidade de liquidez ausente",
    missingDependencies: "Dependncias ausentes",
    deposited: "Depositado",
    withdrawDepositedLiquidity: "Retirar a liquidez depositada",
    depositedPglLiquidity: "Deposited ARL liquidity:",
    whenYouWithdrawWarning: "Quando voc retirar, seu {{ symbol }}  resgatado e seus tokens de liquidez do Arcanum, ARL, so devolvidos para voc. Voc no vai mais ganhar recompensas de {{ symbol }} nessa liquidez. Sua liquidez original de token permanecer na sua pool de liquidez.",
    whenYouWithdrawSingleSideWarning: "When you withdraw, your {{ symbol }} is claimed and your {{ pngSymbol }} is returned to you. You will no longer earn {{ symbol }} rewards on this {{ pngSymbol }}.",
    withdrawAndClaim: "Retirar & resgatar",
    withdrewStakingToken: "Retirar {{ symbol }}!",
    approve: "Aprovar",
    poolWeight: "Peso da piscina",
    withdraw: "Retirar",
    poolRewards: "Recompensas de pool",
    rewardsIn: "Recompensas em",
    removeWarning: "Voc est removendo liquidez deste pool. Esta ao devolver seus tokens. Alternativamente, voc pode optar por apostar seus tokens para farmar para ganhar recompensas."
};
var menu$3 = {
    code: "Cdigo",
    twitter: "Twitter",
    discord: "Discord",
    telegram: "Telegram",
    tutorials: "Tutoriais",
    idos: "IDOs",
    about: "Sobre"
};
var modalView$3 = {
    confirmTransaction: "Confirme esta transao em sua carteira",
    viewTransaction: "Ver transao no Explorer"
};
var navigationTabs$3 = {
    useThisTool: "Use esta ferramenta para encontrar pares que no aparecem automaticamente na interface.",
    swap: "Swap",
    pool: "Pool",
    importPool: "Importar Pool",
    createPair: "Criar par",
    addLiquidity: "Adicionar liquidez",
    removeLiquidity: "Remover liquidez",
    whenYouAddLiquidityInfo: "Quando voc adiciona liquidez, voc recebe pool tokens representando sua posio. Esses tokens ganham automaticamente taxas proporcionais  sua parte do pool e podem ser resgatados a qualquer momento.",
    removingPoolTokensInfo: "Remover tokens do pool converte sua posio de volta em tokens subjacentes  taxa atual, proporcional  sua parte do pool. As taxas acumuladas so includas nos valores que voc recebe."
};
var popups$3 = {
    tokenListUpdated: "A lista de tokens \" {{oldList}} \" foi atualizada para ",
    updateAvailable: "Uma atualizao disponvel para lista de tokens \" {{oldList}} \"",
    viewExplorer: "Ver no explorador",
    hash: "Hash: ",
    added: "adicionado",
    removed: "removido",
    tokensUpdated: "tokens atualizados",
    acceptUpdate: "Aceitar atualizao",
    dismiss: "Dispensar"
};
var positionCard$3 = {
    add: "Adicionar",
    remove: "Remover",
    poolShare: "Sua participao na pool:",
    pooled: "Pooled",
    poolTokens: "Tokens da sua pool:",
    manage: "Gerenciar",
    loading: "Carregando",
    yourPosition: "Sua posio",
    byAddingLiquidityInfo: "Ao adicionar liquidez, voc ganhar 0,25% de todas as trocas sobre este par, proporcional  sua parte do pool. \n Taxas so adicionadas ao pool, acumulando em tempo real e podem ser reivindicadas retirando sua liquidez."
};
var searchModal$3 = {
    commonBases: "Bases comuns",
    tokensPairsHelper: "Esses tokens so comumente emparelhados com outros tokens.",
    addedByUser: "Adicionado pelo usuario",
    foundByAddress: "Encontrado pelo endereo",
    remove: "remover",
    add: "Incluir",
    findToken: "Encontre um token procurando por seu nome ou smbolo ou colando seu endereo abaixo.",
    selectToken: "Selecione um token",
    tokenSearchPlaceholder: "Procurar por nome ou cole o endereo",
    tokenName: "Nome do Token",
    change: "Trocar",
    selectList: "Selecione uma lista",
    confirmListRemovalPrompt: "Por favor, confirme que gostaria de remover esta lista digitando: \"remover\"",
    addList: "Adicione uma lista ",
    tokenListHelper: "Listas de token so uma especificao aberta para listas de tokens ERC20. Voc pode usar qualquer lista de token inserindo sua URL abaixo. Cuidado, pois listas de tokens de terceiros podem conter tokens ERC-20 falsos ou maliciosos.",
    httpsPlaceholder: "https:// or ipfs://",
    manageLists: "Gerenciar Listas",
    viewList: "Ver lista",
    updateList: "Atualizar lista",
    removeList: "Remover lista",
    selected: "Selecionado",
    select: "Selecionar",
    manageTokenLists: "Gerenciar Lista de Tokens"
};
var settings$3 = {
    areYouSure: "Voc tem certeza?",
    expertInfo: "O modo expert desliga o prompt de confirmao de transao e permite alta variao de preo que muitas vezes resultam em taxas ruins e perdas.",
    expertWarningCAPS: "USE APENAS ESTE MODO SE VOC SABE O QUE EST FAZENDO",
    confirm: "confirmar",
    confirmExpertMode: "Por favor digite a palavra \"confirmar\" para habilitar o modo expert.",
    turnOnExpertMode: "Ativar modo expert",
    transactionSettings: "Configuraes de transao",
    interfaceSettings: "Configuraes da Interface",
    toggleExpertMode: "Ativar modo expert",
    expertModeHelper: "Ignora os modais de confirmao e permite alta variao de preo. Use por sua conta e risco.",
    toggleDarkMode: "Ativar modo escuro",
    slippage: "Slippage",
    percent: "Percent"
};
var swap$3 = {
    priceImpact: "Impacto no preo",
    priceImpactHelper: "A diferena entre o preo de mercado e o preo estimado devido ao tamanho da troca.",
    liquidityProviderFee: "Taxa para os provedores de liquidez",
    liquidityProviderHelper: "Uma parte de cada troca (0,30%) vai para os provedores de liquidez como um incentivo do protocolo.",
    route: "Rota",
    routingHelper: "A rota atravs desses tokens resultaram no melhor preo para a sua troca",
    confirmSwap: "Confirmar Swap",
    swapAnyway: "Swap de qualquer maneira",
    confirm: "confirmar",
    price: "Preo",
    accept: "Aceitar",
    minimumReceived: "Mnimo recebido ",
    maximumSold: "Mximo vendido",
    transactionRevertHelper: "Sua transao ser revertida se houver um movimento de preo grande e desfavorvel antes de ser confirmada.",
    priceUpdated: "Preo atualizado",
    outputEstimated: "A sada  estimada. Voc receber pelo menos <strong>{{amount}} {{currencySymbol}}</strong> ou a transao ser revertida.",
    inputEstimated: "A entrada  estimada. Voc vai vender no mximo <strong>{{amount}} {{currencySymbol}}</strong> ou a transao ser revertida.",
    outputSentTo: "Sada ser enviada para ",
    priceImpactMinPrompt: "Este swap tem um impacto no preo de pelo menos {{ priceImpact }}%. Por favor, digite a palavra \"confirmar\" para continuar com este swap.",
    priceImpactHighPrompt: "Este swap tem um impacto no preo de pelo menos {{ priceImpact }}%. . Por favor, confirme que voc gostaria de continuar com este swap."
};
var toggle$3 = {
    on: "On",
    off: "Off"
};
var tokenWarningModal$3 = {
    tokenImported: "Token importado",
    anyoneCanCreateWarning: "Qualquer um pode criar um token ERC-20 na Avalanche com <em>qualquer</em> nome, incluindo  a criao de verses falsas de tokens j existentes e tokens que afirmam representar projetos que no tm um token",
    loadArbitraryWarning: "Esta interface pode carregar tokens arbitrrios por meio de endereos de token. Por favor, tome mais cuidado e faa sua pesquisa ao interagir com tokens arbitrrios de ERC-20.",
    purchaseArbitraryWarning: "Se voc comprar um token arbitrrio, <strong>voc pode no conseguir vend-lo de volta.</strong>",
    understand: "Compreendo",
    "continue": "Continuar",
    viewExplorer: "Ver no explorador"
};
var transactionConfirmation$3 = {
    waitingConfirmation: "Esperando por confirmao",
    confirmTransaction: "Confirme esta transao em sua carteira",
    transactionSubmitted: "Transao enviada",
    viewExplorer: "Ver no explorador",
    close: "Fechar",
    error: "Erro",
    dismiss: "Dispensar",
    addToFarm: "Adicionar  Farm"
};
var transactionSettings$3 = {
    slippageTolerance: "Tolerncia de variao de preo",
    transactionRevertSlippageHelper: "Sua transao ser revertida se o preo For alterado de forma desfavorvel acima dessa porcentagem.",
    transactionDeadline: "Prazo mximo da transao",
    transactionRevertDeadlineHelper: "Sua transao ser revertida se ela demorar mais do que isso.",
    enterValidSlippage: "Digite uma porcentagem vlida de variao de preo",
    transactionMayFail: "Sua transao pode falhar",
    transactionMayFrontrun: "Sua transao pode ser suscetvel a frontrun",
    transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
    minutes: "minutos"
};
var vote$3 = {
    earnedPng: "Os tokens {{ pngSymbol }} ganhos representam aes de votao na governana do Arcanum.",
    canEitherVote: "Voc pode votar em cada proposta voc mesmo ou delegar seus votos a um terceiro.",
    delegateVotes: "Delegar votos",
    selfDelegate: "Delegar voc mesmo",
    remove: "Remover",
    add: "Adicionar",
    delegate: "Delegate",
    delegatingVotes: "Delegando votos",
    unlockingVotes: "Desbloquear votos",
    transactionSubmitted: "Transao enviada",
    "for": "a favor",
    against: "contras",
    vote: "Vote",
    proposal: "proposta",
    votes: "Votos",
    submittingVote: "Enviar voto",
    confirmTransaction: "Confirme essa transao na sua carteira",
    viewExplorer: "Ver no explorador"
};
var walletModal$3 = {
    wrongNetwork: "Rede errada",
    errorConnecting: "Erro ao conectar",
    pleaseConnectAvalanche: "Por favor, conecte-se  rede de avalanche apropriada.",
    switchAvalanche: "Mude para Avalanche Chain",
    errorConnectingRefresh: "Erro ao conectar. Tente atualizar a pgina.",
    connectToWallet: "Conectar a uma carteira",
    newToAvalanche: "Novo na Avalanche? ",
    learnMoreWallet: "Saiba mais sobre como configurar uma carteira",
    initializing: "Inicializando...",
    tryAgain: "Tente novamente"
};
var web3ReactManager$3 = {
    unknownError: "Oops! Ocorreu um erro desconhecido. Por favor, atualize a pgina ou visite de outro navegador ou dispositivo."
};
var web3Status$3 = {
    pending: "Pendente",
    wrongNetwork: "Rede errada",
    error: "Erro",
    connectToWallet: "Conectar a uma carteira"
};
var gasFeeAlert$3 = {
    gasFeeReduction: "!!! Reduo na taxa de GAS !!!",
    transactionsNotAccept: "As transaes no sero aceitas, a menos que a taxa de GAS esteja definida como {{ gasPrice }} gwei."
};
var addLiquidity$3 = {
    deposited: "Depositado",
    shareOfPool: "Sua participao",
    createPoolSupply: "Criar Pool & Supply",
    confirmSupply: "Confirmar Supply",
    giveOrder: "GIVE ORDER",
    outputEstimated: "A sada  estimada. Se o preo alterar em mais de {{efetiveslippage}}% sua transao ser revertida.",
    creatingPool: "Voc est criando uma pool",
    willReceive: "Voc receber",
    firstLP: "Voc  o primeiro provedor de liquidez.",
    ratioTokens: "A proporo de tokens que voc adiciona vai definir o preo desta pool.",
    happyRate: "Assim que estiver satisfeito com a proporo, clique em supply para revisar.",
    initialPrices: "Preos inicias",
    prices: "Preos",
    poolShare: "e participao na pool",
    connectWallet: "Conectar a uma carteira",
    approve: "Aprovar ",
    supply: "Supply",
    per: " por ",
    rates: "Proporo",
    poolTokens: " Pool Tokens"
};
var airdrop$3 = {
    claimPngAirdrop: "Resgatar {{ pngSymbol }} do Airdrop",
    claimPeriodEnded: "O perdo de resgate do airdrop acabou.",
    connectWalletViewLiquidity: "Conecte-se a uma carteira para ver sua liquidez.",
    noAvailableClaim: "Voc no tem resgate diponvel.",
    noUniNoSushi: "Voc no tem tokens UNI ou SUSHI, Por favor, siga o tutorial para adicionar os tokens UNI ou SUSHI na sua carteira.",
    youHave: "Voc tem ",
    pngAvailableClaim: " {{ pngSymbol }} disponvel para resgate",
    loading: "Carregando",
    welcomeToTeamPangolin: "Bem vindo  equipe do Arcanum",
    claim: "Resgatar "
};
var earnPage$3 = {
    pangolinLiquidityMining: "Minerao de liquidez do Arcanum",
    pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
    depositPangolinLiquidity: "Deposite seus tokens ARL (Arcanum Liquidity Provider) para receber {{ pngSymbol }}, o token de governana do protocolo Arcanum.",
    depositPangolinStaking: "Deposit and stake your {{ pngSymbol }} tokens to earn more tokens.",
    currentOpportunities: "Current opportunities",
    readMoreAboutPng: "Leia mais sobre {{ pngSymbol }}",
    getInsuranceCoverage: "Obtenha cobertura em InsurAce.io",
    getCoverNexusMutual: "Obtenha cobertura no Nexus Mutual",
    importantUpdate: "ATUALIZAO IMPORTANTE",
    pangolinGovernanceProposalResult: "Como resultado da proposta de governana 1 do Arcanum, O Arcanum est mudando contratos de staking! Aproximadamente cerca de depois de 08:59 UTC no dia 19/4, todas as recompensas de staking sero distribudas para os novos contratos de staking. Antes da mudana, todas as recompensas ainda sero distribudas para os contratos antigos. Para evitar interrupes nas recompensas de yield farming, Voc precisa remover sua liquidez dos contratos antigos e delegar novamente nos novos contratos. Voc no precisa remover liquidez das suas pools ou alterar suas posies.",
    oldPngPools: "Pools antigas de {{ pngSymbol }}",
    newPngPools: "Novas pools de {{ pngSymbol }}",
    participatingPools: "Pools participantes",
    rewardsNeverEnd: "As recompensas nunca terminam!",
    noActiveRewards: "No h recompensas ativas",
    liquidityMining: "Minerao de liquidez",
    pngStaking: "{{ pngSymbol }} Staking",
    totalStaked: "Total depositado",
    poolRate: "Proporo da Pool",
    step1: "Etapa 1. Obtenha Tokens Arcanum Liquidity (ARL)",
    pglTokenRequired: "Tokens ARL so necessrios. Depois de adicionar liquidez na pool {{ poolHandle }}, voc pode colocar seus tokens de liquidez nesta pgina.",
    addPoolLiquidity: "Adicionar liquidez de {{ poolHandle }} ",
    liquidityDeposits: "Suas liquidez despositadas",
    yourStakedToken: "Your staked {{ symbol }}",
    unclaimedReward: "{{ symbol }} no resgatado",
    claim: "Resgate",
    rewardPerWeek: " {{ symbol }} / Semana",
    automagically: "Quando voc retirar, o contrato automagicamente ir resgatar {{ pngSymbol }} em seu nome!",
    deposit: "Deposite",
    depositStakingTokens: "Deposite Tokens {{ symbol }}",
    stake: "Stake",
    stakeStakingTokens: "Stake {{ symbol }} Tokens",
    unstake: "Unstake",
    stakingTokensAvailable: "Tokens {{ symbol }} disponveis",
    getToken: "Get {{ symbol }}",
    migrateTitle: "Migrar seu ARL empilhado",
    migrateDescription: "O Arcanum mudou a tokenmica. Voc precisar migrar seu ARL empilhado para o novo contrato",
    migrate: "Migrar"
};
var pool$3 = {
    liquidityProviderRewards: "Recompensas dos provedores de liquidez",
    liquidityProvidersEarn: "Os provedores de liquidez ganham uma taxa de 0,25% sobre todas as trocas proporcionais a sua parte na pool. As taxas so adicionadas  pool, acumulando em tempo real e podendo ser reivindicadas retirando sua liquidez.",
    readMoreProviding: "Leia mais sobre como fornecer liquidez",
    viewStakedLiquidity: "Veja sua liquidez depositada",
    yourLiquidity: "Sua liquidez",
    createPair: "Criar um par",
    addLiquidity: "Adicionar liquidez",
    connectWalletToView: "Conecte-se a uma carteira para ver sua liquidez.",
    loading: "Carregando",
    noLiquidity: "Nenhuma liquidez encontrada.",
    uniswapV1Found: "Liquidez da Uniswap V1 encontrada!",
    noSeePoolJoined: "No v uma pool da qual participa?",
    migrateNow: "Migre-a.",
    importIt: "Importe-a.",
    seeDetails: "VEJA DETALHES",
    totalLockedValue: "Valor total bloqueado",
    yourLockedValue: "Seu valor bloqueado",
    allFarms: "Todas as farms",
    yourFarms: "Suas farms",
    yourPools: "Suas pools",
    noFarms: "Nenhuma fazenda encontrada.",
    successWithdraw: "Sua liquidez removida da fazenda e recompensas acumuladas reivindicadas!"
};
var poolFinder$3 = {
    connectToFind: "Conecte-se a uma carteira para encontrar suas pools",
    selectTokenToFind: "Selecione um token para econtrar sua liquidez.",
    selectToken: "Selecione um Token",
    poolFound: "Pool encontrada!",
    managePool: "Gerencie esta pool.",
    noLiquidityYet: "Voc no tem liquidez nesta pool ainda.",
    noPoolFound: "Nenhuma pool encontrada.",
    addLiquidity: "Adicionar liquidez.",
    createPool: "Criar pool.",
    invalidPair: "Par invlido.",
    loading: "Carregando"
};
var removeLiquidity$3 = {
    youWillReceive: "Voc ir receber",
    simple: "Simples",
    detailed: "Detalhado",
    receiveAvax: "{{ symbol }} recebido",
    receiveWavax: "{{ symbol }} recebido",
    price: "Preo:",
    connectWallet: "Conectar a uma carteira",
    approving: "Aprovando",
    approve: "Aprovar",
    approved: "Aprovado",
    remove: "Remover",
    output: "Sada",
    amount: "Quantidade"
};
var swapPage$3 = {
    addSend: "+ adicione um envio (opcional)",
    toEstimated: "Para (estimado)",
    to: "Para",
    removeSend: "- Remover envio",
    price: "Preo",
    slippageTolerance: "Tolerncia de variao de preo",
    connectWallet: "Conectar a uma carteira",
    insufficientLiquidity: "Liquidez insufiente para esta troca.",
    wrap: "Wrap",
    unwrap: "Unwrap",
    approving: "Aprovando",
    approve: "Aprovar ",
    approved: "Aprovado",
    priceImpactHigh: "Impacto no preo alto",
    swap: "Fazer Swap",
    anyway: " de qualquer forma",
    from: "De",
    fromEstimated: "De (estimado)",
    velox: "Definir uma ordem de limite no <1>Velox</1>",
    marginSwap: "Negocie com alavancagem no <1>MarginSwap</1>",
    wowSwap: " ou <1>WOWswap</1>",
    veeFinance: " ou <1>Vee Finance</1>",
    gelatoFee: "Gelato Taxa",
    placeOrder: "Faa a encomenda",
    confirmOrder: "Confirmar pedido",
    "for": "por",
    submittingOrderToSwap: "Enviando pedido de troca",
    limitPrice: "Preo Limite",
    outputWillBeSentTo: "A sada ser enviada para",
    sell: "vender",
    buy: "Comprar",
    betaRelease: "Esta  uma verso BETA e deve ser usada por sua prpria conta e risco!",
    trade: "Troca",
    watchList: "WatchList",
    yourPortFolio: "Seu Portflio",
    comingSoon: "Em breve",
    connectWalletViewPortFolio: "Conecte-se a uma carteira para ver seu portflio.",
    limitOrders: "Limite de pedidos",
    cancelOrder: "Cancelar pedido",
    all: "TUDO",
    open: "ABRIR",
    executed: "EXECUTADA",
    cancelled: "CANCELADA",
    inputAmount: "Valor de entrada",
    outputAmount: "Quantidade de sada",
    status: "Status",
    noLimitOrder: "No {{ orderType }} Pedida",
    cancellingOrder: "Cancelando pedido...",
    cancelLimitOrder: "Comprar {{ outputCurrency }} com {{ inputCurrency }}",
    executionPrice: "Preo de execuo",
    seeMore: "Ver mais",
    seeLess: "Ver menos"
};
var buyPage$3 = {
    buyAvaxInfo: "Compre AVAX com moeda fiduciria do nosso parceiro Wyre.",
    privacyInfo: "A Arcanum no armazena seu histrico de compras ou dados pessoais.",
    firstName: "Nome",
    lastName: "Apelido",
    email: "Email",
    buyAvax: "Compre AVAX"
};
var votePage$3 = {
    unlockVotes: "Desbloquear votos",
    updateDelegation: "Atualizar delegao",
    pangolinGovernance: "Governaa do Arcanum",
    earnedPngTokens: "Os tokens {{ pngSymbol }} representam aes de votao na governana do Arcanum. Voc pode votar em cada proposta voc mesmo ou delegar seus votos a um terceiro .",
    eligibleToVote: "Para ser elegvel para votar, voc deve ter {{ pngSymbol }} em sua carteira e deve delegar eles ao incio da votao. Aps o incio da votao, voc pode pode coloc-los em uma pool ou gast-los.",
    governanceVotes: "Votaes de governana so decididas por maioria simples. No h qurum necessrio.",
    proposals: "Propostas",
    allProposals: "Todas as propostas",
    backToProposals: "Voltar para propostas",
    unlockVoting: "Desbloquear votao ",
    votes: " Votos",
    delegatedTo: "Delegar para:",
    edit: "editar",
    noProposalsFound: "Nenhuma proposta encontrada.",
    proposalCommunityMembers: "Propostas submetidas por membros da comunidade iro aparecer aqui.",
    minimumThreshold: "Um mnimo de 1,000,000 {{ pngSymbol }}  requerido para submeter propostas",
    votingStarted: "Votao iniciada ",
    votingStarts: "Votao inicia em ",
    votingEnded: "Votao terminou ",
    votingEnds: "Votao encerra em ",
    voteFor: "Votos a favor",
    voteAgainst: "Votos contras",
    against: "Contra",
    "for": "A favor",
    details: "Detalhes",
    overview: "Viso geral",
    proposer: "Quem fez a proposta",
    about: "Cerca de",
    vote: "Voto",
    executed: "Executado",
    rejected: "Rejeitado",
    notSupported: "No suportado nesta cadeia"
};
var IDOPage$3 = {
    pangolinIDOs: "Initial DEX Offering (IDO)",
    pangolinIDODescription: "As ofertas iniciais de DEX (IDO) permitem que os projetos faam crowdfund de seus tokens nativos em trocas descentralizadas. Fizemos parcerias com equipes incrveis para trazer grandes projetos para a comunidade Avalanche.",
    upcomingIDOs: "Por vir",
    endedIDOs: "Terminado",
    allIDOs: "Todos os IDOs",
    noIDOsFound: "Nenhum IDOs encontrado",
    IDOAnnounced: "IDOs anunciados publicamente aparecero aqui."
};
var swapHooks$3 = {
    connectWallet: "Conectar a uma carteira",
    enterAmount: "Insira um valor",
    selectToken: "Selecione um token",
    enterRecipient: "Digite um destinatrio",
    invalidRecipient: "Destinatrio invlido",
    insufficient: "Saldo de ",
    balance: " insuficiente"
};
var mintHooks$3 = {
    connectWallet: "Conectar a uma carteira",
    insufficientInputAmount: "Quantidade de entrada insuficiente",
    invalidPair: "Par invlido",
    enterAmount: "Insira um valor",
    insufficient: "Saldo de ",
    balance: " insuficiente"
};
var stakeHooks$3 = {
    connectWallet: "Conectar a uma carteira",
    enterAmount: "Insira um valor"
};
var burnHooks$3 = {
    connectWallet: "Conectar a uma carteira",
    enterAmount: "Insira um valor"
};
var migratePage$3 = {
    stake: "ESTACA",
    unstake: "UNSTAKE",
    add: "ADICIONAR",
    remove: "RETIRAR",
    startMigratingNow: "COMECE A MIGRAR AGORA",
    startMigratingNowDescription: "Abaixo voc encontrar todas as Fazendas de que precisar para migrar para os Contratos V2 da Arcanum",
    seeMore: "VER MAIS",
    migrateWithEase: "MIGRAR COM FACILIDADE",
    migrateWithDescription: "Projetamos um assistente elegante, que ajudar a gui-lo durante o processo de migrao de suas fazendas",
    alreadyMigrate: "j migrou",
    walletMigrate: "carteira migrada",
    alreadyEarned: "j ganhou",
    migrateNow: "MIGRAR AGORA",
    learn: "APRENDER",
    moveYourTokensToNewContracts: "Migre suas fazendas para Arcanum V2",
    readyToMigrate: "Pronto para migrar",
    apr: "APR:",
    totalValueLocked: "Valor total bloqueado",
    lowVolatility: "Baixa volatilidade",
    compoundable: "Composta",
    migrate: "Migrar",
    migrationModalDescription: "Percebemos que voc tem essas piscinas ... Escolha uma ou adicione uma.",
    choosePool: "Escolha o Pool",
    pool: "Pool",
    availableToDeposit: "Disponvel para depositar: ",
    poolInfoDescription: "Agora que voc escolheu sua piscina, vamos desamarr-lo dela.",
    dollarWorth: "Valor em dlar: ",
    usd: "USD",
    yourRate: "Sua taxa: ",
    unclaimedPng: "{{ pngSymbol }} no reivindicado: ",
    shareOfPool: "Participao na Pool: ",
    choose: "ESCOLHER",
    selectAll: "Selecionar tudo",
    loading: "Carregando",
    back: "Voltar",
    availableToUnstake: "Disponvel para desestocar: ",
    submittingTransaction: "Enviando transao",
    moveYourTokensToNewContractsDescription: "Como parte da implementao do Arcanum para novos contratos aprimorados, voc precisar migrar suas Fazendas. Se precisar de ajuda ou orientao, clique no boto Aprender.",
    migrateModalHeading: "Migrar {{ current }} de {{ total }} Fazenda"
};
var dashboardPage$3 = {
    dashboard: "Dashboard",
    greetings: "Greetings kind guests! Lets ape in today",
    portfolioValue: "Portfolio Value",
    earned: "Earned",
    coins: "Coins",
    followedWallets: "Followed Wallets",
    earned_dailyIncome: "Daily Income",
    earned_weeklyIncome: "Weekly Income",
    earned_totalEarned: "Total Earned",
    earned_claim: "Claim",
    earned_customizePools: "Customize Pools",
    followed_address: "Address",
    followed_worth: "Worth",
    followed_interact: "Interact"
};
var stakePage$3 = {
    totalStaked: "Total Staked",
    apr: "Annual Percentage Rate",
    seeDetails: "SEE DETAILS",
    stake: "STAKE",
    earn: "Earn {{symbol}}",
    stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$3 = {
    missingCurrencyAmounts: "Valores de moeda ausentes",
    missingTokens: "Tokens ausentes",
    missingDependencies: "Dependncias ausentes",
    missingLiquidityAmount: "Quantidade de liquidez ausente",
    couldNotWrap: "No foi possvel fazer Wrap",
    attemptingToConfirmApproval: "Tentando confirmar sem aprovao ou assinatura. Por favor, contate o suporte."
};
var sarTitle$3 = {
    addMore: "ADICIONAR MAIS",
    unstake: "RETIRAR UMA POSIO",
    compound: "COMPOR RECOMPENSAS",
    claim: "REIVINDICAR RECOMPENSAS",
    interactingID: "Interagindo com o ID: {{ id }}"
};
var sarStake$3 = {
    createNewPosition: "Crie uma nova posio",
    stake: "Stake",
    staking: "Staking",
    walletBalance: "Na wallet {{ balance }} {{ symbol }}",
    max: "MAX",
    dollarValue: "Valor em Dlar",
    buy: "Comprar {{ symbol }}",
    averageAPR: "APR mdio",
    startingApr: "APR comeando em",
    weeklyDistributed: "{{ symbol }} semanal distribudo",
    confirmDescription: "Uma ao de stake criar um SAR Nft para voc. Com esta NFT voc pode gerenciar seu stake de {{ symbol }}.",
    successSubmit: "Voc depositou com sucesso seus tokens.",
    yourAprRecalculated: "Seu APR ser recalculado.",
    summary: "Resumo",
    pending: "Depositando {{ balance }} {{ symbol }}",
    transactionSummary: "Em stake {{ balance }} {{ symbol }}"
};
var sarStakeMore$3 = {
    stakeMore: "Depositar Mais",
    choosePosition: "Escolha uma posio",
    confirmDescription: "Isso adiciona {{ symbol }}  sua posio SAR NFT. Seu saldo original continua a partir da mesmo APR. O APR de seus tokens recm-adicionados comea em 0% e muda com base na durao do stake. Sua NFT mostrar a mdia.",
    newAPR: "Novo APR",
    add: "Adicionar",
    pending: "Adicionando {{ balance }} {{ symbol }}"
};
var sarUnstake$3 = {
    unstake: "Retirar",
    unstaking: "Retirando {{ balance }} {{ symbol }}",
    stakedBalance: "Depositado {{ balance }} {{ symbol }}",
    confirmDescription: "Vale a pena estar ciente de que retirar suas recompensas far com que sua APR seja de 0% para esta posio. \nEm vez de retirar, voc tambm pode considerar vender sua NFT.",
    successSubmit: "Voc retirou seus tokens com sucesso.",
    pending: "Retirando {{ balance }} {{ symbol }}",
    transactionSummary: "Retirado {{ balance }} {{ symbol }}",
    currentAPR: "APR atual",
    unstakeWarning: "Quando voc retira seus tokens, sua mdia de APR cair para 0%.",
    aprAfter: "APR aps a retirada"
};
var sarCompound$3 = {
    compound: "Compor",
    compounding: "Compondo",
    successSubmit: "Voc comps com sucesso sua posio.",
    pending: "Compondo",
    transactionSummary: "Posio composta",
    aprAfter: "APR Aps composio",
    reward: "Recompensas acumuladas",
    description: "Esteja ciente de que a composio de suas recompensas pode diminuir sua TAEG mdia. Os tokens recentemente depositados comeam apartir de 0%, enquanto os tokens antigos continuaro com o mesmo APR. Isso cria a mdia que  exibida para voc",
    noRewards: "Sem recompensas para compor"
};
var sarClaim$3 = {
    claim: "Reivindicar",
    claiming: "Reivindicando",
    description: "Devido  natureza do sistema de stake SAR, reivindicar suas recompensas reduzir sua APR para 0%. Em vez disso, voc pode compor suas recompensas sem perder seu APR.",
    successSubmit: "Voc reivindicou com sucesso suas recompensas",
    pending: "Reivindicando",
    transactionSummary: "Recompensas da posio reivindicadas",
    aprAfter: "APR aps reivindicao",
    noRewards: "No h recompensas para reivindicar"
};
var sarPortfolio$3 = {
    noPositions: "Voc no tem nenhuma NFT PANGUARDIAN.\nVAMOS TER UMA.",
    start: "COMEAR",
    positionId: "ID da posio",
    apr: "APR",
    amount: "Quantidade",
    newest: "Mais recente",
    oldest: "Menos recente",
    sortBy: "Ordernar por"
};
var pangoChef$3 = {
    claimWarning1: "Quando voc reivindica sem retirar sua liquidez permanece no pool de minerao.",
    claimWarning2: "Reivindicar suas recompensas reduzir sua APR para 0. Em vez disso, voc pode optar por compor.",
    compoundWarning: "A composio de suas recompensas para a farm {{ token0 }}-{{ token1 }} far com que suas recompensas sejam apostadas na farm {{ currency }}-{{ png }}. Voc precisa adicionar o valor igual de {{ currency }} token para suas recompensas acumuladas de {{ png }}.",
    compoundAmountWarning: "Voc precisa adicionar {{ amount }} {{ symbol }} para compor.",
    compoundAmountWarning2: "Tenha cuidado para bloquear sua pool de {{ symbol }} {{ png }} at reivindicar as recompensas desta pool.",
    highVolalityWarning: "Muito cedo, tente em algumas horas",
    compoundSuccess: "Voc comps com sucesso.",
    compoundTransactionSummary: "Farm composta.",
    removeWarning: "A remoo de qualquer valor da fazenda far com que seu APR seja 0. Voc pode, em vez disso, compor suas recompensas sem perder seu APR.",
    lockingPoolZeroWarning: "Voc no pode remover sua liquidez ou reivindicar suas recompensas desta farm. Para fazer isso, primeiro voc precisa reivindicar sua participao nestas farms: "
};
var bridge$3 = {
    availableRoutes: "Available Routes ({{ number }})",
    activeTransfers: "Active Transfers ({{ number }})",
    historicalTransfers: "Historical Transfers ({{ number }})",
    bridgeCard: {
        advanceOptions: "Advance Options",
        title: "Cross Chain",
        swap: "Swap",
        loader: {
            labels: {
                waitingReceivingChain: "Waiting for receiving chain..."
            },
            bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
        },
        filter: {
            bridgePrioritization: "Bridge Prioritization",
            slippage: "Slippage",
            infiniteApproval: "Infinite Approval",
            activeInfiniteApproval: "Active Infinite Approval",
            bridges: "Bridges",
            exchanges: "Exchanges"
        }
    },
    bridgeInputsWidget: {
        tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
        max: "MAX"
    },
    bridgeRoute: {
        selected: "Selected",
        clickToSelect: "Click to select",
        singleTransaction: "Single transaction including",
        estimatedToken: "Estimated Token: {{ token }}",
        estimatedResult: "Estimated Result: {{ result }}",
        min: "{{ minute }} min",
        gasCost: "{{ gasCost }} Gas Cost"
    },
    bridgeTransfer: {
        date: "Date",
        from: "From",
        to: "To",
        via: "Via",
        state: "State",
        resumeSwap: "Resume Swap"
    },
    bridgePrioritizations: {
        recommended: "Recommended",
        fast: "Fast",
        normal: "Normal"
    }
};
var dropdown$3 = {
    select: "Select"
};
var ptBrTranslation = {
    header: header$3,
    accountDetails: accountDetails$3,
    addressInputPanel: addressInputPanel$3,
    currencyInputPanel: currencyInputPanel$3,
    earn: earn$3,
    menu: menu$3,
    modalView: modalView$3,
    navigationTabs: navigationTabs$3,
    popups: popups$3,
    positionCard: positionCard$3,
    searchModal: searchModal$3,
    settings: settings$3,
    swap: swap$3,
    toggle: toggle$3,
    tokenWarningModal: tokenWarningModal$3,
    transactionConfirmation: transactionConfirmation$3,
    transactionSettings: transactionSettings$3,
    vote: vote$3,
    walletModal: walletModal$3,
    web3ReactManager: web3ReactManager$3,
    web3Status: web3Status$3,
    gasFeeAlert: gasFeeAlert$3,
    addLiquidity: addLiquidity$3,
    airdrop: airdrop$3,
    earnPage: earnPage$3,
    pool: pool$3,
    poolFinder: poolFinder$3,
    removeLiquidity: removeLiquidity$3,
    swapPage: swapPage$3,
    buyPage: buyPage$3,
    votePage: votePage$3,
    IDOPage: IDOPage$3,
    swapHooks: swapHooks$3,
    mintHooks: mintHooks$3,
    stakeHooks: stakeHooks$3,
    burnHooks: burnHooks$3,
    migratePage: migratePage$3,
    dashboardPage: dashboardPage$3,
    stakePage: stakePage$3,
    error: error$3,
    sarTitle: sarTitle$3,
    sarStake: sarStake$3,
    sarStakeMore: sarStakeMore$3,
    sarUnstake: sarUnstake$3,
    sarCompound: sarCompound$3,
    sarClaim: sarClaim$3,
    sarPortfolio: sarPortfolio$3,
    pangoChef: pangoChef$3,
    bridge: bridge$3,
    dropdown: dropdown$3
};

var header$2 = {
    dashboard: "Panel",
    swap: "Swap Yap",
    buy: "Satn Al",
    pool: "Havuz",
    farm: "Farm",
    version1: "1. Versiyon",
    version2: "2. Versiyon",
    stake: "Stake Et",
    newPng: "Yeni {{ pngSymbol }}",
    oldPng: "Eski {{ pngSymbol }}",
    vote: "Oy Ver",
    ido: "IDO",
    charts: "izelgeler",
    forum: "Forum",
    pngBreakDown: "{{ symbol }} dalmnz",
    balance: "Bakiye: ",
    unclaimed: "Talep edilmemi: ",
    pngPrice: "{{ symbol }} Fiyat:",
    pngCirculation: "Dolaan {{ symbol }} Arz:",
    totalSupply: "Toplam Arz",
    makeSureURLWarning: "URL'nin bu olduundan emin olun:",
    alwaysMakeSureWarning: "Her zaman URL'nin bu olduundan emin olun:",
    bookmarkIt: "gvenliiniz iin yer imlerine ekleyin.",
    addMetamask: "{{ symbol }}'yi MetaMask'e Ekle",
    bridge: "Kpr",
    ourPartners: "Partnerlerimiz",
    usefulLinks: "Faydal Linkler",
    comeAndJoinUs: "Aramza Katl",
    tryOurNewBetaSite: "Yeni beta sitemizi deneyin",
    returnToLegacySite: "Eski arayze dn",
    switchToNewUI: "Yeni beta arayze ge"
};
var accountDetails$2 = {
    connectedWith: "Bal: ",
    account: "Hesap",
    disconnect: "Balanty Kes",
    change: "Deitir",
    copy: "Adresi Kopyala",
    viewExplorer: "Gezginde grntle",
    clearAll: "(hepsini temizle)",
    transactionAppear: "lemleriniz burada grnecektir...",
    recentTransactions: "Son lemler",
    copied: "Kopyaland"
};
var addressInputPanel$2 = {
    recipient: "Alc",
    viewExplorer: "(Gezginde grntle)",
    walletAddress: "Czdan Adresi"
};
var currencyInputPanel$2 = {
    selectToken: "Bir token sein",
    balance: "Bakiye: ",
    max: "Max",
    to: "Hangi tokena"
};
var earn$2 = {
    claimAccumulated: "Birikmi {{ symbol }} dllerini talep et",
    connectWallet: "Czdan Bala",
    enterAmount: "Bir tutar girin",
    unclaimedReward: "Talep edilmemi {{ symbol }}",
    claim: "Talep Et",
    claimReward: "{{ symbol }} dllerini Talep Et",
    liquidityRemainsPool: "dlleri, likiditenizi ekmeden talep ettiinizde saladnz likidite farmda kalr.",
    withdrawingLiquidity: "{{ amount }} {{ symbol }} ekiliyor",
    claimingReward: "{{ amount }} {{ symbol }} Talep Ediliyor",
    claimedReward: "{{ symbol }} talep edildi!",
    manage: "Ynet",
    deposit: "Yatr",
    poolRate: "Havuzun getirisi",
    currentReward: "Mevcut dller",
    pngPerAvax: "{{ pngSymbol }} (AVAX bana, haftalk)",
    rewardPerWeek: "{{ symbol }} (haftalk)",
    earnUpTo: "Yllk u kadara kadar kazann: ",
    yourRate: "Getiriniz",
    totalDeposited: "Toplam yatrlan",
    totalStaked: "Yatrlan toplam",
    depositLiquidity: "Likidite Yatr",
    attemptingToStakeError: "Onay veya imza olmadan likidite salamaya alyorsunuz. Ltfen onay verdikten veya ilemi imzaladktan sonra tekrar deneyin.",
    transactionSubmitted: "lem Gnderildi",
    depositingLiquidity: "Likidite Yatrlyor",
    depositingToken: "{{ symbol }} Yatrlyor",
    depositedToken: "{{ symbol }} Yatrld",
    availableToDeposit: "Yatrmaya msait olan miktar: ",
    weeklyRewards: "Haftalk dller",
    missingLiquidityAmount: "eksik likidite miktar",
    missingDependencies: "eksik deer",
    deposited: "Yatrld",
    withdrawDepositedLiquidity: "Yatrlan likiditeyi ek",
    depositedPglLiquidity: "Yatrlan ARL likiditesi:",
    whenYouWithdrawWarning: "Saladnz likiditeyi ektiinizde ARL tokenlarnz ve kazandnz {{ symbol }}'ler hesabnza gelecektir. ARL tokenlarnn farmdan ekilmesi durumunda ise artk {{ symbol }} kazanamayacaksnz. Asl tokenlarnz ise siz ekene kadar likidite havuzunda kalacaktr.",
    whenYouWithdrawSingleSideWarning: "ekim ilemi yaptnzda {{ symbol }} tokenlar talep edilir ve {{ pngSymbol }} tokenlarnz size iade edilir. Bu, {{ pngSymbol }} staking zerinden artk {{ symbol }} dl kazanamayacaksnz anlamna gelir.",
    withdrawAndClaim: "ek & dlleri Talep Et",
    withdrewStakingToken: "{{ symbol }} ekildi!",
    approve: "Onayla",
    poolWeight: "Havuz Arl",
    withdraw: "ek",
    extraReward: "Ekstra dl",
    poolRewards: "Havuz dlleri",
    rewardsIn: "dller: ",
    removeWarning: "Bu havuzdan likiditeyi kaldryorsunuz. Bu ilem size jetonlarnz geri verecektir. Alternatif olarak, dl kazanmak iin jetonlarnz iftlie yatrmay seebilirsiniz."
};
var menu$2 = {
    code: "Kaynak Kodu",
    twitter: "Twitter",
    discord: "Discord",
    telegram: "Telegram",
    tutorials: "Rehber",
    idos: "IDO",
    about: "Hakkmzda"
};
var modalView$2 = {
    confirmTransaction: "Bu ilemi czdannzda onaylayn",
    viewTransaction: "lemi Explorer'da grntleyin"
};
var navigationTabs$2 = {
    useThisTool: "Otomatik olarak grnmeyen havuzlara erimek iin bu arac kullann.",
    swap: "Swap Yap",
    pool: "Havuz",
    importPool: "Dardan Havuz Ekle",
    createPair: "lem ifti olutur",
    addLiquidity: "Likidite Ekle",
    removeLiquidity: "Likidite kar",
    whenYouAddLiquidityInfo: "Likidite eklediinizde tarafnza pozisyonunuzu temsil eden havuz tokenlar verilir. Bu tokenlar, havuzdaki paynza gre Arcanum zerinde gerekleen ilemlerden komisyon creti kazanr ve istenildii zaman talep edilebilir.",
    removingPoolTokensInfo: "Havuz tokenlarn ekmek istediinizde; pozisyonunuz, havuzdaki paynzla orantl olarak mevcut parite zerinden likidite saladnz tokenlara dntrlr. lemlerden kazandnz komisyon creti, aldnz tutara dahildir."
};
var popups$2 = {
    tokenListUpdated: "\" {{oldList}} \" token listesi gncellendi: ",
    updateAvailable: "Token listesi iin bir gncelleme mevcut: \" {{oldList}} \"",
    viewExplorer: "Gezginde grntle",
    hash: "Hash: ",
    added: "eklendi",
    removed: "karld",
    tokensUpdated: "tokenlar gncellendi",
    acceptUpdate: "Gncellemeyi kabul et",
    dismiss: "Yoksay"
};
var positionCard$2 = {
    add: "Ekle",
    remove: "kar",
    poolShare: "Havuz paynz:",
    pooled: "Havuzda",
    poolTokens: "Havuz tokenlarnz:",
    manage: "Ynet",
    loading: "Ykleniyor",
    yourPosition: "Pozisyonunuz",
    byAddingLiquidityInfo: "Likidite ekleyerek, havuzdaki paynzla orantl olarak bu havuzdaki/iftteki tm ilemlerden %0.25 komisyon creti kazanacaksnz.\n cretler havuza eklenir, gerek zamanl olarak birikir ve likidite havuzdan karldnda talep edilebilir."
};
var searchModal$2 = {
    commonBases: "Ortak bazlar",
    tokensPairsHelper: "Bu tokenlar genellikle dier tokenlarla eletiriliyor.",
    addedByUser: "u kullanc tarafndan eklendi: ",
    foundByAddress: "u adres tarafndan bulundu:",
    remove: "kar",
    add: "Ekle",
    findToken: "Bir token bulmak iin adn/semboln yazn veya adresini yaptrn.",
    selectToken: "Bir token sein",
    tokenSearchPlaceholder: "sme gre arayn veya adresi yaptrn",
    tokenName: "Token Ad",
    change: "Deitir",
    selectList: "Bir liste sein",
    confirmListRemovalPrompt: "Ltfen \"kaldr\" yazarak bu listeyi kaldrmak istediinizi onaylayn",
    addList: "Bir Liste Ekle ",
    tokenListHelper: "Token listesine yeni bir ERC20 token listesi ekleyebilirsiniz. Eklemek istediiniz token listenin URL'sini aaya girerek o listeyi kullanabilirsiniz. nc parti token listelerinin sahte veya kt amal ERC20 tokenlar ierebileceine ltfen dikkat edin.",
    httpsPlaceholder: "https:// veya ipfs://",
    manageLists: "Listeleri ynet",
    viewList: "Listeyi grntle",
    updateList: "Listeyi gncelle",
    removeList: "Listeyi kar",
    selected: "Seildi",
    select: "Se",
    manageTokenLists: "Token Listelerini Ynet"
};
var settings$2 = {
    areYouSure: "Emin misiniz?",
    expertInfo: "Uzman modu, ilem onay aamasn pas gemenize ve yksek slipajl ilemler yapmanza olanak salar.",
    expertWarningCAPS: "BU MODU SADECE NE YAPTIINIZI BLYORSANIZ KULLANIN.",
    confirm: "onayla",
    confirmExpertMode: "Uzman modunu etkinletirmek iin ltfen \"onayla\" yazn.",
    turnOnExpertMode: "Uzman Modunu A",
    transactionSettings: "lem Ayarlar",
    interfaceSettings: "Arayz Ayarlar",
    toggleExpertMode: "Uzman Modu",
    expertModeHelper: "lem onaylar atlar ve yksek slipajl ilemlere izin verir. Kendi sorumluluunuzda kullann.",
    toggleDarkMode: "Karanlk Mod",
    slippage: "Slippage",
    percent: "Percent"
};
var swap$2 = {
    priceImpact: "Fiyat Etkisi",
    priceImpactHelper: "Swap(takas) ileminin byklne bal olarak piyasa fiyat ile tahmini fiyat arasnda oluacak fark.",
    liquidityProviderFee: "Likidite Salayc creti",
    liquidityProviderHelper: "Her swaptan %0.3 orannda komisyon alnr.",
    route: "Rota",
    routingHelper: "leminiz iin en iyi fiyat bu tokenlar araclyla izlenen rota veriyor.",
    confirmSwap: "Takas Onayla",
    swapAnyway: "Yine de Takasla",
    confirm: "onayla",
    price: "Fiyat",
    accept: "Kabul Et",
    minimumReceived: "Minimum Alnacak",
    maximumSold: "Maksimum Satlacak",
    transactionRevertHelper: "leminiz onaylanmadan nce byk ve olumsuz bir fiyat hareketi olmas halinde ileminiz gereklemeyecektir.",
    priceUpdated: "Fiyat Gncellendi",
    outputEstimated: "kt(hasla) yaklaktr. En az u kadar alacaksnz: <strong>{{amount}} {{currencySymbol}}</strong> veya ileminiz gereklemeyecektir.",
    inputEstimated: "Girdi yaklaktr. En fazla u kadar satacaksnz: <strong>{{amount}} {{currencySymbol}}</strong> veya ileminiz gereklemeyecektir.",
    outputSentTo: "kt(hasla) uraya gnderilecektir: ",
    priceImpactMinPrompt: "Bu takas ileminin fiyata etkisi en az %{{ priceImpact }}'dr. Bu ileme devam etmek iin ltfen \"onayla\" yazn.",
    priceImpactHighPrompt: "Bu takas ileminin fiyata etkisi en az %{{ priceImpact }}'dr. Ltfen ileme devam etmek istediinizi onaylayn."
};
var toggle$2 = {
    on: "A",
    off: "Kapat"
};
var tokenWarningModal$2 = {
    tokenImported: "Token dardan eklendi",
    anyoneCanCreateWarning: "Herhangi bir kimse, mevcut tokenlarn sahte versiyonlarn veya bir tokena sahip olmayan projeleri temsil ettiini iddia eden tokenlar oluturmak da buna dahil olmak zere, <em>herhangi bir</em> isimle bir ERC-20 token oluturabilir.",
    loadArbitraryWarning: "Bu arayze adresini bildiiz herhangi bir token eklenebilir. Ltfen dikkatli olun ve rastgele ERC-20 tokenlaryla etkileim kurmadan nce gerekli aratrmay yaptnza emin olun.",
    purchaseArbitraryWarning: "Eer rastgele bir token alrsanz, <strong>geri satamayabilirsiniz.</strong>",
    understand: "Anladm",
    "continue": "Devam et",
    viewExplorer: "Gezginde grntle"
};
var transactionConfirmation$2 = {
    waitingConfirmation: "Onay Bekleniyor",
    confirmTransaction: "Bu ilemi czdannzda onaylayn",
    transactionSubmitted: "lem Gnderildi",
    viewExplorer: "Gezginde grntle",
    close: "Kapat",
    error: "Hata",
    dismiss: "Yoksay",
    addToFarm: "iftlie ekle"
};
var transactionSettings$2 = {
    slippageTolerance: "Slipaj tolerans",
    transactionRevertSlippageHelper: "Fiyatn bu yzdelik deerden daha fazla olumsuz etkilenmesi durumunda ileminiz gereklemeyecektir.",
    transactionDeadline: "lemin geerlilik sresi",
    transactionRevertDeadlineHelper: "leminiz, bu deerden daha uzun sre beklemede kalrsa gereklemeyecektir.",
    enterValidSlippage: "Geerli bir slipaj yzdesi girin",
    transactionMayFail: "leminiz baarsz olabilir",
    transactionMayFrontrun: "leminiz nden koma ile karlaabilir",
    transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
    minutes: "dakika"
};
var vote$2 = {
    earnedPng: "{{ pngSymbol }} tokenlar size Arcanum'in ynetiiminde oy hakk tanr.",
    canEitherVote: "Her nergeye kendiniz oy verebilir veya oylarnz nc bir partiye devredebilirsiniz.",
    delegateVotes: "Oylarnzn Yetkisini Bakasna Verin",
    selfDelegate: "Kendinizi Temsil Edin",
    remove: "kar",
    add: "Ekle",
    delegate: "Yetki Ver",
    delegatingVotes: "Yetki verilmi olan oylar",
    unlockingVotes: "Oylarn Kilidi Kaldrlyor",
    transactionSubmitted: "lem Gnderildi",
    "for": "nergenin lehine(destekliyorum)",
    against: "nergenin alehine(karym)",
    vote: "Oy Ver:",
    proposal: "",
    votes: "Oylar",
    submittingVote: "Oy Gnderiliyor",
    confirmTransaction: "Bu ilemi czdannzda onaylayn",
    viewExplorer: "Gezginde grntle"
};
var walletModal$2 = {
    wrongNetwork: "Yanl A",
    errorConnecting: "Balant hatas",
    pleaseConnectAvalanche: "Ltfen doru Avalanche ana balann.",
    switchAvalanche: "Avalanche Chaine Ge",
    errorConnectingRefresh: "Balant hatas. Sayfay yenilemeyi deneyin.",
    connectToWallet: "Czdan Bala",
    newToAvalanche: "lk kez mi Avalanche kullanyorsunuz?",
    learnMoreWallet: "Czdan oluturma hakknda daha fazla bilgi edinin",
    initializing: "Balatlyor...",
    tryAgain: "Tekrar Deneyin"
};
var web3ReactManager$2 = {
    unknownError: "Beklenmedik bir hata olutu. Ltfen sayfay yenileyin veya baka bir taraycdan/cihazdan tekrar deneyin."
};
var web3Status$2 = {
    pending: "Bekleniyor",
    wrongNetwork: "Yanl A",
    error: "Hata",
    connectToWallet: "Bir Czdan Balayn"
};
var gasFeeAlert$2 = {
    gasFeeReduction: "!!! Dk lem creti !!!",
    transactionsNotAccept: "lem creti {{ gasPrice }} gwei olarak ayarlanmad srece ilemler kabul edilmeyecektir."
};
var addLiquidity$2 = {
    deposited: "Yatrlan",
    shareOfPool: "Havuzun Pay",
    createPoolSupply: "Havuz Olutur & Likidite Sala",
    confirmSupply: "Likiditeyi Onayla",
    giveOrder: "EMIR VER",
    outputEstimated: "kt(hasla) tahminidir. Fiyat, %{{ allowedSlippage }} oranndan daha fazla deiirse ileminiz gereklemeyecektir.",
    creatingPool: "Bir havuz oluturuyorsunuz",
    willReceive: "u kadar elde edeceksiniz:",
    firstLP: "lk likidite salaycs sizsiniz.",
    ratioTokens: "Eklediiniz tokenlarn oran, bu havuzun fiyatn belirleyecektir.",
    happyRate: "Orandan memnun olduunuzda likidite sala tuuna basn.",
    initialPrices: "Balangtaki Fiyatlar",
    prices: "Fiyatlar",
    poolShare: "ve havuz pay",
    connectWallet: "Czdan Bala",
    approve: "Onayla",
    supply: "Likidite Sala",
    per: " bana ",
    rates: "Oranlar",
    poolTokens: " Havuz Tokenlar"
};
var airdrop$2 = {
    claimPngAirdrop: "Airdropdan Gelen {{ pngSymbol }}leri Talep Et",
    claimPeriodEnded: "Airdropu talep etme sresi sonra erdi.",
    connectWalletViewLiquidity: "Likiditenizi grmek iin bir czdan balayn.",
    noAvailableClaim: "Talep edebileceiniz mevcut PNG: 0.",
    noUniNoSushi: "UNI veya SUSHI tokennz mevcut deil. Czdannza UNI veya SUSHI tokenn eklemek iin ltfen buradaki rehberi inceleyin.",
    youHave: "Talep edebileceiniz mevcut PNG: ",
    pngAvailableClaim: "",
    loading: "Ykleniyor",
    welcomeToTeamPangolin: "Arcanum'e hogeldiniz",
    claim: "Talep Et"
};
var earnPage$2 = {
    pangolinLiquidityMining: "Arcanum likidite madencilii",
    pangolinLiquidityStaking: "Likidite salama",
    depositPangolinLiquidity: "Arcanum protokolnn ynetiim token olan {{ pngSymbol }}'yi elde etmek iin Arcanum Likidite Salayc(ARL) tokenlarnz farma yatrn.",
    depositPangolinStaking: "Daha fazla dl kazanmak iin {{ pngSymbol }} tokenlarnz staking havuzuna yatrn.",
    currentOpportunities: "Mevcut Frsatlar",
    readMoreAboutPng: "{{ pngSymbol }} hakknda daha fazla bilgi edinin",
    getInsuranceCoverage: "InsurAce.io zerinden sigorta teminat aln",
    getCoverNexusMutual: "Nexus Mutual zerinden fonlarnz koruma altna aln",
    importantUpdate: "NEML GNCELLEME",
    pangolinGovernanceProposalResult: "Arcanum ynetiiminin 1. nergesinin oylama sonucuna gre: Arcanum, yatrma ilemlerinde kullanlan akll kontratlarn deitirmitir. 19/04/2021 tarihinde saat 08:59dan sonra (UTC saat dilimi), likidite salama karlnda verilen tm dller, yeni kontratlara datlacaktr. Geiten nce ise, tm dller eski kontratlara datlmaya devam edecektir. Yield farming dllerinin kesintiye uramasn nlemek adna likiditenizi eski kontratlardan kaldrmanz ve yeni kontratlara gei salamanz gerekmektedir. Bununla birlikte havuzlardaki likiditenizi ekmenize veya pozisyonlarnz deitirmenize gerek yoktur.",
    oldPngPools: "Eski {{ pngSymbol }} havuzlar",
    newPngPools: "Yeni {{ pngSymbol }} havuzlar",
    participatingPools: "Katlm salanlan havuzlar",
    rewardsNeverEnd: "dller Hi Bitmiyor!",
    noActiveRewards: "Aktif dl yok",
    liquidityMining: "Likidite Madencilii",
    pngStaking: "{{ pngSymbol }} Stake Etme",
    totalStaked: "Yatrlan Toplam",
    poolRate: "Havuzun Getirisi",
    step1: "1. Aama: ARL token(Arcanum'in likidite token) edinin.",
    pglTokenRequired: "ARL token gereklidir. {{ poolHandle }} havuzuna likidite ekledikten sonra bu sayfadan likidite tokenlarnz farma yatrabilirsiniz.",
    addPoolLiquidity: "{{ poolHandle }} havuzuna likidite ekle",
    liquidityDeposits: "Likidite yatrmlarnz",
    yourStakedToken: "Stake edilmi {{ symbol }} tokenlarnz",
    unclaimedReward: "Talep edilmemi {{ symbol }}larnz",
    claim: "Talep Et",
    rewardPerWeek: " {{ symbol }} / hafta",
    automagically: "Havuz zerinde yeni bir ekim veya yatrma ilemi yaptnzda szleme otomatik olarak {{ pngSymbol }}'lerinizi sizin adnza talep edecek ve czdannza yollayacaktr.",
    deposit: "Yatr",
    depositStakingTokens: "{{ symbol }} Token Yatr",
    stake: "Stake Et",
    stakeStakingTokens: "{{ symbol }} tokenlarnz stake edin",
    unstake: "Stakeden kar",
    stakingTokensAvailable: "Kullanlabilir {{ symbol }} token",
    getToken: "{{ symbol }} elde edin",
    migrateTitle: "Yatrm olduunuz ARL'leri tayn",
    migrateDescription: "Arcanum'in tokenomicsi deiti. Bu nedenle nceden yatrm olduunuz ARL'leri yeni szlemeye tamanz gerekiyor.",
    migrate: "Ta"
};
var pool$2 = {
    liquidityProviderRewards: "Likidite salayanlara verilen dller",
    liquidityProvidersEarn: "Likidite salayanlar, havuzdaki paylaryla orantl olarak tm ilemlerden %0.25 komisyon creti kazanr. cretler havuza eklenir, gerek zamanl olarak birikir ve likiditenizi ekerken talep edilebilir.",
    readMoreProviding: "Likidite salama hakknda daha fazla bilgi edinin",
    viewStakedLiquidity: "Saladnz likiditeyi grntleyin",
    yourLiquidity: "Likiditeniz",
    createPair: "Bir ilem ifti olutur",
    addLiquidity: "Likidite ekle",
    connectWalletToView: "Likiditenizi grntlemek iin bir czdan balayn.",
    noLiquidity: "Likidite bulunamad.",
    uniswapV1Found: "Uniswap V1 likiditesi bulundu!",
    noSeePoolJoined: "Likidite saladnz bir havuzu grmyor musunuz?",
    migrateNow: "imdi ta.",
    importIt: "Dardan ekle.",
    seeDetails: "DETAYLARI GR",
    totalLockedValue: "Toplam Kilitli Deer",
    yourLockedValue: "Kilitli Deeriniz",
    allFarms: "Tm iftlikler",
    yourFarms: "senin iftliklerin",
    yourPools: "Havuzlarnz",
    noFarms: "iftlik bulunamad.",
    successWithdraw: "Likiditeniz iftlikten kaldrld ve tahakkuk eden dller talep edildi!"
};
var poolFinder$2 = {
    connectToFind: "Havuzlar bulmak iin bir czdan balayn",
    selectTokenToFind: "Likiditenizi grmek iin bir token sein.",
    selectToken: "Bir Token Sein",
    poolFound: "Havuz Bulundu!",
    managePool: "Havuzu ynet.",
    noLiquidityYet: "Bu havuzda likiditeniz yok.",
    noPoolFound: "Havuz bulunamad.",
    addLiquidity: "Likidite ekle.",
    createPool: "Havuz olutur.",
    invalidPair: "Geersiz ilem ifti.",
    loading: "Ykleniyor"
};
var removeLiquidity$2 = {
    youWillReceive: "u kadar teslim alacaksnz: ",
    simple: "Basit",
    detailed: "Detayl",
    receiveAvax: "{{ symbol }}'lar Teslim Al",
    receiveWavax: "{{ symbol }}'lar Teslim Al",
    price: "Fiyat:",
    connectWallet: "Czdan Bala",
    approving: "Onaylanyor",
    approve: "Onayla",
    approved: "Onayland",
    remove: "kar",
    output: "Hasla",
    amount: "Miktar"
};
var swapPage$2 = {
    addSend: "+ Bir alc ekleyin (opsiyonel)",
    toEstimated: "Hangi tokena (yaklak)",
    to: "Hangi tokena",
    removeSend: "- Alcy sil",
    price: "Fiyat",
    slippageTolerance: "Slipaj Tolerans",
    connectWallet: "Czdan Bala",
    insufficientLiquidity: "Yetersiz bakiye.",
    wrap: "Wraple",
    unwrap: "Unwraple",
    approving: "Onaylanyor",
    approve: "Onayla ",
    approved: "Onayland",
    priceImpactHigh: "Fiyat Etkisi Yksek",
    swap: "Swap Yap",
    anyway: " (Yine de)",
    from: "Hangi tokendan",
    fromEstimated: "Hangi tokendan (yaklak)",
    velox: "<1>Velox</1> zerinden limit emri girin",
    marginSwap: "<1>MarginSwap</1>",
    wowSwap: " veya <1>WOWswap</1> zerinden kaldral ilem yapn",
    veeFinance: " veya <1>Vee Finance</1> zerinden kaldral ilem yapn",
    gelatoFee: "Gelato creti",
    placeOrder: "Limit Emri Olutur",
    confirmOrder: "Limit Emrini Onayla",
    "for": "iin",
    submittingOrderToSwap: "Limit emri oluturuluyor",
    limitPrice: "Emir Fiyat",
    outputWillBeSentTo: "buraya gnderilecek: ",
    sell: "SAT",
    buy: "AL",
    betaRelease: "Bu bir BETA srmdr ve riski size ait olmak zere kullanlmaldr!",
    trade: "Alm-Satm",
    watchList: "zleme Listesi",
    yourPortFolio: "Portfynz",
    comingSoon: "ok yaknda",
    connectWalletViewPortFolio: "Portfynz grntlemek iin czdan balayn.",
    limitOrders: "Limit Emirleri",
    cancelOrder: "Emri iptal et",
    all: "TM",
    open: "AIK",
    executed: "GEREKLET",
    cancelled: "PTAL EDLD",
    inputAmount: "Girdi Miktar",
    outputAmount: "kt Miktar",
    status: "Durum",
    noLimitOrder: "Emir No: {{ orderType }}",
    cancellingOrder: "ilemi iptal ediliyor..",
    cancelLimitOrder: "{{ inputCurrency }} ile {{ outputCurrency }} swap yapma",
    executionPrice: "Emrin Gerekletii Fiyat",
    seeMore: "Daha Fazlasn Gr",
    seeLess: "Daha Azn Gr"
};
var buyPage$2 = {
    buyAvaxInfo: "Partnerimiz Wyre araclyla AVAX satn aln.",
    privacyInfo: "Arcanum, satn alma gemiinizi ya da ahsi bilgilerinizi kaydetmez.",
    firstName: "Ad",
    lastName: "Soyad",
    email: "E-mail",
    buyAvax: "AVAX Satn Al"
};
var votePage$2 = {
    unlockVotes: "Oylarn Kilidini Kaldr",
    updateDelegation: "Delegasyonu(Yetkilerdirme) Gncelle",
    pangolinGovernance: "Arcanum Ynetiimi",
    earnedPngTokens: "{{ pngSymbol }} tokenlar, Arcanum'in ynetiiminde kullanabildiiniz oy hakkn temsil eder. Her nergede kendiniz oy verebilir veya oy haklarnz nc bir partiye devredebilirsiniz.",
    eligibleToVote: "Oy kullanmaya uygun olmak iin czdannzda {{ pngSymbol }} tutmanz ve oylama banda {{ pngSymbol }}'lerinizi yetkilendirmeniz gerekir. Oylama baladktan sonra {{ pngSymbol }}'lerinizi bir farma/havuza yatrabilir veya harcayabilirsiniz.",
    governanceVotes: "Ynetiimin sunduu nergeler, basit ounlukla kararlatrlr. Ulalmas veya geilmesi gereken bir ounluk eii yoktur.",
    proposals: "nergeler",
    allProposals: "Tm nergeler",
    backToProposals: "nergelere Geri Dn",
    unlockVoting: "Oylamann kilidini kaldr",
    votes: " Oylar",
    delegatedTo: "Yetkilendirilen adres:",
    edit: "dzenle",
    noProposalsFound: "nerge bulunamad.",
    proposalCommunityMembers: "Topluluk yeleri tarafndan sunulan nergeler burada grnecektir.",
    minimumThreshold: "nerge sunmak iin gerekli olan minimum eik 1 milyon {{ pngSymbol }}'dir",
    votingStarted: "Oylama balad ",
    votingStarts: "Oylama balyor ",
    votingEnded: "Oylama bitti ",
    votingEnds: "Oylama bitiyor ",
    voteFor: "Lehine(Destekleyen) Oy Ver",
    voteAgainst: "Alehine(Kar) Oy Ver",
    against: "Kar kan",
    "for": "Destekleyen",
    details: "Detaylar",
    overview: "Genel Bak",
    proposer: "nergeyi sunan",
    about: "Hakknda",
    vote: "Oy",
    executed: "Kabul Edildi",
    rejected: "Reddedildi",
    notSupported: "Bu zincirde desteklenmiyor"
};
var IDOPage$2 = {
    pangolinIDOs: "Initial DEX Offering (IDO)",
    pangolinIDODescription: "Projelerin kendi tokenlarn merkeziyetsiz borsalarda kitle fonlamasna IDO(lk DEX Teklifleri) ad verilir. Arcanum de Avalanche ekosisteminde kan ve bu listede yer alan projelerin bazlaryla partner oluyor.",
    upcomingIDOs: "Yaklaan",
    endedIDOs: "Bitti",
    allIDOs: "Tm IDO'lar",
    noIDOsFound: "IDO bulunamad",
    IDOAnnounced: "Aklanan IDO'lar burada grnecektir."
};
var swapHooks$2 = {
    connectWallet: "Czdan Bala",
    enterAmount: "Bir tutar girin",
    selectToken: "Bir token sein",
    enterRecipient: "Bir alc girin",
    invalidRecipient: "Geersiz alc",
    insufficient: "Yetersiz ",
    balance: " bakiyesi"
};
var mintHooks$2 = {
    connectWallet: "Czdan Bala",
    insufficientInputAmount: "Yetersiz bakiye",
    invalidPair: "Geersiz ilem ifti",
    enterAmount: "Bir tutar girin",
    insufficient: "Yetersiz",
    balance: " bakiyesi"
};
var stakeHooks$2 = {
    connectWallet: "Czdan Bala",
    enterAmount: "Bir tutar girin"
};
var burnHooks$2 = {
    connectWallet: "Czdan Bala",
    enterAmount: "Bir tutar girin"
};
var migratePage$2 = {
    stake: "STAKE ET",
    unstake: "STAKE ETMEY DURDUR",
    add: "EKLE",
    remove: "IKAR",
    startMigratingNow: "MD TAIMAYA BALA",
    startMigratingNowDescription: "Aada Arcanum'in V2 akll kontratlarna gei salamas gereken tm farmlar grebilirsiniz.",
    seeMore: "DAHA FAZLASINI GR",
    migrateWithEase: "KOLAYLIKLA TAIYIN",
    migrateWithDescription: "Farmlarnz tama srecinde size rehberlik edecek bir sihirbaz tasarladk.",
    alreadyMigrate: "zaten tand",
    walletMigrate: "czdan tand",
    alreadyEarned: "zaten kazanld",
    migrateNow: "MD TAI",
    learn: "REN",
    moveYourTokensToNewContracts: "Farmlarnz Arcanum V2'ye Tayn",
    readyToMigrate: "Tamaya hazr",
    apr: "APR(Yllk Getiri Oran):",
    totalValueLocked: "Toplam Kilitli Deer",
    lowVolatility: "Dk Volatilite",
    compoundable: "birletirilebilir",
    migrate: "Ta",
    migrationModalDescription: "Tamak istediiniz havuzlar sein",
    choosePool: "Havuz Se",
    pool: "Havuz",
    availableToDeposit: "Yatrmaya msait olan miktar: ",
    poolInfoDescription: "Tamak istediiniz miktar girin",
    dollarWorth: "Dolar Karl: ",
    usd: "USD",
    yourRate: "Getiriniz: ",
    unclaimedPng: "Talep Edilmemi {{ pngSymbol }}: ",
    shareOfPool: "Havuz Pay: ",
    choose: "SE",
    selectAll: "Hepsini se",
    loading: "Ykleniyor",
    back: "Geri",
    availableToUnstake: "Stake etmeyi durdurmaya msait olan miktar: ",
    submittingTransaction: "lem gnderiliyor",
    moveYourTokensToNewContractsDescription: "Arcanum'in yeni gelitirilmi olduu kontratlara geiin bir paras olarak, farmlarnz tamanz gerekiyor. Herhangi bir konuda yardma ihtiyacnz varsa, ltfen ren tuuna tklayn.",
    migrateModalHeading: "{{ total }} farmlar iinden {{ current }}' ta"
};
var dashboardPage$2 = {
    dashboard: "Panel",
    greetings: "Arcanum'e Hogeldiniz.",
    portfolioValue: "Portfolyonuzun Deeri",
    earned: "Kazanlan",
    coins: "Coinler",
    followedWallets: "Takip Edilen Czdanlar",
    earned_dailyIncome: "Gnlk Getiri",
    earned_weeklyIncome: "Haftalk Getiri",
    earned_totalEarned: "Toplam Kazanlan",
    earned_claim: "Talep Et",
    earned_customizePools: "Havuzlar zelletir",
    followed_address: "Adres",
    followed_worth: "Deer",
    followed_interact: "ncele"
};
var stakePage$2 = {
    totalStaked: "Toplam Stake Edilen Miktar",
    apr: "APR(Yllk Getiri Oran)",
    seeDetails: "DETAYLARI GR",
    stake: "STAKE ET",
    earn: "{{symbol}} Kazan",
    stakeAndEarn: "{{ pngSymbol }}'lerinizi stake edin ve dller kazann!"
};
var error$2 = {
    missingCurrencyAmounts: "Eksik para birimi tutarlar",
    missingTokens: "Eksik jetonlar",
    missingDependencies: "Eksik bamllklar",
    missingLiquidityAmount: "Eksik likidite tutar",
    couldNotWrap: "Kaydrlamad",
    attemptingToConfirmApproval: "Onay veya imza olmadan onaylamaya allyor. Ltfen destek ile iletiime gein."
};
var sarTitle$2 = {
    addMore: "DAHA EKLE",
    unstake: "BR POZSYONU KALDIR",
    compound: "BLEK DLLER",
    claim: "DL TALEB",
    interactingID: "Kimlik ile etkileim: {{ id }}"
};
var sarStake$2 = {
    createNewPosition: "Yeni bir pozisyon oluturma",
    stake: "Kazk",
    staking: "Staking",
    walletBalance: "Czdan'da {{ balance }} {{ symbol }}",
    max: "Max",
    dollarValue: "Dolar Deeri",
    buy: "{{ symbol }} satn aln",
    averageAPR: "Ortalama APR",
    startingApr: "APR'nin Balatlmas",
    weeklyDistributed: "Haftalk {{ symbol }} Datld",
    confirmDescription: "Bir bahis eylemi sizin iin bir SAR Nft yaratacaktr. Bu NFT ile {{ symbol }} paynz ynetebilirsiniz.",
    successSubmit: "Jetonunuzu baaryla yatrdnz.",
    yourAprRecalculated: "APR'niz yeniden hesaplanr.",
    summary: "zet",
    pending: "Staking {{ balance }} {{ symbol }}",
    transactionSummary: "Stake edilmi {{ balance }} {{ symbol }}"
};
var sarStakeMore$2 = {
    stakeMore: "Bahis Tutar Daha Fazla",
    choosePosition: "Bir Pozisyon Sein",
    confirmDescription: "Bu, SAR NFT pozisyonunuza {{ symbol }} ekler. Orijinal bakiyeniz ayn Nisan'dan itibaren devam eder. Yeni eklenen jetonlarnzn APR'si %0'dan balar ve bahis miktarna gre deiir. NFT'niz ortalamay gsterecektir.",
    newAPR: "Yeni APR",
    add: "Eklemek",
    pending: "{{ balance }} {{ symbol }} ekleme"
};
var sarUnstake$2 = {
    unstake: "Bahis D",
    unstaking: "Unstaking {{ balance }} {{ symbol }}",
    stakedBalance: "Stake edilmi {{ balance }} {{ symbol }}",
    confirmDescription: "dllerinizi geri almann APR'nizi bu pozisyon iin% 0'a karacann farknda olmaya deer. \nRiskten kurtulmak yerine NFT'nizi satmay da dnebilirsiniz.",
    successSubmit: "Jetonlarnz baaryla kaldrdnz.",
    pending: "Unstaking {{ balance }} {{ symbol }}",
    transactionSummary: "Yatrlmam {{ balance }} {{ symbol }}",
    currentAPR: "Mevcut APR",
    unstakeWarning: "Bahsi kaldrdnzda, ortalama APR'niz% 0'a decektir.",
    aprAfter: "Bahis Sonras APR"
};
var sarCompound$2 = {
    compound: "Bileik",
    compounding: "Bileik",
    successSubmit: "Pozisyonunuzu baaryla birletirdiniz.",
    pending: "Bileik",
    transactionSummary: "Bileik pozisyon",
    aprAfter: "Bileikten Sonra Nisan",
    reward: "Tahakkuk eden dller",
    description: "Ltfen dllerinizi birletirmenin ortalama APR'nizi azaltabileceini unutmayn. Yeni stake edilen jetonlar 0'dan balar, eski jetonlar ayn APR ile devam eder. Bu, size gsterilen ortalamay oluturur.",
    noRewards: "Bestelenecek dl yok"
};
var sarClaim$2 = {
    claim: "ddia etmek",
    claiming: "Iddia",
    description: "SAR staking sisteminin doas gerei dllerinizi talep etmek APR'nizi 0'a drecektir. Bunun yerine APR'nizi kaybetmeden dllerinizi birletirebilirsiniz.",
    successSubmit: "dllerinizi baaryla aldnz",
    pending: "Iddia",
    transactionSummary: "Talep edilen pozisyon dlleri",
    aprAfter: "Talep Sonras APR",
    noRewards: "Talep edilecek dl yok"
};
var sarPortfolio$2 = {
    noPositions: "Herhangi bir PANGUARDIAN NFT'niz yok.\nSZE BR TANE ALABLR",
    start: "BALAMAK",
    positionId: "Konum Kimlii",
    apr: "Nisan",
    amount: "Miktar",
    newest: "Yeni",
    oldest: "Eski",
    sortBy: "Sralama lt"
};
var pangoChef$2 = {
    claimWarning1: "Likiditenizi ekmeden talep ettiinizde madencilik havuzunda kalr.",
    claimWarning2: "dllerinizi talep etmek, APR'nizi 0'a drr. Bunun yerine birletirmeyi seebilirsiniz.",
    compoundWarning: "{{ token0 }}-{{ token1 }} iftlii iin dllerinizi birletirmek, dllerinizi {{ para birimi }}-{{ png }} iftliine yatrr. {{ currency }} 'a eit deer eklemeniz gerekir. jeton, tahakkuk eden {{ png }} dllerinize.",
    compoundAmountWarning: "Bileik iin {{ amount }} {{ symbol }} eklemeniz gerekiyor.",
    compoundAmountWarning2: "Bu havuzun dllerini alana kadar {{ symbol }} {{ png }} havuzunuzu kilitleyeceinize dikkat edin.",
    highVolalityWarning: "ok erken, birka saat sonra deneyin",
    compoundSuccess: "iftliinizi baaryla oluturdunuz.",
    compoundTransactionSummary: "Birleik iftlik.",
    removeWarning: "iftlikten herhangi bir miktar karmak, APR'nizi 0'a getirecektir. Bunun yerine dllerinizi, APR'nizi kaybetmeden birletirebilirsiniz.",
    lockingPoolZeroWarning: "Bu iftlikten likiditenizi kaldramaz veya dllerinizi talep edemezsiniz. Bunu yapmak iin nce bu iftliklerden hissenizi talep etmeniz gerekir: "
};
var bridge$2 = {
    availableRoutes: "Mevcut Rotalar ({{ number }})",
    activeTransfers: "Aktif Transferler ({{ number }})",
    historicalTransfers: "Gemi Transferler ({{ number }})",
    bridgeCard: {
        advanceOptions: "Gelimi Seenekler",
        title: "Cross Chain",
        swap: "Swap",
        loader: {
            labels: {
                waitingReceivingChain: "Waiting for receiving chain..."
            },
            bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
        },
        filter: {
            bridgePrioritization: "Bridge Prioritization",
            slippage: "Slippage",
            infiniteApproval: "Infinite Approval",
            activeInfiniteApproval: "Active Infinite Approval",
            bridges: "Bridges",
            exchanges: "Exchanges"
        }
    },
    bridgeInputsWidget: {
        tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
        max: "MAX"
    },
    bridgeRoute: {
        selected: "Seildi",
        clickToSelect: "Semek iin tkla",
        singleTransaction: "Single transaction including",
        estimatedToken: "Tahmini Token: {{ token }}",
        estimatedResult: "Tahmini Result: {{ result }}",
        min: "{{ minute }} dk",
        gasCost: "{{ gasCost }} Gas Cost"
    },
    bridgeTransfer: {
        date: "Tarih",
        from: "From",
        to: "To",
        via: "zerinden",
        state: "State",
        resumeSwap: "Resume Swap"
    },
    bridgePrioritizations: {
        recommended: "nerilen",
        fast: "Hzl",
        normal: "Normal"
    }
};
var dropdown$2 = {
    select: "Se"
};
var trTranslation = {
    header: header$2,
    accountDetails: accountDetails$2,
    addressInputPanel: addressInputPanel$2,
    currencyInputPanel: currencyInputPanel$2,
    earn: earn$2,
    menu: menu$2,
    modalView: modalView$2,
    navigationTabs: navigationTabs$2,
    popups: popups$2,
    positionCard: positionCard$2,
    searchModal: searchModal$2,
    settings: settings$2,
    swap: swap$2,
    toggle: toggle$2,
    tokenWarningModal: tokenWarningModal$2,
    transactionConfirmation: transactionConfirmation$2,
    transactionSettings: transactionSettings$2,
    vote: vote$2,
    walletModal: walletModal$2,
    web3ReactManager: web3ReactManager$2,
    web3Status: web3Status$2,
    gasFeeAlert: gasFeeAlert$2,
    addLiquidity: addLiquidity$2,
    airdrop: airdrop$2,
    earnPage: earnPage$2,
    pool: pool$2,
    poolFinder: poolFinder$2,
    removeLiquidity: removeLiquidity$2,
    swapPage: swapPage$2,
    buyPage: buyPage$2,
    votePage: votePage$2,
    IDOPage: IDOPage$2,
    swapHooks: swapHooks$2,
    mintHooks: mintHooks$2,
    stakeHooks: stakeHooks$2,
    burnHooks: burnHooks$2,
    migratePage: migratePage$2,
    dashboardPage: dashboardPage$2,
    stakePage: stakePage$2,
    error: error$2,
    sarTitle: sarTitle$2,
    sarStake: sarStake$2,
    sarStakeMore: sarStakeMore$2,
    sarUnstake: sarUnstake$2,
    sarCompound: sarCompound$2,
    sarClaim: sarClaim$2,
    sarPortfolio: sarPortfolio$2,
    pangoChef: pangoChef$2,
    bridge: bridge$2,
    dropdown: dropdown$2
};

var header$1 = {
    dashboard: "Dashboard",
    swap: "Hon i",
    buy: "Mua",
    pool: "B",
    farm: "Farm",
    version1: "Phin bn 1",
    version2: "Phin bn 2",
    stake: "Stake",
    newPng: "{{ pngSymbol }} mi",
    oldPng: "{{ pngSymbol }} c",
    vote: "Bnh chn",
    ido: "IDO",
    charts: "Bng",
    forum: "Din n",
    pngBreakDown: "{{ symbol }} ca bn gp s c",
    balance: "S d: ",
    unclaimed: "Cha c nhn: ",
    pngPrice: "Gi {{ symbol }}:",
    pngCirculation: "Tng {{ symbol }} ang lu thng:",
    totalSupply: "Tng cung",
    makeSureURLWarning: "m bo rng URL l:",
    alwaysMakeSureWarning: "Lun m bo rng URL l:",
    bookmarkIt: "nh du n  an ton.",
    addMetamask: "Thm {{ symbol }} vo MetaMask",
    bridge: "Cu",
    ourPartners: "Nhng cng s ca chng ta",
    usefulLinks: "LIN KT HU CH",
    comeAndJoinUs: "Hy n v tham gia cng chng ti",
    tryOurNewBetaSite: "Hy th trang web beta mi ca chng ti",
    returnToLegacySite: "Quay li trang web c",
    switchToNewUI: "Chuyn sang giao din ngi dng mi"
};
var accountDetails$1 = {
    connectedWith: "Kt ni vi",
    account: "Ti khon",
    disconnect: "Mt kt ni",
    change: "Thay i",
    copy: "Sao chp a ch",
    viewExplorer: "Xem trn explorer",
    clearAll: "(xa tt c)",
    transactionAppear: "Cc giao dch ca bn s xut hin ti y ...",
    recentTransactions: "Cc giao dch gn y",
    copied: "Sao chp"
};
var addressInputPanel$1 = {
    recipient: "Ngi nhn",
    viewExplorer: "(Xem trn explorer)",
    walletAddress: "a ch v"
};
var currencyInputPanel$1 = {
    selectToken: "Chn token",
    balance: "S d: ",
    max: "MAX",
    to: "Ti"
};
var earn$1 = {
    claimAccumulated: "Yu cu phn thng {{symbol}} tch ly c",
    connectWallet: "Kt ni v",
    enterAmount: "Nhp s lng",
    unclaimedReward: " Phn thng cha c nhn{{ symbol }}",
    claim: "nhn",
    claimReward: "{{ symbol }} Nhn phn thng",
    liquidityRemainsPool: "Nu bn yu cu khon thanh khon ca mnh m khng rt tin, tin ca bn s vn  trong b khai thc.",
    withdrawingLiquidity: "Rt {{ amount }} {{ symbol }}",
    claimingReward: "ang nhn phn thng {{ amount }} {{ symbol }}",
    claimedReward: "{{ symbol }}  nhn!",
    manage: "Qun l",
    deposit: "Gi",
    poolRate: "T sut b",
    currentReward: "Phn thng hin ti",
    pngPerAvax: "{{ pngSymbol }}/tun trn mi AVAX",
    rewardPerWeek: "{{ symbol }} / Tun",
    earnUpTo: "Li nhun hng nm ln n",
    yourRate: "T l ca bn",
    totalDeposited: "Tng gi tr  gi",
    totalStaked: "Tng s gi tr  t c phn",
    depositLiquidity: "K gi thanh khon",
    attemptingToStakeError: "ang c gng t c phn m khng c s chp thun hoc ch k. Xin vui lng lin h b phn h tr",
    transactionSubmitted: "Giao dch  c gi",
    depositingLiquidity: "ang gi thanh khon",
    depositingToken: "ang gi {{ symbol }}",
    depositedToken: " gi{{ symbol }}",
    availableToDeposit: "Kh dng  gi: ",
    weeklyRewards: "Phn thng hng tun",
    missingLiquidityAmount: "S lng thanh khon b mt",
    missingDependencies: "Mt ph thuc",
    deposited: " gi",
    withdrawDepositedLiquidity: "Rt thanh khon  gi",
    depositedPglLiquidity: "Thanh khon ARL  gi:",
    whenYouWithdrawWarning: "Khi bn rt tin, s phn thng {{ symbol }} c nhn v m thng bo Arcanum Liquidity ca bn, ARL, c tr li cho bn. Bn s khng c thng thm {{ symbol }} trn m thanh khon ny na. S token thanh khon ban u vn cn li trong b",
    whenYouWithdrawSingleSideWarning: "Khi bn rt tin, {{symbol}} ca bn s c nhn v {{ pngSymbol }} ca bn s c tr li. Bn s khng cn kim c phn thng {{Symbol}} trn token {{ pngSymbol }} ny na.",
    withdrawAndClaim: "Rt v nhn",
    withdrewStakingToken: " rt!{{ symbol }}",
    approve: "Chp nhn",
    poolWeight: "Khi lng b",
    withdraw: "Rt",
    extraReward: "Phn thng b sung",
    poolRewards: "Phn thng h bi",
    rewardsIn: "Phn thng trong",
    removeWarning: "Bn ang xa thanh khon khi nhm ny. Hnh ng ny s tr li cho bn cc m thng bo ca bn. Ngoi ra, bn c th chn t cc m thng bo ca mnh vo trang tri  kim phn thng."
};
var menu$1 = {
    code: "M",
    twitter: "Twitter",
    discord: "Discord",
    telegram: "Telegram",
    tutorials: "Hng dn",
    idos: "IDOs",
    about: "Thng tin v chng ti"
};
var modalView$1 = {
    confirmTransaction: "Xc nhn giao dch ny trong v ca bn",
    viewTransaction: "Xem giao dch trn Explorer"
};
var navigationTabs$1 = {
    useThisTool: "S dng cng c ny  tm cc cp khng t ng xut hin trong giao din.",
    swap: "Hon i",
    pool: "B",
    importPool: "Nhp b",
    createPair: "To cp",
    addLiquidity: "Thm thanh khon",
    removeLiquidity: "Loi b thanh khon",
    whenYouAddLiquidityInfo: "Khi bn thm thanh khon, bn s nhn c m token chung i din cho c phn ca bn trong b. Cc m token ny s c t ng phn phi phn thng da vo c phn ca bn trong b. Bn c th i m token ca mnh trong b bt c lc no!",
    removingPoolTokensInfo: "Vic xa m token chung s chuyn i v tr ca bn tr li thnh cc m token c bn vi t l hin ti, t l thun vi th phn ca bn trong nhm. Ph tch ly c bao gm trong s tin bn nhn c."
};
var popups$1 = {
    tokenListUpdated: "Danh sch m token \" {{oldList}} \"  c cp nht n ",
    updateAvailable: "Bn cp nht kh dng cho danh sch token\" {{oldList}} \"",
    viewExplorer: "Xem trn explorer",
    hash: "Bm:",
    added: "thm",
    removed: "loi b",
    tokensUpdated: "Cc token  cp nht",
    acceptUpdate: "Chp nhn cp nht",
    dismiss: "B qua"
};
var positionCard$1 = {
    add: "Thm",
    remove: "Loi b",
    poolShare: "C phn ca bn trong b:",
    pooled: "Chung vn",
    poolTokens: "Token b ca bn:",
    manage: "Qun l",
    loading: "ang ti",
    yourPosition: "V th ca bn",
    byAddingLiquidityInfo: "Bng cch thm thanh khon, bn s nhn c 0,3% tt c cc giao dch trn cp tin ny t l vi phn ca bn trong b .\n Ph c thm vo b, s tch ly trong thi gian thc v c th c nhn bng cch rt thanh khon ca bn ."
};
var searchModal$1 = {
    commonBases: "C s chung",
    tokensPairsHelper: "Cc m token ny thng c ghp vi cc m token khc.",
    addedByUser: " thm bi ngi dng",
    foundByAddress: " tm thy bi a ch",
    remove: "loi b",
    add: "Thm",
    findToken: "Tm m token bng cch tm kim tn hoc k hiu ca n hoc bng cch dn a ch ca n bn di.",
    selectToken: "La chn mt token",
    tokenSearchPlaceholder: "Tm tn hoc dn a ch",
    tokenName: "Tn Token",
    change: "Thay i",
    selectList: "La chn mt danh sch",
    confirmListRemovalPrompt: "Vui lng xc nhn rng bn mun xa danh sch ny bng cch nhp REMOVE",
    addList: "Thm mt danh sch ",
    tokenListHelper: "Danh sch m token l mt c im k thut m cho danh sch m token ERC20. Bn c th s dng bt k danh sch m token no bng cch nhp URL ca n vo bn di. Lu  rng danh sch m token ca bn th ba c th cha m token ERC20 gi mo hoc c hi.",
    httpsPlaceholder: "https:// hoc ipfs://",
    manageLists: "Qun l danh sch",
    viewList: "Quan st danh sch",
    updateList: "Cp nht danh sch",
    removeList: "Loi b danh sch",
    selected: " chn",
    select: "Chn",
    manageTokenLists: "Qun l danh sch token"
};
var settings$1 = {
    areYouSure: "Bn chc chn ch?",
    expertInfo: "Ch  chuyn gia tt li nhc xc nhn giao dch v cho php cc giao dch trt gi cao thng dn n t gi xu v mt tin.",
    expertWarningCAPS: "CH S DNG CH  NY NU BN BIT BN ANG LM G.",
    confirm: "xc nhn",
    confirmExpertMode: "Vui lng nh t \"confirm\"  kch hot ch  chuyn gia.",
    turnOnExpertMode: "Bt ch  chuyn gia",
    transactionSettings: "Ci t giao dch",
    interfaceSettings: "Giao din ci t",
    toggleExpertMode: "Chuyn i ch  chuyn gia",
    expertModeHelper: "B qua cc phng thc xc nhn v cho php cc giao dch c  trt cao. S s dng vi nguy c ca ring bn .",
    toggleDarkMode: "Chuyn i ch  ban m",
    slippage: "Slippage",
    percent: "Percent"
};
var swap$1 = {
    priceImpact: "Tc ng gi",
    priceImpactHelper: "Chnh lch gia gi th trng v gi c tnh do khi lng chuyn i.",
    liquidityProviderFee: "Ph ngi cung cp thanh khon",
    liquidityProviderHelper: "Mt phn ca mi giao dch (0,30%) c chuyn n cc ngi cung cp thanh khon nh mt bin php  khuyn khch giao thc. ",
    route: "L tuyn",
    routingHelper: "nh tuyn thng qua cc m token ny a ra gi tt nht cho giao dch ca bn .",
    confirmSwap: "Xc nhn han i",
    swapAnyway: "Hon i d sao i na",
    confirm: "xc nhn",
    price: "Gi",
    accept: "Chp nhn",
    minimumReceived: "Nhn c ti thiu",
    maximumSold: "Bn ti a",
    transactionRevertHelper: "Giao dch ca bn s hon li nu c mt bin ng gi ln, bt li trc khi n c xc nhn .",
    priceUpdated: "Gi  c cp nht",
    outputEstimated: "u ra c c tnh.Bn s nhn li ti thiu <strong>{{amount}} {{currencySymbol}}</strong> hoc giao dch s hon li.",
    inputEstimated: "u vo c c tnh. Bn s bn c nhiu nht <strong>{{amount}} {{currencySymbol}}</strong> hoc giao dch s hon li.",
    outputSentTo: "u ra s c gi ti ",
    priceImpactMinPrompt: "S hon i ny c tc ng v gi t nht l  {{ priceImpact }}%. Vui lng g t \"confirm\"  tip tc thao tc hon i ny.",
    priceImpactHighPrompt: "S hon i ny c tc ng v gi t nht l  {{ priceImpact }}%. Vui lng xc nhn rng bn mun tip tc thao tc hon i ny."
};
var toggle$1 = {
    on: "M",
    off: "Tt"
};
var tokenWarningModal$1 = {
    tokenImported: " nhp m token",
    anyoneCanCreateWarning: "Bt k ai cng c th to m thng bo ERC-20 trn Avalanche vi  <em>any</em> tn, bao gm c vic to cc phin bn gi mo ca m token hin c v m token tuyn b i din cho cc d n khng c m token.",
    loadArbitraryWarning: "Giao din ny c th ti m token ty chnh theo a ch. Vui lng thn trng hn v thc hin nghin cu ca bn khi tng tc vi cc m token ERC-20 ty chnh.",
    purchaseArbitraryWarning: "Nu bn mua mt m token ty chnh, <strong>bn c th khng bn li c.</strong>",
    understand: "Ti hiu",
    "continue": "Tip tc",
    viewExplorer: "Xem trn explorer"
};
var transactionConfirmation$1 = {
    waitingConfirmation: "ang ch xc nhn",
    confirmTransaction: "Xc nhn giao dch ny trong v ca bn",
    transactionSubmitted: "Giao dch  c gi i",
    viewExplorer: "Xem trn explorer",
    close: "ng",
    error: "Li",
    dismiss: "B qua",
    addToFarm: "Thm vo trang tri"
};
var transactionSettings$1 = {
    slippageTolerance: "Chng trt gi",
    transactionRevertSlippageHelper: "Giao dch ca bn s hon nguyn nu gi thay i bt li hn t l phn trm ny.",
    transactionDeadline: "Thi hn giao dch",
    transactionRevertDeadlineHelper: "Giao dch ca bn s hon nguyn nu n ang ch x l lu hn th ny.",
    enterValidSlippage: "Nhp phn trm trt gi hp l ",
    transactionMayFail: "Giao dch ca bn c th tht bi",
    transactionMayFrontrun: "Giao dch ca bn c th b chn",
    transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
    minutes: "pht"
};
var vote$1 = {
    earnedPng: "M token {{ pngSymbol }} kim c i din cho c phn biu quyt trong qun tr Arcanum.",
    canEitherVote: "Bn c th t b phiu cho tng  xut hoc y thc phiu bu ca mnh cho bn th ba. ",
    delegateVotes: "Phiu bu y quyn",
    selfDelegate: "T y quyn",
    remove: "Loi b",
    add: "Thm",
    delegate: "y quyn",
    delegatingVotes: "ang y quyn phiu bu",
    unlockingVotes: "ang m kha phiu bu",
    transactionSubmitted: "Giao dch  c gi",
    "for": "cho",
    against: "chng",
    vote: "Bu",
    proposal: " xut",
    votes: "nhng phiu bu",
    submittingVote: "ang gi phiu bu",
    confirmTransaction: "Xc nhn giao dch ny trn v ca bn",
    viewExplorer: "Xem trn explorer"
};
var walletModal$1 = {
    wrongNetwork: "Sai mng li",
    errorConnecting: "Kt ni xy ra li",
    pleaseConnectAvalanche: "Vui lng kt ni vi mng Avalanche thch hp.",
    switchAvalanche: "Chuyn sang chui Avalanche",
    errorConnectingRefresh: "Li khi kt ni.Th lm mi trang",
    connectToWallet: "Kt ni ti mt v",
    newToAvalanche: "Bn mi s dng Avalanche? ",
    learnMoreWallet: "Tm hiu thm v cch thit lp v",
    initializing: "ang khi to...",
    tryAgain: "Th li"
};
var web3ReactManager$1 = {
    unknownError: "Oops!  xy ra li khng xc nh. Vui lng lm mi trang hoc truy cp t trnh duyt hoc thit b khc. "
};
var web3Status$1 = {
    pending: "ang ch x l",
    wrongNetwork: "Sai mng li",
    error: "Li",
    connectToWallet: "Kt ni vi mt v"
};
var gasFeeAlert$1 = {
    gasFeeReduction: "!!! Gim ph gas !!!",
    transactionsNotAccept: "Giao dch s khng c chp nhn tr khi ph gas c t thnh {{ gasPrice }} gwei."
};
var addLiquidity$1 = {
    deposited: "K gi",
    shareOfPool: "C phn b",
    createPoolSupply: "To b & ngun cung cp",
    confirmSupply: "Xc nhn cung cp",
    giveOrder: "GIVE ORDER",
    outputEstimated: "u ra c c tnh. Nu gi thay i nhiu hn {{ allowedSlippage }}% giao dch ca bn s hon nguyn.",
    creatingPool: "Bn ang to ra mt b",
    willReceive: "Bn s nhn",
    firstLP: "Bn l ngi u tin cung cp thanh khon.",
    ratioTokens: "T l m token bn thm vo s t gi ca b ny.",
    happyRate: "Mt khi bn hi lng vi t l, nhp Supply  tin hnh xem xt.",
    initialPrices: "Gi ban u",
    prices: "Gi",
    poolShare: "v c phn b",
    connectWallet: "Kt ni v",
    approve: "Chp nhn ",
    supply: "Cung cp",
    per: " mi ",
    rates: "T l",
    poolTokens: " B token"
};
var airdrop$1 = {
    claimPngAirdrop: "Nhn {{ pngSymbol }} t Aidrop",
    claimPeriodEnded: "Thi gian nhn airdrop  kt thc.",
    connectWalletViewLiquidity: "Kt ni vi v  tm hiu thanh khon ca bn.",
    noAvailableClaim: "Bn khng c phn thng no.",
    noUniNoSushi: "Bn khng c m token UNI hoc SUSHI. Vui lng lm theo hng dn ti y  thm m token UNI hoc SUSHI vo v ca bn .",
    youHave: "Bn c ",
    pngAvailableClaim: " {{ pngSymbol }} kh dng  nhn",
    loading: "ang ti",
    welcomeToTeamPangolin: "Cho mng n i Pagonlin",
    claim: "Nhn "
};
var earnPage$1 = {
    pangolinLiquidityMining: "Khai thc thanh khon Arcanum",
    pangolinLiquidityStaking: "t c phn Arcanum {{ pngSymbol }} ",
    depositPangolinLiquidity: "Gi m token ARL ca v th cung cp thanh khon Arcanum ca bn  nhn {{ pngSymbol }}, m thng bo qun tr giao thc Arcanum.",
    depositPangolinStaking: "Gi v t c phn m token {{ pngSymbol }} ca bn  nhn c nhiu token hn.",
    currentOpportunities: "C hi hin ti",
    readMoreAboutPng: "Tm hiu nhiu hn v {{ pngSymbol }}",
    getInsuranceCoverage: "Nhn trang ba trn InsurAce.io",
    getCoverNexusMutual: "Nhn trang ba trn Nexus Mutual",
    importantUpdate: "CP NHT QUAN TRNG",
    pangolinGovernanceProposalResult: "Theo kt qu ca  xut qun tr Arcanum 1, Arcanum ang thay i cc hp ng t c phn! Sau khong 08:59 UTC vo ngy 19 thng 4, tt c phn thng t c phn s c phn phi cho cc hp ng t c phn mi. Trc khi chuyn i, tt c phn thng s vn c phn phi cho cc hp ng c.  trnh b gin on vic kim phn thng farming, bn cn loi b thanh khon ca mnh khi cc hp ng c v thc hin li cc hp ng mi. Bn khng cn phi xa thanh khon khi b ca mnh hoc thay i v th ca mnh. ",
    oldPngPools: "Nhng b {{ pngSymbol }} c",
    newPngPools: "Nhng b {{ pngSymbol }} mi",
    participatingPools: "ang tham gia vo cc b",
    rewardsNeverEnd: "Phn thng khng bao gi kt thc!",
    noActiveRewards: "Khng c phn thng hot ng",
    liquidityMining: "Khai thc thanh khon",
    pngStaking: "ang t c phn {{ pngSymbol }}",
    totalStaked: "Tng s c phn  t",
    poolRate: "T sut b",
    step1: "Bc 1. Nhn token thanh khon Arcanum (ARL)",
    pglTokenRequired: "M token ARL l bt buc. Khi bn thm thanh khon vo {{ poolHandle }} b bn c th t c phn m token thanh khon ca mnh trn trang ny.",
    addPoolLiquidity: "Thm {{ poolHandle }} thanh khon",
    liquidityDeposits: "S tin thanh khon ca bn",
    yourStakedToken: "S c phn {{ symbol }}  t ca bn",
    unclaimedReward: "S {{ symbol }} ca bn cha nhn",
    claim: "Nhn",
    rewardPerWeek: " {{ symbol }} / tun",
    automagically: "Khi bn rt tin, hp ng s t ng nhn phn thng {{ pngSymbol }} thay cho bn! ",
    deposit: "Gi",
    depositStakingTokens: "Gi token {{ symbol }}",
    stake: "t c phn",
    stakeStakingTokens: "t c phn {{ symbol }}",
    unstake: "Rt c phn",
    stakingTokensAvailable: "{{ symbol }} kh dng",
    getToken: "Nhn {{ symbol }}",
    migrateTitle: "Di chuyn ARL xp chng ca bn",
    migrateDescription: "Arcanum  thay i tokenomics. Bn s cn di chuyn ARL xp chng ca mnh sang hp ng mi",
    migrate: "Di c"
};
var pool$1 = {
    liquidityProviderRewards: "Phn thng ngi cung cp thanh khon",
    liquidityProvidersEarn: "Nhng ngi cung cp thanh khon kim c mt khon ph 0,3% cho tt c cc giao dch t l vi c phn ca h trong b. Ph c thm vo b, tch ly trong thi gian thc v c th c nhn bng cch rt tin thanh khon ca bn.",
    readMoreProviding: "Tm hiu thm v cung cp thanh khon",
    viewStakedLiquidity: "Quan st s lng thanh khon  cung cp ca bn",
    yourLiquidity: "S lng thanh khon ca bn",
    createPair: "To mt cp",
    addLiquidity: "Thm thanh khon",
    connectWalletToView: "Kt ni vi mt v bt k  quan st thanh khon ca bn",
    loading: "ang ti",
    noLiquidity: "Khng tm thy thanh khon.",
    uniswapV1Found: "Thanh khon uniswap V1 c tm thy",
    noSeePoolJoined: "Bn khng tm thy b m bn  tham gia?",
    migrateNow: "Chuyn i ngay by gi.",
    importIt: "Nhp.",
    seeDetails: "XEM CHI TIT",
    totalLockedValue: "Tng gi tr  kha",
    yourLockedValue: "Gi tr  kha ca bn",
    allFarms: "tt c cc trang tri",
    yourFarms: "trang tri ca bn",
    yourPools: "H bi ca bn",
    noFarms: "Khng tm thy trang tri no.",
    successWithdraw: "Thanh khon ca bn  b xa khi trang tri v  nhn c phn thng tch ly!"
};
var poolFinder$1 = {
    connectToFind: "Kt ni vi mt v  nhn thy b",
    selectTokenToFind: "Chn mt token  tm thanh khon ca bn.",
    selectToken: "SChn mt token",
    poolFound: "B  tm thy!",
    managePool: "Qun l b ny.",
    noLiquidityYet: "Bn cha c thanh khon trong b ny.",
    noPoolFound: "Khng tm thy b.",
    addLiquidity: "Thm thanh khon.",
    createPool: "To b.",
    invalidPair: "Cp khng hp l.",
    loading: "ang ti"
};
var removeLiquidity$1 = {
    youWillReceive: "Bn s nhn",
    simple: "n gin",
    detailed: "Chi tit",
    receiveAvax: "Nhn {{ symbol }}",
    receiveWavax: "Nhn {{ symbol }}",
    price: "Gi:",
    connectWallet: "Kt ni v",
    approving: "ang chp nhn",
    approve: "Chp nhn",
    approved: " chp nhn",
    remove: "Loi b",
    output: "u ra",
    amount: "S lng"
};
var swapPage$1 = {
    addSend: "+ Thm ln gi (ty chn) ",
    toEstimated: "n ( c tnh)",
    to: "n",
    removeSend: "- Xa gi",
    price: "Gi",
    slippageTolerance: "Chng trt gi",
    connectWallet: "Kt ni v",
    insufficientLiquidity: "Khng  thanh khon cho hon i ny.",
    wrap: "Bc",
    unwrap: "G bc",
    approving: "ang chp nhn",
    approve: "Chp nhn ",
    approved: " chp nhn",
    priceImpactHigh: "Tc ng gi cao",
    swap: "Hon i",
    anyway: " D sao i na",
    from: "T",
    fromEstimated: "T (c tnh)",
    velox: "t lnh gii hn trn  <1>Velox</1>",
    marginSwap: "Hon i vi n by trn <1>MarginSwap</1>",
    wowSwap: " hoc <1>WOWswap</1>",
    veeFinance: " hoc <1>Vee Finance</1>",
    gelatoFee: "Gelato Hc ph",
    placeOrder: "t hng",
    confirmOrder: "Xc nhn n hng",
    "for": "v",
    submittingOrderToSwap: "Gi n t hng  hon i",
    limitPrice: "Gi gii hn",
    outputWillBeSentTo: "u ra s c gi n",
    sell: "sell",
    buy: "mua",
    betaRelease: "y l bn pht hnh BETA v bn nn t chu ri ro khi s dng!",
    trade: "Bun bn",
    watchList: "WatchList",
    yourPortFolio: "Danh mc u t ca bn",
    comingSoon: "Sp c",
    connectWalletViewPortFolio: "Kt ni vi v  xem danh mc u t ca bn.",
    limitOrders: "n hng gii hn",
    cancelOrder: "Hy n hng",
    all: "TT C",
    open: "M",
    executed: "THC THI",
    cancelled: "HY",
    inputAmount: "S lng u vo",
    outputAmount: "S lng u ra",
    status: "Trng thi",
    noLimitOrder: "Khng {{ orderType }} Gi mn",
    cancellingOrder: "ang hy n t hng...",
    cancelLimitOrder: "Mua {{ outputCurrency }} vi {{ inputCurrency }}",
    executionPrice: "Gi thc hin",
    seeMore: "Xem thm",
    seeLess: "Thy t"
};
var buyPage$1 = {
    buyAvaxInfo: "Mua AVAX bng fiat t i tc Wyre ca chng ti.",
    privacyInfo: "Arcanum khng lu tr lch s mua hng ca bn hoc bt k d liu c nhn no.",
    firstName: "Tn u",
    lastName: "Tn cui",
    email: "Th in t",
    buyAvax: "Mua AVAX"
};
var votePage$1 = {
    unlockVotes: "M kha phiu bu",
    updateDelegation: "Cp nht y quyn",
    pangolinGovernance: "Qun tr Arcanum",
    earnedPngTokens: "Cc m token {{ pngSymbol }} i din cho c phn c quyn biu quyt trong qun tr Arcanum. Bn c th t b phiu cho tng  xut hoc y thc phiu bu ca mnh cho bn th ba.",
    eligibleToVote: "  iu kin b phiu, bn phi gi {{ pngSymbol }} trong v ca mnh v y quyn khi bt u b phiu. Sau khi bt u b phiu, bn c th gp hoc s dng {{ pngSymbol }} ca mnh.",
    governanceVotes: "Cc phiu bu qun tr c quyt nh theo a s. Khng c ngng i biu. ",
    proposals: " xut",
    allProposals: "Tt c  xut",
    backToProposals: "Quay li  xut",
    unlockVoting: "M kha biu quyt",
    votes: " Phiu bu",
    delegatedTo: "y quyn cho:",
    edit: "sa",
    noProposalsFound: "Khng  xut no c tm thy.",
    proposalCommunityMembers: "Cc  xut do cc thnh vin cng ng gi s xut hin  y.",
    minimumThreshold: "Yu cu ngng ti thiu 1.000.000 {{ pngSymbol }}  gi  xut ",
    votingStarted: "B phiu  bt u",
    votingStarts: "Bt u b phiu ",
    votingEnded: "B phiu  kt thc ",
    votingEnds: "Kt thc b phiu ",
    voteFor: "B phiu cho",
    voteAgainst: "B phiu chng li",
    against: "Chng",
    "for": "Cho",
    details: "Chi tit",
    overview: "Tng quan",
    proposer: "Ngi  xut",
    about: "V",
    vote: "Bu c",
    executed: "Thc thi",
    rejected: "Bc b",
    notSupported: "Khng c h tr trn chui ny"
};
var IDOPage$1 = {
    pangolinIDOs: "Initial DEX Offering (IDO)",
    pangolinIDODescription: "Initial DEX Offerings (IDO) cho php cc d n huy ng vn t cc m token bn v ca h trn cc sn giao dch phi tp trung. Chng ti  hp tc vi cc nhm tuyt vi  mang li nhng d n tuyt vi cho cng ng Avalanche. ",
    upcomingIDOs: "Sp ti",
    endedIDOs: "Kt thc",
    allIDOs: "Tt c IDO",
    noIDOsFound: "Khng IDO no c tm thy",
    IDOAnnounced: "Cc IDO c thng bo cng khai s xut hin ti y ."
};
var swapHooks$1 = {
    connectWallet: "Kt ni v",
    enterAmount: "Nhp s lng",
    selectToken: "Chn mt token",
    enterRecipient: "Nhp mt ngi nhn",
    invalidRecipient: "Ngi nhn khng hp l",
    insufficient: "Khng  ",
    balance: " s d"
};
var mintHooks$1 = {
    connectWallet: "Kt ni v",
    insufficientInputAmount: "S lng u vo khng ",
    invalidPair: "Cp khng hp l ",
    enterAmount: "Nhp s lng",
    insufficient: "Khng  ",
    balance: " s d"
};
var stakeHooks$1 = {
    connectWallet: "Kt ni v",
    enterAmount: "Nhp s lng"
};
var burnHooks$1 = {
    connectWallet: "Kt ni v",
    enterAmount: "Nhp s lng"
};
var migratePage$1 = {
    stake: "C PHN",
    unstake: "BT NG",
    add: "CNG",
    remove: "TY",
    startMigratingNow: "BT U DI C NGAY BY GI",
    startMigratingNowDescription: "Di y, bn s tm thy tt c cc Trang tri m bn s cn  di chuyn sang Hp ng V2 ca Arcanum",
    seeMore: "XEM THM",
    migrateWithEase: "DI CHUYN VI EASE",
    migrateWithDescription: "Chng ti  thit k mt trnh hng dn thanh lch, s gip hng dn bn trong qu trnh di chuyn Trang tri ca bn",
    alreadyMigrate: " di c",
    walletMigrate: "v  di chuyn",
    alreadyEarned: " kim c",
    migrateNow: "DI TR NGAY BY GI",
    learn: "HC",
    moveYourTokensToNewContracts: "Di chuyn trang tri ca bn sang Arcanum V2",
    readyToMigrate: "Sn sng di chuyn",
    apr: "APR:",
    totalValueLocked: "Tng gi tr  kha",
    lowVolatility: "S bin ng thp",
    compoundable: "Hp cht",
    migrate: "Di c",
    migrationModalDescription: "Chng ti nhn thy rng bn c cc nhm ny Hy chn mt hoc thm mt nhm.",
    choosePool: "Chn nhm",
    pool: "H bi",
    availableToDeposit: "C sn  t cc: ",
    poolInfoDescription: "By gi bn  chn h bi ca mnh, sau  cho php bn ri khi .",
    dollarWorth: "Gi tr  la: ",
    usd: "USD",
    yourRate: "T l ca bn: ",
    unclaimedPng: "{{ pngSymbol }} v tha nhn: ",
    shareOfPool: "Chia s ca Pool: ",
    choose: "LA CHN",
    selectAll: "Chn tt c",
    loading: "ang ti",
    back: "Mt sau",
    availableToUnstake: "C sn  hy b: ",
    submittingTransaction: "Gi giao dch",
    moveYourTokensToNewContractsDescription: "L mt phn trong k hoch trin khai cc hp ng ci tin mi ca Arcanum, bn s cn phi di chuyn Trang tri ca mnh. Nu bn cn bt k tr gip hoc hng dn no, vui lng nhp vo nt Tm hiu.",
    migrateModalHeading: "Di c {{ current }} ca {{ total }} trang tri"
};
var dashboardPage$1 = {
    dashboard: "Dashboard",
    greetings: "Greetings kind guests! Lets ape in today",
    portfolioValue: "Portfolio Value",
    earned: "Earned",
    coins: "Coins",
    followedWallets: "Followed Wallets",
    earned_dailyIncome: "Daily Income",
    earned_weeklyIncome: "Weekly Income",
    earned_totalEarned: "Total Earned",
    earned_claim: "Claim",
    earned_customizePools: "Customize Pools",
    followed_address: "Address",
    followed_worth: "Worth",
    followed_interact: "Interact"
};
var stakePage$1 = {
    totalStaked: "Total Staked",
    apr: "Annual Percentage Rate",
    seeDetails: "SEE DETAILS",
    stake: "STAKE",
    earn: "Earn {{symbol}}",
    stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$1 = {
    missCurrencyAmounts: "Thiu s tin",
    missTokens: "Thiu m thng bo",
    "Thiu ph thuc": "Thiu ph thuc",
    missingLiquidityAmount: "Thiu s tin thanh khon",
    couldNotWrap: "Khng th qun",
    trytingToConfirmApproval: "ang c gng xc nhn m khng cn ph duyt hoc ch k. Vui lng lin h vi b phn h tr."
};
var sarTitle$1 = {
    addMore: "B SUNG THM",
    unstake: "B L V TR",
    compound: "PHN THNG HP L",
    claim: "PHN THNG KHIU NI",
    interactingID: "Tng tc vi ID: {{ id }}"
};
var sarStake$1 = {
    createNewPosition: "To mt v tr mi",
    stake: "Cc",
    staking: "Staking",
    walletBalance: "Trong V {{ balance }} {{ symbol }}",
    max: "Max",
    dollarValue: "Gi tr  la",
    buy: "Mua {{ symbol }}",
    averageAPR: "APR trung bnh",
    startingApr: "Bt u APR",
    weeklyDistributed: "Hng tun {{ biu tng }} Phn phi",
    confirmDescription: "Mt hnh ng t cc s to ra SAR Nft cho bn. Vi NFT ny, bn c th qun l s tin t cc {{ symbol }} ca mnh.",
    successSubmit: "Bn  stake thnh cng token ca mnh.",
    yourAprRecalculated: "APR ca bn s c tnh ton li.",
    summary: "Tm tt",
    pending: "Staking {{ balance }} {{ symbol }}",
    transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore$1 = {
    stakeMore: "t cc nhiu hn",
    choosePosition: "Chn mt v tr",
    confirmDescription: "iu ny s thm {{ symbol }} vo v tr SAR NFT ca bn. S d ban u ca bn vn tip tc t cng mt APR. APR ca cc m thng bo mi thm ca bn bt u t 0% v thay i da trn  di c phn. NFT ca bn s hin th mc trung bnh.",
    newAPR: "APR mi",
    add: "Thm",
    pending: "Thm {{ balance }} {{ symbol }}"
};
var sarUnstake$1 = {
    unstake: "Hy tham gia",
    unstaking: "Unstaking {{ balance }} {{ symbol }}",
    stakedBalance: "Staked {{ balance }} {{ symbol }}",
    confirmDescription: "Cn lu  rng vic b t cc phn thng ca bn s gip APR ca bn v 0% cho v tr ny. \nThay v b t cc, bn cng c th cn nhc bn NFT ca mnh.",
    successSubmit: "Bn  hy s dng thnh cng token ca mnh.",
    pending: "Unstaking {{ balance }} {{ symbol }}",
    transactionSummary: "Unstaked {{ balance }} {{ symbol }}",
    currentAPR: "APR hin ti",
    unstakeWarning: "Khi bn hy tham gia, APR trung bnh ca bn s gim xung 0%.",
    aprAfter: "APR sau khi unstake"
};
var sarCompound$1 = {
    compound: "Hp cht",
    compounding: "Kp",
    successSubmit: "Bn  thnh cng trong vic kt hp v tr ca mnh.",
    pending: "Kp",
    transactionSummary: "V tr kt hp",
    aprAfter: "APR sau khi kt hp",
    reward: "Phn thng tch ly",
    description: "Xin lu  rng vic cng gp phn thng ca bn c th lm gim APR trung bnh ca bn. Cc m thng bo t cc mi bt u t 0, trong khi cc m thng bo c s tip tc vi cng mt APR. iu ny to ra mc trung bnh c hin th cho bn.",
    noRewards: "Khng c phn thng  kt hp"
};
var sarClaim$1 = {
    claim: "i",
    claiming: "Tuyn b",
    description: "Do tnh cht ca h thng t cc SAR yu cu phn thng ca bn s gim APR ca bn xung 0. Thay vo , bn c th cng gp phn thng ca mnh m khng mt APR ca mnh.",
    successSubmit: "Bn  nhn thnh cng phn thng ca mnh",
    pending: "Tuyn b",
    transactionSummary: "Phn thng v tr  nhn",
    aprAfter: "APR sau khi yu cu bi thng",
    noRewards: "Khng c phn thng  yu cu"
};
var sarPortfolio$1 = {
    noPositions: "Bn khng c bt k PANGUARDIAN NFT no.\nHY GIP BN C C MT",
    start: "BT U",
    positionId: "ID v tr",
    apr: "Apr",
    amount: "Lng",
    newest: "Mi nht",
    oldest: "C nht",
    sortBy: "Sp xp theo"
};
var pangoChef$1 = {
    claimWarning1: "Khi bn yu cu m khng rt tin, thanh khon ca bn vn cn trong nhm khai thc.",
    claimWarning2: "Yu cu phn thng ca bn s gim APR ca bn xung 0. Thay vo , bn c th chn kt hp.",
    compoundWarning: "Tch ly phn thng ca bn cho trang tri {{token0}} - {{token1}} s nhn c phn thng ca bn vo trang tri {{currency}} - {{png}}. Bn cn thm gi tr tng ng ca m thng bo {{currency}} vo phn thng {{png}}  tch ly ca mnh.",
    compoundAmountWarning: "Bn cn thm {{amount}} {{symbol}}  kt hp.",
    compoundAmountWarning2: "Hy cn thn rng bn s kha nhm {{symbol}} {{png}} ca mnh cho n khi bn nhn c phn thng ca nhm ny.",
    highVolalityWarning: "Cn qu sm, hy th sau vi gi",
    compoundSuccess: "Bn  son thnh cng trang tri ca mnh.",
    compoundTransactionSummary: "Trang tri tng hp.",
    removeWarning: "Loi b bt k s tin no khi trang tri s nhn c APR ca bn thnh 0. Thay vo , bn c th gp phn thng ca mnh m khng b mt APR.",
    lockingPoolZeroWarning: "Bn khng th xa thanh khon ca mnh hoc yu cu phn thng ca mnh t trang tri ny.  lm iu ny, trc tin bn cn phi yu cu c phn ca bn t cc trang tri ny: "
};
var bridge$1 = {
    availableRoutes: "Available Routes ({{ number }})",
    activeTransfers: "Active Transfers ({{ number }})",
    historicalTransfers: "Historical Transfers ({{ number }})",
    bridgeCard: {
        advanceOptions: "Advance Options",
        title: "Cross Chain",
        swap: "Swap",
        loader: {
            labels: {
                waitingReceivingChain: "Waiting for receiving chain..."
            },
            bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
        },
        filter: {
            bridgePrioritization: "Bridge Prioritization",
            slippage: "Slippage",
            infiniteApproval: "Infinite Approval",
            activeInfiniteApproval: "Active Infinite Approval",
            bridges: "Bridges",
            exchanges: "Exchanges"
        }
    },
    bridgeInputsWidget: {
        tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
        max: "MAX"
    },
    bridgeRoute: {
        selected: "Selected",
        clickToSelect: "Click to select",
        singleTransaction: "Single transaction including",
        estimatedToken: "Estimated Token: {{ token }}",
        estimatedResult: "Estimated Result: {{ result }}",
        min: "{{ minute }} min",
        gasCost: "{{ gasCost }} Gas Cost"
    },
    bridgeTransfer: {
        date: "Date",
        from: "From",
        to: "To",
        via: "Via",
        state: "State",
        resumeSwap: "Resume Swap"
    },
    bridgePrioritizations: {
        recommended: "Recommended",
        fast: "Fast",
        normal: "Normal"
    }
};
var dropdown$1 = {
    select: "Select"
};
var vnTranslation = {
    header: header$1,
    accountDetails: accountDetails$1,
    addressInputPanel: addressInputPanel$1,
    currencyInputPanel: currencyInputPanel$1,
    earn: earn$1,
    menu: menu$1,
    modalView: modalView$1,
    navigationTabs: navigationTabs$1,
    popups: popups$1,
    positionCard: positionCard$1,
    searchModal: searchModal$1,
    settings: settings$1,
    swap: swap$1,
    toggle: toggle$1,
    tokenWarningModal: tokenWarningModal$1,
    transactionConfirmation: transactionConfirmation$1,
    transactionSettings: transactionSettings$1,
    vote: vote$1,
    walletModal: walletModal$1,
    web3ReactManager: web3ReactManager$1,
    web3Status: web3Status$1,
    gasFeeAlert: gasFeeAlert$1,
    addLiquidity: addLiquidity$1,
    airdrop: airdrop$1,
    earnPage: earnPage$1,
    pool: pool$1,
    poolFinder: poolFinder$1,
    removeLiquidity: removeLiquidity$1,
    swapPage: swapPage$1,
    buyPage: buyPage$1,
    votePage: votePage$1,
    IDOPage: IDOPage$1,
    swapHooks: swapHooks$1,
    mintHooks: mintHooks$1,
    stakeHooks: stakeHooks$1,
    burnHooks: burnHooks$1,
    migratePage: migratePage$1,
    dashboardPage: dashboardPage$1,
    stakePage: stakePage$1,
    error: error$1,
    sarTitle: sarTitle$1,
    sarStake: sarStake$1,
    sarStakeMore: sarStakeMore$1,
    sarUnstake: sarUnstake$1,
    sarCompound: sarCompound$1,
    sarClaim: sarClaim$1,
    sarPortfolio: sarPortfolio$1,
    pangoChef: pangoChef$1,
    bridge: bridge$1,
    dropdown: dropdown$1
};

var header = {
    dashboard: "Dashboard",
    swap: "",
    buy: "",
    pool: "",
    farm: "",
    version1: " 1",
    version2: " 2",
    stake: "",
    newPng: " {{ pngSymbol }}",
    oldPng: " {{ pngSymbol }}",
    vote: "",
    ido: "IDO",
    charts: "",
    forum: "",
    pngBreakDown: " {{ symbol }} ",
    balance: ": ",
    unclaimed: ": ",
    pngPrice: "{{ symbol }} :",
    pngCirculation: "{{ symbol }} :",
    totalSupply: "",
    makeSureURLWarning: " URL ",
    alwaysMakeSureWarning: " URL ",
    bookmarkIt: "",
    addMetamask: " {{ symbol }}  MetaMask",
    bridge: "",
    ourPartners: "",
    usefulLinks: "",
    comeAndJoinUs: "",
    tryOurNewBetaSite: "",
    returnToLegacySite: "",
    switchToNewUI: ""
};
var accountDetails = {
    connectedWith: " ",
    account: "",
    disconnect: "",
    change: "",
    copy: "",
    viewExplorer: "",
    clearAll: "()",
    transactionAppear: "...",
    recentTransactions: "",
    copied: ""
};
var addressInputPanel = {
    recipient: "",
    viewExplorer: "()",
    walletAddress: ""
};
var currencyInputPanel = {
    selectToken: "",
    balance: ": ",
    max: "",
    to: ""
};
var earn = {
    claimAccumulated: " {{ symbol }} ",
    connectWallet: "",
    enterAmount: "",
    unclaimedReward: " {{ symbol }}",
    claim: "",
    claimReward: " {{ symbol }}",
    liquidityRemainsPool: "LP",
    withdrawingLiquidity: " {{ amount }} {{ symbol }}",
    claimingReward: " {{ amount }} {{ symbol }}",
    claimedReward: " {{ symbol }}!",
    manage: "",
    deposit: "",
    poolRate: "",
    currentReward: "",
    pngPerAvax: "{{ pngSymbol }} /  AVAX",
    rewardPerWeek: "{{ symbol }} / ",
    earnUpTo: "",
    yourRate: "",
    totalDeposited: "",
    totalStaked: "",
    depositLiquidity: "",
    attemptingToStakeError: "",
    transactionSubmitted: "",
    depositingLiquidity: "",
    depositingToken: " {{ symbol }}",
    depositedToken: " {{ symbol }}",
    availableToDeposit: ": ",
    weeklyRewards: "",
    missingLiquidityAmount: "",
    missingDependencies: "",
    deposited: "",
    withdrawDepositedLiquidity: "",
    depositedPglLiquidity: " ARL :",
    whenYouWithdrawWarning: " {{ symbol }} Pangolin ARL  {{ symbol }} ",
    whenYouWithdrawSingleSideWarning: " {{ symbol }} {{ pngSymbol }}  {{ pngSymbol }}  {{ symbol }} ",
    withdrawAndClaim: " & ",
    withdrewStakingToken: " {{ symbol }}!",
    approve: "",
    poolWeight: "",
    withdraw: "",
    extraReward: "",
    poolRewards: "",
    rewardsIn: "",
    removeWarning: "  "
};
var menu = {
    code: "Code",
    twitter: "",
    discord: "Discord",
    telegram: "Telegram",
    tutorials: "Tutorials",
    idos: "IDOs",
    about: ""
};
var modalView = {
    confirmTransaction: "",
    viewTransaction: ""
};
var navigationTabs = {
    useThisTool: "",
    swap: "",
    pool: "",
    importPool: "",
    createPair: "",
    addLiquidity: "",
    removeLiquidity: "",
    whenYouAddLiquidityInfo: "LP",
    removingPoolTokensInfo: ""
};
var popups = {
    tokenListUpdated: "\" {{oldList}} \"  ",
    updateAvailable: " \" {{oldList}} \"",
    viewExplorer: "",
    hash: ": ",
    added: "",
    removed: "",
    tokensUpdated: "",
    acceptUpdate: "",
    dismiss: ""
};
var positionCard = {
    add: "",
    remove: "",
    poolShare: ":",
    pooled: "",
    poolTokens: ":",
    manage: "",
    loading: "",
    yourPosition: "",
    byAddingLiquidityInfo: " 0.25%\n "
};
var searchModal = {
    commonBases: "",
    tokensPairsHelper: ".",
    addedByUser: "",
    foundByAddress: "",
    remove: "",
    add: "",
    findToken: "",
    selectToken: "",
    tokenSearchPlaceholder: "",
    tokenName: "",
    change: "",
    selectList: "",
    confirmListRemovalPrompt: " \"\" ",
    addList: " ",
    tokenListHelper: " ERC20  URL  ERC20 ",
    httpsPlaceholder: "https://  ipfs://",
    manageLists: "",
    viewList: "",
    updateList: "",
    removeList: "",
    selected: "",
    select: "",
    manageTokenLists: ""
};
var settings = {
    areYouSure: "?",
    expertInfo: "",
    expertWarningCAPS: "",
    confirm: "",
    confirmExpertMode: " \"\" ",
    turnOnExpertMode: "",
    transactionSettings: "",
    interfaceSettings: "",
    toggleExpertMode: "",
    expertModeHelper: "",
    toggleDarkMode: "",
    slippage: "Slippage",
    percent: "Percent"
};
var swap = {
    priceImpact: "",
    priceImpactHelper: "",
    liquidityProviderFee: "",
    liquidityProviderHelper: "0.30%",
    route: "",
    routingHelper: "",
    confirmSwap: "",
    swapAnyway: "",
    confirm: "",
    price: "",
    accept: "",
    minimumReceived: "",
    maximumSold: "",
    transactionRevertHelper: "",
    priceUpdated: "",
    outputEstimated: " <strong>{{amount}} {{currencySymbol}}</strong>  ",
    inputEstimated: " <strong>{{amount}} {{currencySymbol}}</strong>  ",
    outputSentTo: " ",
    priceImpactMinPrompt: " {{ priceImpact }}%. \"\" ",
    priceImpactHighPrompt: " {{ priceImpact }}%. "
};
var toggle = {
    on: "",
    off: ""
};
var tokenWarningModal = {
    tokenImported: "",
    anyoneCanCreateWarning: " Avalanche <em></em> ERC-20 ",
    loadArbitraryWarning: " ERC-20 ",
    purchaseArbitraryWarning: "<strong></strong>",
    understand: "",
    "continue": "",
    viewExplorer: ""
};
var transactionConfirmation = {
    waitingConfirmation: "",
    confirmTransaction: "",
    transactionSubmitted: "",
    viewExplorer: "",
    close: "",
    error: "",
    dismiss: "",
    addToFarm: ""
};
var transactionSettings = {
    slippageTolerance: "",
    transactionRevertSlippageHelper: "",
    transactionDeadline: "",
    transactionRevertDeadlineHelper: "",
    enterValidSlippage: "",
    transactionMayFail: "",
    transactionMayFrontrun: "",
    transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
    minutes: ""
};
var vote = {
    earnedPng: " {{ pngSymbol }}  Arcanum ",
    canEitherVote: "",
    delegateVotes: "",
    selfDelegate: "",
    remove: "",
    add: "",
    delegate: "",
    delegatingVotes: "",
    unlockingVotes: "",
    transactionSubmitted: "",
    "for": "",
    against: "",
    vote: "",
    proposal: "",
    votes: "",
    submittingVote: "",
    confirmTransaction: "",
    viewExplorer: ""
};
var walletModal = {
    wrongNetwork: "",
    errorConnecting: "",
    pleaseConnectAvalanche: " Avalanche ",
    switchAvalanche: " Avalanche ",
    errorConnectingRefresh: "",
    connectToWallet: "",
    newToAvalanche: "Avalanche ? ",
    learnMoreWallet: "",
    initializing: "...",
    tryAgain: ""
};
var web3ReactManager = {
    unknownError: ""
};
var web3Status = {
    pending: "",
    wrongNetwork: "",
    error: "",
    connectToWallet: ""
};
var gasFeeAlert = {
    gasFeeReduction: "!!! Gas  !!!",
    transactionsNotAccept: "gas{{ gasPrice }} gwei."
};
var addLiquidity = {
    deposited: "",
    shareOfPool: "",
    createPoolSupply: "",
    confirmSupply: "",
    giveOrder: "GIVE ORDER",
    outputEstimated: " {{ allowedSlippage }}% ",
    creatingPool: "",
    willReceive: "",
    firstLP: "",
    ratioTokens: "",
    happyRate: ".",
    initialPrices: "",
    prices: "",
    poolShare: "",
    connectWallet: "",
    approve: " ",
    supply: "",
    per: "  ",
    rates: "",
    poolTokens: " "
};
var airdrop = {
    claimPngAirdrop: " {{ pngSymbol }} ",
    claimPeriodEnded: "",
    connectWalletViewLiquidity: "",
    noAvailableClaim: "",
    noUniNoSushi: " UNI  SUSHI  UNI  SUSHI ",
    youHave: " ",
    pngAvailableClaim: " {{ pngSymbol }} ",
    loading: "Loading",
    welcomeToTeamPangolin: " Arcanum ",
    claim: " "
};
var earnPage = {
    pangolinLiquidityMining: "Arcanum ",
    pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} ",
    depositPangolinLiquidity: " Arcanum LP PGL  Arcanum  {{ pngSymbol }}",
    depositPangolinStaking: " {{ pngSymbol }} ",
    currentOpportunities: "",
    readMoreAboutPng: " {{ pngSymbol }} ",
    getInsuranceCoverage: " InsurAce.io ",
    getCoverNexusMutual: " Nexus Mutual ",
    importantUpdate: "",
    pangolinGovernanceProposalResult: " Arcanum 1Staking  4/19 UTC  08:59  Staking  Staking    ",
    oldPngPools: " {{ pngSymbol }} ",
    newPngPools: " {{ pngSymbol }} ",
    participatingPools: "",
    rewardsNeverEnd: "",
    noActiveRewards: "",
    liquidityMining: "",
    pngStaking: "{{ pngSymbol }} ",
    totalStaked: "",
    poolRate: "",
    step1: "S  Arcanum  (ARL)",
    pglTokenRequired: "PGL  {{ poolHandle }} ",
    addPoolLiquidity: " {{ poolHandle }} ",
    liquidityDeposits: "",
    yourStakedToken: " {{ symbol }}",
    unclaimedReward: "{{ symbol }}",
    claim: "",
    rewardPerWeek: " {{ symbol }} / ",
    automagically: " {{ pngSymbol }}!",
    deposit: "",
    depositStakingTokens: " {{ symbol }} ",
    stake: "",
    stakeStakingTokens: " {{ symbol }} ",
    unstake: "",
    stakingTokensAvailable: " {{ symbol }} ",
    getToken: " {{ symbol }}",
    migrateTitle: " ARL",
    migrateDescription: " ARL ",
    migrate: ""
};
var pool = {
    liquidityProviderRewards: "",
    liquidityProvidersEarn: " 0.25% ",
    readMoreProviding: "",
    viewStakedLiquidity: "",
    yourLiquidity: "",
    createPair: "",
    addLiquidity: "",
    connectWalletToView: "",
    loading: "",
    noLiquidity: "",
    uniswapV1Found: "Uniswap V1 !",
    noSeePoolJoined: "?",
    migrateNow: "",
    importIt: "",
    seeDetails: "",
    totalLockedValue: "",
    yourLockedValue: "",
    allFarms: "",
    yourFarms: "",
    yourPools: "",
    noFarms: "",
    successWithdraw: ""
};
var poolFinder = {
    connectToFind: "",
    selectTokenToFind: "",
    selectToken: "",
    poolFound: "",
    managePool: "",
    noLiquidityYet: "",
    noPoolFound: "",
    addLiquidity: "",
    createPool: "",
    invalidPair: ".",
    loading: ""
};
var removeLiquidity = {
    youWillReceive: "",
    simple: "",
    detailed: "",
    receiveAvax: " AVAX",
    receiveWavax: " WAVAX",
    price: ":",
    connectWallet: "",
    approving: "",
    approve: "",
    approved: "",
    remove: "",
    output: "",
    amount: ""
};
var swapPage = {
    addSend: "+ ",
    toEstimated: "",
    to: "",
    removeSend: "- ",
    price: "",
    slippageTolerance: "",
    connectWallet: "",
    insufficientLiquidity: "",
    wrap: "",
    unwrap: "",
    approving: "",
    approve: " ",
    approved: "",
    priceImpactHigh: "",
    swap: "",
    anyway: " ",
    from: "",
    fromEstimated: "",
    velox: " <1>Velox</1> ",
    marginSwap: " <1>Marginswap</1>",
    wowSwap: "  <1>WOWswap</1> ",
    veeFinance: "  <1>Vee Finance</1> ",
    gelatoFee: "Gelato ",
    placeOrder: "",
    confirmOrder: "",
    "for": "",
    submittingOrderToSwap: "",
    limitPrice: "",
    outputWillBeSentTo: "",
    sell: "",
    buy: "",
    betaRelease: " BETA ",
    trade: "",
    watchList: "",
    yourPortFolio: "",
    connectWalletViewPortFolio: ".",
    limitOrders: "",
    cancelOrder: "",
    all: "",
    open: "",
    executed: "",
    cancelled: "",
    inputAmount: "",
    outputAmount: "",
    status: "",
    noLimitOrder: " {{ orderType }} ",
    cancellingOrder: "...",
    cancelLimitOrder: " {{ outputCurrency }}  {{ inputCurrency }}",
    executionPrice: "",
    seeMore: "",
    seeLess: ""
};
var buyPage = {
    buyAvaxInfo: " AVAX",
    privacyInfo: "Arcanum ",
    firstName: "",
    lastName: "",
    email: "",
    buyAvax: " AVAX"
};
var votePage = {
    unlockVotes: "",
    updateDelegation: "",
    pangolinGovernance: "Pangolin",
    earnedPngTokens: "{{ pngSymbol }} Pangolin ",
    eligibleToVote: " {{ pngSymbol }}  {{ pngSymbol }}",
    governanceVotes: "",
    proposals: "",
    allProposals: "",
    backToProposals: "",
    unlockVoting: "",
    votes: "  ",
    delegatedTo: "",
    edit: "",
    noProposalsFound: "",
    proposalCommunityMembers: "",
    minimumThreshold: " 1,000,000 {{ pngSymbol }}",
    votingStarted: "",
    votingStarts: " ",
    votingEnded: " ",
    votingEnds: "",
    voteFor: "",
    voteAgainst: "",
    against: "",
    "for": "",
    details: "",
    overview: "",
    proposer: "",
    about: "",
    vote: "",
    executed: "",
    rejected: "",
    notSupported: ""
};
var IDOPage = {
    pangolinIDOs: "Initial DEX Offering (IDO)",
    pangolinIDODescription: " DEX  (IDO)   Avalanche .",
    upcomingIDOs: "",
    endedIDOs: "",
    allIDOs: " IDO",
    noIDOsFound: " IDO",
    IDOAnnounced: " IDO ."
};
var swapHooks = {
    connectWallet: "",
    enterAmount: "",
    selectToken: "",
    enterRecipient: "",
    invalidRecipient: "",
    insufficient: " ",
    balance: ""
};
var mintHooks = {
    connectWallet: "",
    insufficientInputAmount: "",
    invalidPair: "",
    enterAmount: "",
    insufficient: " ",
    balance: " balance"
};
var stakeHooks = {
    connectWallet: "",
    enterAmount: ""
};
var burnHooks = {
    connectWallet: "",
    enterAmount: ""
};
var migratePage = {
    stake: "",
    unstake: "",
    add: "",
    remove: "",
    startMigratingNow: "",
    startMigratingNowDescription: " Arcanum's V2 ",
    seeMore: "",
    migrateWithEase: "",
    migrateWithDescription: "",
    alreadyMigrate: "",
    walletMigrate: "",
    alreadyEarned: "",
    migrateNow: "",
    learn: "",
    moveYourTokensToNewContracts: " Arcanum V2",
    readyToMigrate: "",
    apr: "APR:",
    totalValueLocked: "",
    lowVolatility: "",
    compoundable: "",
    migrate: "",
    migrationModalDescription: "",
    choosePool: "",
    pool: "",
    availableToDeposit: " ",
    poolInfoDescription: "",
    dollarWorth: " ",
    usd: "USD",
    yourRate: " ",
    unclaimedPng: "{{ pngSymbol }}: ",
    shareOfPool: " ",
    choose: "",
    selectAll: "",
    loading: "",
    back: "",
    availableToUnstake: ": ",
    submittingTransaction: "",
    moveYourTokensToNewContractsDescription: "... Arcanum's ",
    migrateModalHeading: " {{ current }}  {{ total }} "
};
var dashboardPage = {
    dashboard: "Dashboard",
    greetings: "Greetings kind guests! Lets ape in today",
    portfolioValue: "Portfolio Value",
    earned: "Earned",
    coins: "Coins",
    followedWallets: "Followed Wallets",
    earned_dailyIncome: "Daily Income",
    earned_weeklyIncome: "Weekly Income",
    earned_totalEarned: "Total Earned",
    earned_claim: "Claim",
    earned_customizePools: "Customize Pools",
    followed_address: "Address",
    followed_worth: "Worth",
    followed_interact: "Interact"
};
var stakePage = {
    totalStaked: "Total Staked",
    apr: "Annual Percentage Rate",
    seeDetails: "SEE DETAILS",
    stake: "STAKE",
    earn: "Earn {{symbol}}",
    stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error = {
    missingCurrencyAmounts: "",
    missingTokens: "",
    missingDependencies: "",
    missingLiquidityAmount: "",
    couldNotWrap: "",
    attemptingToConfirmApproval: ""
};
var sarTitle = {
    addMore: "",
    unstake: "",
    compound: "",
    claim: "",
    interactingID: " ID  {{ id }}"
};
var sarStake = {
    createNewPosition: "",
    stake: "",
    staking: "",
    walletBalance: " {{ balance }} {{ symbol }}",
    max: "",
    dollarValue: "",
    buy: " {{ symbol }}",
    averageAPR: "",
    startingApr: " 4 ",
    weeklyDistributed: " {{ symbol }} ",
    confirmDescription: " SAR Nft  NFT {{ symbol }} ",
    successSubmit: "",
    yourAprRecalculated: "",
    summary: "",
    pending: "Staking {{ balance }} {{ symbol }}",
    transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore = {
    stakeMore: "",
    choosePosition: "",
    confirmDescription: " {{ symbol }}  SAR NFT   APR   APR  0%   NFT ",
    newAPR: "",
    add: "",
    pending: " {{ balance }} {{ symbol }}"
};
var sarUnstake = {
    unstake: "",
    unstaking: " {{ balance }} {{ symbol }}",
    stakedBalance: "Staked {{ balance }} {{ symbol }}",
    confirmDescription: "APR0%\nstakeNFT",
    successSubmit: "",
    pending: " {{ balance }} {{ symbol }}",
    transactionSummary: "Unstaked {{ balance }} {{ symbol }}",
    currentAPR: "",
    unstakeWarning: "0%",
    aprAfter: "APR  "
};
var sarCompound = {
    compound: "",
    compounding: "",
    successSubmit: "",
    pending: "",
    transactionSummary: "",
    aprAfter: " APR",
    reward: "",
    description: " APR  0  APR  ",
    noRewards: ""
};
var sarClaim = {
    claim: "",
    claiming: "",
    description: "SARAPR0APR",
    successSubmit: "",
    pending: "",
    transactionSummary: "",
    aprAfter: "",
    noRewards: ""
};
var sarPortfolio = {
    noPositions: "PANGUARDIAN NFT\n",
    start: "",
    positionId: "",
    apr: "",
    amount: "",
    newest: "",
    oldest: "",
    sortBy: ""
};
var pangoChef = {
    claimWarning1: "",
    claimWarning2: " APR  0",
    compoundWarning: " {{ token0 }}-{{ token1 }}  {{ currency }}-{{ png }}   {{ png }}  {{ currency }} ",
    compoundAmountWarning: " {{ amount }} {{ symbol }} ",
    compoundAmountWarning2: " {{ symbol }} {{ png }} ",
    highVolalityWarning: "",
    compoundSuccess: "",
    compoundTransactionSummary: "",
    removeWarning: " APR  0 APR ",
    lockingPoolZeroWarning: "  "
};
var bridge = {
    availableRoutes: "Available Routes ({{ number }})",
    activeTransfers: "Active Transfers ({{ number }})",
    historicalTransfers: "Historical Transfers ({{ number }})",
    bridgeCard: {
        advanceOptions: "Advance Options",
        title: "Cross Chain",
        swap: "Swap",
        loader: {
            labels: {
                waitingReceivingChain: "Waiting for receiving chain..."
            },
            bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
        },
        filter: {
            bridgePrioritization: "Bridge Prioritization",
            slippage: "Slippage",
            infiniteApproval: "Infinite Approval",
            activeInfiniteApproval: "Active Infinite Approval",
            bridges: "Bridges",
            exchanges: "Exchanges"
        }
    },
    bridgeInputsWidget: {
        tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
        max: "MAX"
    },
    bridgeRoute: {
        selected: "Selected",
        clickToSelect: "Click to select",
        singleTransaction: "Single transaction including",
        estimatedToken: "Estimated Token: {{ token }}",
        estimatedResult: "Estimated Result: {{ result }}",
        min: "{{ minute }} min",
        gasCost: "{{ gasCost }} Gas Cost"
    },
    bridgeTransfer: {
        date: "Date",
        from: "From",
        to: "To",
        via: "Via",
        state: "State",
        resumeSwap: "Resume Swap"
    },
    bridgePrioritizations: {
        recommended: "Recommended",
        fast: "Fast",
        normal: "Normal"
    }
};
var dropdown = {
    select: "Select"
};
var zhTranslation = {
    header: header,
    accountDetails: accountDetails,
    addressInputPanel: addressInputPanel,
    currencyInputPanel: currencyInputPanel,
    earn: earn,
    menu: menu,
    modalView: modalView,
    navigationTabs: navigationTabs,
    popups: popups,
    positionCard: positionCard,
    searchModal: searchModal,
    settings: settings,
    swap: swap,
    toggle: toggle,
    tokenWarningModal: tokenWarningModal,
    transactionConfirmation: transactionConfirmation,
    transactionSettings: transactionSettings,
    vote: vote,
    walletModal: walletModal,
    web3ReactManager: web3ReactManager,
    web3Status: web3Status,
    gasFeeAlert: gasFeeAlert,
    addLiquidity: addLiquidity,
    airdrop: airdrop,
    earnPage: earnPage,
    pool: pool,
    poolFinder: poolFinder,
    removeLiquidity: removeLiquidity,
    swapPage: swapPage,
    buyPage: buyPage,
    votePage: votePage,
    IDOPage: IDOPage,
    swapHooks: swapHooks,
    mintHooks: mintHooks,
    stakeHooks: stakeHooks,
    burnHooks: burnHooks,
    migratePage: migratePage,
    dashboardPage: dashboardPage,
    stakePage: stakePage,
    error: error,
    sarTitle: sarTitle,
    sarStake: sarStake,
    sarStakeMore: sarStakeMore,
    sarUnstake: sarUnstake,
    sarCompound: sarCompound,
    sarClaim: sarClaim,
    sarPortfolio: sarPortfolio,
    pangoChef: pangoChef,
    bridge: bridge,
    dropdown: dropdown
};

const resources = {
    en: {
        translation: enTranslation,
    },
    de: {
        translation: deTranslation,
    },
    tr: {
        translation: trTranslation,
    },
    zh: {
        translation: zhTranslation,
    },
    es: {
        translation: esTranslation,
    },
    fr: {
        translation: frTranslation,
    },
    pt: {
        translation: ptBrTranslation,
    },
    vn: {
        translation: vnTranslation,
    },
};
const availableLanguages = ['en', 'de', 'tr', 'zh', 'es', 'fr', 'pt-br', 'vn'];
const defaultLocale = 'en';
const determineLngFn = (code) => {
    if (!code || code.length === 0) {
        return (i18next.language = defaultLocale);
    }
    // Full locale match
    if (availableLanguages.includes(code.toLowerCase())) {
        return (i18next.language = code.toLowerCase());
    }
    // Base locale match
    const codeBase = code.split('-')[0].toLowerCase();
    if (availableLanguages.includes(codeBase)) {
        return (i18next.language = codeBase);
    }
    // Fallback
    return (i18next.language = defaultLocale);
};
i18next
    .use(LanguageDetector)
    .use(initReactI18next)
    .init({
        resources,
        react: {
            useSuspense: true,
        },
        load: 'languageOnly',
        lowerCaseLng: true,
        fallbackLng: determineLngFn,
        preload: [defaultLocale],
        keySeparator: '.',
        interpolation: { escapeValue: false },
    });

function Updater() {
    const { chainId } = usePangolinWeb3();
    const { library } = useLibrary();
    const dispatch = useDispatch();
    const feeTo = useSelector((state) => state.pswap.feeTo);
    const router = useMemo(() => {
        if (!chainId || !library || !feeTo || feeTo === ZERO_ADDRESS)
            return null;
        return getRouterContractDaaS(chainId, library);
    }, [chainId, library, feeTo]);
    const feeInfoResponse = useSingleCallResult(router, 'getFeeInfo', [feeTo], NEVER_RELOAD).result;
    useEffect(() => {
        if (!feeInfoResponse || !dispatch || !updateFeeInfo)
            return;
        const feeInfo = {
            feePartner: feeInfoResponse.feePartner,
            feeProtocol: feeInfoResponse.feeProtocol,
            feeTotal: feeInfoResponse.feeTotal,
            feeCut: feeInfoResponse.feeCut,
            initialized: feeInfoResponse.initialized,
        };
        dispatch(updateFeeInfo({ feeInfo }));
    }, [feeInfoResponse, dispatch, updateFeeInfo]);
    return null;
}

const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            staleTime: 5 * 1000 * 60,
            refetchOnWindowFocus: false,
        },
    },
});
function PangolinProvider({ chainId = ChainId.AVALANCHE, library, children, account, theme, }) {
    return (jsx(Provider, Object.assign({ store: store, context: StoreContext }, { children: jsx(PangolinWeb3Provider, Object.assign({ chainId: chainId, library: library, account: account }, { children: jsx(ThemeProvider, Object.assign({ theme: theme }, { children: jsxs(QueryClientProvider, Object.assign({ client: queryClient }, { children: [jsx(Updater$3, {}), jsx(ApplicationUpdater, {}), jsx(Updater$2, {}), jsx(Updater$1, {}), jsx(Updater, {}), isEvmChain(chainId) ? (jsx(Provider, Object.assign({ store: galetoStore }, { children: jsx(GelatoProvider, Object.assign({ library: library, chainId: chainId, account: account !== null && account !== void 0 ? account : undefined, useDefaultTheme: false, handler: 'pangolin' }, { children: children })) }))) : (children)] })) })) })) })));
}

export { ALLOWED_PRICE_IMPACT_HIGH, ALLOWED_PRICE_IMPACT_LOW, ALLOWED_PRICE_IMPACT_MEDIUM, ANALYTICS_PAGE, AVALANCHE_CHAIN_PARAMS, AddLiquidityModal, BASES_TO_CHECK_TRADES_AGAINST, BASES_TO_TRACK_LIQUIDITY_FOR, BIG_INT_SECONDS_IN_WEEK, BIG_INT_TWO, BIG_INT_ZERO, BIPS_BASE, BLOCKED_PRICE_IMPACT_NON_EXPERT, Box, Bridge, Button, COINGECKO_API, COINGECKO_CURRENCY_ID, COINGEKO_BASE_URL, CUSTOM_BASES, Checkbox, CheckboxGroup, CoinDescription, Collapsed, CurrencyInput, CurrencyLogo, DEFAULT_DEADLINE_FROM_NOW, DIRECTUS_URL_NEWS, DoubleCurrencyLogo, Drawer, DropdownMenu, INITIAL_ALLOWED_SLIPPAGE, IS_IN_IFRAME, LANDING_PAGE, Loader, Logo$1 as Logo, MINICHEF_ADDRESS, MIN_ETH, Modal, MyPortfolio, NATIVE, NEAR_ACCOUNT_MIN_STORAGE_AMOUNT, NEAR_API_BASE_URL, NEAR_EXCHANGE_CONTRACT_ADDRESS, NEAR_LP_STORAGE_AMOUNT, NEAR_MIN_DEPOSIT_PER_TOKEN, NEAR_MIN_DEPOSIT_PER_TOKEN_FARM, NEAR_STORAGE_PER_TOKEN, NEAR_STORAGE_TO_REGISTER_WITH_FT, NETWORK_CHAIN_ID, NearConnector, NetworkContextName, NetworkSelection, NewsWidget, NumberOptions, ONE_BIPS, ONE_FRACTION, ONE_TOKEN, ONE_YOCTO_NEAR, ONLY_ZEROS, OPEN_API_DEBANK, PANGOCHEF_ADDRESS, PANGOCHEF_COMPOUND_SLIPPAGE, PANGOLIN_API_BASE_URL, PANGOLIN_PERSISTED_KEYS, PANGOLIN_TOKENS_REPO_RAW_BASE_URL, PINNED_PAIRS, PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN, PROVIDER_MAPPING, PangolinProvider, PoolImportModal, PoolType$1 as PoolType, Pools, Portfolio$1 as Portfolio, ROUTER_ADDRESS, ROUTER_DAAS_ADDRESS, RadioButton, RadioButtonGroup, SAR_STAKING_ADDRESS, SUBGRAPH_BASE_URL, SUPPORTED_WALLETS, SWAP_DEFAULT_CURRENCY, SarMangePortfolio as SarManageWidget, SarNFTPortfolio, SarManageWidget as SarStakeWidget, SelectTokenDrawer$1 as SelectTokenDrawer, ShowMore, Stat, Step, Steps, SwapTypes, SwapWidget, Switch, TIMEFRAME, TRUSTED_TOKEN_ADDRESSES, Text, TextInput, ToggleButtons, Tooltip, TransactionCompleted, Wallet, WalletModal, WatchList, ZERO_ADDRESS, availableLanguages, bitKeep, calculateTotalStakedAmountInAvax, calculateTotalStakedAmountInAvaxFromPng, existSarContract, fetchChunkedAprs, fetchMinichefData, getEtherscanLink, getNetworkLibrary, gnosisSafe, injected, near, nearFn, network, pangolinReducers, shortenAddress, talisman, useAccountBalanceHook, useActivePopups, useAddPopup, useAllTokens, useAllTransactions, useAllTransactionsClearer, useDerivedStakeInfo, useDerivedSwapInfo, useGelatoLimitOrderDetail, useGelatoLimitOrderList, useGetAllFarmData, useGetAllFarmDataHook, useGetMinichefStakingInfosViaSubgraphHook, useGetUserLP, useLibrary, useMinichefPools, useMinichefStakingInfos, useMinichefStakingInfosHook, usePair, usePangoChefInfos, useParsedQueryString, useRemovePopup, useSarPositions, useSarStakeInfo, useSwapActionHandlers, useTokenBalance, useTokenBalanceHook, useTotalSupply, useTotalSupplyHook, useUSDCPrice, useUSDCPriceHook, walletconnect, walletlink, wrappedCurrency, xDefi };
//# sourceMappingURL=index.js.map
