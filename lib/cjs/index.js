'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var limitOrdersReact = require('@gelatonetwork/limit-orders-react');
var sdk = require('@arcanumdex/sdk');
var reactI18next = require('react-i18next');
var reactQuery = require('react-query');
var reactRedux = require('react-redux');
var React = require('react');
var reactDeviceDetect = require('react-device-detect');
var AutoSizer = require('react-virtualized-auto-sizer');
var reactWindow = require('react-window');
var reactFeather = require('react-feather');
var styled = require('styled-components');
var ReactSwitch = require('react-switch');
var tslib = require('tslib');
var merge = require('lodash.merge');
var ReactGA = require('react-ga');
var get = require('lodash.get');
var polished = require('polished');
var styledSystem = require('styled-system');
var reactIs = require('react-is');
var deepEqual = require('deep-equal');
var providers$1 = require('@ethersproject/providers');
var core = require('@web3-react/core');
var BN = require('bn.js');
var safeAppsWeb3React = require('@gnosis.pm/safe-apps-web3-react');
var web3ReactInjectedConnector = require('@arcanumdex/web3-react-injected-connector');
var web3reactV6Connector = require('@talismn/web3react-v6-connector');
var walletconnectConnector = require('@web3-react/walletconnect-connector');
var walletlinkConnector = require('@web3-react/walletlink-connector');
var events = require('events');
var nearApiJs = require('near-api-js');
var providers = require('near-api-js/lib/providers');
var toolkit = require('@reduxjs/toolkit');
var reduxLocalstorageSimple = require('redux-localstorage-simple');
var tokenLists = require('@arcanumdex/token-lists');
var address = require('@ethersproject/address');
var bignumber = require('@ethersproject/bignumber');
var constants = require('@ethersproject/constants');
var contracts = require('@ethersproject/contracts');
var IPangolinRouter = require('@arcanumdex/exchange-contracts/artifacts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol/IPangolinRouter.json');
var IPangolinRouterSupportingFees = require('@arcanumdex/exchange-contracts/artifacts/contracts/pangolin-periphery/interfaces/IPangolinRouterSupportingFees.sol/IPangolinRouterSupportingFees.json');
var ReactTooltip = require('react-tooltip');
var useCollapse = require('react-collapsed');
var strings = require('@ethersproject/strings');
var axios = require('axios');
var flatMap = require('lodash.flatmap');
var borsh = require('borsh');
var abi$1 = require('@ethersproject/abi');
var IPangolinPair = require('@arcanumdex/exchange-contracts/artifacts/contracts/pangolin-core/interfaces/IPangolinPair.sol/IPangolinPair.json');
var LRUCache = require('lru-cache');
var MiniChefV2 = require('@arcanumdex/exchange-contracts/artifacts/contracts/mini-chef/MiniChefV2.sol/MiniChefV2.json');
require('@arcanumdex/exchange-contracts/artifacts/contracts/pangolin-token/Png.sol/Png.json');
var StakingRewards = require('@arcanumdex/exchange-contracts/artifacts/contracts/staking-rewards/StakingRewards.sol/StakingRewards.json');
var units = require('@ethersproject/units');
var qs = require('qs');
var utils = require('ethers/lib/utils');
var ethers = require('ethers');
var schema = require('@arcanumdex/token-lists/src/tokenlist.schema.json');
var Ajv = require('ajv');
var IArcanumPair_json = require('@arcanumdex/exchange-contracts/artifacts/contracts/arcanum-core/interfaces/IArcanumPair.sol/IArcanumPair.json');
var isEqual = require('lodash.isequal');
var apolloCacheInmemory = require('apollo-cache-inmemory');
var apolloClient = require('apollo-client');
var apolloLinkHttp = require('apollo-link-http');
var graphqlRequest = require('graphql-request');
var gql = require('graphql-tag');
var i18next = require('i18next');
var LanguageDetector = require('i18next-browser-languagedetector');
var reactPortal = require('react-portal');
var Scrollbars = require('react-custom-scrollbars');
var recharts = require('recharts');
var dayjs = require('dayjs');
var utc = require('dayjs/plugin/utc');
var numeral = require('numeral');
var ReactMarkdown = require('react-markdown');
var Slider = require('react-slick');
var remarkGfm = require('remark-gfm');
var Select = require('react-select');
var ReactHtmlParser = require('react-html-parser');
var reactUse = require('react-use');
var ReactPaginate = require('react-paginate');
var reactTabs = require('react-tabs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var AutoSizer__default = /*#__PURE__*/_interopDefaultLegacy(AutoSizer);
var styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);
var ReactSwitch__default = /*#__PURE__*/_interopDefaultLegacy(ReactSwitch);
var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);
var ReactGA__default = /*#__PURE__*/_interopDefaultLegacy(ReactGA);
var get__default = /*#__PURE__*/_interopDefaultLegacy(get);
var deepEqual__default = /*#__PURE__*/_interopDefaultLegacy(deepEqual);
var BN__default = /*#__PURE__*/_interopDefaultLegacy(BN);
var IPangolinRouter__default = /*#__PURE__*/_interopDefaultLegacy(IPangolinRouter);
var IPangolinRouterSupportingFees__default = /*#__PURE__*/_interopDefaultLegacy(IPangolinRouterSupportingFees);
var ReactTooltip__default = /*#__PURE__*/_interopDefaultLegacy(ReactTooltip);
var useCollapse__default = /*#__PURE__*/_interopDefaultLegacy(useCollapse);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var flatMap__default = /*#__PURE__*/_interopDefaultLegacy(flatMap);
var IPangolinPair__default = /*#__PURE__*/_interopDefaultLegacy(IPangolinPair);
var LRUCache__default = /*#__PURE__*/_interopDefaultLegacy(LRUCache);
var MiniChefV2__default = /*#__PURE__*/_interopDefaultLegacy(MiniChefV2);
var StakingRewards__default = /*#__PURE__*/_interopDefaultLegacy(StakingRewards);
var qs__default = /*#__PURE__*/_interopDefaultLegacy(qs);
var schema__default = /*#__PURE__*/_interopDefaultLegacy(schema);
var Ajv__default = /*#__PURE__*/_interopDefaultLegacy(Ajv);
var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);
var gql__default = /*#__PURE__*/_interopDefaultLegacy(gql);
var i18next__default = /*#__PURE__*/_interopDefaultLegacy(i18next);
var LanguageDetector__default = /*#__PURE__*/_interopDefaultLegacy(LanguageDetector);
var Scrollbars__default = /*#__PURE__*/_interopDefaultLegacy(Scrollbars);
var dayjs__default = /*#__PURE__*/_interopDefaultLegacy(dayjs);
var utc__default = /*#__PURE__*/_interopDefaultLegacy(utc);
var numeral__default = /*#__PURE__*/_interopDefaultLegacy(numeral);
var ReactMarkdown__default = /*#__PURE__*/_interopDefaultLegacy(ReactMarkdown);
var Slider__default = /*#__PURE__*/_interopDefaultLegacy(Slider);
var remarkGfm__default = /*#__PURE__*/_interopDefaultLegacy(remarkGfm);
var Select__default = /*#__PURE__*/_interopDefaultLegacy(Select);
var ReactHtmlParser__default = /*#__PURE__*/_interopDefaultLegacy(ReactHtmlParser);
var ReactPaginate__default = /*#__PURE__*/_interopDefaultLegacy(ReactPaginate);

const MEDIA_WIDTHS = {
    upToExtraSmall: 500,
    upToSmall: 720,
    upToMedium: 960,
    upToLarge: 1280,
};
const mediaWidthTemplates = Object.keys(MEDIA_WIDTHS).reduce((acc, sizeKey) => {
    acc[sizeKey] = (a, b, c) => styled.css `
      @media (max-width: ${MEDIA_WIDTHS[sizeKey]}px) {
        ${styled.css(a, b, c)}
      }
    `;
    return acc;
}, {});
const white = '#FFFFFF';
const black = '#000000';
const philippineYellow = '#FFC800'; //primary
const mustardYellow = '#E1AA00';
const eerieBlack = '#1C1C1C';
const ghostWhite = '#F7F8FA';
const ghostWhite1 = '#FAF9FD';
const chineseBlack = '#111111';
const darkGunmetal = '#212427';
const platinum = '#E5E5E5';
const darkSilver = '#717171';
const venetianRed = '#CC1512';
const oceanBlue = '#18C145';
const quickSilver = '#A3A3A3';
const warning$1 = '#F3841E';
const success = '#18C145';
const defaultColors = {
    // base
    white,
    black,
    // text
    text1: '#000000',
    text2: '#565A69',
    text3: '#888D9B',
    text4: '#C3C5CB',
    text5: '#EDEEF2',
    text6: '#EDEEF2',
    text7: '#000000',
    text8: '#565A69',
    text9: '#000000',
    text10: '#000000',
    text11: '#18C145',
    text12: '#E84142',
    text13: '#000000',
    text14: '#000000',
    text15: '#000000',
    // backgrounds / greys
    bg1: '#FFFFFF',
    bg2: '#F7F8FA',
    bg3: '#EDEEF2',
    bg4: '#CED0D9',
    bg5: '#888D9B',
    bg6: '#FFFFFF',
    bg7: '#FFFFFF',
    bg8: '#FFFFFF',
    bg9: '#000000',
    //specialty colors
    modalBG: 'rgba(0,0,0,0.3)',
    modalBG2: 'rgba(0,0,0,0.8)',
    advancedBG: 'rgba(255,255,255,0.6)',
    closeCircleBG: 'rgba(255,255,255,0.2)',
    //primary colors
    primary1: '#FF6B00',
    primary2: '#FF6B00',
    primary3: '#FF6B00',
    primary4: '#FF6B00',
    primary5: '#FF6B00',
    primary6: '#FFFFFF',
    // color text
    primaryText1: '#ffffff',
    // secondary colors
    secondary1: '#ff007a',
    secondary2: '#F6DDE8',
    secondary3: '#FDEAF1',
    // other
    red1: '#FF6871',
    red2: '#F82D3A',
    green1: '#27AE60',
    yellow1: '#FFE270',
    yellow2: '#F3841E',
    blue1: '#2172E5',
    avaxRed: '#E84142',
    // theme color objects for components
    swapWidget: {
        primary: black,
        secondary: quickSilver,
        backgroundColor: ghostWhite,
        detailsBackground: white,
        interactiveColor: quickSilver,
        interactiveBgColor: platinum,
    },
    drawer: {
        text: black,
        backgroundColor: ghostWhite,
    },
    textInput: {
        text: quickSilver,
        labelText: quickSilver,
        placeholderText: quickSilver,
        backgroundColor: white,
    },
    currencySelect: {
        defaultText: black,
        selectedText: black,
        defaultBackgroundColor: philippineYellow,
        selectedBackgroundColor: ghostWhite,
    },
    loader: {
        text: black,
    },
    numberOptions: {
        text: black,
        activeTextColor: black,
        activeBackgroundColor: philippineYellow,
        inactiveBackgroundColor: white,
        borderColor: white,
    },
    switch: {
        onColor: philippineYellow,
        offColor: '#CED0D9',
        backgroundColor: platinum,
    },
    toggleButton: {
        backgroundColor: platinum,
        selectedColor: ghostWhite,
        fontColor: chineseBlack,
    },
    button: {
        primary: {
            background: philippineYellow,
            color: black,
        },
        secondary: {
            background: chineseBlack,
            color: white,
        },
        outline: {
            borderColor: philippineYellow,
            color: black,
        },
        plain: {
            color: black,
        },
        disable: {
            background: platinum,
            color: darkSilver,
        },
        confirmed: {
            background: oceanBlue,
            color: oceanBlue,
            borderColor: oceanBlue,
        },
    },
    bridge: {
        primaryBgColor: white,
        secondaryBgColor: ghostWhite,
        text: black,
        infoIconColor: black,
        routeInfoColor: platinum,
        transferKeyColor: quickSilver,
        loaderCloseIconColor: mustardYellow,
        informationBoxesBackgroundColor: chineseBlack,
    },
    tabs: {
        tabColor: quickSilver,
        tabListColor: black,
        tabPanelBorderColor: quickSilver,
    },
    dropdown: {
        color: black,
        primaryBgColor: white,
    },
    primary: philippineYellow,
    mustardYellow,
    eerieBlack,
    ghostWhite,
    ghostWhite1,
    chineseBlack,
    darkGunmetal,
    platinum,
    darkSilver,
    venetianRed,
    oceanBlue,
    quickSilver,
    error: venetianRed,
    warning: warning$1,
    success,
    color2: ghostWhite,
    color3: platinum,
    color4: chineseBlack,
    color5: white,
    color6: chineseBlack,
    color7: ghostWhite,
    color8: platinum,
    color9: quickSilver,
    color10: white,
    color11: white,
    color12: platinum,
};
const defaultTheme = Object.assign(Object.assign({}, defaultColors), { grids: {
        sm: 8,
        md: 12,
        lg: 24,
    }, 
    //shadows
    shadow1: '#2F80ED', 
    // media queries
    mediaWidth: mediaWidthTemplates, 
    // css snippets
    flexColumnNoWrap: styled.css `
    display: flex;
    flex-flow: column nowrap;
  `, flexRowNoWrap: styled.css `
    display: flex;
    flex-flow: row nowrap;
  ` });
function ThemeProvider({ children, theme }) {
    const finalTheme = merge__default["default"]({}, defaultTheme, theme || {});
    return jsxRuntime.jsx(styled.ThemeProvider, Object.assign({ theme: finalTheme }, { children: children }));
}
const useTheme = () => {
    const theme = React.useContext(styled.ThemeContext);
    if (!theme) {
        throw Error('useTheme is used outside of ThemeContext');
    }
    return theme;
};
const StyledLink = styled__default["default"].a `
  text-decoration: none;
  cursor: pointer;
  color: ${({ theme }) => theme.primary};
  font-weight: 500;

  :hover {
    text-decoration: underline;
  }

  :focus {
    outline: none;
    text-decoration: underline;
  }

  :active {
    text-decoration: none;
  }
`;
/**
 * Outbound link that handles firing google analytics events
 */
function ExternalLink(_a) {
    var { target = '_blank', href, rel = 'noopener noreferrer' } = _a, rest = tslib.__rest(_a, ["target", "href", "rel"]);
    const handleClick = React.useCallback((event) => {
        // don't prevent default, don't redirect if it's a new tab
        if (target === '_blank' || event.ctrlKey || event.metaKey) {
            // eslint-disable-next-line import/no-named-as-default-member
            ReactGA__default["default"].outboundLink({ label: href }, () => {
                console.debug('Fired outbound link event', href);
            });
        }
        else {
            event.preventDefault();
            // send a ReactGA event and then trigger a location change
            // eslint-disable-next-line import/no-named-as-default-member
            ReactGA__default["default"].outboundLink({ label: href }, () => {
                window.location.href = href;
            });
        }
    }, [href, target]);
    return jsxRuntime.jsx(StyledLink, Object.assign({ target: target, rel: rel, href: href, onClick: handleClick }, rest));
}

// here we need to do some hack, because react-switch package is still in commonjs
// https://github.com/vitejs/vite/issues/2139#issuecomment-824557740
const BaseSwitch = ReactSwitch__default["default"].default ? ReactSwitch__default["default"].default : ReactSwitch__default["default"];
const Switch = (props) => {
    var _a, _b, _c, _d;
    const { checked, onChange, checkedIcon, disabled, height, offColor, offHandleColor, onColor, onHandleColor, uncheckedIcon, width, } = props;
    const theme = useTheme();
    return (jsxRuntime.jsx(BaseSwitch, { checked: checked, onChange: (isChecked) => onChange === null || onChange === void 0 ? void 0 : onChange(isChecked), onHandleColor: onHandleColor || ((_a = theme.switch) === null || _a === void 0 ? void 0 : _a.onColor), offHandleColor: offHandleColor || ((_b = theme.switch) === null || _b === void 0 ? void 0 : _b.offColor), onColor: onColor || ((_c = theme.switch) === null || _c === void 0 ? void 0 : _c.backgroundColor), offColor: offColor || ((_d = theme.switch) === null || _d === void 0 ? void 0 : _d.backgroundColor), uncheckedIcon: uncheckedIcon || false, checkedIcon: checkedIcon || false, disabled: disabled, height: height, width: width }));
};
Switch.defaultProps = {
    onChange: () => { },
    checked: false,
    checkedIcon: false,
    disabled: false,
    uncheckedIcon: false,
};

const Primary = (props) => props.variant === 'primary' &&
    styled.css `
    background-color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.primary) === null || _b === void 0 ? void 0 : _b.background; }};
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.primary) === null || _b === void 0 ? void 0 : _b.color; }};
  `;
const Secondary = (props) => props.variant === 'secondary' &&
    styled.css `
    background-color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.secondary) === null || _b === void 0 ? void 0 : _b.background; }};
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.secondary) === null || _b === void 0 ? void 0 : _b.background; }};
  `;
const Outline = (props) => props.variant === 'outline' &&
    styled.css `
    border: 1px solid ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.outline) === null || _b === void 0 ? void 0 : _b.borderColor; }};
    background-color: transparent;
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.outline) === null || _b === void 0 ? void 0 : _b.color; }};
  `;
const Plain = (props) => props.variant === 'plain' &&
    styled.css `
    background-color: transparent;
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.plain) === null || _b === void 0 ? void 0 : _b.color; }};
    display: flex;
    justify-content: center;
    align-items: center;
  `;
const Disable = (props) => (props.isDisabled || props.loading) &&
    styled.css `
    background-color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.disable) === null || _b === void 0 ? void 0 : _b.background; }};
    border: 1px solid transparent;
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.disable) === null || _b === void 0 ? void 0 : _b.color; }};
    cursor: auto;
    pointer-events: none;
  `;
const Confirmed = (props) => props.variant === 'confirm' &&
    styled.css `
    background-color: ${({ theme }) => { var _a, _b; return polished.lighten(0.5, ((_b = (_a = theme === null || theme === void 0 ? void 0 : theme.button) === null || _a === void 0 ? void 0 : _a.confirmed) === null || _b === void 0 ? void 0 : _b.background) || (theme === null || theme === void 0 ? void 0 : theme.oceanBlue)); }};
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.confirmed) === null || _b === void 0 ? void 0 : _b.color; }};
    border: 1px solid ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.confirmed) === null || _b === void 0 ? void 0 : _b.borderColor; }};
    opacity: 50%;
    cursor: auto;
  `;
const Root$q = styled__default["default"].button `
  padding: ${(props) => ((props === null || props === void 0 ? void 0 : props.padding) ? props === null || props === void 0 ? void 0 : props.padding : '0px')};
  width: ${({ width }) => (width ? width : '100%')};
  height: ${({ height }) => (height ? height : '51px')};
  font-weight: 500;
  text-align: center;
  border-radius: ${(props) => { var _a; return (_a = props === null || props === void 0 ? void 0 : props.borderRadius) !== null && _a !== void 0 ? _a : '8px'; }};
  outline: none;
  border: 1px solid transparent;
  color: white;
  text-decoration: none;
  display: flex;
  justify-content: center;
  flex-wrap: nowrap;
  align-items: center;
  cursor: pointer;
  position: relative;
  z-index: 1;
  text-decoration: none;
  box-sizing: border-box;

  ${Primary}
  ${Secondary}
  ${Outline}
  ${Plain}
  ${Disable}
  ${Confirmed}

  /* Customizable Colors */
  color: ${({ color, theme }) => color && get__default["default"](theme, color, color)};
  background-color: ${({ backgroundColor, theme }) => backgroundColor && get__default["default"](theme, backgroundColor, backgroundColor)};
  border: ${({ borderColor, theme }) => `1px solid ${borderColor && get__default["default"](theme, borderColor, borderColor)}`};

  > * {
    user-select: none;
  }
`;
const IconAfter = styled__default["default"].div `
  color: white;
  margin-left: 10px;
`;
const IconBefore = styled__default["default"].div `
  color: white;
  margin-right: 10px;
`;

const Button = (props) => {
    const { iconBefore, children, iconAfter, loading, loadingText, as, target } = props, rest = tslib.__rest(props, ["iconBefore", "children", "iconAfter", "loading", "loadingText", "as", "target"]);
    return (jsxRuntime.jsx(Root$q, Object.assign({}, rest, { as: as, target: target }, { children: loading ? (loadingText || 'Loading...') : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [iconBefore && jsxRuntime.jsx(IconBefore, { children: iconBefore }), children, iconAfter && jsxRuntime.jsx(IconAfter, { children: iconAfter })] })) })));
};
Button.defaultProps = {
    target: '_blank',
};

//TODO: set appropriate type
const Box = styled__default["default"].div `
  color: ${({ color, theme }) => (color ? get__default["default"](theme, color) : 'black')};
  background-color: ${({ bgColor, theme }) => (bgColor ? get__default["default"](theme, bgColor) : 'transparent')};
  ${styledSystem.space}
  ${styledSystem.layout}
  ${styledSystem.flexbox}
  ${styledSystem.typography}
  ${styledSystem.border}
  ${styledSystem.position}
`;

const Text = styled__default["default"].div `
  ${styledSystem.space}
  ${styledSystem.typography}
  ${styledSystem.position}
  color: ${({ color, theme }) => color && get__default["default"](theme, color, color)};
  cursor: ${(props) => props.cursor && props.cursor};
`;

const InputWrapper$3 = styled__default["default"](Box) `
  width: 100%;
  border-radius: 8px;
  padding: 10px;
  border: 1px solid transparent;
  display: flex;
  position: relative;
  box-sizing: border-box;
  background-color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.text; }};
  input {
    background-color: inherit;
  }
`;
const StyledInput = styled__default["default"].input `
  flex: 1;
  border: 1px solid transparent;
  font-size: ${(props) => ((props === null || props === void 0 ? void 0 : props.fontSize) ? `${props === null || props === void 0 ? void 0 : props.fontSize}px` : '18px')};
  color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.text; }};
  background-color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  outline: none;
  width: 100%;
  padding: 0;
  cursor: ${(props) => ((props === null || props === void 0 ? void 0 : props.disabled) ? 'not-allowed' : 'default')};
  -moz-appearance: textfield;
  ::-webkit-inner-spin-button,
  ::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  ::placeholder {
    color: ${({ theme }) => { var _a; return (_a = theme.textInput) === null || _a === void 0 ? void 0 : _a.placeholderText; }};
  }
`;
const AddonAfter = styled__default["default"](Box) `
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
`;
const AddonBefore = styled__default["default"](Box) `
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
`;
const ErrorText = styled__default["default"](Text) `
  margin-top: 5px;
  color: ${({ theme }) => theme.red2};
  font-size: 12px;
`;

const TextInput = (props) => {
    const { label, addonLabel, addonAfter, addonBefore, error, showErrorMessage = true, onChange, isNumeric, getRef = () => { }, autoComplete = 'off' } = props, rest = tslib.__rest(props, ["label", "addonLabel", "addonAfter", "addonBefore", "error", "showErrorMessage", "onChange", "isNumeric", "getRef", "autoComplete"]);
    const inputRegex = new RegExp(`^\\d+\\.?\\d*$`);
    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: label ? 'space-between' : 'flex-end' }, { children: [label && jsxRuntime.jsx(Text, Object.assign({ color: "textInput.labelText" }, { children: label })), addonLabel && addonLabel] })), jsxRuntime.jsxs(InputWrapper$3, { children: [addonBefore && jsxRuntime.jsx(AddonBefore, { children: addonBefore }), jsxRuntime.jsx(StyledInput, Object.assign({}, rest, { autoComplete: autoComplete, ref: (ref) => getRef(ref), type: isNumeric ? 'number' : 'text', onChange: (e) => {
                            const value = e.target.value;
                            if (isNumeric && !!value) {
                                if (inputRegex.test(value)) {
                                    onChange && onChange(value);
                                }
                            }
                            else {
                                onChange && onChange(value);
                            }
                        } })), addonAfter && jsxRuntime.jsx(AddonAfter, { children: addonAfter })] }), showErrorMessage && !!error && jsxRuntime.jsx(ErrorText, { children: error })] }));
};

const StepWrapper = styled__default["default"]('div') `
  margin-top: auto;
  display: flex;
  justify-content: space-between;
`;
const StepItem = styled__default["default"].div `
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
  font-weight: ${({ active }) => (active ? 'bold' : 'normal')};
  pointer-events: ${({ disabled }) => (disabled ? 'none' : 'auto')};
  opacity: ${({ disabled }) => (disabled ? 0.4 : 1)};
  cursor: ${({ disabled }) => (disabled ? 'none' : 'pointer')};

  @media (max-width: 768px) {
    font-size: 12px;
  }
  &:before {
    position: absolute;
    content: '';
    border-bottom: ${({ theme }) => `2px solid ${theme.bg5}`};
    width: 100%;
    top: ${({ progressDot }) => (progressDot ? '21px' : '15px')};
    left: ${({ progressDot }) => (progressDot ? '-50%' : '-38%')};
    z-index: 2;
  }
  &:after {
    position: absolute;
    content: '';
    border-bottom: 2px solid;
    border-bottom-color: ${({ completed, theme }) => (completed ? theme.primary : theme.bg5)};
    width: 100%;
    top: ${({ progressDot }) => (progressDot ? '21px' : '15px')};
    left: ${({ progressDot }) => (progressDot ? '50%' : '38%')};
    z-index: ${({ completed }) => (completed ? 3 : 2)};
  }
  &:first-child:before {
    content: none;
  }
  &:last-child::after {
    content: none;
  }
`;
const StepCounter = styled__default["default"].div `
  position: relative;
  z-index: 5;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background: ${({ completed, active, theme }) => (completed || active ? theme.primary : theme.bg5)};
  color: ${({ completed, active, theme }) => (completed || active ? theme.text6 : theme.white)};
  margin-bottom: 6px;
`;
const StepName = styled__default["default"]('div') `
  margin-top: auto;
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
  color: ${({ theme }) => theme.text4};
`;
const IconDot = styled__default["default"].div `
  position: relative;
  z-index: 5;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: ${({ completed, active, theme }) => (completed || active ? theme.primary : theme.bg5)};
  margin-top: 17px;
`;

const Step = (props) => {
    const { active, completed, stepNumber, disabled, title, progressDot, stepIndex, onStepClick } = props;
    const renderIconNode = () => {
        let iconNode;
        if (progressDot) {
            iconNode = jsxRuntime.jsx(IconDot, { completed: completed, active: active });
        }
        else {
            iconNode = (jsxRuntime.jsx(StepCounter, Object.assign({ completed: completed, active: active }, { children: stepNumber })));
        }
        return iconNode;
    };
    const onClick = () => {
        onStepClick && onStepClick(stepIndex || 0);
    };
    return (jsxRuntime.jsxs(StepItem, Object.assign({ completed: completed, active: active, onClick: onClick, disabled: disabled, progressDot: progressDot }, { children: [renderIconNode(), active && jsxRuntime.jsxs(StepName, { children: [" ", title] })] })));
};

const toChildrenArray = (children, option = {}) => {
    let ret = [];
    React__default["default"].Children.forEach(children, (child) => {
        if ((child === undefined || child === null) && !option.keepEmpty) {
            return;
        }
        if (Array.isArray(child)) {
            ret = ret.concat(toChildrenArray(child));
        }
        else if (reactIs.isFragment(child) && child.props) {
            ret = ret.concat(toChildrenArray(child.props.children, option));
        }
        else {
            ret.push(child);
        }
    });
    return ret;
};

const Steps = (props) => {
    const { children, current = 0, progressDot = false, onChange, allowChangeOnClick = true } = props;
    const onStepClick = (next) => {
        if (onChange && current !== next && allowChangeOnClick) {
            onChange(next);
        }
    };
    return (jsxRuntime.jsx(StepWrapper, { children: toChildrenArray(children).map((child, index) => {
            const stepNumber = index;
            const childProps = Object.assign({ stepNumber: `${stepNumber + 1}`, stepIndex: stepNumber, key: stepNumber, progressDot, onStepClick: onChange && onStepClick, active: stepNumber === current, completed: stepNumber < (current || 0) }, child.props);
            return React.cloneElement(child, childProps);
        }) }));
};

const Root$p = styled__default["default"].div `
  flex-direction: row;
  align-items: center;
  display: flex;
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  pointer-events: ${({ disabled }) => (disabled ? 'none' : '')};
`;
const OuterSquare = styled__default["default"].div `
  width: ${(props) => `${props === null || props === void 0 ? void 0 : props.size}px`};
  height: ${(props) => `${props === null || props === void 0 ? void 0 : props.size}px`};
  border: 1px solid;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: ${({ theme }) => theme.bg4};
  border-color: ${({ theme }) => theme.bg4};
  transition: all ease-in 0.2s;
`;
const InnerSquare = styled__default["default"].div `
  width: ${(props) => `${(props === null || props === void 0 ? void 0 : props.size) / 2}px`};
  height: ${(props) => `${(props === null || props === void 0 ? void 0 : props.size) / 2}px`};
  background-color: ${({ theme, selected }) => (selected ? theme.bg5 : theme.bg4)};
`;
const Label$1 = styled__default["default"](Text) `
  margin-left: 10px;
  font-size: 14px;
  font-weight: 300;
`;

const Checkbox = (props) => {
    const { value, label, labelColor = 'text1', onChange, disabled, size, checked } = props;
    const [internalChekced, setInternalChecked] = React.useState(checked);
    React.useEffect(() => {
        setInternalChecked(checked);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [checked]);
    return (jsxRuntime.jsxs(Root$p, Object.assign({ disabled: disabled, onClick: () => {
            onChange && onChange(!internalChekced, value);
            setInternalChecked((prev) => !prev);
        } }, { children: [jsxRuntime.jsx(OuterSquare, Object.assign({ size: size }, { children: jsxRuntime.jsx(InnerSquare, { selected: internalChekced, size: size }) })), Boolean(label) && jsxRuntime.jsx(Label$1, Object.assign({ color: labelColor }, { children: label }))] })));
};
Checkbox.defaultProps = {
    size: 15,
};

const Root$o = styled__default["default"].div `
  flex-direction: ${(props) => ((props === null || props === void 0 ? void 0 : props.type) === 'horizontal' ? 'row' : 'column')};
  display: flex;
`;

const CheckboxGroup = (props) => {
    const { value, onChange, options, type } = props, rest = tslib.__rest(props, ["value", "onChange", "options", "type"]);
    const [selected, setSelected] = React.useState([]);
    const handleOnChange = (isChecked, checkValue) => {
        var _a;
        const index = selected === null || selected === void 0 ? void 0 : selected.indexOf(checkValue);
        const newValues = [...selected];
        if (isChecked) {
            (_a = (newValues || [])) === null || _a === void 0 ? void 0 : _a.push(checkValue);
        }
        else {
            (newValues || []).splice(index, 1);
        }
        setSelected(newValues);
        onChange === null || onChange === void 0 ? void 0 : onChange(newValues);
    };
    React.useEffect(() => {
        if (value) {
            setSelected(value);
        }
    }, [value]);
    return (jsxRuntime.jsx(Root$o, Object.assign({ type: type }, { children: (options || []).map((option, i) => (jsxRuntime.jsx(Box, Object.assign({ ml: type === 'horizontal' ? '5px' : '0px' }, { children: jsxRuntime.jsx(Checkbox, Object.assign({ value: option.value, label: option.label, onChange: (checked, someValue) => {
                    handleOnChange(checked, someValue);
                }, checked: (selected === null || selected === void 0 ? void 0 : selected.indexOf(option.value)) > -1 ? true : false }, rest)) }), i))) })));
};

const Root$n = styled__default["default"].div `
  flex-direction: row;
  align-items: center;
  display: flex;
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  pointer-events: ${({ disabled }) => (disabled ? 'none' : '')};
`;
const OuterCircle = styled__default["default"].div `
  width: ${(props) => `${props === null || props === void 0 ? void 0 : props.size}px`};
  height: ${(props) => `${props === null || props === void 0 ? void 0 : props.size}px`};
  border-radius: 50%;
  border: 1px solid;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: ${({ theme }) => theme.bg4};
  border-color: ${({ theme }) => theme.bg4};
  transition: all ease-in 0.2s;
`;
const InnerCircle = styled__default["default"].div `
  width: ${(props) => `${(props === null || props === void 0 ? void 0 : props.size) / 2}px`};
  height: ${(props) => `${(props === null || props === void 0 ? void 0 : props.size) / 2}px`};
  border-radius: 50%;
  background-color: ${({ theme, selected }) => (selected ? theme.bg5 : theme.bg4)};
`;
const Label = styled__default["default"](Text) `
  margin-left: 10px;
  font-size: 14px;
  font-weight: 300;
`;

const RadioButton = (props) => {
    const { value, label, onChange, disabled, size, checked } = props;
    return (jsxRuntime.jsxs(Root$n, Object.assign({ disabled: disabled, onClick: () => {
            onChange && onChange(value);
        } }, { children: [jsxRuntime.jsx(OuterCircle, Object.assign({ size: size }, { children: jsxRuntime.jsx(InnerCircle, { selected: checked, size: size }) })), Boolean(label) && jsxRuntime.jsx(Label, { children: label })] })));
};
RadioButton.defaultProps = {
    size: 15,
};

const Root$m = styled__default["default"].div `
  flex-direction: ${(props) => ((props === null || props === void 0 ? void 0 : props.type) === 'horizontal' ? 'row' : 'column')};
  display: flex;
`;

const RadioButtonGroup = (props) => {
    const { value, onChange, options, type } = props, rest = tslib.__rest(props, ["value", "onChange", "options", "type"]);
    const [selected, setSelected] = React.useState('');
    React.useEffect(() => {
        setSelected(value);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [value]);
    return (jsxRuntime.jsx(Root$m, Object.assign({ type: type }, { children: (options || []).map((option, i) => (jsxRuntime.jsx(Box, Object.assign({ ml: type === 'horizontal' ? '5px' : '0px' }, { children: jsxRuntime.jsx(RadioButton, Object.assign({ checked: selected === option.value, value: option.value, label: option.label, onChange: () => {
                    onChange && onChange(option.value);
                    setSelected(option.value);
                } }, rest)) }), i))) })));
};

var NearLogo = "data:image/svg+xml,%3Csvg%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%2050%2050%22%20fill%3D%22none%22%20%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%20%20%3Ccircle%20cx%3D%2225%22%20cy%3D%2225%22%20r%3D%2225%22%20fill%3D%22white%22%3E%3C%2Fcircle%3E%20%20%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M16.1053%2017.7695V31.4934L22.9474%2026.25L23.6316%2026.8654L17.894%2035.1541C15.7622%2037.16%2012%2035.8028%2012%2033.0278V16.0832C12%2013.2131%2015.9825%2011.9058%2018.0379%2014.1012L33.8947%2031.038V17.8772L27.7368%2022.5575L27.0526%2021.9421L31.9327%2014.2049C33.9696%2011.9688%2038%2013.2643%2038%2016.1551V32.7243C38%2035.5944%2034.0175%2036.9017%2031.9621%2034.7063L16.1053%2017.7695Z%22%20fill%3D%22black%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E";

var SongBirdLogo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAD6CAMAAAC/MqoPAAAC8VBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////++/z6/P3FhaTRhJ359fjYeo9Zr9fMiKHLkKrMp77biJnPf5fPmK+/hqPXgJbDkq7lgYzSbYTPobfDi6i8fpzPeJXvgoezia3Jgp307fK4gqWwmbrCmLS8jq/76etittjfg5PteoHFobm6nLa8jKjUip/EfZ19rs7LrcWun8G2krLx4eh8wtnmmab2r7K9dJitdJLHdI/SdIxuvdtOrdLqh5LkeIemr8yfgqbQjaTCpb+5oL7ZpLfHe5XFa4pgrdDhsMCjnr/Im7S8hqv8joO5X4Hy+Pv99PWJxdvWqr2miavyi4/geY7q1+Fvs9SWsM5sqcuxq8iPm76pjLPTk6nsX2frzddonsOCnL+3lLjtprCyeKDjiJnddYTFYoGJqcrVtMehl7rbnK7znaPikJ/abofvbG7r9Pn5295Ap86UqcjqrLiejrFyhq2tgKzalKekeaCcc5S6bo2Ylrqvk7bbi6DtcHd2qcian8Cnlbfgo7WTj7PrkZr3iofeYXnnZnb0d3WUvNarutLQvdCIstDnvMlPpsmQfKFse6Hlbn/SY33T6fOtYofr6PDe4+zeztzdwtG4utGbp8empsW4psLCmsCRg6t5c5r4m5mJcpfzkZWVZpD5hHyl0+Z7t9dfpcmIkraGZ5C62umexduMosR3kriDia5chqrbanyRzOJyx+F/qMavgZ6UXHzgUWLH4O3CuM9Tm8FbkLHObo3UVG1Liq33p6mBf6Oiao3jWm7R0uK/pMgtm8Y/k7lomLb6lY9+X4Le8Peft9H4y873vMB1oMDJWHi+r8ZXdpx9yuOvV3LSOlPn8PbDyd2yydtnaY6fTWyVb6F0bs2XAAAAKHRSTlMA+u70VgceDbwZTT3Nw9x8KuXU4pwjg3ZqNtmtFJVcRa+TiNqXoIuQxwGXyAAAIhNJREFUeNrc1GluwjAQBeCxnXjJ5pCFBAIJe+f+J6yi/kGgSq3A9oTvBk9v3oA/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";

var WgmiLogo = "data:image/png;base64,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";

const Svg = styled__default["default"].svg `
  @keyframes spinners-react-dotted-shrink {
    50% {
      transform: translate(0, 0);
      opacity: 0;
    }
  }
`;
const Loading = () => {
    return (jsxRuntime.jsxs(Svg, Object.assign({ fill: "none", viewBox: "0 0 66 66", style: { color: '#e1aa00', overflow: 'visible' }, xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("circle", { cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                    transform: 'translate(22px, -20px)',
                    animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0s infinite normal none running spinners-react-dotted-shrink',
                } }), jsxRuntime.jsx("circle", { cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                    transform: 'translate(29px)',
                    animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.1s infinite normal none running spinners-react-dotted-shrink',
                } }), jsxRuntime.jsx("circle", { cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                    transform: 'translate(22px, 20px)',
                    animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.2s infinite normal none running spinners-react-dotted-shrink',
                } }), jsxRuntime.jsx("circle", { cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                    transform: 'translate(0px, 30px)',
                    animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.3s infinite normal none running spinners-react-dotted-shrink',
                } }), jsxRuntime.jsx("circle", { cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                    transform: 'translate(-23px, 20px)',
                    animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.4s infinite normal none running spinners-react-dotted-shrink',
                } }), jsxRuntime.jsx("circle", { cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                    transform: 'translate(-30px)',
                    animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.5s infinite normal none running spinners-react-dotted-shrink',
                } }), jsxRuntime.jsx("circle", { cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                    transform: 'translate(-23px, -20px)',
                    animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.6s infinite normal none running spinners-react-dotted-shrink',
                } }), jsxRuntime.jsx("circle", { cx: "33", cy: "33", fill: "currentColor", r: "3", style: {
                    transform: 'translate(0px, -30px)',
                    animation: '2s cubic-bezier(0, 0.9, 0, 0.9) 0.7s infinite normal none running spinners-react-dotted-shrink',
                } })] })));
};

const rotate$1 = styled.keyframes `
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`;
const StyledSVG$2 = styled__default["default"].svg `
  animation: 2s ${rotate$1} linear infinite;
  height: ${({ size }) => size};
  width: ${({ size }) => size};
  path {
    stroke: ${({ stroke, theme }) => stroke !== null && stroke !== void 0 ? stroke : theme.primary1};
  }
`;
/**
 * Takes in custom size and stroke for circle color, default to primary color as fill,
 * need ...rest for layered styles on top
 */
function LoaderIcon(_a) {
    var { size = '16px', stroke } = _a, rest = tslib.__rest(_a, ["size", "stroke"]);
    return (jsxRuntime.jsx(StyledSVG$2, Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", size: size, stroke: stroke }, rest, { children: jsxRuntime.jsx("path", { d: "M12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 9.27455 20.9097 6.80375 19.1414 5", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round" }) })));
}

const LogoIcon = () => {
    return (jsxRuntime.jsxs("svg", Object.assign({ width: "50", height: "50", viewBox: "0 0 1053 987", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsxRuntime.jsx("path", { d: "M957.158 0.770165L815.237 0.657715L846.697 100.693L857.306 134.444L829.473 155.25L589.981 334.445L801.6 493.282L1052.89 305.289L957.158 0.770165Z", fill: "#FFC800" }), jsxRuntime.jsx("path", { d: "M223.323 154.888L195.53 134.013L206.18 100.317L237.639 0.646202L96.235 0.53418L0.104492 304.941L251.087 493.327L462.99 334.77L223.323 154.888Z", fill: "#E1AA00" }), jsxRuntime.jsx("path", { d: "M502.192 161.848L287.451 0.727051L251.21 115.473L502.192 303.859L502.328 303.747V161.82L502.192 161.848Z", fill: "#E1AA00" }), jsxRuntime.jsx("path", { d: "M765.574 0.890137L550.547 161.759V303.686L801.679 115.804L765.574 0.890137Z", fill: "#FFC800" }), jsxRuntime.jsx("path", { d: "M278.907 532.814L251.74 553.171L251.21 554.824L502.192 743.21L502.328 743.098V365.654L278.907 532.814Z", fill: "#E1AA00" }), jsxRuntime.jsx("path", { d: "M801.068 553.29L773.765 532.779L550.832 365.451L550.547 365.662V743.105L801.679 555.224L801.068 553.29Z", fill: "#FFC800" }), jsxRuntime.jsx("path", { d: "M502.152 803.537L474.36 782.675L297.856 650.22L251.21 797.946L502.192 986.333L502.328 986.221V803.397L502.152 803.537Z", fill: "#E1AA00" }), jsxRuntime.jsx("path", { d: "M755.169 650.314L578.203 782.714L550.547 803.407V986.231L801.679 798.349L755.169 650.314Z", fill: "#FFC800" })] })));
};

const AvaxLogo = ({ size = '24px' }) => {
    return (jsxRuntime.jsxs("svg", Object.assign({ version: "1.0", xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 1000.000000 1000.000000", preserveAspectRatio: "xMidYMid meet" }, { children: [jsxRuntime.jsx("circle", { cx: "500", cy: "500", r: "400", fill: "white" }), jsxRuntime.jsx("g", Object.assign({ transform: "translate(0.000000,1000.000000) scale(0.100000,-0.100000)", fill: "#E84142", stroke: "none" }, { children: jsxRuntime.jsx("path", { d: "M4590 9989 c-1442 -124 -2734 -838 -3594 -1984 -572 -761 -904 -1642\n-986 -2610 -13 -155 -13 -635 0 -790 123 -1453 833 -2745 1985 -3609 761 -572\n1642 -904 2610 -986 155 -13 635 -13 790 0 1453 123 2745 833 3609 1985 572\n761 904 1642 986 2610 13 155 13 635 0 790 -123 1453 -833 2745 -1985 3609\n-761 572 -1642 904 -2610 986 -139 11 -666 11 -805 -1z m458 -1530 c39 -19 79\n-50 109 -84 64 -72 782 -1332 824 -1445 41 -113 59 -231 59 -385 0 -159 -19\n-277 -63 -394 -23 -59 -293 -536 -861 -1521 -456 -789 -853 -1472 -882 -1516\n-118 -179 -349 -347 -582 -423 -157 -51 -179 -53 -992 -49 l-755 3 -60 24\nc-86 34 -158 108 -180 185 -19 63 -16 116 10 202 21 70 2972 5247 3025 5307\n114 129 223 159 348 96z m1919 -3378 c50 -23 124 -90 163 -146 42 -62 1009\n-1762 1043 -1835 43 -89 49 -202 17 -278 -28 -65 -92 -123 -169 -154 l-56 -23\n-1110 0 -1110 0 -59 24 c-63 25 -138 87 -162 132 -42 82 -38 189 10 295 36 79\n1035 1807 1076 1862 41 54 118 115 164 130 53 17 147 13 193 -7z" }) }))] })));
};

const CflrLogo = ({ size = '24px ' }) => {
    return (jsxRuntime.jsxs("svg", Object.assign({ version: "1.1", id: "Layer_1", xmlns: "http://www.w3.org/2000/svg", x: "0px", y: "0px", width: size, height: size, viewBox: "0 0 1920 1920", enableBackground: "new 0 0 1920 1920" }, { children: [jsxRuntime.jsx("g", { transform: "translate(0.000000,1000.000000) scale(0.100000,-0.100000)", fill: "#ffe669", stroke: "none" }), jsxRuntime.jsx("image", { id: "image0", width: "1920", height: "1920", x: "0", y: "0", href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAVZklEQVR4Xu1de4xc1Xn/5j2zsy+vH9iAbdUEhEMFSUuaSGkxcdKYAmmRm7TQUFJStcEpbYFgSCJXQFK1BLcBUkgaCEpMU4qgfwBRoVHACs2DkCAlQUYiNA0QG4ht9r07s/O6t7/fOffs3J2dtT3rmXvveM61Vt6duY9zv+93vvO9T8zFIfboWQrELAB6lvfqxS0Aepv/FgA9zn8LAAsAqwT2NAasDtDT7LdKYI+z3wLAAsD6AXobA1YH6G3+WzOwx/lvAWABYP0APY0BqwP0NPutGdjj7LcAsACwfoDexoDVAXqb/9YM7HH+WwBYAFg/QE9jwOoAPc1+awb2OPstACwAusEP4DiOxOPxnmdWJwjQNTpApVIR6quxWEzRIZlMztPDfNat+mytVlPvZd7D/3snmO6/Z1cAgAQyUiCRSCggGGaTWPyd3/O7bj0MuM37GDB0+n26BgBkLoFAScDlIJ1Od5o2odzfgJnvGAQIugIA5ES1Wp0nCEFAAPiJ1c06AoHtBziXt1QqFQgAwwcAa5P1so7DwU+DsofveUqxUJVsLikHD07IgQP75cD+A5AGNZkrlaRaqUomnZJCcU4y2bSUSmWlI3BZ4EFwEECZjP4ujXMruMaAhuelUkkplyvz53Tm+hTGizGq59fwfC5ZMTX+fD4nxWIBn4kCw0UXv19WrVrZcRCECwDwp1bG2p2Jg1kVvCzWcjcmlTKJkMKMd2XvUz+UBx/6TxkdnQLzD4lTozRwMPuBGlcTUP3gbzeGGyowLUCVR0TzWeP//vObfWd40I7rAfF4aX68cRez3I2LCwCm00kpFSclyYkfd+TRR78mGzaefGIDwK1Aq8c/NwHiQpmrlMsSB/oxEWXf8z+TPXv+Q579wXOQCwSIi1lNguF7nBCPwwpYBADeJ8rtDgDwONBNgGLsBgDJBCRUpSTxWFXK1VlZs2aVfP3f75RTTl17YgOgUoLoTcdleqqgZnC2Lyev/vKg3H77v2Dmf0cGh0YgmjMyNzendQBJqLUxnc7KzHTRt1zoNcSNNPO1pHFiEGF6YcJE1+t8MkHwlySbwf8AQDIVk//5zmOS6+u8HhDqElAqlsHQtJRLVbx0Ql588YDs3n2HPPPMc7Jq9ToZH59SazOXAsp219U6AnuaJOJKVnrE7BYAYAkwIAXg4y59GTFJQQLUHCwN+HHcOTn3t94m9957G6RhxwVAuOHgGhWxRFIKs4786leHZfv2y8HYHGYymC4p6AH4rjALKYG5A+ZrpS6u7X2snQsVRuoAURb/mplaLSVgIQHUOxDM1GnKUqtCCUxW5cEH75czzjj5xAfA9PSU5HJ5eeP1Cbn1H++UHzzzU8wEvc67MRKHDHVALorNRsVusWuYemHUD1c5rqjyUAfQUi0JHahSmQUtRM4+50y58wu34ndKvs6/TahLQLFYxOzOyS037ZaHH35chgbXSWkOs0Ex38wXAoDz5ujU6AYAGAlAJ4+WAJz9JZifMXnjjf+TPfd/Sd561mZZe9JI57lPqoYZDHKA/kOHJuSiCy+DeZeFKMxjJoDRyqqrUmXC7zATHRLKD4Dmor4rAIBlCqxXy5kDxZZ2fx7K3vTMm3LNNX8pH/mzD8Ha0XGB+PxE6BwWQgMAvXg1EOHFF38hV1xxNSZCDgTJgulQjMB0BwAQ/uCThKOVpfrRzQCgRNNmbQ0ODzJ7dnZMtm3bInfd9Vkhz2eLE9KfGwAI6gGvTkEgNADwhaZm5+SOf75bHnnkSUiADBwhMUln8mA+Zz4BAHufUsDJNFkAFoMg+hIATK+B6SlvicMEyGRTsuvvbpCt558rSZjEVWdWsmnoBzE6wk5gAJB95ZorH77sY/LKKwdh11cknxsCgTzGegBQOrObgRygy6iuCvpVwiP56MzMaYcf70jPpzt3PoDDJQwSLkmnFpxWFOcpuH9duDGTcASVywX8nZAN60+VSy/bLh/6o9/TCp8SctQSqPTSBux8DkRoEoAMGZuYk/duvUD68yMyV3RkfGwKvw+rJUARQS0BylI+JiWwU2LyWO5LJjOoY8K6BEOtpmMMJcQrGMAaGOyXkeGsrFu7WnbuvE5+bdN65f9fvWZAP2IeAHx/4+Y+lqcv/5xQAXDg9YNy6aWXQ/ynIPLSkk71KT+/PuAPhn2sjkVK4PJfuFNXIkNhPvhEPwWDSdlMRgYHhyTfn5fTNm2S9evXytlnnSmb37pJxTLi8Zjy+qlkpwUBMY6y87NfYS4sK4AzpeJW5fDhUZg82uddBc99iT7HYvl1ip8t3xeTX09iMNJkr8HKhdNK//CoIfaRgtuXEmFqakpGVg6ryORie9+YvUc3fVseaMMFoQGAa93oxCEZhr/fqTH5gd49zIYm7k/OLr36R/hQWUp6JrvQ8LXbmh4fzGTl+Ykrnz+/48ynGcglgkc6nQntxUIFgCOMjPEg1/Wap1U9HmYpMP+HRqO2Prj5nDZrQOdnfOPLhAoAV7SSVz/8AIj4jF82LPxMNut8MOt9syGHDAATGl0Igebi3hDOAGOpv3mvTp3TjnvP23veS4fHfA4gRABoW3mBuIf5V18CDCj8s8ToAn4imiXCfObXF/wxBfW63k+zcxrv7T+n8brlPt8bT2Nca9nS5PgvDBkA5gV01E+xaF5C+okc/Np4/KRd4g7NVrYQXy9UANRJdDSzp5kiuJTobCYljjS7zX2anUOVvgkjQ2RYu4EZMgAaGdu4PvolhFl/DfV9XGhc8tumA7Sb3NG7X8QA4F/3/eBYYrYHMjtbkT7RY/DRRhQxAPjFsJ/wSwRGlrIUj2YwGH3wSEr9/DlMVzdHMxOuUVk9Gsmj9X3IACAxDKMN8/1c9ZJAvRw6TbogzSaOpdFX4UdPnfmM8XfjETIAGsWrI9WaJrgu9PTqBtRvcBvxO7iL9XfMp6sHaBmN00mjjYFfM83r5y48xzC0WcB4aZbqsrR6CDiVyHYj/8P1A9Rnf13E6jo5nfqtDvgGyPgYIixMkXLwRblUkWwWGZTGbeznXQBs4HhYp5BFGRoTPAi8DCKZ3XiEKAE4W7WI9zjtzWpRRR8kbgq1AsVSDVlCCTBenzU1VZTXXntdpqdnEFjRpeG6ilb/bv729xJo/Mz/t8KYV2K++H8GqFiODgdVnPdGHT9C1OvWrZGVq1YgiJNQf2dQvIIcnm7kf5gSwGS+kHn1YAizghktI0MLs0V59kc/lZdeelmef/4F+eX+/TIxPoHSsQoiiDr6xqVBRxB0nl17DzM2D6xIURNU9tzwyWvkkksuAjBRo4ChV2qQSInwInrH884hSwBq2GS+p+WDf4VCGYkUKfnCnV9DruCjMjo2jVmWB+GZJ8+wMZcHJIqiNlDrAJ78UDrA8ZCi2bWG8SZDiQAoy00334jq3a1SQrqXAgGeTQnQjf6hUAHgICGkykwKJ401FflyKAG658sPyKOPPCGHDo/rvLpkDhUzSk7rmko14xvTxJUgbyFlwO9wMlLD+5/VRQSWSktjcgcaUyBThYmc5cocliVXvnj3bfKb79gsKFxCufcMEjuTyGWmBOg+CIQKgNGJw7JiaBXW9ZJKlLj1c/8qe/d+T/UCyPT1oUikrCto2jyxY6q03Lurx2j9iEZTlAkqrFTSSRzFwjQA6aJc/ctyxumn4jtX5spTSmlNp/otAFrlUw1KlYt8v0o5Jtde+yl5+ukfInFyJWZcDIUSBVTH5lWiJRJp2nooABzLoSRBClZHEcyuSl9fAk0b+uWRx+6HDlJDZi+relDSjfz+vtygBcCx0NR/zgzqAlj+vfMTu+Spp74LMdsPgnJtTyFHPq3W9Arq5lk9286jXkPqBwKlQiMwIP5haSShojgyAxDMyWduuVEuvPh8AIAta7TVoczADM3S7jtCWwKowVNr//73npebb/oHdACZVrMtodZ8JIwiX64CW3tgIC9VtHVpZ+OHhUXEvuCSAoDPLGUzCugmKVTsxpLTcu65m+Wee/9JaqjlS3pp3yhlUYppt7YxDA0AXG7RLkd27LgeXUB+gv4/eTX7qzVq89Cq0QgijplfLM7Czm5vhYwGgPEeaQAoH4BnRbD7iG5LB9Uu2yeTkwdl9dq07Nr1t/LOd/060rzTSud3sHyxgoeSI4Ayvo6Il1ABsHfvj+UT130SM541/xkwHwSlas0mEEqp9zTxNmcE46U9ANSXlkKhgEZNBKEL0BVleHhYxsbGMIKanLRmWO657/NyyikrkOevG1aozCXVoobOIp38241HqAC48iM3yrPPPoeZxqKQrJSQN09TkIfqpOHJatbRt/NYuAQAZN4HOhsJLIePn42b2LVkZNWgfHzHX2Dd34LPWOZVw3qPXH6zXHhjswBokUM1VAB9cPvH0fLtDWUJwNBSHcKYFagENMyzeQkw3wyqxYcscXrdCqAkIAAo7vGbSwbrz+ijWInCjQce+qr0oYCT/oBkEmOETyCb9YpVfYkoQTRzaM/bL7xLaBKAAPidd38QhZKcbdqxE09moHTp+LuqEDZLgOql0z4ZWweAKedBH2KIegfKHf37b/+Nc+Taa3bIqetPlmJ1VJVqpxDsKRXRyQsun74+KH5+OnJJ6FIEhAYARvS2vucPURtfBDFp+nE5pZuX7l7O/voSEPO6aenWKjS92EDBz4H6Z+acxV65hdepdRz3oIWZz6NRFfz5F160TX7/AxfLW07bCCBASYWpl06hGSXa16XjDPdS22fptu/uahwWAMuSTi//4jW0gOOsyyjxynZwIyMjMjExhVmWg3RgU0XdF7gAn8Hw8KCMT4yjlcyQzMBRxMpbrt+svO3P98vk1LSsGB6SickJXN+nuo/xSGfYbKqAMrRhXD+Jmrx+3LsIxvcpDyQLOTO5rE478Xr0duuMbpURoUkADrSIwA+Zq2c1iA+XH50/ZISpszMGgAoFKAmw8H/e50jfGYL4z1GdxdGZgwc9jaZdOxNNTKt2C4BWobTM82l2sSScsX/TNLnprYzZbr70KWDqI38k2CwPS5yjAkreGqKqlCFB+HezPQiW+Vpdc1moEqCKbBpG9vQeAPD8wafO3oD1FdafMEIl0NjvjdE8fr5Ufr9BR93xoxI8fEpE42YNXcO9Ngw0RACw8SM7gelpqjp2oxewyQlc8G4mcteGF1ZwUEqkzi00WUCUBN3ccn65pAkVAItzApd6jfaZgPoJfgmyXNKdGNdZAJwYfFz2W4QIACX4fbNxqSrfds/+ZdPqhLwwZACckDTtqpcKGQDHUP/n6f6GqovCQs0SgY9iBnZh6l7HQBUiAGD2OQUkVsANiyaLzAyi5447higVDZKfWnkJ3kAWhSg7nUkYrMbB92pLGZVN7ENIe4OGHSN6lG4cKgCmC+OqM+jQwCr4AJhfx45ZzO/X+wKV4YPvy2eRHYSMYbiKJ+Hi5Q4jGZiLaYSNNQBU4kBduY8SdbtgLCECAIkXpYJqDlkuIyoHJr76yn759re/L6++egC7hSAtHEjYsGmjbDptg1yw7XdVfJ5t5DJI0WYQR7eTsSbd8eAsRACICswwo6YfmThPPP603Pa525Eh7CJwU1RJlqy/Y9fwFErDTsJGSp/9+5vlLadvQPwHbVcH+piU1fDu1mJoFQyhAYBSu4S981gTcP11u+QnP96H/fQGlDSIowqIeQK65So7aFeQdo2eu9hV46odH5Xtl1yAPYXQTl0BwFQE89WDabDcKpGjfH6oAGC38Icf+m9U2twnU5PYLwf9gpllq/36dd8+M3USiBg6Lnqvotv21//tLjlz85lqm7UEijPKTB2HXhBfsJFUlMkenbGFCoBvfutHsvP6TyHHXjOdzNe7gfn6xao4ADN2kYqNsqzZ4pi8/ZzT5d777oZ0QMIGMnhYsMnScdVuto2ZQ9FhU+dGEioA/uTDf6Mqfx0H5d/sF8zMIJZ8K5ab6B+1fPbar8ACYJMISooCNlbajTz9s7C5EgpIICF0IkcA+6x1jheh3Dk0ALCy9n3brkBK2By6ZzP1KgcFkGFaf1iXNMFuAbF+tb9OzSmiXgAh43hFztvyDtQS3oLruDRoZbCbt48Phfukbljt4smy3z7vj2HuTaq1n+s3+TgPAJMUioTQhAuNX4mFEqpysI8gRH//QEqefPIxXIdScWT3sMpI9xWwRysUCA0AhUJJ3g0AJOEBnJ3BzAYAuEdOvX0s87+ACOgAcaSFp6HkOQJpUZ6WXMYFANKoJ/wG3hXZPR7juzQxtxV+tf3c0ADAXj/nvedy7Ah+GA0h8lDosGnUHLR9lmPPu/a0i4+FIVVkC6Wxtx4KsqEdcHvVs+WO23er/XXJePbeZ5m2PVqjQGgAqMLL9weXXCVvjk6oEqvJyRnJZQd8W8aYFwFjdSUeRH0NEgD1+OzS8ZlPy/veex4ye9mYgW5kLAUKPPZohQKhAYBz+xv/9V25YeenwfhBMJ6mHtZ7BIe0e9fMZu6sAXuf+wdB+SvADHzXO9+GPfY+DxPQwQ8KOWEF0A9gHUGtsF6fGyoAxqcqyv37xONPKR8AO4Nks+i0saBMm1FBFx7DUZRqDcr07Ju45ma5+ANb1ZbrDA5V2LolyfRy/47irROjF68IFQDTs9xDryofvXKHvPSzl1WbFfoC0ogDFFExxHWdNXosxcmhD89caUo+dtWVOP8yVOmyPk/vLFrPLGpvCVkvACI0AJC4h8fGUcmzQl7Y93PZs+cB+dY3n1bKYAUxAu3aRSUe+gRUkD4+NJiX919wvvzV1X8O4wCVQCoYZABgUr6tJ7BV0IYKAFb/lsFstnxjV5Cf/+8B+cpXvir79r0gY6Pjquxr/caNsmXLFrn6r/8UfYPKyvPnOnOQCJQAjRlF1groIgCwBWwZP6jDR3MIdotjY8gU+gSwQKSKap0ykkRWrl4BKYBtZrFUJFELSJO/VJxRtYP17WVsTkCrjDfnhyYB2Ha1ggBPKoGUMISAK2gOkUf2zyz0Ah6meiehkkAQFkbdIItG2Ksvjx05VTXPvKVgZ37XAUA1gEF+n8rrQZqPf7MoUwTKl1IdwNm9QfUE9gpHvfawi0vAl0uG3r0uNAnQuySP1ptbAESLH4GPxgIgcJJH64EWANHiR+CjsQAInOTReqAFQLT4EfhoLAACJ3m0HmgBEC1+BD4aC4DASR6tB1oARIsfgY/GAiBwkkfrgRYA0eJH4KOxAAic5NF6oAVAtPgR+GgsAAInebQeaAEQLX4EPhoLgMBJHq0HWgBEix+Bj8YCIHCSR+uBFgDR4kfgo7EACJzk0XqgBUC0+BH4aCwAAid5tB5oARAtfgQ+GguAwEkerQf+PzHRIxeeW+s1AAAAAElFTkSuQmCC" })] })));
};

var arrowRightIcon = "data:image/svg+xml,%3Csvg%20width%3D%2218%22%20height%3D%2218%22%20viewBox%3D%220%200%2018%2018%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M9.79261%2016.1108L17.5398%208.36364L9.79261%200.616477L8.25852%202.15057L13.3807%207.25568H0V9.47159H13.3807L8.25852%2014.5852L9.79261%2016.1108Z%22%20fill%3D%22%23333639%22%2F%3E%3C%2Fsvg%3E";

var bitKeepIcon = "data:image/svg+xml,%3Csvg%20width%3D%2236%22%20height%3D%2236%22%20viewBox%3D%220%200%2036%2036%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M18%200C27.942%200%2036%208.05967%2036%2018C36%2027.942%2027.942%2036%2018%2036C8.05967%2036%200%2027.9413%200%2018C0%208.05967%208.05967%200%2018%200Z%22%20fill%3D%22%237524F9%22%2F%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M28%2013.1817V14.2863C28.0002%2014.3931%2027.9714%2014.4981%2027.9165%2014.5907C27.8616%2014.6833%2027.7826%2014.7601%2027.6875%2014.8135L24.0242%2016.8686L27.2969%2018.6995C27.5108%2018.8196%2027.6884%2018.9924%2027.8118%2019.2005C27.9353%2019.4085%2028.0002%2019.6445%2028%2019.8847V22.8302C28.0003%2023.0705%2027.9355%2023.3066%2027.812%2023.5148C27.6886%2023.723%2027.5109%2023.8959%2027.2969%2024.0161L18.6898%2028.8168C18.4761%2028.9368%2018.2336%2029%2017.9867%2029C17.7399%2029%2017.4974%2028.9368%2017.2836%2028.8168L14.4672%2027.235C14.4196%2027.2084%2014.3802%2027.17%2014.3527%2027.1238C14.3253%2027.0776%2014.3108%2027.0252%2014.3108%2026.9718C14.3108%2026.9184%2014.3253%2026.866%2014.3527%2026.8198C14.3802%2026.7736%2014.4196%2026.7352%2014.4672%2026.7086L23.7641%2021.5052C23.7877%2021.4918%2023.8074%2021.4727%2023.8211%2021.4496C23.8347%2021.4265%2023.8419%2021.4004%2023.8419%2021.3738C23.8419%2021.3472%2023.8347%2021.321%2023.8211%2021.2979C23.8074%2021.2749%2023.7877%2021.2557%2023.7641%2021.2423L20.3125%2019.3035C20.2175%2019.2502%2020.1097%2019.2221%2020%2019.2221C19.8903%2019.2221%2019.7825%2019.2502%2019.6875%2019.3035L10.2445%2024.5927C10.1733%2024.6327%2010.0924%2024.6538%2010.0102%2024.6538C9.92788%2024.6538%209.84704%2024.6327%209.77578%2024.5927L8.70625%2023.9979C8.4913%2023.8779%208.31277%2023.7048%208.18875%2023.4961C8.06472%2023.2875%207.99961%2023.0507%208%2022.8096V21.6055C7.99995%2021.5254%208.02158%2021.4468%208.06273%2021.3774C8.10387%2021.3081%208.16307%2021.2505%208.23438%2021.2104L21.7734%2013.6443C21.7971%2013.631%2021.8168%2013.6118%2021.8304%2013.5887C21.8441%2013.5657%2021.8513%2013.5395%2021.8513%2013.5129C21.8513%2013.4863%2021.8441%2013.4601%2021.8304%2013.4371C21.8168%2013.414%2021.7971%2013.3948%2021.7734%2013.3815L18.3164%2011.4358C18.2214%2011.3825%2018.1136%2011.3544%2018.0039%2011.3544C17.8942%2011.3544%2017.7864%2011.3825%2017.6914%2011.4358L8.46875%2016.5936C8.42127%2016.6202%208.36741%2016.6343%208.31258%2016.6343C8.25775%2016.6343%208.20389%2016.6203%208.15639%2016.5937C8.10889%2016.567%208.06944%2016.5287%208.04199%2016.4826C8.01454%2016.4364%208.00006%2016.384%208%2016.3307V13.1672C7.99971%2012.9269%208.06454%2012.6907%208.18798%2012.4825C8.31142%2012.2743%208.4891%2012.1015%208.70313%2011.9813L17.3086%207.18212C17.5219%207.0628%2017.7637%207%2018.0098%207C18.2558%207%2018.4976%207.0628%2018.7109%207.18212L27.2969%2011.998C27.5106%2012.118%2027.688%2012.2905%2027.8114%2012.4983C27.9349%2012.706%2027.9999%2012.9417%2028%2013.1817Z%22%20fill%3D%22white%22%2F%3E%3C%2Fsvg%3E";

var coinbaseWalletIcon = "data:image/png;base64,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";

var gnosisSafeIcon = "data:image/png;base64,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";

var metamaskIcon = "data:image/png;base64,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";

var rabbyIcon = "data:image/svg+xml,%3Csvg%20width%3D%22320%22%20height%3D%22320%22%20viewBox%3D%220%200%20320%20320%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M310.142%20178.941C322.057%20152.322%20263.149%2077.9513%20206.872%2046.9671C171.399%2022.9641%20134.435%2026.2617%20126.949%2036.8008C110.52%2059.93%20181.351%2079.5284%20228.721%20102.398C218.538%20106.821%20208.943%20114.758%20203.3%20124.908C185.64%20105.627%20146.878%2089.0245%20101.396%20102.398C70.7464%20111.411%2045.2741%20132.658%2035.4293%20164.749C33.0371%20163.686%2030.3886%20163.095%2027.6021%20163.095C16.9467%20163.095%208.3087%20171.733%208.3087%20182.389C8.3087%20193.044%2016.9467%20201.682%2027.6021%20201.682C29.5772%20201.682%2035.7526%20200.357%2035.7526%20200.357L134.435%20201.073C94.97%20263.68%2063.7812%20272.832%2063.7812%20283.679C63.7812%20294.525%2093.6234%20291.586%20104.828%20287.543C158.468%20268.189%20216.08%20207.869%20225.966%20190.505C267.482%20195.685%20302.372%20196.298%20310.142%20178.941Z%22%20fill%3D%22url%28%23paint0_linear%29%22%2F%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M228.717%20102.401C228.72%20102.403%20228.722%20102.404%20228.725%20102.405C230.92%20101.54%20230.565%2098.297%20229.962%2095.7505C228.577%2089.8972%20204.667%2066.2872%20182.215%2055.7122C151.62%2041.3023%20129.091%2042.0452%20125.763%2048.6868C131.995%2061.4595%20160.886%2073.4515%20191.061%2085.9761C203.934%2091.3196%20217.041%2096.7599%20228.722%20102.399C228.72%20102.4%20228.719%20102.401%20228.717%20102.401Z%22%20fill%3D%22url%28%23paint1_linear%29%22%2F%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M189.892%20230.954C183.705%20228.59%20176.716%20226.42%20168.77%20224.452C177.242%20209.292%20179.02%20186.849%20171.019%20172.659C159.789%20152.745%20145.693%20142.146%20112.937%20142.146C94.9207%20142.146%2046.4136%20148.214%2045.5525%20188.707C45.4621%20192.956%2045.5502%20196.849%2045.8578%20200.43L134.435%20201.072C122.494%20220.016%20111.31%20234.066%20101.519%20244.75C113.275%20247.762%20122.976%20250.291%20131.883%20252.613C140.334%20254.816%20148.069%20256.832%20156.165%20258.898C168.378%20250%20179.86%20240.298%20189.892%20230.954Z%22%20fill%3D%22url%28%23paint2_linear%29%22%2F%3E%3Cpath%20d%3D%22M34.2473%20196.269C37.8658%20227.03%2055.3476%20239.085%2091.0698%20242.652C126.792%20246.22%20147.283%20243.826%20174.563%20246.308C197.347%20248.381%20217.691%20259.992%20225.238%20255.98C232.03%20252.369%20228.23%20239.323%20219.142%20230.953C207.361%20220.103%20191.056%20212.56%20162.366%20209.883C168.084%20194.228%20166.482%20172.279%20157.602%20160.337C144.763%20143.07%20121.064%20135.263%2091.0699%20138.674C59.733%20142.238%2029.7062%20157.666%2034.2473%20196.269Z%22%20fill%3D%22url%28%23paint3_linear%29%22%2F%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22paint0_linear%22%20x1%3D%2297.8271%22%20y1%3D%22155.368%22%20x2%3D%22307.576%22%20y2%3D%22214.849%22%20gradientUnits%3D%22userSpaceOnUse%22%3E%3Cstop%20stop-color%3D%22%238797FF%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%23AAA8FF%22%2F%3E%3C%2FlinearGradient%3E%3ClinearGradient%20id%3D%22paint1_linear%22%20x1%3D%22272.257%22%20y1%3D%22151.38%22%20x2%3D%22120.914%22%20y2%3D%22-0.332927%22%20gradientUnits%3D%22userSpaceOnUse%22%3E%3Cstop%20stop-color%3D%22%233B22A0%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%235156D8%22%20stop-opacity%3D%220%22%2F%3E%3C%2FlinearGradient%3E%3ClinearGradient%20id%3D%22paint2_linear%22%20x1%3D%22194.103%22%20y1%3D%22236.239%22%20x2%3D%2248.7216%22%20y2%3D%22152.655%22%20gradientUnits%3D%22userSpaceOnUse%22%3E%3Cstop%20stop-color%3D%22%233B1E8F%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%236A6FFB%22%20stop-opacity%3D%220%22%2F%3E%3C%2FlinearGradient%3E%3ClinearGradient%20id%3D%22paint3_linear%22%20x1%3D%22110.349%22%20y1%3D%22153.803%22%20x2%3D%22208.616%22%20y2%3D%22278.661%22%20gradientUnits%3D%22userSpaceOnUse%22%3E%3Cstop%20stop-color%3D%22%238898FF%22%2F%3E%3Cstop%20offset%3D%220.983895%22%20stop-color%3D%22%235F47F1%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3C%2Fsvg%3E";

var talismanIcon = "data:image/svg+xml,%3Csvg%20width%3D%2249%22%20height%3D%2248%22%20viewBox%3D%220%200%2049%2048%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M38.3067%2026.7464C38.7631%2027.7399%2040.1065%2028.0909%2040.8796%2027.3177L42.2961%2025.9013C43.7606%2024.4368%2046.1349%2024.4368%2047.5994%2025.9013C49.0639%2027.3657%2049.0639%2029.7401%2047.5994%2031.2046L36.1465%2042.6575C33.3949%2045.9243%2029.2741%2048%2024.6686%2048C19.8655%2048%2015.5897%2045.7426%2012.8443%2042.2308L1.81877%2031.2052C0.354304%2029.7408%200.354304%2027.3664%201.81877%2025.9019C3.28323%2024.4375%205.65759%2024.4375%207.12206%2025.9019L8.51754%2027.2974C9.2735%2028.0534%2010.5859%2027.7134%2011.0324%2026.742C11.1206%2026.5501%2011.1686%2026.3441%2011.1686%2026.1328L11.1686%208.99993C11.1686%206.92887%2012.8475%205.24994%2014.9186%205.24994C16.9896%205.24994%2018.6686%206.92887%2018.6686%208.99993L18.6686%2017.6675C18.6686%2018.4132%2019.4324%2018.9194%2020.1435%2018.6947C20.5935%2018.5525%2020.9186%2018.1427%2020.9186%2017.6708L20.9186%203.75C20.9186%201.67894%2022.5975%201.44747e-05%2024.6686%201.39315e-05C26.7396%201.33883e-05%2028.4186%201.67894%2028.4186%203.75L28.4186%2017.671C28.4186%2018.1429%2028.7436%2018.5524%2029.1935%2018.6946C29.9043%2018.9192%2030.6679%2018.4132%2030.6679%2017.6678L30.6679%208.99994C30.6679%206.92888%2032.3468%205.24995%2034.4178%205.24995C36.4889%205.24995%2038.1678%206.92887%2038.1678%208.99993L38.1678%2026.1249C38.1678%2026.3404%2038.2168%2026.5505%2038.3067%2026.7464Z%22%20fill%3D%22%23FF3D23%22%2F%3E%3Cpath%20d%3D%22M36.6684%2034.5C36.6684%2034.5%2031.2958%2042%2024.6684%2042C18.041%2042%2012.6685%2034.5%2012.6685%2034.5C12.6685%2034.5%2018.041%2027%2024.6684%2027C31.2958%2027%2036.6684%2034.5%2036.6684%2034.5Z%22%20fill%3D%22%23D5FF5C%22%2F%3E%3Cpath%20d%3D%22M30.3031%2034.5C30.3031%2037.6114%2027.7808%2040.1337%2024.6694%2040.1337C21.558%2040.1337%2019.0357%2037.6114%2019.0357%2034.5C19.0357%2031.3886%2021.558%2028.8663%2024.6694%2028.8663C27.7808%2028.8663%2030.3031%2031.3886%2030.3031%2034.5Z%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cpath%20d%3D%22M28.0522%2034.5002C28.0522%2036.369%2026.5372%2037.884%2024.6685%2037.884C22.7997%2037.884%2021.2847%2036.369%2021.2847%2034.5002C21.2847%2032.6315%2022.7997%2031.1165%2024.6684%2031.1165C26.5372%2031.1165%2028.0522%2032.6315%2028.0522%2034.5002Z%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cpath%20d%3D%22M32.5531%2034.5C32.5531%2038.854%2029.0235%2042.3837%2024.6694%2042.3837C20.3154%2042.3837%2016.7857%2038.854%2016.7857%2034.5C16.7857%2030.1459%2020.3154%2026.6163%2024.6694%2026.6163C29.0235%2026.6163%2032.5531%2030.1459%2032.5531%2034.5Z%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cpath%20d%3D%22M34.8021%2034.5C34.8021%2040.0967%2030.2651%2044.6337%2024.6684%2044.6337C19.0717%2044.6337%2014.5347%2040.0967%2014.5347%2034.5C14.5347%2028.9033%2019.0717%2024.3663%2024.6684%2024.3663C30.2651%2024.3663%2034.8021%2028.9033%2034.8021%2034.5Z%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cpath%20d%3D%22M25.8032%2034.4998C25.8032%2035.1259%2025.2956%2035.6335%2024.6694%2035.6335C24.0433%2035.6335%2023.5357%2035.1259%2023.5357%2034.4998C23.5357%2033.8736%2024.0433%2033.366%2024.6694%2033.366C25.2956%2033.366%2025.8032%2033.8736%2025.8032%2034.4998Z%22%20fill%3D%22%23162BEB%22%20stroke%3D%22%23FF3D23%22%20stroke-width%3D%220.732536%22%2F%3E%3Cellipse%20cx%3D%2224.6694%22%20cy%3D%2234.4998%22%20rx%3D%221.5%22%20ry%3D%221.5%22%20fill%3D%22%23FF3D23%22%2F%3E%3Cpath%20d%3D%22M13.2011%2034.5971C13.1738%2034.562%2013.1487%2034.5296%2013.126%2034.5C13.1487%2034.4704%2013.1738%2034.438%2013.2011%2034.4029C13.3576%2034.2021%2013.5895%2033.9139%2013.8887%2033.5675C14.4874%2032.8742%2015.3535%2031.9502%2016.4225%2031.0272C18.5719%2029.1714%2021.4874%2027.3663%2024.6684%2027.3663C27.8495%2027.3663%2030.765%2029.1714%2032.9143%2031.0272C33.9833%2031.9502%2034.8494%2032.8742%2035.4482%2033.5675C35.7474%2033.9139%2035.9792%2034.2021%2036.1357%2034.4029C36.1631%2034.438%2036.1881%2034.4704%2036.2108%2034.5C36.1881%2034.5296%2036.1631%2034.562%2036.1357%2034.5971C35.9792%2034.7979%2035.7474%2035.086%2035.4482%2035.4325C34.8494%2036.1258%2033.9833%2037.0497%2032.9143%2037.9727C30.765%2039.8286%2027.8495%2041.6337%2024.6684%2041.6337C21.4874%2041.6337%2018.5719%2039.8286%2016.4225%2037.9728C15.3535%2037.0497%2014.4874%2036.1258%2013.8887%2035.4325C13.5895%2035.0861%2013.3576%2034.7979%2013.2011%2034.5971Z%22%20stroke%3D%22%23D5FF5C%22%20stroke-width%3D%220.732536%22%2F%3E%3C%2Fsvg%3E";

var walletConnectIcon = "data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2216%22%20viewBox%3D%220%200%2024%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%20%20%3Crect%20width%3D%2224%22%20height%3D%2215.0867%22%20fill%3D%22url%28%23pattern0%29%22%2F%3E%20%20%3Cdefs%3E%20%20%20%20%3Cpattern%20id%3D%22pattern0%22%20patternContentUnits%3D%22objectBoundingBox%22%20width%3D%221%22%20height%3D%221%22%3E%20%20%20%20%20%20%3Cuse%20xlink%3Ahref%3D%22%23image0%22%20transform%3D%22translate%28-0.00968744%29%20scale%280.00339792%200.00540541%29%22%2F%3E%20%20%20%20%3C%2Fpattern%3E%20%20%20%20%3Cimage%20id%3D%22image0%22%20width%3D%22300%22%20height%3D%22185%22%20xlink%3Ahref%3D%22data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAASwAAAC5CAYAAACSoQIxAAAgAElEQVR4Ae19fZgdVZnn761TnQ%2FCtwmugxhkGPXZDIjDoENIuu9twsAm4CS7EpFhWHYktN23AwzC6Dg6xI%2FVWcGsk%2FTtNgQ0MogQ9lkQDAtLTN%2FuhDjIk5koG10eWRwQdAjRYBLIR9epd5%2B3um%2FS6dx7%2B35U3Vt16tx%2Fqu6pc96P33vqd8%2BtOu85BPuxCFRAYF4%2Fn%2BJ4ONNV3izt0AzycRwRzQBjBgPHEfszfMIMIjqOGDNAmAHguDGRb4HxJhPeZOa3yMFe%2BM5%2BR74DbzHzmyC8ST7vZXJ%2Fs9fFL7Z10e8qmGMvpRwBSrn%2F1n0AF97Np07d753rK2eOw%2F4fENG7ffCZYDrTIZzYTJAY%2BB3AvwDoX5nk6PxcaWfHb2fgJ9v%2FC73RTFusrvghYAkrfjGJ1KL21XyO4%2BgPMvhch%2BhcAHMAzIpUaUjCmfEagP8D4ucA2u6z%2BtFwjn4WkngrJgEIWMJKQJDqNfE%2FfJNnvXVQz3OYLwToAmZ8iAjT65UXy3aMfSD8E3x%2BlhVtPdimtv7wevptLG21RjWMgCWshiGMj4DzvsUnn3RAZx2NLDvcSSAZPaXq4zN8Av8YwCZi2rST1PCOHO1LFQgGO2sJK%2BHB7cjzBWDvcihc7jD9UcLdicR8Zv4hkfOY1s73h5fTc5EosUKbgoAlrKbAHJ6Ss1fx1He26UvIx4dBuBzAO8KTbr4kZvwrgx91GI%2FyLneosII88702x0NLWAmJZTCSIn29A3wMwAkJMTvWZjLjN8z8bZrmDhSupxdibaw1LkDAElaMO8JF9%2FAJ6qB%2FrQP%2FegKdF2NTE28ag7cw0V2vjqj1L9xIBxPvkKEOWMKKYWDb8zzXgV5GhKsATIuhicaa5DP2EHAvjai%2BwZvpeWMdTahjlrBiEjgZTU095P9nH%2F4NxHROTMxKtRkMfpqJ1thRV3y6gSWsFsciczefjUP6UwRcY0dTLQ5GGfWjoy6%2BS7vuys1d9Osy1WxxExCwhNUEkEupGCOqLzJjqUNwStWxZTFDgHGQgbXaVV%2B2xNWa2FjCajLulqiaDHgU6ixxRYFqVTItYVUFU%2BOV2vN8hkP6y2N%2F%2FRoXaCXEAgFm%2FgeP3M9v6aHdsTDIcCMsYUUcYHmY7h7yPuv4dBMIUyNWZ8W3AgHGbhB9aY9yVm%2FropFWmJAWnZawIop0ZgW7fJrf7YD%2FDsDMiNRYsXFCgPGiT%2Fj0UI%2F7UJzMMskWS1gRRDPbN3Kx76DfAb0nAvFWZMwRkEmo2nG7Nn%2BCfhpzUxNnniWsEEMmy7nsP6BXEYIJnyFKtqIShwDDA%2FF%2F36PcFdu66K3E2R9Tgy1hhREYZur8hp%2Fzmb9EwElhiLQyjEHgZQDLB3vcR43xqIWOWMJqEPxsH89h8tYR0R83KMo2NxuBR5lVVyFH%2F2a2m9F6ZwmrXnxXsJM9zf%2B0D77dAabUK8a2Sw8CPvBbYvQUcu6D6fE6XE8tYdWB5%2BjkT%2B8BAp1fR3PbJO0IMP7nm6xu%2BFEv%2FSbtUNTqv00JqQUxZmrP65twUP%2FEklUtwNm6RyFA%2BI%2FTSf80kx%2B57Khy%2B2VSBOwIa1KIRitk1vBMaL2egGyVTWw1i8CkCDCj7%2FVZ6pM7ltKhSSvbCrCEVUUnyPTzn4D1I0R4exXVbRWLQE0IMPO%2F%2BFPc%2FzS8jH5RU8MUVrZ%2FCSsFnZkyffqzBL3FklUloOy1RhAgog%2BoEf3jbL%2F34UbkpKGtHWGVifIH%2B%2Fhtx5F%2BkAgXl6liiy0CoSPgM68ayrXdFLpgQwRawioRyMwafh95%2Bn%2BDcEaJy7bIIhApAj54q4Z7uV0B4liY7V%2FCCZhk%2B7yF5OlnLVlNAMZ%2BbRoCDmiuy%2Fqf5YezaUoTosgS1rhAZfv1Z9jB90E4flyxPbUINB0BIpwpP5zyA9p05TFWaP8SjgUn2%2B99B8DVMY6VNS2lCDDRrYVu9bWUun%2BU26knrGAnZaUfI8IlRyFjv1gEYoQAg79e6Gn7qxiZ1BJTUk1YQlZnuPoJAJmWoG%2BVWgRqQMBnfHOoR10PIq6hmVFVU0tYF67k6dOm6cctWRnVn9PgzEO8U11dWEFeGpyd6GMqH7rPyfPxU6Z5Gy1ZTewO9nsCELgSp%2BlH5d9BAmwN3cTUjbDOvZdnnLrXe4qILgwdTSvQItAkBJh58%2BtwF%2B7I0b4mqYyFmlQR1odW8YnTlfcDu9heCH2PsY%2BB34H4DTkS6HeQ74w34PDosik%2BvQ2EkwGcxOCT4ONkIjopWJXVTh1pOAjM%2FE%2F7tXvpMzfSnoaFJURAaghLUm2mO94mB3RuQmLTOjODjUL5ZSJ6yWe87BC9xOCXoPklV7kvezvxcqPPUGRXIecdmA3fm%2B379C44NJuYZ%2Fs%2BZpOD2QycYRdGnLwLMHj7fs%2FtSAtppYKw%2FnSATzvke1uI6A8m7wKprLELjGENGoZ2hod%2Fix9jBfktRWI9q8xr%2BABcv4OY28GYD8IpLbUppsqFtDy4nWlI5TGesC65h3%2FPO6i3AHh3TPtbK8z6FQPDTDTskzOUiO2omGn%2BAM5xMEpgDLQ7hNNaAV4cdTJ4B5SbKXTRrjjaF5ZNRhPWgjX8Lq31ZgDvCguwBMt5GeAHR%2BA%2BuKWHtiXYj1HTmakjjz8BeVc5oKUg%2FLvE%2B9SgA8z8PFx3nsmkZSxhtef5DEX6GQDvaLAfJLn56wz%2Bjtbu%2F9i8nJ5OsiOT2d45MNKpmT7qMK5M819H%2BXtY6Gn7wGR4JfW6sYSVyY88m9K3gW%2BCcT85%2FMCm7rZNSe2YjdgdJAw7wWa2f9GInMS29fkrg71tn0ms%2FRUMN5KwMnnvOiJ8q4LfJl76NTOt3K%2Bdu9LyxmiyIMqb4RmOn%2FPBNznAqZPVN%2Bj6G4M9rpEvKIwkrGy%2F9z0AqVhulsE%2FZqb%2FNpRzv2vQDRe6K5m893Em%2FmsH9J7QhcdRoK%2F%2BcLCXdsTRtEZschtpHNe2zHwWkZFcPB7yR4n4HwZT%2BrdvPBDVnBdy7j0A7sn2eX%2FGxJ8kovnVtEtqHQLellTbK9ltJGGBYGxiKDMe86E%2BNZyjn1UKrL1WGoHBXldG39%2Bbv4o%2FqFxvJYEuKl0z4aUK%2Fy%2FhHpQ030zCAv1fAOeV9DihhcEra0JvIdcmSdv20yACm2%2BkHwGYlxnwroKPO4lweoMiY9NcUnYGe%2BjV2BgUoiFGrtbgAPeGiFFLRTHjNz5RTyHX9r5CjyWrsINR6HYfwHHqbPbpc8zYH7b8Vshjh77aCr3N0Gnsg56O%2FpGnZTH%2FZoAYlQ5ZZXKvclds6woSi6NSY%2BWOITB%2FDb%2FD9fTfg3BtYkFhfGcw516TWPsnMdxYwjp%2FDR93gqcfTei%2BggXtqBuGP0E%2FnyR%2B9nIECMzr5%2FNdePcQ6P0RiI9OJGP9YM79aHQKWi%2FZyL%2BEAuu2LnrrFa0WMeOp1sNcnQU%2Bw2fmzw%2FuVBdbsqoOsyhqSerSK577IWZ8Iwr5Uchk4IHBWcr4TVSMHWEVO8X5a7jtBE9viPsmE8x4zYX6yMYcSaK2%2FcQEgUy%2Ft5gY%2Fxjnrd%2BErArd6uo0rPVuPGFJvw9IS%2BuHCVgUk%2FvgKDMYGIRSS01OWj3K4YR9yQzwmWDvkVj%2BRWTcO9ijrksDWUm3SQVhiaOyYBxm6fVEWBKb%2B4XhMdFnC93OV9PS4WKDfY2GjI7UvTuI6KYam0ZXnbF2sEd1panvpIawir0m0%2B89QEDLH0wy4RVPq49s6SVZUcJ%2BEoJAZsC7HIz7gmWeW2gzM%2FoKOXd5C01oiWpjH7qXQ7MwU%2F25%2FOcvd70Z5T74J8pVf2zJqhloh6uj0O1%2B33PVBwG8HK7k6qWllawEodSNsIJuwUyZAX0%2FIViCpPqeEkJNeV61V6nL5S1mCOKsiBYhkFnDM6G9Jwh0fjNNSDNZCc7pJCzxnJmy%2FXpdUycJygPSWeovsZR0Mzu51RUNAplv8TTs1w8RcHk0Go6Wysx3FnJttx1dmq5v6SUsifMoaa0BYVn0YafbB3vUF6LXYzU0FQFZqvkb3t87TH8dpV6Zn1fIta2IUkcSZKebsMYilM17d0VFWgyMyCguyFlLQo%2BwNtaFQHveu1YRvglA1SWgQiNmuq2QU3dWqJKaS5awxkKdyY98PYJX1geIeFFalypOzV005mhnfuRPmUiWr5kWnu%2F0ycEetTI8ecmWZAlrXPwyeW81EXrHFdV%2FytinoS4dztHW%2BoXYlklDoD3Pcx3ojUSY3qjtRLR8U7fqa1SOSe0tYU2IZiY%2FIpMDb51QXNtXxj4fqnMoR8%2FW1tDWNgGBMEjLZ9wwlHPXmoBHmD6kbh7WZODJWxh5wDlZvXLXfcYeS1bl0ElHuYyqfagFYOyr1WMG2JJVedTsCKsMNpm8vpWI7yhzuXQxYzdDdRZytL10BVuaJgQ68nyBA72p2sTpMbK6bjjnGrMAZdjxtoRVAdEaSWsXfJUxcaeSChDZS5MgIKQF6I0O4cRKVYWsQLjavk2uhFKaJ45WxuXw1c4B3cvMqw8XlD7ZhUNq3uDN9Hzpy7Y0zQhk8nweQw9VIC3NhGssWU3eS%2BwIa3KM0JH3ljmEu0pVlXWsaER1WLIqhY4tKyJQgbS0T7hyqNt9uFjXHssjYB%2B6l8fm8BV5W0Og7sMFR05%2B5Ss135LVEUDsWWkE5LkmQXXIKh3jarzpM5ZYshqHyCSndoQ1CUDjL49NDPwbBhOBdrpT1c1PfZx%2BNb6OPbcIVELgvG%2FxySfv84It6BzX%2FfmmbjO346qEgb1mEbAIWAQsAhYBi4BFwCJgEbAIWAQsAhaBOhCI5BnWJffw740c8JaDcGFgE9Mb5PDAYHfbk3XYaJskBIHsKn4%2FlL6FiWeLycT0kvbVncPL6bmEuGDNrAOB7MDIpexTN4hPDuLuY6vX5q7e3EW%2FrkNcxSahE1YmP3InEX2ylFYGb%2FMd92N2z71S6CS37Pw1fNIJWq8jYHEZLx7ao9Qyu4N1GXQSWjz%2FG%2FzvHd%2F7rgM6t6QLPn9lsLftMyWv1VkYGmFVu5WW5NoBaoFNDK4zYjFrdvFafrs%2B5A0R0XsrmcbMz6spbscPltFrlerZa8lAoIYZ%2FBv2KrVkWxeNhOFZKPOwzl7FU4PNSqvY909m%2B0p%2B1ajDYbhgZbQKgc4BPt0%2FpLdORlZin9SRukJwrbLX6g0HgbHVKDZVmLl%2FWJHsBSrcIBxxuLCBk4ZHWGLIGa5%2BQrb%2Bq8kOu15UTXDFrXJAVqyfJiB4XlW1fYwXyVHtdv5R1YjFqmIDS%2BcUfumpy164kQ424lBDhHXhSp4%2BbZp%2BvGayGrOYGfvh88LC8rZCI07Yts1FoPNunu0f0kM1k1Ux7sBLzhTVsel6eqm5llttjSCQWT2SgUOPN7A4YeHAAbXwh7fQ%2FnrtqPsv4Zw8Hz9lmrexXrISg8VxcuiJAIh6PbDtmopAQFYH6xhZjbNSiM4%2FqJ8WWeOK7WmMEejoG7lE7tUGyEq8ywhnCHfU62pdI6wPreITp7veRgJdUK%2Fio9oxDvrMVwz1tj11VLn9EisEFvTzWR7rYSKcHoZhzHjVJdW%2BsYdeDEOelRENAmNktYGAtjA0MPjZ%2FZ674JkbaU%2Bt8momrHn9fIoLbxOBgnyoWhWWqy%2B7yxCwZLDH3VCuji1vHQLZr%2FN7uU0PESHUh%2Bay2oVLaq4lrdbFtpLmbL%2B3iIGHwyKroi4Gb9%2FvuR21klZNhDVGVpsJNKeoONQjwwNhsSWtUFFtWJiQFaboLQBmNiyshAC7RE8JUGJQJGQFxiMguFGYI6Tlwe3c0kO7q5Vf9TMs2ZrbhRcdWYnFAgzjkY4Bb0m1Dth60SKQ7eM5UZJVEHYZtU3RWwJd0bpjpVeJQHAPRkhWQdxB5wmnCLdUaRaqIqxg7oznbYlsZDXeWoLrMB6ypDUelNacy6JzIL05qpHVBK9mii5LWhNQacHXzIB3ldyDUY2sxrsUcIrnbal2ft6kfwllvg37ehiEs8YrasK5XTa2CSCXU1FhhcxyTcIptxt5hINjnVKErMC4n5q9fDrjRWeKmjtZJkTFEVZxcmALyErgVgKcbAFeJ%2Fa2WZ0ISBbCJGuQ1ym5imaEU0S3zYSoAquQqwT3WivISvwgnCWZEMI5ldwqS1jBfJt6ZjJX0lbjNWF5h7DOklaNwDVQXYhCUqeqSbtoQE3FpjZ9qyI8kVwc27dAEtgn%2FdcViQEiVEiLK8%2FPK0lYMt9GJvbVO5M5TIeKpCWAhinXyjoWgWKOWLX76B0rIcQSwvFCnGJTiFKtqBIIFDdZaSlZjdlVnFQsHFTC1GMfussrbI8loTWcyYGllNZaNkZad8mWW7W2tfWrQ0CyDRzojbEgq6LJo6S10ZJWEZDwj3JPldsRKnxt1UkU7hEOCqbTTGhy1PAv6vk2E3TX9ZWIlm%2FqVn11NbaNSiIgZCVpFyCEklFfUkkDhTbntAHwKjStcs%2FNChIiv3TMfp%2BH%2FxI2Y75NGO7JpqayI3MYsqwMoJgjFleykhgVc07FVhuzcBCQe6iKDYLDUVa%2FlJkT5%2BcFI6yArJxgJnOwxGn98pvZkv52sEd9uZkaTdOV7fMWwkGiUqEIWLipx%2F1fpsWimf5k%2BvRnyeEvNlNng7re8Bx10eZP0E%2Bd89fwcXD0YwASRFbiPv%2FXzMDIlxoEIrXNs33enyWNrIKoA49n%2B70PpzZwDTqe7Rv5csLISjw%2BWfn6UTlxTvD8vwLw7gZxaElzYvrbTH7kKy1RnmClmbz3ETh4JMEufC%2FT75VbPz7BbkVrekffyNfg0N9EqyUa6QT8frZf3%2BIAfqIDT0Sflo0vooHJPKmZvPdRIjyUdM8IeDjb5y1Nuh%2FNsr9jYGSl49AtzdIXjR6%2BwiGis6MR3jypsktPJu%2Btbp7GZGqStAsifCeZ1pew2sH9QSpJiUu26AgC2bx3l8Mk%2F6SS%2FWG8T94Sesn2YtR6IvRKYMB81FQNE3wLw4di2kWQ8hSGwHjICNK3LGmVCQYzBfcEwYhJ1z7gOMz8szLuJq%2BYsCwzoO9KnuHRWpzJex9XhG%2FHYSZz2J6KT8T4bvuA95dhy066vGy%2FXgtDyEpiQcBzDoiMusEJuL4j792T9M4Wlv3ZvO4hwt1hyYurHMW4J9uvb4irfc22K9vv3QvCx5utN0p9BPSPzsPq92Qt9QVRKmu2bAbuK%2FS4f9FsvXHS19GvlzvgVXGyKWpbNKh3uEflo9YTZ%2FnZvHcfCH8eZxtrtY2B7xd63CuCme67p6srmflfahUS5%2FoEXJPp974bZxujtG30FXC6yErwVOC%2Bzn59c5TYxll2Nu89aBpZ%2BcT%2FvN9TAQEffkAd%2Bk44MYkqMx7G62ppYQUZ8XKhGlgl7YKI76imrql1mOm2Qk6lZrpLZgW7mKXXE8Go5cUn7rBzmLCk48p%2BYbMo2BEnnO27YnI3MLABO9XiNJBWdkB%2FDsxfiAn0LTUjLaR1%2FhpuO0Fr2dlmUUsBD1m5D966i91Ld%2BRoX1H04eRnKZALr7PbKRWLFUw4BoE8TT8igTXBn3I%2BZPIjd1iyOoKOjDIzA%2Fr2IyXmnQVk5WnZM9A4sjp0wF0wnqwkekcRlhRIBakIwKjt4yWgJ3h6w9mrOJZLqDR6KwlZEZFdxWICkMS8IiDyCeUmfJW%2BLH2aCKatYlEQDiq1pf1RfwnHB1HAeKfSj5kIxi89ddkLN9LB8f4m%2BVxm%2BcvE2ST7ELXtzHxnIdd2W9R6miX%2FwpU8fdo0%2Fbhs%2F94snc3Qw4ynXtHqinL3Z1nCEuMODzcNZPADB9TCUgzejKCEqcOSVfVoMqOvkHOXV98injWFrKZM8zY6IKOWjxay2uuqRdu6aKQc8hUJSxqZ%2FECv3LCzHFixKpe0i369xqSZzE3Bl7F2MOcmdoKpvBibSd6TxpEVsGGvUksqkZX0j2OeYU3sNIGAnWpxMD1g4sUEf5eAy6%2BUdIDEuTFKVussWdUROcKypOacFt%2FiG0dWMvVop1o8GVlJtCcdYR3uEutZZXbp%2Bwi46nCZAScT53nE3qUjZGX3a2wkWIx7B3vUdUEmYiNymtTW2HmSwAOFmeoaLCVdDZTVE5ZIY6bMgJZdYU0jre37PbfjmRtpTzWgtayOoT8arcKT5WbpVlfHnbTm9fMpLoL5kee1Cqso9NaDf22EJVYb%2BgvP4O0e3M4tPbQ7iuA0LFPI6nX9kGkzmRvGpUEBwU1Twy98g%2Bpqbj5GVpsJNKfmxnFuUOcIt3bCEhAMfeDL4B1QbqbQRbviFGtT0y7igrE8ny3MUldW%2B7ekWXZn1vBMaK9gIFmtHexRXfWMbOsjrLGImbQ4WLETMvPzcN15cSGtgKxO04%2BYNpO5iHdcjnHLOb14Lb9dH%2FKGiOi9ccEoDDsanVrSEGGJAybOAxLSUlPcjh8so9fCCFK9MkydUlIvHlG3k5zTal6tR22HkJV%2FSG8FoeR27VHrj0p%2Bo2Qldk06rWEy42Uinswinqxekq7Lr5p0GOk4rbL7cNqFYTlircKzGr3F9C35oaimfhR1Ogf4dDPJSjINGp%2B02zBhSdAk5cH3DVshgHCWdBzpQFF0zEoyhazOcPUTBqZFVXI7FtcE81blnHbezbN91k%2BbN7Liz4eVFtXwX8LxvczEdZgYeMmZojo2XU8vjfc1qnNTc8SiwitCuYVm5pwGZHVQP02Epv9ARoihvJ8LdV2yUAlLHDeStBivOlPVRVGTlqlpF1HeEBHLLjQj53RBP5%2FlsR42jayIaPmmbtUXZoxCJywxrnNA9zKzUfsEMuNVl1T7xh56McwAFGUV0y4IZNTiiUX%2FknostYhcmL6MkdVWIrTseWmY%2FhRlRUFWIjsSwhLBHXlvGRHWmLS1FDNec0nNDZu0TE27KHbepB8lfUsWtpy4mFyjfmW%2Fzu%2FlNj1kElmxzNJkdA3l3LWN4lOqfWSEJcpk806HsM400qIR1TF4Mz1fCtBay0xNu6gVh7jXDzvnNNvHc%2BBoWSRzZtx9r9Y%2BISufcd1wzr232ja11gvlLWE5pYHhDKM2uAx%2BDafozZkB%2FsNyfldbfuHdfKpL3hCBjMoR88E%2FYeLnqsUhCfXkr%2Fp05RXkB6ZRe9tX8zm%2Bo4dNIivBJGqyEh2REpYoKOTcdRpm7ZEGYBazHsqu4vfX23kl7WLKIW%2BQmM6pV0Yc2zFj3VBP2%2FsL3W3nAvh2HG2s1yYi%2BoAkITdCWvP7%2BI%2BUo4cc4NR67YhjOyZ8LMqRVdHnSP8SFpXIsWPAW%2BL4WA%2BCO7480eeM3QzVWcjR9lr8CHLEPG%2BLaWkXmJjQam6ifF05px15vgDQGx3CibX0l1jXZXi%2Bg6VD3e7DzbAz8hFW0YnAIcJiMMzZH5BwCkMPjXbEoqeVj8HseTPJShJaj15fioiDMkYkD2ArIx3d1SAZ2fO2BD88VaqRPuJAbzKNrEBY3CyyEqibRliibLDH3SAOMlB2zeYq4x%2BbatIBpSNWQ1rFtAvTRlaSIxYsO0zExwRGSCvn3iB1jrmW4IIghp63pZr0rfY8z5U%2BAkLyVrctE6PgHiYsDu7pMnWiKG4qYYkD4iD7vAgMY3atkY4oHVI6ZrkgBWRlZtpFVTliJuecVkrfGiOrjSaRldy7cg83m6zk3mo6YYnSod62p9jnywwkrY2lSKuYI0bA7HKElsTyWrfOknwy0xLlJe9P8v9KkVZm9UjGgd5IhOlJjG8pm5mxX%2B5duYdLXY%2B6rCWEJU4VlrcVxHEBIGonmyVfOqZ0UOmoRZ0yk9mXHDHDyApEf1dPQutoGzJqN2aJbUBad%2FPhH6SOvpFLyCFJYDeKrHyoBXLvFvt3s49Ne0tYzrH5q%2Fki19FPGDVkBg744JUM51cO8%2BdMmskscQwjoTXbr28D%2BKvl%2BkUiyxn%2F5jv0BdL%2BbHLoU4n0oZzRjH0a6tLhHG0tV6UZ5S0nLHHSyNe9zYheC3SEmSNmYs5pC0ISuUqfsQdQC4Zy9GzkyiZREAvCEhszeT5PpggY9dp3EvCTdDmqHDHJOXUIdyUJi1TZWudcw6gwig1hiYNCWjT6%2Brfh9IeoAEuj3KhzxExMlDeinzB2g9X8wV7aERd%2FYkVYAoqJSaFxCXY9dkRNVkWbTEyUL%2FqW0OMu%2BCoTJ7ISHGNHWGKUictuJLTTaiZcU%2Bh2H2iG%2FZkB7ypi3AdANUOf1VEaAVlGKcwVSUprqa80loQlrpi6sFl9YWpBqybniBU9DHJOGQ9Z0ioi0txjVGu%2BheVFy%2BZhTeaALJIni%2BXJSp%2BT1bXXQ0ZA8j2bnCNW9EDy0nzClUblnBadi%2FlxbFXd0BeoDNPt2I6wik4Gs8QP6SHjJl4WHYzZUXLECFjSirSL8VBk%2B71FDDxMQMu23Bpvj%2Bnnzd5spV48YzvCKjokGz84pC4CI5K11It67FFmhLYuR2wi%2FkbmnE50Mi7fGS%2FKPRb1JithuBv7EVbRSVN3wy361%2BpjkCLl88JWpl2UwkDSnCTFBYSppa7bsgYRELKaoua2epfzar2I%2FQir6IgAKsDKNvLFMnsMCQHGvlbniJXzxMSc03K%2BNrtc7qUkkZXgk5gRVjGYwaJp2isEi6gVC%2B2xfgRGyaozDmkXlZyQVTAU9JOG5ZxWcjnSawyua9XUSI2qQnjiCEt8GttpZrMlrSoiXKFKnHLEKph5%2BJLNOT0MRUMnDN7uwe3c0kO7GxLUgsaJJCzByW6P1WBviVmOWLXe2PStapEqXU%2FIar%2FndjxzI%2B0pXSPepYl5hjURRvl1EOBlv7iJ1%2Bz3SRHYJTlitW6eManUJlQIbGY1H5LnZj81ITC2t2JiyUqcTewIqxgp2eJ9JnlPOqCyyxMX69pjgMAuHFLzwtoItlWY2pzT2pD3wVt3sXtp2LtX12ZF47UTO8Iqui4BOHTAXSABKZbZY2kEJO3CBLIS74Kk3ENqXuBTaXdt6REECnKPJJ2sxJ3Ej7CKMblwJU%2BfNk0%2FLqvUFMvs8QgCY2kX7ZLydKQ0%2BWdjOafDRDg9%2Bd5E4kHhl5667IUbyYhNX4whLAn12at46qA5Wb8AAAVoSURBVDuVfowIl0QS%2BoQKTUraRb3wBulbsm6%2BJa2jIGTGU69odYUpZCXOJf4v4fgISWD2ukpy0DaML0%2F1eYLSLuqNU5C%2BNVVdJMRcrwzT2sk9IPeCSWQlMTKKsMShbV00gp1KNmu1pDWWdrGpm4xf8cLmnB6h3KDv71SLg3vhSLERZ8YRlkSlsIK8gLQYDxsRpTqcSGLaRR1uHtVEiDnt6VssfX6nWhzcA0ehY8YXo55hHROS9awyu%2FR9BFx1zDWDC5KadhFWSIL0Lc%2FbEmwnH5bQBMhh4IHCTHUNlpJOgLl1mWg2YQkkzJTt1%2BtAuLYuhBLWKMlpF2FCnbqcU8a9gz3qOhBxmDjGTZb5hCWIp4S0kp52EfbNkZr0rZSQlfQPI59hHdPxiTj49WGsPeaaIQUmpF2EHYpUpG8x1qZhZFXsG%2BkYYRW9DfY%2B9FYToXdcUeJPTUm7iCoQpqZvMaOvkHOXR4VbHOWmY4Q1DnkJsAR6XFHST41Ju4gqECambzHznWkjK%2BkfqRthFW%2BKTH7kDiK6tfg9iUcTZzJHGQdT0rdGyarttiixiqvs1BKWBCQzoG8n5hVxDU4lu4SsZCaziZMDK%2Fnd6LXkp2%2FR7YM96guN4pDU9qkmLAlaJq9vJeI7khTAIO1CqSWWrOqL2vlruO0ErWULsUX1SWhNK2a6rZBTd7ZGezy0pu4Z1kTYpQMQUWIeXBZnMluymhjJ6r8H2CUsfUv6aNrJSiKc%2BhFWsZt3DuheZl5d%2FB7HYxpmMjcT98wKdjFLryfCkmbqrVWXz7hhKOcaOyWnFjwsYY1DqyPvLSPCGoohkQdk1a2uNn0m87hwNOc0xulbLFOeGV2WrI50BUtYR7AIztrz3rUOYV2sSCtFM5knhKM5X2OYCSFk5TOuG8659zYHhGRosYRVIk6ZAe8qMO6PBWmNzmTusiOrEoEKsyhGpCVkBcLVhW73gTBdNEFW6h%2B6lwpi0FEIVwNoada7THAdzLk3WLIqFaWQy%2BKTvqUtWZWPrR1hlccGHQPeEsfHehDcCtUiuZTmyYGRAFqD0Ey%2BRelbDM93sHSo203tOm6ThcmOsCogFHQcgqxeOlKhWuiXLFmFDmlNAkfTt7ip852CPkZYbMmqcqgsYVXGB4M97gb2WdaJbxJp0e2FXDrTLiYJRVMvBzFg%2FmIzlErfkj4mfa0Z%2BpKsw%2F4lrDJ6HX0jlzhEj4EwtcomNVezM5lrhizyBpFnQjAO%2BsxXDPW2PRW5MwYosIRVQxAzq0cycOhxIkyvoVlVVWUm86ZuZdIqElX5nYRKUZEWM%2FbD54WF5W2FJOAQBxstYdUYhfY8z3WgN4ZJWnYmc41BaEH10DMhGPs01KXDObI7ltcQT0tYNYBVrCqkpaCfBOH4Ylk9RzuTuR7UWtcmtEwIxj4fqnMoR8%2B2zptkaraEVWfcOvJ8AaA3OoQT6xFhZzLXg1rr2zSaCeEz9gBqgSWr%2BmJpCas%2B3IJWmTyfR9CbQDilRjGaCdfYmcw1ohaT6nWTFmM3Q3UWcrQ9Jq4kzgxLWA2GLNvHc0B6c9WkZScHNoh4PJpL%2BhYx7gOgqrRoF3yVGeylHVXWt9VKIGAJqwQotRYFpOVoedMzs2JbhgfCYjvfpiJKiblYQybELhxS8wZvpucT41xMDbUTR0MIjPxqakfN9X3%2BaVlxjN0%2B80JLVmURStwFmZVO4EWjz6VKmy%2B7cEvfsGRVGp9aS%2B0Iq1bEJqnfPqC7iP1bHNB7pCozXiOiVXuUk9%2FWRb%2BbpLm9nEAEZMPWNvJ7wSwr184K4g7%2BGZi%2BVsi59yTQJWty2hBoX8vvnt%2FP56bN77T7KzHvvJtnpx2HqPz%2F%2F6omxnsqyGCHAAAAAElFTkSuQmCC%22%2F%3E%20%20%3C%2Fdefs%3E%3C%2Fsvg%3E";

var xDefiIcon = "data:image/png;base64,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";

var ConnectorEvent;

(function (ConnectorEvent) {
  ConnectorEvent["Update"] = "Web3ReactUpdate";
  ConnectorEvent["Error"] = "Web3ReactError";
  ConnectorEvent["Deactivate"] = "Web3ReactDeactivate";
})(ConnectorEvent || (ConnectorEvent = {}));

function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var AbstractConnector =
/*#__PURE__*/
function (_EventEmitter) {
  _inheritsLoose$1(AbstractConnector, _EventEmitter);

  function AbstractConnector(_temp) {
    var _this;

    var _ref = _temp === void 0 ? {} : _temp,
        supportedChainIds = _ref.supportedChainIds;

    _this = _EventEmitter.call(this) || this;
    _this.supportedChainIds = supportedChainIds;
    return _this;
  }

  var _proto = AbstractConnector.prototype;

  _proto.emitUpdate = function emitUpdate(update) {
    if (process.env.NODE_ENV !== "production") {
      console.log("Emitting '" + ConnectorEvent.Update + "' with payload", update);
    }

    this.emit(ConnectorEvent.Update, update);
  };

  _proto.emitError = function emitError(error) {
    if (process.env.NODE_ENV !== "production") {
      console.log("Emitting '" + ConnectorEvent.Error + "' with payload", error);
    }

    this.emit(ConnectorEvent.Error, error);
  };

  _proto.emitDeactivate = function emitDeactivate() {
    if (process.env.NODE_ENV !== "production") {
      console.log("Emitting '" + ConnectorEvent.Deactivate + "'");
    }

    this.emit(ConnectorEvent.Deactivate);
  };

  return AbstractConnector;
}(events.EventEmitter);

var isProduction$1 = process.env.NODE_ENV === 'production';
function warning(condition, message) {
  if (!isProduction$1) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

function parseSendReturn(sendReturn) {
    return sendReturn.hasOwnProperty('result') ? sendReturn.result : sendReturn;
}
class NoEthereumProviderError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
        this.message = 'No Ethereum provider was found on window.xfi.ethereum.';
    }
}
class UserRejectedRequestError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
        this.message = 'The user rejected the request.';
    }
}
class DefiConnector extends AbstractConnector {
    constructor(kwargs) {
        super(kwargs);
        this.handleNetworkChanged = this.handleNetworkChanged.bind(this);
        this.handleChainChanged = this.handleChainChanged.bind(this);
        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
        this.handleClose = this.handleClose.bind(this);
    }
    handleChainChanged(chainId) {
        var _a;
        console.log("Handling 'chainChanged' event with payload", chainId);
        this.emitUpdate({ chainId, provider: (_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum });
    }
    handleAccountsChanged(accounts) {
        console.log("Handling 'accountsChanged' event with payload", accounts);
        if (accounts.length === 0) {
            this.emitDeactivate();
        }
        else {
            this.emitUpdate({ account: accounts[0] });
        }
    }
    handleClose(code, reason) {
        console.log("Handling 'close' event with payload", code, reason);
        this.emitDeactivate();
    }
    handleNetworkChanged(networkId) {
        var _a;
        console.log("Handling 'networkChanged' event with payload", networkId);
        this.emitUpdate({ chainId: networkId, provider: (_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum });
    }
    activate() {
        var _a, _b, _c;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            if ((_b = window === null || window === void 0 ? void 0 : window.xfi) === null || _b === void 0 ? void 0 : _b.ethereum.on) {
                window.xfi.ethereum.on('chainChanged', this.handleChainChanged);
                window.xfi.ethereum.on('accountsChanged', this.handleAccountsChanged);
                window.xfi.ethereum.on('close', this.handleClose);
                window.xfi.ethereum.on('networkChanged', this.handleNetworkChanged);
            }
            if ((_c = window === null || window === void 0 ? void 0 : window.xfi) === null || _c === void 0 ? void 0 : _c.ethereum.isXDEFI) {
                window.xfi.ethereum.autoRefreshOnNetworkChange = false;
            }
            // try to activate + get account via eth_requestAccounts
            let account;
            try {
                account = yield window.xfi.ethereum.send('eth_requestAccounts').then((sendReturn) => parseSendReturn(sendReturn)[0]);
            }
            catch (error) {
                if (error.code === 4001) {
                    throw new UserRejectedRequestError();
                }
                warning(false, 'eth_requestAccounts was unsuccessful, falling back to enable');
            }
            // if unsuccessful, try enable
            if (!account) {
                // if enable is successful but doesn't return accounts, fall back to getAccount (not happy i have to do this...)
                account = yield window.xfi.ethereum
                    .enable()
                    .then((sendReturn) => sendReturn && parseSendReturn(sendReturn)[0]);
            }
            return Object.assign({ provider: window.xfi.ethereum }, (account ? { account } : {}));
        });
    }
    getProvider() {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return (_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum;
        });
    }
    getChainId() {
        var _a, _b;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            let chainId;
            try {
                chainId = yield window.xfi.ethereum.send('eth_chainId').then(parseSendReturn);
            }
            catch (_c) {
                warning(false, 'eth_chainId was unsuccessful, falling back to net_version');
            }
            if (!chainId) {
                try {
                    chainId = yield window.xfi.ethereum.send('net_version').then(parseSendReturn);
                }
                catch (_d) {
                    warning(false, 'net_version was unsuccessful, falling back to net version v2');
                }
            }
            if (!chainId) {
                try {
                    chainId = parseSendReturn(window.xfi.ethereum.send({ method: 'net_version' }));
                }
                catch (_e) {
                    warning(false, 'net_version v2 was unsuccessful, falling back to manual matches and static properties');
                }
            }
            if (!chainId) {
                if ((_b = window === null || window === void 0 ? void 0 : window.xfi) === null || _b === void 0 ? void 0 : _b.ethereum.isDapper) {
                    chainId = parseSendReturn(window.xfi.ethereum.cachedResults.net_version);
                }
                else {
                    chainId =
                        window.xfi.ethereum.chainId ||
                            window.xfi.ethereum.netVersion ||
                            window.xfi.ethereum.networkVersion ||
                            window.xfi.ethereum._chainId;
                }
            }
            return chainId;
        });
    }
    getAccount() {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            let account;
            try {
                account = yield window.xfi.ethereum.send('eth_accounts').then((sendReturn) => parseSendReturn(sendReturn)[0]);
            }
            catch (_b) {
                warning(false, 'eth_accounts was unsuccessful, falling back to enable');
            }
            if (!account) {
                try {
                    account = yield window.xfi.ethereum.enable().then((sendReturn) => parseSendReturn(sendReturn)[0]);
                }
                catch (_c) {
                    warning(false, 'enable was unsuccessful, falling back to eth_accounts v2');
                }
            }
            if (!account) {
                account = parseSendReturn(window.xfi.ethereum.send({ method: 'eth_accounts' }))[0];
            }
            return account;
        });
    }
    deactivate() {
        var _a, _b;
        if (((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum) && ((_b = window === null || window === void 0 ? void 0 : window.xfi) === null || _b === void 0 ? void 0 : _b.ethereum.removeListener)) {
            window.xfi.ethereum.removeListener('chainChanged', this.handleChainChanged);
            window.xfi.ethereum.removeListener('accountsChanged', this.handleAccountsChanged);
            window.xfi.ethereum.removeListener('close', this.handleClose);
            window.xfi.ethereum.removeListener('networkChanged', this.handleNetworkChanged);
        }
    }
    isAuthorized() {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.xfi) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                return false;
            }
            try {
                return yield window.xfi.ethereum.send('eth_accounts').then((sendReturn) => {
                    if (parseSendReturn(sendReturn).length > 0) {
                        return true;
                    }
                    else {
                        return false;
                    }
                });
            }
            catch (_b) {
                return false;
            }
        });
    }
}

class BitKeepConnector extends AbstractConnector {
    constructor(kwargs) {
        super(kwargs);
        this.handleNetworkChanged = this.handleNetworkChanged.bind(this);
        this.handleChainChanged = this.handleChainChanged.bind(this);
        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
        this.handleClose = this.handleClose.bind(this);
    }
    handleChainChanged(chainId) {
        var _a;
        console.log("Handling 'chainChanged' event with payload", chainId);
        this.emitUpdate({ chainId, provider: (_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum });
    }
    handleAccountsChanged(accounts) {
        console.log("Handling 'accountsChanged' event with payload", accounts);
        if (accounts.length === 0) {
            this.emitDeactivate();
        }
        else {
            this.emitUpdate({ account: accounts[0] });
        }
    }
    handleClose(code, reason) {
        console.log("Handling 'close' event with payload", code, reason);
        this.emitDeactivate();
    }
    handleNetworkChanged(networkId) {
        var _a;
        console.log("Handling 'networkChanged' event with payload", networkId);
        this.emitUpdate({ chainId: networkId, provider: (_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum });
    }
    activate() {
        var _a, _b, _c;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            if ((_b = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _b === void 0 ? void 0 : _b.ethereum.on) {
                window.bitkeep.ethereum.on('chainChanged', this.handleChainChanged);
                window.bitkeep.ethereum.on('accountsChanged', this.handleAccountsChanged);
                window.bitkeep.ethereum.on('close', this.handleClose);
                window.bitkeep.ethereum.on('networkChanged', this.handleNetworkChanged);
            }
            if ((_c = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _c === void 0 ? void 0 : _c.ethereum.isBitKeep) {
                window.bitkeep.ethereum.autoRefreshOnNetworkChange = false;
            }
            // try to activate + get account via eth_requestAccounts
            let account;
            try {
                const _account = yield this.getAccount();
                if (_account)
                    account = _account;
            }
            catch (error) {
                if (error.code === 4001) {
                    throw new UserRejectedRequestError();
                }
                else {
                    warning(false, 'eth_requestAccounts was unsuccessful, falling back to enable');
                }
            }
            return { provider: window.bitkeep.ethereum, account };
        });
    }
    getProvider() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return window.bitkeep && window.bitkeep.ethereum;
        });
    }
    getChainId() {
        var _a, _b;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            let chainId = window.bitkeep.ethereum.chainId || window.bitkeep.ethereum.networkVersion;
            if (!chainId) {
                chainId = yield ((_b = window.bitkeep) === null || _b === void 0 ? void 0 : _b.ethereum.request({ method: 'eth_chainId' }));
            }
            return chainId;
        });
    }
    getAccount() {
        var _a, _b;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                throw new NoEthereumProviderError();
            }
            const accounts = yield ((_b = window.bitkeep) === null || _b === void 0 ? void 0 : _b.ethereum.request({ method: 'eth_accounts' }));
            return accounts && accounts.length > 0 ? accounts[0] : null;
        });
    }
    deactivate() {
        var _a, _b;
        if (((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum) && ((_b = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _b === void 0 ? void 0 : _b.ethereum.removeListener)) {
            window.bitkeep.ethereum.removeListener('chainChanged', this.handleChainChanged);
            window.bitkeep.ethereum.removeListener('accountsChanged', this.handleAccountsChanged);
            window.bitkeep.ethereum.removeListener('close', this.handleClose);
            window.bitkeep.ethereum.removeListener('networkChanged', this.handleNetworkChanged);
        }
    }
    isAuthorized() {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!((_a = window === null || window === void 0 ? void 0 : window.bitkeep) === null || _a === void 0 ? void 0 : _a.ethereum)) {
                return false;
            }
            try {
                const account = yield this.getAccount();
                return !!account;
            }
            catch (_b) {
                return false;
            }
        });
    }
}

class NearConnector extends AbstractConnector {
    constructor(kwargs) {
        var _a;
        super(kwargs);
        const keyStore = new nearApiJs.keyStores.BrowserLocalStorageKeyStore();
        // connect to NEAR
        this.near = new nearApiJs.Near(Object.assign({ keyStore, headers: {} }, kwargs.config));
        this.wallet = new nearApiJs.WalletConnection(this.near, 'pangolin');
        this.normalizeChainId = kwargs === null || kwargs === void 0 ? void 0 : kwargs.normalizeChainId;
        this.normalizeAccount = kwargs === null || kwargs === void 0 ? void 0 : kwargs.normalizeAccount;
        this.chainId = (_a = kwargs === null || kwargs === void 0 ? void 0 : kwargs.config) === null || _a === void 0 ? void 0 : _a.chainId;
        this.handleNetworkChanged = this.handleNetworkChanged.bind(this);
        this.handleChainChanged = this.handleChainChanged.bind(this);
        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
        this.handleClose = this.handleClose.bind(this);
        this.provider = new providers.JsonRpcProvider(kwargs.config.nodeUrl);
    }
    handleChainChanged(chainId) {
        console.log("Handling 'chainChanged' event with payload", chainId);
        this.emitUpdate({ chainId, provider: this.provider });
    }
    handleAccountsChanged(accounts) {
        console.log("Handling 'accountsChanged' event with payload", accounts);
        if (accounts.length === 0) {
            this.emitDeactivate();
        }
        else {
            this.emitUpdate({ account: accounts[0] });
        }
    }
    handleClose(code, reason) {
        console.log("Handling 'close' event with payload", code, reason);
        this.emitDeactivate();
    }
    handleNetworkChanged(networkId) {
        console.log("Handling 'networkChanged' event with payload", networkId);
        this.emitUpdate({ chainId: networkId, provider: this.provider });
    }
    getChainId() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.wallet) {
                return this.chainId;
            }
            return null;
        });
    }
    getProvider() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.provider;
        });
    }
    activate() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.wallet) {
                const isAuthorized = yield this.isAuthorized();
                if (isAuthorized) {
                    const account = yield this.getAccount();
                    const chainId = yield this.getChainId();
                    return { chainId: chainId, provider: this.provider, account: account };
                }
                else {
                    this.wallet.requestSignIn(this.near.config.contractId);
                    return { provider: this.provider };
                }
            }
        });
    }
    getAccount() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.wallet && this.wallet.isSignedIn()) {
                return this.wallet.getAccountId();
            }
            return null;
        });
    }
    deactivate() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.wallet) {
                this.wallet.signOut();
            }
        });
    }
    getAccountBalance() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.wallet) {
                const account = this.wallet.account();
                return account.getAccountBalance();
            }
            return undefined;
        });
    }
    isAuthorized() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.wallet && this.wallet.isSignedIn()) {
                return true;
            }
            return false;
        });
    }
}

var isProduction = process.env.NODE_ENV === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    var provided = typeof message === 'function' ? message() : message;
    var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
}

class RequestError extends Error {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    constructor(message, code, data) {
        super(message);
    }
}
class MiniRpcProvider {
    constructor(chainId, url, batchWaitTimeMs) {
        this.isMetaMask = false;
        this.isXDEFI = false;
        this.nextId = 1;
        this.batchTimeoutId = null;
        this.batch = [];
        this.clearBatch = () => tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            console.debug('Clearing batch', this.batch);
            const batch = this.batch;
            this.batch = [];
            this.batchTimeoutId = null;
            let response;
            try {
                response = yield fetch(this.url, {
                    method: 'POST',
                    headers: { 'content-type': 'application/json', accept: 'application/json' },
                    body: JSON.stringify(batch.map((item) => item.request)),
                });
            }
            catch (error) {
                batch.forEach(({ reject }) => reject(new Error('Failed to send batch call')));
                return;
            }
            if (!response.ok) {
                batch.forEach(({ reject }) => reject(new RequestError(`${response.status}: ${response.statusText}`, -32000)));
                return;
            }
            let json;
            try {
                json = yield response.json();
            }
            catch (error) {
                batch.forEach(({ reject }) => reject(new Error('Failed to parse JSON response')));
                return;
            }
            const byKey = batch.reduce((memo, current) => {
                memo[current.request.id] = current;
                return memo;
            }, {});
            for (const result of json) {
                const { resolve, reject, request: { method }, } = byKey[result.id];
                // eslint-disable-next-line  @typescript-eslint/ban-ts-comment
                // @ts-ignore
                if (resolve && reject) {
                    if ('error' in result) {
                        reject(new RequestError((_a = result === null || result === void 0 ? void 0 : result.error) === null || _a === void 0 ? void 0 : _a.message, (_b = result === null || result === void 0 ? void 0 : result.error) === null || _b === void 0 ? void 0 : _b.code, (_c = result === null || result === void 0 ? void 0 : result.error) === null || _c === void 0 ? void 0 : _c.data));
                    }
                    else if ('result' in result) {
                        resolve(result.result);
                    }
                    else {
                        reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result));
                    }
                }
            }
        });
        this.sendAsync = (request, callback) => {
            this.request(request.method, request.params)
                .then((result) => callback(null, { jsonrpc: '2.0', id: request.id, result }))
                .catch((error) => callback(error, null));
        };
        this.request = (method, params) => tslib.__awaiter(this, void 0, void 0, function* () {
            var _d;
            if (typeof method !== 'string') {
                return this.request(method.method, method.params);
            }
            if (method === 'eth_chainId') {
                return `0x${this.chainId.toString(16)}`;
            }
            const promise = new Promise((resolve, reject) => {
                this.batch.push({
                    request: {
                        jsonrpc: '2.0',
                        id: this.nextId++,
                        method,
                        params,
                    },
                    resolve,
                    reject,
                });
            });
            this.batchTimeoutId = (_d = this.batchTimeoutId) !== null && _d !== void 0 ? _d : setTimeout(this.clearBatch, this.batchWaitTimeMs);
            return promise;
        });
        this.chainId = chainId;
        this.url = url;
        const parsed = new URL(url);
        this.host = parsed.host;
        this.path = parsed.pathname;
        // how long to wait to batch calls
        this.batchWaitTimeMs = batchWaitTimeMs !== null && batchWaitTimeMs !== void 0 ? batchWaitTimeMs : 50;
    }
}
class NetworkConnector extends AbstractConnector {
    constructor({ urls, defaultChainId }) {
        invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url');
        super({ supportedChainIds: Object.keys(urls).map((k) => Number(k)) });
        this.currentChainId = defaultChainId || Number(Object.keys(urls)[0]);
        this.providers = Object.keys(urls).reduce((accumulator, chainId) => {
            accumulator[Number(chainId)] = new MiniRpcProvider(Number(chainId), urls[Number(chainId)]);
            return accumulator;
        }, {});
    }
    get provider() {
        return this.providers[this.currentChainId];
    }
    activate() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return { provider: this.providers[this.currentChainId], chainId: this.currentChainId, account: null };
        });
    }
    getProvider() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.providers[this.currentChainId];
        });
    }
    getChainId() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.currentChainId;
        });
    }
    getAccount() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    deactivate() {
        return;
    }
}

var _a$2;
const NETWORK_URL = 'https://api.avax.network/ext/bc/C/rpc';
// Near Exchnage Contract
const NEAR_EXCHANGE_CONTRACT_ADDRESS = {
    [sdk.ChainId.NEAR_MAINNET]: 'png-exchange-v1.mainnet',
    [sdk.ChainId.NEAR_TESTNET]: 'png-exchange-v1.testnet',
};
const NETWORK_CHAIN_ID = parseInt((_a$2 = process.env.REACT_APP_CHAIN_ID) !== null && _a$2 !== void 0 ? _a$2 : '43114');
const network = new NetworkConnector({
    urls: { [NETWORK_CHAIN_ID]: NETWORK_URL },
    defaultChainId: NETWORK_CHAIN_ID,
});
let networkLibrary;
function getNetworkLibrary() {
    networkLibrary = networkLibrary !== null && networkLibrary !== void 0 ? networkLibrary : new providers$1.Web3Provider(network.provider);
    return networkLibrary;
}
const injected = new web3ReactInjectedConnector.InjectedConnector({
    supportedChainIds: [43113, 43114, 11111, 16, 19],
});
const talisman = new web3reactV6Connector.TalismanConnector({
    supportedChainIds: [43113, 43114, 11111, 16, 19],
});
const gnosisSafe = new safeAppsWeb3React.SafeAppConnector({
    supportedChainIds: [43113, 43114, 11111, 16, 19],
});
const walletlink = new walletlinkConnector.WalletLinkConnector({
    url: NETWORK_URL,
    supportedChainIds: [43113, 43114, 11111, 16, 19],
    appName: 'Arcanum',
    appLogoUrl: 'https://raw.githubusercontent.com/pangolindex/interface/master/public/images/384x384_App_Icon.png',
});
const walletconnect = new walletconnectConnector.WalletConnectConnector({
    rpc: {
        43114: NETWORK_URL,
    },
    qrcode: true,
    bridge: 'https://bridge.walletconnect.org',
});
const xDefi = new DefiConnector({
    supportedChainIds: [1, 43114, 11111, 16, 19],
});
const bitKeep = new BitKeepConnector({
    supportedChainIds: [43113, 43114, 11111, 16, 19],
});
function getNearMainnetConfig() {
    return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
        explorerUrl: 'https://nearblocks.io',
        indexerUrl: 'https://indexer.ref-finance.net',
        chainId: sdk.ChainId.NEAR_MAINNET,
        contractId: NEAR_EXCHANGE_CONTRACT_ADDRESS[sdk.ChainId.NEAR_MAINNET],
    };
}
// TODO: set configuration dynemically as per env
function getNearConfig(env = 'testnet') {
    switch (env) {
        case 'production':
        case 'mainnet':
            return getNearMainnetConfig();
        case 'testnet':
            return {
                networkId: 'testnet',
                nodeUrl: 'https://rpc.testnet.near.org',
                walletUrl: 'https://wallet.testnet.near.org',
                helperUrl: 'https://helper.testnet.near.org',
                explorerUrl: 'https://testnet.nearblocks.io',
                chainId: sdk.ChainId.NEAR_TESTNET,
                contractId: NEAR_EXCHANGE_CONTRACT_ADDRESS[sdk.ChainId.NEAR_TESTNET],
            };
        default:
            return getNearMainnetConfig();
    }
}
const near = new NearConnector({
    normalizeChainId: false,
    normalizeAccount: false,
    config: getNearConfig('testnet'),
});

const CommonEVMProvider = (provider) => {
    if (provider) {
        provider.getTransactionReceipt = (hash) => tslib.__awaiter(void 0, void 0, void 0, function* () {
            const receipt = yield provider.request({
                method: 'eth_getTransactionReceipt',
                params: [hash],
            });
            if (!receipt.blockNumber || !receipt.blockHash) {
                return undefined;
            }
            receipt.blockNumber = Number(receipt.blockNumber);
            receipt.transactionIndex = Number(receipt.transactionIndex);
            receipt.hash = receipt.transactionHash;
            receipt.status = Number(receipt.status);
            return receipt;
        });
        provider.getBlockNumber = () => tslib.__awaiter(void 0, void 0, void 0, function* () {
            const block = yield provider.request({
                method: 'eth_blockNumber',
                params: [],
            });
            return Number(block);
        });
        provider.execute = (method, params) => tslib.__awaiter(void 0, void 0, void 0, function* () {
            const res = yield provider.request({ method: method, params: params });
            return res;
        });
        provider.getBlockTimestamp = (blockNumber) => tslib.__awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const result = yield provider.request({
                method: 'eth_getBlockByNumber',
                params: [`0x${blockNumber.toString(16)}`, false],
            });
            if (!result) {
                return 0;
            }
            return (_a = parseInt(result === null || result === void 0 ? void 0 : result.timestamp, 16).toString()) !== null && _a !== void 0 ? _a : 0;
        });
    }
    return provider;
};

const NearProvider = (provider) => {
    if (provider) {
        provider.getTransactionReceipt = (hash) => tslib.__awaiter(void 0, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            try {
                const accountId = (_c = (_b = (_a = near === null || near === void 0 ? void 0 : near.wallet) === null || _a === void 0 ? void 0 : _a.account) === null || _b === void 0 ? void 0 : _b.call(_a)) === null || _c === void 0 ? void 0 : _c.accountId;
                const res = yield (provider === null || provider === void 0 ? void 0 : provider.txStatus(hash, accountId));
                const isSuccess = (_d = res === null || res === void 0 ? void 0 : res.receipts_outcome) === null || _d === void 0 ? void 0 : _d.every((item) => { var _a, _b; return !((_b = (_a = item === null || item === void 0 ? void 0 : item.outcome) === null || _a === void 0 ? void 0 : _a.status) === null || _b === void 0 ? void 0 : _b.Failure); });
                const blockHash = (_e = res === null || res === void 0 ? void 0 : res.transaction_outcome) === null || _e === void 0 ? void 0 : _e.block_hash;
                let blockNumber = 0;
                try {
                    const block = yield provider.block({ blockId: blockHash });
                    blockNumber = (_f = block === null || block === void 0 ? void 0 : block.header) === null || _f === void 0 ? void 0 : _f.height;
                }
                catch (error) {
                    console.log(error);
                }
                return {
                    blockHash: blockHash,
                    blockNumber,
                    contractAddress: '',
                    from: (_g = res === null || res === void 0 ? void 0 : res.transaction) === null || _g === void 0 ? void 0 : _g.signer_id,
                    status: isSuccess ? 1 : 0,
                    to: (_h = res === null || res === void 0 ? void 0 : res.transaction) === null || _h === void 0 ? void 0 : _h.receiver_id,
                    hash,
                    transactionHash: hash,
                    transactionIndex: (_j = res === null || res === void 0 ? void 0 : res.transaction) === null || _j === void 0 ? void 0 : _j.nonce,
                };
            }
            catch (error) {
                console.log(error);
            }
        });
        provider.getBlockNumber = () => tslib.__awaiter(void 0, void 0, void 0, function* () {
            var _k;
            const block = yield provider.block({ finality: 'optimistic' });
            return (_k = block === null || block === void 0 ? void 0 : block.header) === null || _k === void 0 ? void 0 : _k.height;
        });
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        provider.execute = (_method, _params) => tslib.__awaiter(void 0, void 0, void 0, function* () {
            //  implement it
        });
        provider.getBlockTimestamp = (blockNumber) => tslib.__awaiter(void 0, void 0, void 0, function* () {
            var _l, _m, _o;
            const block = yield provider.block(blockNumber);
            return (_o = (_m = (_l = block === null || block === void 0 ? void 0 : block.header) === null || _l === void 0 ? void 0 : _l.timestamp) === null || _m === void 0 ? void 0 : _m.toString()) !== null && _o !== void 0 ? _o : '0';
        });
    }
    return provider;
};

const ZERO_ADDRESS$1 = '0x0000000000000000000000000000000000000000';
const PNG = {
    [sdk.ChainId.FUJI]: new sdk.Token(sdk.ChainId.FUJI, sdk.CHAINS[sdk.ChainId.FUJI].contracts.png, 18, sdk.CHAINS[sdk.ChainId.FUJI].png_symbol, 'Arcanum'),
    [sdk.ChainId.AVALANCHE]: new sdk.Token(sdk.ChainId.AVALANCHE, sdk.CHAINS[sdk.ChainId.AVALANCHE].contracts.png, 18, sdk.CHAINS[sdk.ChainId.AVALANCHE].png_symbol, 'Arcanum'),
    [sdk.ChainId.WAGMI]: new sdk.Token(sdk.ChainId.WAGMI, sdk.CHAINS[sdk.ChainId.WAGMI].contracts.png, 18, sdk.CHAINS[sdk.ChainId.WAGMI].png_symbol, 'Wagmi Arcanum'),
    [sdk.ChainId.COSTON]: new sdk.Token(sdk.ChainId.COSTON, sdk.CHAINS[sdk.ChainId.COSTON].contracts.png, 18, sdk.CHAINS[sdk.ChainId.COSTON].png_symbol, 'Coston Arcanum'),
    [sdk.ChainId.SONGBIRD]: new sdk.Token(sdk.ChainId.SONGBIRD, sdk.CHAINS[sdk.ChainId.SONGBIRD].contracts.png, 18, sdk.CHAINS[sdk.ChainId.SONGBIRD].png_symbol, 'Songbird Arcanum'),
    [sdk.ChainId.NEAR_MAINNET]: new sdk.Token(sdk.ChainId.NEAR_MAINNET, sdk.CHAINS[sdk.ChainId.NEAR_MAINNET].contracts.png, 18, sdk.CHAINS[sdk.ChainId.NEAR_MAINNET].png_symbol, 'Arcanum Near'),
    [sdk.ChainId.NEAR_TESTNET]: new sdk.Token(sdk.ChainId.NEAR_TESTNET, sdk.CHAINS[sdk.ChainId.NEAR_TESTNET].contracts.png, 18, sdk.CHAINS[sdk.ChainId.NEAR_TESTNET].png_symbol, 'Arcanum Near'),
};
const DAIe = {
    [sdk.ChainId.FUJI]: new sdk.Token(sdk.ChainId.FUJI, ZERO_ADDRESS$1, 18, 'DAI.e', 'Dai Stablecoin'),
    [sdk.ChainId.AVALANCHE]: new sdk.Token(sdk.ChainId.AVALANCHE, '0xd586E7F844cEa2F87f50152665BCbc2C279D8d70', 18, 'DAI.e', 'Dai Stablecoin'),
    [sdk.ChainId.WAGMI]: new sdk.Token(sdk.ChainId.WAGMI, ZERO_ADDRESS$1, 18, 'DAI.e', 'Dai Stablecoin'),
    [sdk.ChainId.COSTON]: new sdk.Token(sdk.ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.SONGBIRD]: new sdk.Token(sdk.ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.NEAR_MAINNET]: new sdk.Token(sdk.ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.NEAR_TESTNET]: new sdk.Token(sdk.ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};
const USDCe = {
    [sdk.ChainId.FUJI]: new sdk.Token(sdk.ChainId.FUJI, ZERO_ADDRESS$1, 6, 'USDC.e', 'USD Coin'),
    [sdk.ChainId.AVALANCHE]: new sdk.Token(sdk.ChainId.AVALANCHE, '0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664', 6, 'USDC.e', 'USD Coin'),
    [sdk.ChainId.WAGMI]: new sdk.Token(sdk.ChainId.WAGMI, ZERO_ADDRESS$1, 6, 'USDC.e', 'USD Coin'),
    [sdk.ChainId.COSTON]: new sdk.Token(sdk.ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.SONGBIRD]: new sdk.Token(sdk.ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.NEAR_MAINNET]: new sdk.Token(sdk.ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.NEAR_TESTNET]: new sdk.Token(sdk.ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};
const USDC = {
    [sdk.ChainId.FUJI]: new sdk.Token(sdk.ChainId.FUJI, ZERO_ADDRESS$1, 6, 'USDC', 'USD Coin'),
    [sdk.ChainId.AVALANCHE]: new sdk.Token(sdk.ChainId.AVALANCHE, '0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E', 6, 'USDC', 'USD Coin'),
    [sdk.ChainId.WAGMI]: new sdk.Token(sdk.ChainId.WAGMI, ZERO_ADDRESS$1, 6, 'USDC', 'USD Coin'),
    [sdk.ChainId.COSTON]: new sdk.Token(sdk.ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.SONGBIRD]: new sdk.Token(sdk.ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, 'USDC', 'USD Coin'),
    [sdk.ChainId.NEAR_MAINNET]: new sdk.Token(sdk.ChainId.NEAR_MAINNET, 'usdc.fakes.testnet', 18, 'USDC', 'USDC'),
    [sdk.ChainId.NEAR_TESTNET]: new sdk.Token(sdk.ChainId.NEAR_TESTNET, 'usdc.fakes.testnet', 18, 'USDC', 'USDC'),
};
const USDTe = {
    [sdk.ChainId.FUJI]: new sdk.Token(sdk.ChainId.FUJI, ZERO_ADDRESS$1, 6, 'USDT.e', 'Tether USD'),
    [sdk.ChainId.AVALANCHE]: new sdk.Token(sdk.ChainId.AVALANCHE, '0xc7198437980c041c805A1EDcbA50c1Ce5db95118', 6, 'USDT.e', 'Tether USD'),
    [sdk.ChainId.WAGMI]: new sdk.Token(sdk.ChainId.WAGMI, ZERO_ADDRESS$1, 6, 'USDT.e', 'Tether USD'),
    [sdk.ChainId.COSTON]: new sdk.Token(sdk.ChainId.COSTON, ZERO_ADDRESS$1, 6, '', ''),
    [sdk.ChainId.SONGBIRD]: new sdk.Token(sdk.ChainId.SONGBIRD, ZERO_ADDRESS$1, 6, '', ''),
    [sdk.ChainId.NEAR_MAINNET]: new sdk.Token(sdk.ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.NEAR_TESTNET]: new sdk.Token(sdk.ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};
const axlUST = {
    [sdk.ChainId.FUJI]: new sdk.Token(sdk.ChainId.FUJI, ZERO_ADDRESS$1, 6, 'axlUST', 'Axelar Wrapped UST'),
    [sdk.ChainId.AVALANCHE]: new sdk.Token(sdk.ChainId.AVALANCHE, '0x260Bbf5698121EB85e7a74f2E45E16Ce762EbE11', 6, 'axlUST', 'Axelar Wrapped UST'),
    [sdk.ChainId.WAGMI]: new sdk.Token(sdk.ChainId.WAGMI, ZERO_ADDRESS$1, 18, 'axlUST', 'Axelar Wrapped UST'),
    [sdk.ChainId.COSTON]: new sdk.Token(sdk.ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.SONGBIRD]: new sdk.Token(sdk.ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.NEAR_MAINNET]: new sdk.Token(sdk.ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.NEAR_TESTNET]: new sdk.Token(sdk.ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};
const UST = {
    [sdk.ChainId.FUJI]: new sdk.Token(sdk.ChainId.FUJI, ZERO_ADDRESS$1, 6, 'UST', 'Wormhole UST'),
    [sdk.ChainId.AVALANCHE]: new sdk.Token(sdk.ChainId.AVALANCHE, '0xb599c3590F42f8F995ECfa0f85D2980B76862fc1', 6, 'UST', 'Wormhole UST'),
    [sdk.ChainId.WAGMI]: new sdk.Token(sdk.ChainId.WAGMI, ZERO_ADDRESS$1, 6, 'UST', 'Wormhole UST'),
    [sdk.ChainId.COSTON]: new sdk.Token(sdk.ChainId.COSTON, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.SONGBIRD]: new sdk.Token(sdk.ChainId.SONGBIRD, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.NEAR_MAINNET]: new sdk.Token(sdk.ChainId.NEAR_MAINNET, ZERO_ADDRESS$1, 18, '', ''),
    [sdk.ChainId.NEAR_TESTNET]: new sdk.Token(sdk.ChainId.NEAR_TESTNET, ZERO_ADDRESS$1, 18, '', ''),
};

var _a$1, _b$1, _c$1, _d$1, _e$1, _f$1, _g$1, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
const BIG_INT_ZERO = sdk.JSBI.BigInt(0);
const BIG_INT_TWO = sdk.JSBI.BigInt(2);
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const NATIVE = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
const BIG_INT_SECONDS_IN_WEEK = sdk.JSBI.BigInt(60 * 60 * 24 * 7);
const ONE_TOKEN = sdk.JSBI.exponentiate(sdk.JSBI.BigInt(10), sdk.JSBI.BigInt(18));
const ROUTER_ADDRESS = {
    [sdk.ChainId.FUJI]: sdk.CHAINS[sdk.ChainId.FUJI].contracts.router,
    [sdk.ChainId.AVALANCHE]: sdk.CHAINS[sdk.ChainId.AVALANCHE].contracts.router,
    [sdk.ChainId.WAGMI]: sdk.CHAINS[sdk.ChainId.WAGMI].contracts.router,
    [sdk.ChainId.COSTON]: sdk.CHAINS[sdk.ChainId.COSTON].contracts.router,
    [sdk.ChainId.SONGBIRD]: sdk.CHAINS[sdk.ChainId.SONGBIRD].contracts.router,
    [sdk.ChainId.NEAR_MAINNET]: (_a$1 = sdk.CHAINS[sdk.ChainId.NEAR_MAINNET]) === null || _a$1 === void 0 ? void 0 : _a$1.contracts.router,
    [sdk.ChainId.NEAR_TESTNET]: (_b$1 = sdk.CHAINS[sdk.ChainId.NEAR_TESTNET]) === null || _b$1 === void 0 ? void 0 : _b$1.contracts.router,
};
const ROUTER_DAAS_ADDRESS = {
    [sdk.ChainId.FUJI]: (_e$1 = (_d$1 = (_c$1 = sdk.CHAINS[sdk.ChainId.FUJI]) === null || _c$1 === void 0 ? void 0 : _c$1.contracts) === null || _d$1 === void 0 ? void 0 : _d$1.router_daas) !== null && _e$1 !== void 0 ? _e$1 : ZERO_ADDRESS,
    [sdk.ChainId.AVALANCHE]: (_h = (_g$1 = (_f$1 = sdk.CHAINS[sdk.ChainId.AVALANCHE]) === null || _f$1 === void 0 ? void 0 : _f$1.contracts) === null || _g$1 === void 0 ? void 0 : _g$1.router_daas) !== null && _h !== void 0 ? _h : ZERO_ADDRESS,
    [sdk.ChainId.WAGMI]: (_l = (_k = (_j = sdk.CHAINS[sdk.ChainId.WAGMI]) === null || _j === void 0 ? void 0 : _j.contracts) === null || _k === void 0 ? void 0 : _k.router_daas) !== null && _l !== void 0 ? _l : ZERO_ADDRESS,
    [sdk.ChainId.COSTON]: (_p = (_o = (_m = sdk.CHAINS[sdk.ChainId.COSTON]) === null || _m === void 0 ? void 0 : _m.contracts) === null || _o === void 0 ? void 0 : _o.router_daas) !== null && _p !== void 0 ? _p : ZERO_ADDRESS,
    [sdk.ChainId.SONGBIRD]: (_s = (_r = (_q = sdk.CHAINS[sdk.ChainId.SONGBIRD]) === null || _q === void 0 ? void 0 : _q.contracts) === null || _r === void 0 ? void 0 : _r.router_daas) !== null && _s !== void 0 ? _s : ZERO_ADDRESS,
    [sdk.ChainId.NEAR_MAINNET]: (_v = (_u = (_t = sdk.CHAINS[sdk.ChainId.NEAR_MAINNET]) === null || _t === void 0 ? void 0 : _t.contracts) === null || _u === void 0 ? void 0 : _u.router_daas) !== null && _v !== void 0 ? _v : ZERO_ADDRESS,
    [sdk.ChainId.NEAR_TESTNET]: (_y = (_x = (_w = sdk.CHAINS[sdk.ChainId.NEAR_TESTNET]) === null || _w === void 0 ? void 0 : _w.contracts) === null || _x === void 0 ? void 0 : _x.router_daas) !== null && _y !== void 0 ? _y : ZERO_ADDRESS,
};
/**
 * Some tokens can only be swapped via certain pairs, so we override the list of bases that are considered for these
 * tokens.
 */
const CUSTOM_BASES = {
    [sdk.ChainId.AVALANCHE]: {},
};
const NetworkContextName = 'NETWORK';
// default allowed slippage, in bips
const INITIAL_ALLOWED_SLIPPAGE = 50;
// 10 minutes, denominated in seconds
const DEFAULT_DEADLINE_FROM_NOW = '600';
const getMiniChefAddress = (chainId) => {
    var _a;
    const minichefObj = (_a = sdk.CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef;
    if ((minichefObj === null || minichefObj === void 0 ? void 0 : minichefObj.type) === sdk.ChefType.MINI_CHEF_V2) {
        return minichefObj.address;
    }
    return undefined;
};
const MINICHEF_ADDRESS = {
    [sdk.ChainId.FUJI]: getMiniChefAddress(sdk.ChainId.FUJI),
    [sdk.ChainId.AVALANCHE]: getMiniChefAddress(sdk.ChainId.AVALANCHE),
    [sdk.ChainId.WAGMI]: getMiniChefAddress(sdk.ChainId.WAGMI),
    [sdk.ChainId.COSTON]: getMiniChefAddress(sdk.ChainId.COSTON),
    [sdk.ChainId.SONGBIRD]: getMiniChefAddress(sdk.ChainId.SONGBIRD),
    [sdk.ChainId.NEAR_MAINNET]: getMiniChefAddress(sdk.ChainId.NEAR_MAINNET),
    [sdk.ChainId.NEAR_TESTNET]: getMiniChefAddress(sdk.ChainId.NEAR_TESTNET),
};
const getPangoChefAddress = (chainId) => {
    var _a;
    const minichefObj = (_a = sdk.CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef;
    if ((minichefObj === null || minichefObj === void 0 ? void 0 : minichefObj.type) === sdk.ChefType.PANGO_CHEF) {
        return minichefObj.address;
    }
    return undefined;
};
const PANGOCHEF_ADDRESS = {
    [sdk.ChainId.FUJI]: getPangoChefAddress(sdk.ChainId.FUJI),
    [sdk.ChainId.AVALANCHE]: getPangoChefAddress(sdk.ChainId.AVALANCHE),
    [sdk.ChainId.WAGMI]: getPangoChefAddress(sdk.ChainId.WAGMI),
    [sdk.ChainId.COSTON]: getPangoChefAddress(sdk.ChainId.COSTON),
    [sdk.ChainId.SONGBIRD]: getPangoChefAddress(sdk.ChainId.SONGBIRD),
    [sdk.ChainId.NEAR_MAINNET]: undefined,
    [sdk.ChainId.NEAR_TESTNET]: undefined,
};
// these tokens can be directly linked to (via url params) in the swap page without prompting a warning
const TRUSTED_TOKEN_ADDRESSES = {
    [sdk.ChainId.FUJI]: [],
    [sdk.ChainId.AVALANCHE]: [sdk.WAVAX[sdk.ChainId.AVALANCHE].address, PNG[sdk.ChainId.AVALANCHE].address],
    [sdk.ChainId.WAGMI]: [sdk.WAVAX[sdk.ChainId.WAGMI].address, PNG[sdk.ChainId.WAGMI].address],
    [sdk.ChainId.COSTON]: [sdk.WAVAX[sdk.ChainId.COSTON].address, PNG[sdk.ChainId.COSTON].address],
    [sdk.ChainId.SONGBIRD]: [sdk.WAVAX[sdk.ChainId.SONGBIRD].address, PNG[sdk.ChainId.SONGBIRD].address],
    [sdk.ChainId.NEAR_MAINNET]: [sdk.WAVAX[sdk.ChainId.NEAR_MAINNET].address, PNG[sdk.ChainId.NEAR_MAINNET].address],
    [sdk.ChainId.NEAR_TESTNET]: [sdk.WAVAX[sdk.ChainId.NEAR_TESTNET].address, PNG[sdk.ChainId.NEAR_TESTNET].address],
};
const SWAP_DEFAULT_CURRENCY = {
    [sdk.ChainId.AVALANCHE]: {
        inputCurrency: 'AVAX',
        outputCurrency: USDC[sdk.ChainId.AVALANCHE].address,
    },
    [sdk.ChainId.FUJI]: {
        inputCurrency: '',
        outputCurrency: '',
    },
    [sdk.ChainId.WAGMI]: {
        inputCurrency: '',
        outputCurrency: '',
    },
    [sdk.ChainId.COSTON]: {
        inputCurrency: '',
        outputCurrency: '',
    },
    [sdk.ChainId.SONGBIRD]: {
        inputCurrency: 'SGB',
        outputCurrency: PNG[sdk.ChainId.SONGBIRD].address,
    },
    [sdk.ChainId.NEAR_MAINNET]: {
        inputCurrency: sdk.WAVAX[sdk.ChainId.NEAR_MAINNET].address,
        outputCurrency: PNG[sdk.ChainId.NEAR_MAINNET].address,
    },
    [sdk.ChainId.NEAR_TESTNET]: {
        inputCurrency: sdk.WAVAX[sdk.ChainId.NEAR_TESTNET].address,
        outputCurrency: PNG[sdk.ChainId.NEAR_TESTNET].address,
    },
};
// used to construct intermediary pairs for trading
const BASES_TO_CHECK_TRADES_AGAINST = {
    [sdk.ChainId.FUJI]: [sdk.WAVAX[sdk.ChainId.FUJI], PNG[sdk.ChainId.FUJI]],
    [sdk.ChainId.AVALANCHE]: [
        sdk.WAVAX[sdk.ChainId.AVALANCHE],
        PNG[sdk.ChainId.AVALANCHE],
        USDTe[sdk.ChainId.AVALANCHE],
        DAIe[sdk.ChainId.AVALANCHE],
        USDCe[sdk.ChainId.AVALANCHE],
        UST[sdk.ChainId.AVALANCHE],
        axlUST[sdk.ChainId.AVALANCHE],
        USDC[sdk.ChainId.AVALANCHE],
    ],
    [sdk.ChainId.WAGMI]: [sdk.WAVAX[sdk.ChainId.WAGMI], PNG[sdk.ChainId.WAGMI]],
    [sdk.ChainId.COSTON]: [sdk.WAVAX[sdk.ChainId.COSTON], PNG[sdk.ChainId.COSTON]],
    [sdk.ChainId.SONGBIRD]: [sdk.WAVAX[sdk.ChainId.SONGBIRD], PNG[sdk.ChainId.SONGBIRD]],
    [sdk.ChainId.NEAR_MAINNET]: [sdk.WAVAX[sdk.ChainId.NEAR_MAINNET], PNG[sdk.ChainId.NEAR_MAINNET]],
    [sdk.ChainId.NEAR_TESTNET]: [sdk.WAVAX[sdk.ChainId.NEAR_TESTNET], PNG[sdk.ChainId.NEAR_TESTNET]],
};
// one basis point
const ONE_BIPS = new sdk.Percent(sdk.JSBI.BigInt(1), sdk.JSBI.BigInt(10000));
const BIPS_BASE = sdk.JSBI.BigInt(10000);
// used for warning states
const ALLOWED_PRICE_IMPACT_LOW = new sdk.Percent(sdk.JSBI.BigInt(100), BIPS_BASE); // 1%
const ALLOWED_PRICE_IMPACT_MEDIUM = new sdk.Percent(sdk.JSBI.BigInt(300), BIPS_BASE); // 3%
const ALLOWED_PRICE_IMPACT_HIGH = new sdk.Percent(sdk.JSBI.BigInt(500), BIPS_BASE); // 5%
// if the price slippage exceeds this number, force the user to type 'confirm' to execute
const PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN = new sdk.Percent(sdk.JSBI.BigInt(1000), BIPS_BASE); // 10%
// for non expert mode disable swaps above this
const BLOCKED_PRICE_IMPACT_NON_EXPERT = new sdk.Percent(sdk.JSBI.BigInt(1500), BIPS_BASE); // 15%
// used to ensure the user doesn't send so much ETH so they end up with <.01
const MIN_ETH = sdk.JSBI.exponentiate(sdk.JSBI.BigInt(10), sdk.JSBI.BigInt(16)); // .01 ETH
const PANGOLIN_TOKENS_REPO_RAW_BASE_URL = `https://raw.githubusercontent.com/pangolindex/tokens`;
const ANALYTICS_PAGE = 'https://info.pangolin.exchange';
const PANGOLIN_API_BASE_URL = `https://api.pangolin.exchange`;
const TIMEFRAME = [
    {
        description: 'DAY',
        label: '1D',
        interval: 3600,
        momentIdentifier: 'day',
        days: '1',
    },
    {
        description: 'WEEK',
        label: '1W',
        interval: 86400,
        momentIdentifier: 'week',
        days: '7',
    },
    {
        description: 'MONTH',
        label: '1M',
        interval: 604800,
        momentIdentifier: 'month',
        days: '30',
    },
    {
        description: 'YEAR',
        label: '1Y',
        interval: 2629746,
        momentIdentifier: 'year',
        days: '365',
    },
    {
        description: 'ALL',
        label: 'ALL',
        interval: 2629746,
        momentIdentifier: '',
        days: 'max',
    },
];
const SUBGRAPH_BASE_URL = `https://api.thegraph.com/subgraphs/name/pangolindex`;
const LANDING_PAGE = 'https://pangolin.exchange';
const SUPPORTED_WALLETS = {
    INJECTED: {
        connector: injected,
        name: 'Injected',
        iconName: arrowRightIcon,
        description: 'Injected web3 provider.',
        href: null,
        color: '#010101',
        primary: true,
        isEVM: true,
    },
    METAMASK: {
        connector: injected,
        name: 'MetaMask',
        iconName: metamaskIcon,
        description: 'Easy-to-use browser extension.',
        href: null,
        color: '#E8831D',
        isEVM: true,
    },
    GNOSISSAFE: {
        connector: gnosisSafe,
        name: 'Gnosis Safe',
        iconName: gnosisSafeIcon,
        description: 'Gnosis Safe Multisig Wallet.',
        href: null,
        color: '#010101',
        isEVM: true,
    },
    WALLET_LINK: {
        connector: walletlink,
        name: 'Coinbase Wallet',
        iconName: coinbaseWalletIcon,
        description: 'Use Coinbase Wallet app on mobile device',
        href: null,
        color: '#315CF5',
        isEVM: true,
    },
    WALLET_CONNECT: {
        connector: walletconnect,
        name: 'Wallet Connect',
        iconName: walletConnectIcon,
        description: 'Use Wallet Connect',
        href: null,
        color: '#315CF5',
        isEVM: true,
    },
    XDEFI: {
        connector: xDefi,
        name: 'XDEFI Wallet',
        iconName: xDefiIcon,
        description: window.xfi && window.xfi.ethereum ? 'Easy-to-use browser extension.' : 'Please Install',
        href: null,
        color: '#315CF5',
        isEVM: true,
    },
    RABBY: {
        connector: injected,
        name: 'Rabby Wallet',
        iconName: rabbyIcon,
        description: 'Easy-to-use browser extension.',
        href: null,
        color: '#7a7cff',
        isEVM: true,
    },
    TALISMAN: {
        connector: talisman,
        name: 'Talisman',
        iconName: talismanIcon,
        description: 'Enter the Paraverse.',
        href: null,
        color: '#FF3D23',
        isEVM: true,
    },
    BITKEEP: {
        connector: bitKeep,
        name: 'BitKeep',
        iconName: bitKeepIcon,
        description: 'Easy-to-use browser extension.',
        href: null,
        color: '#7524f9',
        isEVM: true,
    },
    NEAR: {
        connector: near,
        name: 'Near',
        iconName: NearLogo,
        description: 'Near Web',
        href: null,
        color: '#315CF5',
        primary: true,
        isEVM: false,
    },
};
const PROVIDER_MAPPING = {
    [sdk.ChainId.FUJI]: CommonEVMProvider,
    [sdk.ChainId.AVALANCHE]: CommonEVMProvider,
    [sdk.ChainId.WAGMI]: CommonEVMProvider,
    [sdk.ChainId.COSTON]: CommonEVMProvider,
    [sdk.ChainId.SONGBIRD]: CommonEVMProvider,
    [sdk.ChainId.NEAR_MAINNET]: NearProvider,
    [sdk.ChainId.NEAR_TESTNET]: NearProvider,
};
const AVALANCHE_CHAIN_PARAMS = {
    chainId: '0xa86a',
    chainName: 'Avalanche Mainnet C-Chain',
    nativeCurrency: {
        name: 'Avalanche',
        symbol: 'AVAX',
        decimals: 18,
    },
    rpcUrls: ['https://api.avax.network/ext/bc/C/rpc'],
    blockExplorerUrls: ['https://snowtrace.io//'],
};
const IS_IN_IFRAME = window.parent !== window;
const DIRECTUS_URL_NEWS = `https://pangolin.directus.app`;
const COINGEKO_BASE_URL = `https://api.coingecko.com/api/v3`;
const NEAR_API_BASE_URL = `https://testnet-indexer.ref-finance.com`;
const OPEN_API_DEBANK = 'https://openapi.debank.com/v1/user';
const COINGECKO_API = 'https://api.coingecko.com/api/v3';
const ONE_YOCTO_NEAR = '0.000000000000000000000001';
const NEAR_STORAGE_PER_TOKEN = '0.005';
const NEAR_STORAGE_TO_REGISTER_WITH_FT = '0.1';
const NEAR_MIN_DEPOSIT_PER_TOKEN = new BN__default["default"]('5000000000000000000000');
const NEAR_MIN_DEPOSIT_PER_TOKEN_FARM = new BN__default["default"]('45000000000000000000000');
const NEAR_ACCOUNT_MIN_STORAGE_AMOUNT = '0.005';
const NEAR_LP_STORAGE_AMOUNT = '0.01';
const ONLY_ZEROS = /^0*\.?0*$/;
const WAVAX_AND_PNG_ONLY = {
    [sdk.ChainId.FUJI]: [sdk.WAVAX[sdk.ChainId.FUJI], PNG[sdk.ChainId.FUJI]],
    [sdk.ChainId.AVALANCHE]: [sdk.WAVAX[sdk.ChainId.AVALANCHE], PNG[sdk.ChainId.AVALANCHE]],
    [sdk.ChainId.WAGMI]: [sdk.WAVAX[sdk.ChainId.WAGMI], PNG[sdk.ChainId.WAGMI]],
    [sdk.ChainId.COSTON]: [sdk.WAVAX[sdk.ChainId.COSTON], PNG[sdk.ChainId.COSTON]],
    [sdk.ChainId.SONGBIRD]: [sdk.WAVAX[sdk.ChainId.SONGBIRD], PNG[sdk.ChainId.SONGBIRD]],
    [sdk.ChainId.NEAR_MAINNET]: [sdk.WAVAX[sdk.ChainId.NEAR_MAINNET], PNG[sdk.ChainId.NEAR_MAINNET]],
    [sdk.ChainId.NEAR_TESTNET]: [sdk.WAVAX[sdk.ChainId.NEAR_TESTNET], PNG[sdk.ChainId.NEAR_TESTNET]],
};
// used to construct the list of all pairs we consider by default in the frontend
const BASES_TO_TRACK_LIQUIDITY_FOR = Object.assign({}, WAVAX_AND_PNG_ONLY);
const PINNED_PAIRS = {
    [sdk.ChainId.AVALANCHE]: [],
};
const getSarAddress = (chainId) => {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.contracts) === null || _b === void 0 ? void 0 : _b.staking) === null || _c === void 0 ? void 0 : _c.find((c) => c.type === sdk.StakingType.SAR_POSITIONS && c.active)) === null || _d === void 0 ? void 0 : _d.address;
};
const SAR_STAKING_ADDRESS = {
    [sdk.ChainId.FUJI]: getSarAddress(sdk.ChainId.FUJI),
    [sdk.ChainId.AVALANCHE]: getSarAddress(sdk.ChainId.AVALANCHE),
    [sdk.ChainId.WAGMI]: getSarAddress(sdk.ChainId.WAGMI),
    [sdk.ChainId.COSTON]: getSarAddress(sdk.ChainId.COSTON),
    [sdk.ChainId.SONGBIRD]: getSarAddress(sdk.ChainId.SONGBIRD),
    [sdk.ChainId.NEAR_MAINNET]: getSarAddress(sdk.ChainId.NEAR_MAINNET),
    [sdk.ChainId.NEAR_TESTNET]: getSarAddress(sdk.ChainId.NEAR_TESTNET),
};
/* eslint-enable max-lines */
exports.SwapTypes = void 0;
(function (SwapTypes) {
    SwapTypes["MARKET"] = "MARKET";
    SwapTypes["LIMIT"] = "LIMIT";
})(exports.SwapTypes || (exports.SwapTypes = {}));
const PANGOCHEF_COMPOUND_SLIPPAGE = new sdk.Fraction('1', '50'); // 2% of slippage tolerange
const ONE_FRACTION = new sdk.Fraction('1');
const COINGECKO_CURRENCY_ID = {
    [sdk.ChainId.FUJI]: undefined,
    [sdk.ChainId.AVALANCHE]: 'avalanche-2',
    [sdk.ChainId.WAGMI]: undefined,
    [sdk.ChainId.COSTON]: undefined,
    [sdk.ChainId.SONGBIRD]: 'songbird',
    [sdk.ChainId.NEAR_MAINNET]: 'near',
    [sdk.ChainId.NEAR_TESTNET]: undefined,
};

var ApplicationModal;
(function (ApplicationModal) {
    ApplicationModal[ApplicationModal["WALLET"] = 0] = "WALLET";
    ApplicationModal[ApplicationModal["POOL_DETAIL"] = 1] = "POOL_DETAIL";
})(ApplicationModal || (ApplicationModal = {}));
const updateBlockNumber = toolkit.createAction('papplication/updateBlockNumber');
const setOpenModal = toolkit.createAction('papplication/setOpenModal');
const addPopup = toolkit.createAction('papplication/addPopup');
const removePopup = toolkit.createAction('papplication/removePopup');

const initialState$a = {
    blockNumber: {},
    popupList: [],
    openModal: null,
};
var papplication = toolkit.createReducer(initialState$a, (builder) => builder
    .addCase(updateBlockNumber, (state, action) => {
    var _a, _b;
    const { chainId, blockNumber } = action.payload;
    if (typeof ((_a = state === null || state === void 0 ? void 0 : state.blockNumber) === null || _a === void 0 ? void 0 : _a[chainId]) !== 'number') {
        state.blockNumber[chainId] = blockNumber;
    }
    else {
        state.blockNumber[chainId] = Math.max(blockNumber, (_b = state === null || state === void 0 ? void 0 : state.blockNumber) === null || _b === void 0 ? void 0 : _b[chainId]);
    }
})
    .addCase(setOpenModal, (state, action) => {
    state.openModal = action.payload;
})
    .addCase(addPopup, (state, { payload: { content, key, removeAfterMs = 15000 } }) => {
    state.popupList = (key ? state.popupList.filter((popup) => popup.key !== key) : state.popupList).concat([
        {
            key: key || toolkit.nanoid(),
            show: true,
            content,
            removeAfterMs,
        },
    ]);
})
    .addCase(removePopup, (state, { payload: { key } }) => {
    state.popupList.forEach((p) => {
        if (p.key === key) {
            p.show = false;
        }
    });
}));

var Field$2;
(function (Field) {
    Field["LIQUIDITY_PERCENT"] = "LIQUIDITY_PERCENT";
    Field["LIQUIDITY"] = "LIQUIDITY";
    Field["CURRENCY_A"] = "CURRENCY_A";
    Field["CURRENCY_B"] = "CURRENCY_B";
})(Field$2 || (Field$2 = {}));
const typeInput$2 = toolkit.createAction('burn/typeInputBurn');

const initialState$9 = {
    independentField: Field$2.LIQUIDITY_PERCENT,
    typedValue: '0',
};
var pburn = toolkit.createReducer(initialState$9, (builder) => builder.addCase(typeInput$2, (state, { payload: { field, typedValue } }) => {
    return Object.assign(Object.assign({}, state), { independentField: field, typedValue });
}));

// the Arcanum Default token list lives here
const PANGOLIN_LIST = 'https://raw.githubusercontent.com/pangolindex/tokenlists/main/pangolin.tokenlist.json';
const DEFAULT_TOKEN_LISTS_SELECTED = [PANGOLIN_LIST];
const DEFAULT_TOKEN_LISTS = [PANGOLIN_LIST];
// Token addresses (excluding PNG and WAVAX) ported from:
// https://raw.githubusercontent.com/pangolindex/tokenlists/main/aeb.tokenlist.json
const AEB_TOKENS = [
    '0xf20d962a6c8f70c731bd838a3a388D7d48fA6e15',
    '0xE54EB2C3009Fa411BF24fB017F9725b973CE36F0',
    '0x8cE2Dee54bB9921a2AE0A63dBb2DF8eD88B91dD9',
    '0x6b329326E0F6b95B93b52229b213334278D6f277',
    '0xaEb044650278731Ef3DC244692AB9F64C78FfaEA',
    '0xB3fe5374F67D7a22886A0eE082b2E2f9d2651651',
    '0xbA7dEebBFC5fA1100Fb055a87773e1E99Cd3507a',
    '0x46C54b16aF7747067f412c78eBaDaE203a26aDa0',
    '0xE1463E8991c8A62e64b77b5Fb6B22F190344C2A9',
    '0x39cf1BD5f15fb22eC3D9Ff86b0727aFc203427cc',
    '0x68e44C4619db40ae1a0725e77C02587bC8fBD1c9',
    '0xde3A24028580884448a5397872046a019649b084',
    '0x390ba0fb0Bd3Aa2a5484001606329701148074e6',
    '0xC84d7bfF2555955b44BDF6A307180810412D751B',
    '0xf39f9671906d8630812f9d9863bBEf5D523c84Ab',
    '0x408D4cD0ADb7ceBd1F1A1C33A0Ba2098E1295bAB',
    '0x99519AcB025a0e0d44c3875A4BbF03af65933627',
];

// fired once when the app reloads but before the app renders
// allows any updates to be applied to store data loaded from localStorage
const updateVersion = toolkit.createAction('pglobal/updateVersion');

const fetchTokenList = {
    pending: toolkit.createAction('plists/fetchTokenList/pending'),
    fulfilled: toolkit.createAction('plists/fetchTokenList/fulfilled'),
    rejected: toolkit.createAction('plists/fetchTokenList/rejected'),
};
const acceptListUpdate = toolkit.createAction('plists/acceptListUpdate');
const addList = toolkit.createAction('plists/addList');
const removeList = toolkit.createAction('plists/removeList');
const selectList = toolkit.createAction('plists/selectList');
toolkit.createAction('plists/rejectVersionUpdate');

const NEW_LIST_STATE = {
    error: null,
    current: null,
    loadingRequestId: null,
    pendingUpdate: null,
};
const initialState$8 = {
    lastInitializedDefaultListOfLists: DEFAULT_TOKEN_LISTS,
    byUrl: Object.assign({}, DEFAULT_TOKEN_LISTS.reduce((memo, listUrl) => {
        memo[listUrl] = NEW_LIST_STATE;
        return memo;
    }, {})),
    selectedListUrl: DEFAULT_TOKEN_LISTS_SELECTED,
};
var plists = toolkit.createReducer(initialState$8, (builder) => builder
    .addCase(fetchTokenList.pending, (state, { payload: { requestId, url } }) => {
    state.byUrl[url] = Object.assign(Object.assign({ 
        // eslint-disable-next-line  @typescript-eslint/ban-ts-comment
        // @ts-ignore
        current: null, 
        // eslint-disable-next-line  @typescript-eslint/ban-ts-comment
        // @ts-ignore
        pendingUpdate: null }, state.byUrl[url]), { loadingRequestId: requestId, error: null });
})
    .addCase(fetchTokenList.fulfilled, (state, { payload: { requestId, tokenList, url } }) => {
    var _a, _b;
    const current = (_a = state.byUrl[url]) === null || _a === void 0 ? void 0 : _a.current;
    const loadingRequestId = (_b = state.byUrl[url]) === null || _b === void 0 ? void 0 : _b.loadingRequestId;
    // no-op if update does nothing
    if (current) {
        const upgradeType = tokenLists.getVersionUpgrade(current.version, tokenList.version);
        if (upgradeType === tokenLists.VersionUpgrade.NONE)
            return;
        if (loadingRequestId === null || loadingRequestId === requestId) {
            state.byUrl[url] = Object.assign(Object.assign({}, state.byUrl[url]), { loadingRequestId: null, error: null, current: current, pendingUpdate: tokenList });
        }
    }
    else {
        state.byUrl[url] = Object.assign(Object.assign({}, state.byUrl[url]), { loadingRequestId: null, error: null, current: tokenList, pendingUpdate: null });
    }
})
    .addCase(fetchTokenList.rejected, (state, { payload: { url, requestId, errorMessage } }) => {
    var _a;
    if (((_a = state.byUrl[url]) === null || _a === void 0 ? void 0 : _a.loadingRequestId) !== requestId) {
        // no-op since it's not the latest request
        return;
    }
    state.byUrl[url] = Object.assign(Object.assign({}, state.byUrl[url]), { loadingRequestId: null, error: errorMessage, current: null, pendingUpdate: null });
})
    .addCase(selectList, (state, { payload: { url, shouldSelect } }) => {
    const existingSelectedListUrl = [].concat(state.selectedListUrl || []);
    if (shouldSelect) {
        // if user want to select the list, then just push it into selected array
        existingSelectedListUrl.push(url);
        state.selectedListUrl = existingSelectedListUrl;
    }
    else {
        const index = existingSelectedListUrl.indexOf(url);
        if (index !== -1) {
            if ((existingSelectedListUrl === null || existingSelectedListUrl === void 0 ? void 0 : existingSelectedListUrl.length) === 1) {
                // if user want to deselect the list and if there is only one item in the list
                state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
            }
            else {
                existingSelectedListUrl.splice(index, 1);
                state.selectedListUrl = existingSelectedListUrl;
            }
        }
    }
    // automatically adds list
    if (!state.byUrl[url]) {
        state.byUrl[url] = NEW_LIST_STATE;
    }
})
    .addCase(addList, (state, { payload: url }) => {
    if (!state.byUrl[url]) {
        state.byUrl[url] = NEW_LIST_STATE;
    }
})
    .addCase(removeList, (state, { payload: url }) => {
    if (state.byUrl[url]) {
        delete state.byUrl[url];
    }
    const existingList = [].concat(state.selectedListUrl || []);
    const index = existingList.indexOf(url);
    if (index !== -1) {
        if ((existingList === null || existingList === void 0 ? void 0 : existingList.length) === 1) {
            // if user want to remove the list and if there is only one item in the selected list
            state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
        }
        else {
            existingList.splice(index, 1);
            state.selectedListUrl = existingList;
        }
    }
})
    .addCase(acceptListUpdate, (state, { payload: url }) => {
    var _a;
    if (!((_a = state.byUrl[url]) === null || _a === void 0 ? void 0 : _a.pendingUpdate)) {
        throw new Error('accept list update called without pending update');
    }
    state.byUrl[url] = Object.assign(Object.assign({}, state.byUrl[url]), { pendingUpdate: null, current: state.byUrl[url].pendingUpdate });
})
    .addCase(updateVersion, (state) => {
    // state loaded from localStorage, but new lists have never been initialized
    if (!state.lastInitializedDefaultListOfLists) {
        state.byUrl = initialState$8.byUrl;
        state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
    }
    else if (state.lastInitializedDefaultListOfLists) {
        const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce((s, l) => s.add(l), new Set());
        const newListOfListsSet = DEFAULT_TOKEN_LISTS.reduce((s, l) => s.add(l), new Set());
        // Detected addition of default token lists
        DEFAULT_TOKEN_LISTS.forEach((listUrl) => {
            if (!lastInitializedSet.has(listUrl)) {
                state.byUrl[listUrl] = NEW_LIST_STATE;
                if (DEFAULT_TOKEN_LISTS_SELECTED.includes(listUrl)) {
                    if (!state.selectedListUrl || !state.selectedListUrl.includes(listUrl)) {
                        state.selectedListUrl = (state.selectedListUrl || []).concat([listUrl]);
                    }
                }
            }
        });
        // Detected removal of default token lists
        state.lastInitializedDefaultListOfLists.forEach((listUrl) => {
            if (!newListOfListsSet.has(listUrl)) {
                delete state.byUrl[listUrl];
                if (!!state.selectedListUrl && state.selectedListUrl.includes(listUrl)) {
                    state.selectedListUrl = state.selectedListUrl.filter((url) => url !== listUrl);
                    if (state.selectedListUrl.length === 0) {
                        state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
                    }
                }
            }
        });
    }
    state.lastInitializedDefaultListOfLists = DEFAULT_TOKEN_LISTS;
    if (!state.selectedListUrl) {
        state.selectedListUrl = DEFAULT_TOKEN_LISTS_SELECTED;
        DEFAULT_TOKEN_LISTS.forEach((listUrl) => {
            if (!state.byUrl[listUrl]) {
                state.byUrl[listUrl] = NEW_LIST_STATE;
            }
        });
    }
}));

var Field$1;
(function (Field) {
    Field["CURRENCY_A"] = "CURRENCY_A";
    Field["CURRENCY_B"] = "CURRENCY_B";
})(Field$1 || (Field$1 = {}));
const typeInput$1 = toolkit.createAction('mint/typeInputMint');
const resetMintState = toolkit.createAction('mint/resetMintState');

const initialState$7 = {
    independentField: Field$1.CURRENCY_A,
    typedValue: '',
    otherTypedValue: '',
};
var pmint = toolkit.createReducer(initialState$7, (builder) => builder
    .addCase(resetMintState, () => initialState$7)
    .addCase(typeInput$1, (state, { payload: { field, typedValue, noLiquidity } }) => {
    if (noLiquidity) {
        // they're typing into the field they've last typed in
        if (field === state.independentField) {
            return Object.assign(Object.assign({}, state), { independentField: field, typedValue });
        }
        // they're typing into a new field, store the other value
        else {
            return Object.assign(Object.assign({}, state), { independentField: field, typedValue, otherTypedValue: state.typedValue });
        }
    }
    else {
        return Object.assign(Object.assign({}, state), { independentField: field, typedValue, otherTypedValue: '' });
    }
}));

const ADDRESS_REGEX$1 = /^0x[a-fA-F0-9]{40}$/;
const LOWER_HEX_REGEX = /^0x[a-f0-9]*$/;
function toCallKey(call) {
    if (!ADDRESS_REGEX$1.test(call.address)) {
        throw new Error(`Invalid address: ${call.address}`);
    }
    if (!LOWER_HEX_REGEX.test(call.callData)) {
        throw new Error(`Invalid hex: ${call.callData}`);
    }
    return `${call.address}-${call.callData}`;
}
function parseCallKey(callKey) {
    const pcs = callKey.split('-');
    if (pcs.length !== 2) {
        throw new Error(`Invalid call key: ${callKey}`);
    }
    return {
        address: pcs[0],
        callData: pcs[1],
    };
}
const addMulticallListeners = toolkit.createAction('pmulticall/addMulticallListeners');
const removeMulticallListeners = toolkit.createAction('pmulticall/removeMulticallListeners');
const fetchingMulticallResults = toolkit.createAction('pmulticall/fetchingMulticallResults');
const errorFetchingMulticallResults = toolkit.createAction('pmulticall/errorFetchingMulticallResults');
const updateMulticallResults = toolkit.createAction('pmulticall/updateMulticallResults');

const initialState$6 = {
    callResults: {},
};
var pmulticall = toolkit.createReducer(initialState$6, (builder) => builder
    .addCase(addMulticallListeners, (state, { payload: { calls, chainId, options: { blocksPerFetch = 1 } = {} } }) => {
    var _a;
    const listeners = state.callListeners
        ? state.callListeners
        : (state.callListeners = {});
    listeners[chainId] = (_a = listeners[chainId]) !== null && _a !== void 0 ? _a : {};
    calls.forEach((call) => {
        var _a, _b;
        const callKey = toCallKey(call);
        listeners[chainId][callKey] = (_a = listeners[chainId][callKey]) !== null && _a !== void 0 ? _a : {};
        listeners[chainId][callKey][blocksPerFetch] = ((_b = listeners[chainId][callKey][blocksPerFetch]) !== null && _b !== void 0 ? _b : 0) + 1;
    });
})
    .addCase(removeMulticallListeners, (state, { payload: { chainId, calls, options: { blocksPerFetch = 1 } = {} } }) => {
    const listeners = state.callListeners
        ? state.callListeners
        : (state.callListeners = {});
    if (!listeners[chainId])
        return;
    calls.forEach((call) => {
        const callKey = toCallKey(call);
        if (!listeners[chainId][callKey])
            return;
        if (!listeners[chainId][callKey][blocksPerFetch])
            return;
        if (listeners[chainId][callKey][blocksPerFetch] === 1) {
            delete listeners[chainId][callKey][blocksPerFetch];
        }
        else {
            listeners[chainId][callKey][blocksPerFetch]--;
        }
    });
})
    .addCase(fetchingMulticallResults, (state, { payload: { chainId, fetchingBlockNumber, calls } }) => {
    var _a;
    state.callResults[chainId] = (_a = state.callResults[chainId]) !== null && _a !== void 0 ? _a : {};
    calls.forEach((call) => {
        var _a;
        const callKey = toCallKey(call);
        const current = state.callResults[chainId][callKey];
        if (!current) {
            state.callResults[chainId][callKey] = {
                fetchingBlockNumber,
            };
        }
        else {
            if (((_a = current.fetchingBlockNumber) !== null && _a !== void 0 ? _a : 0) >= fetchingBlockNumber)
                return;
            state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber;
        }
    });
})
    .addCase(errorFetchingMulticallResults, (state, { payload: { fetchingBlockNumber, chainId, calls } }) => {
    var _a;
    state.callResults[chainId] = (_a = state.callResults[chainId]) !== null && _a !== void 0 ? _a : {};
    calls.forEach((call) => {
        const callKey = toCallKey(call);
        const current = state.callResults[chainId][callKey];
        if (!current)
            return; // only should be dispatched if we are already fetching
        if (current.fetchingBlockNumber === fetchingBlockNumber) {
            delete current.fetchingBlockNumber;
            current.data = null;
            current.blockNumber = fetchingBlockNumber;
        }
    });
})
    .addCase(updateMulticallResults, (state, { payload: { chainId, results, blockNumber } }) => {
    var _a;
    state.callResults[chainId] = (_a = state.callResults[chainId]) !== null && _a !== void 0 ? _a : {};
    Object.keys(results).forEach((callKey) => {
        var _a;
        const current = state.callResults[chainId][callKey];
        if (((_a = current === null || current === void 0 ? void 0 : current.blockNumber) !== null && _a !== void 0 ? _a : 0) > blockNumber)
            return;
        state.callResults[chainId][callKey] = {
            data: results[callKey],
            blockNumber,
        };
    });
}));

const updateMinichefStakingAllData = toolkit.createAction('pstake/updateMinichefStakingAllData');
const updateMinichefStakingAllAprs = toolkit.createAction('pstake/updateMinichefStakingAllAprs');
const updateMinichefStakingAllFarmsEarnedAmount = toolkit.createAction('pstake/updateMinichefStakingAllFarmsEarnedAmount');

const initialState$5 = {
    minichefStakingData: {},
    aprs: {},
    earnedAmounts: {},
};
var SortingType$1;
(function (SortingType) {
    SortingType["totalStakedInUsd"] = "totalStakedInUsd";
    SortingType["totalApr"] = "totalApr";
})(SortingType$1 || (SortingType$1 = {}));
var pstake = toolkit.createReducer(initialState$5, (builder) => builder
    .addCase(updateMinichefStakingAllData, (state, { payload: { data: { chainId, data }, }, }) => {
    // console.info('updateMinichefStakingAllData')
    const existingData = Object.assign(Object.assign({}, (state.minichefStakingData[chainId] || {})), data);
    state.minichefStakingData[chainId] = existingData;
})
    .addCase(updateMinichefStakingAllAprs, (state, { payload: { data: { chainId, data }, }, }) => {
    // console.info('updateMinichefStakingALLAprs')
    state.aprs[chainId] = data;
})
    .addCase(updateMinichefStakingAllFarmsEarnedAmount, (state, { payload: { data: { chainId, data }, }, }) => {
    // console.info('updateMinichefStakingAllFarmsEarnedAmount')
    state.earnedAmounts[chainId] = data;
}));

var Field;
(function (Field) {
    Field["INPUT"] = "INPUT";
    Field["OUTPUT"] = "OUTPUT";
})(Field || (Field = {}));
var LimitField;
(function (LimitField) {
    LimitField["INPUT"] = "input";
    LimitField["OUTPUT"] = "output";
    LimitField["PRICE"] = "price";
})(LimitField || (LimitField = {}));
var LimitNewField;
(function (LimitNewField) {
    LimitNewField["INPUT"] = "INPUT";
    LimitNewField["OUTPUT"] = "OUTPUT";
    LimitNewField["PRICE"] = "PRICE";
})(LimitNewField || (LimitNewField = {}));
const selectCurrency = toolkit.createAction('pswap/selectCurrency');
const switchCurrencies = toolkit.createAction('pswap/switchCurrencies');
const typeInput = toolkit.createAction('pswap/typeInput');
const replaceSwapState = toolkit.createAction('pswap/replaceSwapState');
const setRecipient = toolkit.createAction('pswap/setRecipient');
const updateFeeTo = toolkit.createAction('pswap/updateFeeTo');
const updateFeeInfo = toolkit.createAction('pswap/updateFeeInfo');

const initialState$4 = {
    independentField: Field.INPUT,
    typedValue: '',
    [Field.INPUT]: {
        currencyId: '',
    },
    [Field.OUTPUT]: {
        currencyId: '',
    },
    recipient: null,
    feeTo: ZERO_ADDRESS,
    feeInfo: {
        feePartner: 0,
        feeProtocol: 0,
        feeTotal: 0,
        feeCut: 5000,
        initialized: false,
    },
};
var pswap = toolkit.createReducer(initialState$4, (builder) => builder
    .addCase(replaceSwapState, (state, { payload: { typedValue, recipient, field, inputCurrencyId, outputCurrencyId } }) => {
    return Object.assign(Object.assign({}, state), { [Field.INPUT]: {
            currencyId: inputCurrencyId,
        }, [Field.OUTPUT]: {
            currencyId: outputCurrencyId,
        }, independentField: field, typedValue: typedValue, recipient });
})
    .addCase(selectCurrency, (state, { payload: { currencyId, field } }) => {
    const otherField = field === Field.INPUT ? Field.OUTPUT : Field.INPUT;
    if (currencyId === state[otherField].currencyId) {
        // the case where we have to swap the order
        return Object.assign(Object.assign({}, state), { independentField: state.independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT, [field]: { currencyId: currencyId }, [otherField]: { currencyId: state[field].currencyId } });
    }
    else {
        // the normal case
        return Object.assign(Object.assign({}, state), { [field]: { currencyId: currencyId } });
    }
})
    .addCase(switchCurrencies, (state) => {
    return Object.assign(Object.assign({}, state), { independentField: state.independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT, [Field.INPUT]: { currencyId: state[Field.OUTPUT].currencyId }, [Field.OUTPUT]: { currencyId: state[Field.INPUT].currencyId } });
})
    .addCase(typeInput, (state, { payload: { field, typedValue } }) => {
    return Object.assign(Object.assign({}, state), { independentField: field, typedValue });
})
    .addCase(setRecipient, (state, { payload: { recipient } }) => {
    state.recipient = recipient;
})
    .addCase(updateFeeTo, (state, { payload: { feeTo } }) => {
    state.feeTo = feeTo;
})
    .addCase(updateFeeInfo, (state, { payload: { feeInfo } }) => {
    state.feeInfo = feeInfo;
}));

const updateTokenWeeklyPriceChartData = toolkit.createAction('token/updateTokenWeeklyPriceChartData');
const updateTokenPriceChartData = toolkit.createAction('token/updateTokenPriceChartData');

const initialState$3 = {
    weekly: {},
    tokenPrices: {},
};
var ptoken = toolkit.createReducer(initialState$3, (builder) => builder
    .addCase(updateTokenWeeklyPriceChartData, (state, { payload: { address, chartData } }) => {
    const container = {};
    container[address] = chartData;
    const existingChartData = Object.assign(Object.assign({}, (state.weekly || {})), container);
    state.weekly = existingChartData;
})
    .addCase(updateTokenPriceChartData, (state, { payload: { address, chartData } }) => {
    const container = {};
    container[address] = chartData;
    const existingChartData = Object.assign(Object.assign({}, (state.tokenPrices || {})), container);
    state.tokenPrices = existingChartData;
}));

const addTransaction = toolkit.createAction('ptransactions/addTransaction');
const clearAllTransactions = toolkit.createAction('ptransactions/clearAllTransactions');
const finalizeTransaction = toolkit.createAction('ptransactions/finalizeTransaction');
const checkedTransaction = toolkit.createAction('ptransactions/checkedTransaction');

const now = () => new Date().getTime();
const initialState$2 = {};
var ptransactions = toolkit.createReducer(initialState$2, (builder) => builder
    .addCase(addTransaction, (transactions, { payload: { chainId, from, hash, approval, summary, claim } }) => {
    var _a, _b;
    // if transaction is already exist then do nothing
    if ((_a = transactions[chainId]) === null || _a === void 0 ? void 0 : _a[hash]) {
        return;
    }
    const txs = (_b = transactions[chainId]) !== null && _b !== void 0 ? _b : {};
    txs[hash] = { hash, approval, summary, claim, from, addedTime: now() };
    transactions[chainId] = txs;
})
    .addCase(clearAllTransactions, (transactions, { payload: { chainId } }) => {
    if (!transactions[chainId])
        return;
    transactions[chainId] = {};
})
    .addCase(checkedTransaction, (transactions, { payload: { chainId, hash, blockNumber } }) => {
    var _a;
    const tx = (_a = transactions[chainId]) === null || _a === void 0 ? void 0 : _a[hash];
    if (!tx) {
        return;
    }
    if (!tx.lastCheckedBlockNumber) {
        tx.lastCheckedBlockNumber = blockNumber;
    }
    else {
        tx.lastCheckedBlockNumber = Math.max(blockNumber, tx.lastCheckedBlockNumber);
    }
})
    .addCase(finalizeTransaction, (transactions, { payload: { hash, chainId, receipt } }) => {
    var _a;
    const tx = (_a = transactions[chainId]) === null || _a === void 0 ? void 0 : _a[hash];
    if (!tx) {
        return;
    }
    tx.receipt = receipt;
    tx.confirmedTime = now();
}));

const updateUserSlippageTolerance = toolkit.createAction('puser/updateUserSlippageTolerance');
const updateUserExpertMode = toolkit.createAction('puser/updateUserExpertMode');
const updateUserDeadline = toolkit.createAction('puser/updateUserDeadline');
const addSerializedToken = toolkit.createAction('puser/addSerializedToken');
const removeSerializedToken = toolkit.createAction('puser/removeSerializedToken');
const addSerializedPair = toolkit.createAction('puser/addSerializedPair');

const currentTimestamp = () => new Date().getTime();
function pairKey(token0Address, token1Address) {
    return `${token0Address};${token1Address}`;
}
const initialState$1 = {
    userSlippageTolerance: INITIAL_ALLOWED_SLIPPAGE,
    tokens: {},
    timestamp: currentTimestamp(),
    userExpertMode: false,
    userDeadline: DEFAULT_DEADLINE_FROM_NOW,
    pairs: {},
};
var puser = toolkit.createReducer(initialState$1, (builder) => builder
    .addCase(updateUserSlippageTolerance, (state, action) => {
    state.userSlippageTolerance = action.payload.userSlippageTolerance;
    state.timestamp = currentTimestamp();
})
    .addCase(updateUserExpertMode, (state, action) => {
    state.userExpertMode = action.payload.userExpertMode;
    state.timestamp = currentTimestamp();
})
    .addCase(updateUserDeadline, (state, action) => {
    state.userDeadline = action.payload.userDeadline;
    state.timestamp = currentTimestamp();
})
    .addCase(addSerializedToken, (state, { payload: { serializedToken } }) => {
    state.tokens[serializedToken.chainId] = state.tokens[serializedToken.chainId] || {};
    state.tokens[serializedToken.chainId][serializedToken.address] = serializedToken;
    state.timestamp = currentTimestamp();
})
    .addCase(removeSerializedToken, (state, { payload: { address, chainId } }) => {
    state.tokens[chainId] = state.tokens[chainId] || {};
    delete state.tokens[chainId][address];
    state.timestamp = currentTimestamp();
})
    .addCase(addSerializedPair, (state, { payload: { serializedPair } }) => {
    if (serializedPair.token0.chainId === serializedPair.token1.chainId &&
        serializedPair.token0.address !== serializedPair.token1.address) {
        state.pairs = state.pairs || {};
        const chainId = serializedPair.token0.chainId;
        state.pairs[chainId] = state.pairs[chainId] || {};
        state.pairs[chainId][pairKey(serializedPair.token0.address, serializedPair.token1.address)] = serializedPair;
    }
    state.timestamp = currentTimestamp();
}));

const addCurrency = toolkit.createAction('watchlists/addCurrency');
const removeCurrency = toolkit.createAction('watchlists/removeCurrency');

const initialState = {
    currencies: [],
};
var pwatchlists = toolkit.createReducer(initialState, (builder) => builder
    .addCase(addCurrency, (state, { payload: address }) => {
    const existingSelectedListUrl = [].concat(state.currencies || []);
    existingSelectedListUrl.push(address);
    state.currencies = existingSelectedListUrl;
})
    .addCase(removeCurrency, (state, { payload: address }) => {
    const existingList = [].concat(state.currencies || []);
    const index = existingList.indexOf(address);
    if (index !== -1) {
        if ((existingList === null || existingList === void 0 ? void 0 : existingList.length) === 1) {
            // if user want to remove the list and if there is only one item in the selected list
            state.currencies = [];
        }
        else {
            existingList.splice(index, 1);
            state.currencies = existingList;
        }
    }
}));

const PANGOLIN_PERSISTED_KEYS = [
    'puser',
    'plists',
    'ptransactions',
    'pwatchlists',
    'ptoken',
    'pstake',
];
const pangolinReducers = {
    papplication,
    ptransactions,
    pswap,
    plists,
    pmulticall,
    puser,
    pwatchlists,
    ptoken,
    pstake,
    pmint,
    pburn,
};
const store = toolkit.configureStore({
    reducer: pangolinReducers,
    middleware: [...toolkit.getDefaultMiddleware({ thunk: false }), reduxLocalstorageSimple.save({ states: PANGOLIN_PERSISTED_KEYS })],
    preloadedState: reduxLocalstorageSimple.load({ states: PANGOLIN_PERSISTED_KEYS }),
});
const StoreContext = React__default["default"].createContext(null);
// Export your custom hooks if you wish to use them in other files.
reactRedux.createStoreHook(StoreContext);
const useDispatch = reactRedux.createDispatchHook(StoreContext);
const useSelector = reactRedux.createSelectorHook(StoreContext);
/**
 * create separate galeto store
 */
const galetoStore = toolkit.configureStore({
    reducer: limitOrdersReact.gelatoReducers,
    middleware: [...toolkit.getDefaultMiddleware({ thunk: false }), reduxLocalstorageSimple.save({ states: limitOrdersReact.GELATO_PERSISTED_KEYS })],
    preloadedState: reduxLocalstorageSimple.load({ states: limitOrdersReact.GELATO_PERSISTED_KEYS }),
});

function useBlockNumber() {
    const chainId = useChainId();
    return useSelector((state) => { var _a, _b; return (_b = (_a = state === null || state === void 0 ? void 0 : state.papplication) === null || _a === void 0 ? void 0 : _a.blockNumber) === null || _b === void 0 ? void 0 : _b[chainId]; });
}
function useModalOpen(modal) {
    const openModal = useSelector((state) => state.papplication.openModal);
    return openModal === modal;
}
function useToggleModal(modal) {
    const open = useModalOpen(modal);
    const dispatch = useDispatch();
    return React.useCallback(() => dispatch(setOpenModal(open ? null : modal)), [dispatch, modal, open]);
}
function useWalletModalToggle() {
    return useToggleModal(ApplicationModal.WALLET);
}
function usePoolDetailnModalToggle() {
    return useToggleModal(ApplicationModal.POOL_DETAIL);
}
// returns a function that allows adding a popup
function useAddPopup() {
    const dispatch = useDispatch();
    return React.useCallback((content, key) => {
        dispatch(addPopup({ content, key }));
    }, [dispatch]);
}
// returns a function that allows removing a popup via its key
function useRemovePopup() {
    const dispatch = useDispatch();
    return React.useCallback((key) => {
        dispatch(removePopup({ key }));
    }, [dispatch]);
}
// get the list of active popups
function useActivePopups() {
    const list = useSelector((state) => state.papplication.popupList);
    return React.useMemo(() => list.filter((item) => item.show), [list]);
}

function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
function waitRandom(min, max) {
    return wait(min + Math.round(Math.random() * Math.max(0, max - min)));
}
/**
 * This error is thrown if the function is cancelled before completing
 */
class CancelledError extends Error {
    constructor() {
        super('Cancelled');
    }
}
/**
 * Throw this error if the function should retry
 */
class RetryableError extends Error {
}
/**
 * Retries the function that returns the promise until the promise successfully resolves up to n retries
 * @param fn function to retry
 * @param n how many times to retry
 * @param minWait min wait between retries in ms
 * @param maxWait max wait between retries in ms
 */
function retry(fn, { n, minWait, maxWait }) {
    let completed = false;
    let rejectCancelled;
    const promise = new Promise((resolve, reject) => tslib.__awaiter(this, void 0, void 0, function* () {
        rejectCancelled = reject;
        while (true) {
            let result;
            try {
                result = yield fn();
                if (!completed) {
                    resolve(result);
                    completed = true;
                }
                break;
            }
            catch (error) {
                if (completed) {
                    break;
                }
                if (n <= 0 || !(error instanceof RetryableError)) {
                    reject(error);
                    completed = true;
                    break;
                }
                n--;
            }
            yield waitRandom(minWait, maxWait);
        }
    }));
    return {
        promise,
        cancel: () => {
            if (completed)
                return;
            completed = true;
            rejectCancelled(new CancelledError());
        },
    };
}

var _a, _b, _c, _d, _e, _f, _g;
// returns the checksummed address if the address is valid, otherwise returns false
function isAddress(value) {
    try {
        return address.getAddress(value);
    }
    catch (_a) {
        return false;
    }
}
const ETHERSCAN_PREFIXES = {
    43113: ((_a = sdk.CHAINS[sdk.ChainId.FUJI].blockExplorerUrls) === null || _a === void 0 ? void 0 : _a[0]) || '',
    43114: ((_b = sdk.CHAINS[sdk.ChainId.AVALANCHE].blockExplorerUrls) === null || _b === void 0 ? void 0 : _b[0]) || '',
    11111: ((_c = sdk.CHAINS[sdk.ChainId.WAGMI].blockExplorerUrls) === null || _c === void 0 ? void 0 : _c[0]) || '',
    16: ((_d = sdk.CHAINS[sdk.ChainId.COSTON].blockExplorerUrls) === null || _d === void 0 ? void 0 : _d[0]) || '',
    19: ((_e = sdk.CHAINS[sdk.ChainId.SONGBIRD].blockExplorerUrls) === null || _e === void 0 ? void 0 : _e[0]) || '',
    329847900: ((_f = sdk.CHAINS[sdk.ChainId.NEAR_MAINNET].blockExplorerUrls) === null || _f === void 0 ? void 0 : _f[0]) || '',
    329847901: ((_g = sdk.CHAINS[sdk.ChainId.NEAR_TESTNET].blockExplorerUrls) === null || _g === void 0 ? void 0 : _g[0]) || '',
};
const transactionPath = {
    [sdk.ChainId.FUJI]: 'tx',
    [sdk.ChainId.AVALANCHE]: 'tx',
    [sdk.ChainId.WAGMI]: 'tx',
    [sdk.ChainId.COSTON]: 'tx',
    [sdk.ChainId.SONGBIRD]: 'tx',
    [sdk.ChainId.NEAR_MAINNET]: 'transactions',
    [sdk.ChainId.NEAR_TESTNET]: 'transactions',
};
const addressPath = {
    [sdk.ChainId.FUJI]: 'address',
    [sdk.ChainId.AVALANCHE]: 'address',
    [sdk.ChainId.WAGMI]: 'address',
    [sdk.ChainId.COSTON]: 'address',
    [sdk.ChainId.SONGBIRD]: 'address',
    [sdk.ChainId.NEAR_MAINNET]: 'accounts',
    [sdk.ChainId.NEAR_TESTNET]: 'accounts',
};
const blockPath = {
    [sdk.ChainId.FUJI]: 'block',
    [sdk.ChainId.AVALANCHE]: 'block',
    [sdk.ChainId.WAGMI]: 'block',
    [sdk.ChainId.COSTON]: 'block',
    [sdk.ChainId.SONGBIRD]: 'block',
    [sdk.ChainId.NEAR_MAINNET]: 'blocks',
    [sdk.ChainId.NEAR_TESTNET]: 'blocks',
};
const tokenPath = {
    [sdk.ChainId.FUJI]: 'token',
    [sdk.ChainId.AVALANCHE]: 'token',
    [sdk.ChainId.WAGMI]: 'token',
    [sdk.ChainId.COSTON]: 'token',
    [sdk.ChainId.SONGBIRD]: 'token',
    [sdk.ChainId.NEAR_MAINNET]: 'accounts',
    [sdk.ChainId.NEAR_TESTNET]: 'accounts',
};
function getEtherscanLink(chainId, data, type) {
    const prefix = `${ETHERSCAN_PREFIXES[chainId] || ETHERSCAN_PREFIXES[43114]}`;
    switch (type) {
        case 'transaction': {
            return `${prefix}/${transactionPath[chainId]}/${data}`;
        }
        case 'token': {
            return `${prefix}/${tokenPath[chainId]}/${data}`;
        }
        case 'block': {
            return `${prefix}/${blockPath[chainId]}/${data}`;
        }
        case 'address':
        default: {
            return `${prefix}/${addressPath[chainId]}/${data}`;
        }
    }
}
// shorten the checksummed version of the input address to have 0x + 4 characters at start and end
function shortenAddress(address, chainId = sdk.ChainId.AVALANCHE, chars = 4) {
    const parsed = isEvmChain(chainId) ? isAddress(address) : address;
    if (!parsed) {
        throw Error(`Invalid 'address' parameter '${address}'.`);
    }
    return `${parsed.substring(0, chars)}...${parsed.substring(parsed.length - chars)}`;
}
// add 10%
function calculateGasMargin(value) {
    return value.mul(bignumber.BigNumber.from(10000).add(bignumber.BigNumber.from(1000))).div(bignumber.BigNumber.from(10000));
}
// converts a basis points value to a sdk percent
function basisPointsToPercent(num) {
    return new sdk.Percent(sdk.JSBI.BigInt(num), sdk.JSBI.BigInt(10000));
}
// account is not optional
function getSigner(library, account) {
    return library.getSigner(account).connectUnchecked();
}
// account is optional
function getProviderOrSigner(library, account) {
    return account ? getSigner(library, account) : library;
}
// account is optional
function getContract(address, ABI, library, account) {
    if (!isAddress(address) || address === constants.AddressZero) {
        return null;
    }
    return new contracts.Contract(address, ABI, getProviderOrSigner(library, account));
}
// account is optional
function getRouterContract(chainId, library, account) {
    return getContract(ROUTER_ADDRESS[chainId], IPangolinRouter__default["default"].abi, library, account);
}
function getRouterContractDaaS(chainId, library, account) {
    return getContract(ROUTER_DAAS_ADDRESS[chainId], IPangolinRouterSupportingFees__default["default"].abi, library, account);
}
function isTokenOnList(defaultTokens, chainId, currency) {
    var _a;
    if (chainId && currency === sdk.CAVAX[chainId])
        return true;
    return Boolean(currency instanceof sdk.Token && ((_a = defaultTokens[currency.chainId]) === null || _a === void 0 ? void 0 : _a[currency.address]));
}
/**
 * Returns true if the trade requires a confirmation of details before we can submit it
 * @param tradeA trade A
 * @param tradeB trade B
 */
function tradeMeaningfullyDiffers(tradeA, tradeB) {
    return (tradeA.tradeType !== tradeB.tradeType ||
        !sdk.currencyEquals(tradeA.inputAmount.currency, tradeB.inputAmount.currency) ||
        !tradeA.inputAmount.equalTo(tradeB.inputAmount) ||
        !sdk.currencyEquals(tradeA.outputAmount.currency, tradeB.outputAmount.currency) ||
        !tradeA.outputAmount.equalTo(tradeB.outputAmount));
}
function getChainByNumber(chainId) {
    return sdk.ALL_CHAINS.find((chain) => chain.chain_id === chainId);
}
function calculateSlippageAmount(value, slippage) {
    if (slippage < 0 || slippage > 10000) {
        throw Error(`Unexpected slippage value: ${slippage}`);
    }
    return [
        sdk.JSBI.divide(sdk.JSBI.multiply(value.raw, sdk.JSBI.BigInt(10000 - slippage)), sdk.JSBI.BigInt(10000)),
        sdk.JSBI.divide(sdk.JSBI.multiply(value.raw, sdk.JSBI.BigInt(10000 + slippage)), sdk.JSBI.BigInt(10000)),
    ];
}
// check if exist address of sar contract of a certain chain
function existSarContract(chainId) {
    return SAR_STAKING_ADDRESS[chainId] !== undefined;
}
// https://github.com/ethers-io/ethers.js/issues/945#issuecomment-1074683436
// wait for transaction confirmation or set timeout
function waitForTransaction(tx, confirmations, timeout = 10000) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        yield Promise.race([
            tx.wait(confirmations),
            (() => tslib.__awaiter(this, void 0, void 0, function* () {
                yield wait(timeout);
            }))(),
        ]);
    });
}
function getBuyUrl(token, chainId) {
    const origin = window.location.origin;
    const path = `/#/swap?inputCurrency=${chainId ? sdk.CAVAX[chainId].symbol : ZERO_ADDRESS}&outputCurrency=${token.address}`;
    return origin.includes('localhost') || origin.includes('pangolin.exchange') ? path : `app.pangolin.exchange${path}`;
}
// some browsers do not support scrollIntoView
// https://stackoverflow.com/a/50411076/18268694
function scrollElementIntoView(element, behavior) {
    if (element) {
        const scrollTop = window.scrollY || element.scrollTop;
        const finalOffset = element.getBoundingClientRect().top + scrollTop;
        window.parent.scrollTo({
            top: finalOffset,
            behavior: behavior || 'auto',
        });
    }
}
function isEvmChain(chainId = 43114) {
    var _a;
    if ((_a = sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.evm) {
        return true;
    }
    return false;
}
// http://jsfiddle.net/5QrhQ/5/
function decimalToFraction(number) {
    const gcd = (a, b) => {
        if (b < 0.0000001)
            return a; // Since there is a limited precision we need to limit the value.
        return gcd(b, Math.floor(a % b)); // Discard any fractions due to limitations in precision.
    };
    const len = number.toString().length - 2;
    let denominator = Math.pow(10, len);
    let numerator = number * denominator;
    const divisor = gcd(numerator, denominator);
    numerator /= divisor;
    denominator /= divisor;
    return new sdk.Fraction(Math.floor(numerator).toString(), Math.floor(denominator).toString());
}

const initialWeb3State = {
    library: undefined,
    chainId: undefined,
    account: undefined,
};
const Web3Context = React.createContext({});
const usePangolinWeb3 = () => {
    const context = React.useContext(Web3Context);
    if (context === undefined) {
        throw new Error('usePangolinWeb3 must be used within a component wrapped with PangolinWeb3Provider');
    }
    return context;
};
const PangolinWeb3Provider = ({ children, library, chainId, account, }) => {
    const [state, setState] = React.useState(initialWeb3State);
    React.useEffect(() => {
        var _a;
        let normalizedAccount;
        if (chainId) {
            normalizedAccount = ((_a = sdk.CHAINS === null || sdk.CHAINS === void 0 ? void 0 : sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.evm) ? isAddress(account) : account;
        }
        setState({
            library,
            chainId: chainId || sdk.ChainId.AVALANCHE,
            account: normalizedAccount,
        });
    }, [library, chainId, account]);
    return (jsxRuntime.jsx(Web3Context.Provider, Object.assign({ value: Object.assign({}, state) }, { children: children })));
};
const useChainId = () => {
    const { chainId } = usePangolinWeb3();
    return (chainId || sdk.ChainId.AVALANCHE);
};
// library -> web3.js
// provider -> ethers.js
// extendedProvider -> extended library
function useLibrary() {
    const [result, setResult] = React.useState({});
    const { connector } = core.useWeb3React();
    const chainId = useChainId();
    const { library: userProvidedLibrary } = usePangolinWeb3();
    React.useEffect(() => {
        function load() {
            var _a, _b;
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // const walletKey = Object.keys(SUPPORTED_WALLETS).find(
                //   (key) => SUPPORTED_WALLETS[key].connector === connector,
                // ) as string;
                const web3jsProvider = (yield (connector === null || connector === void 0 ? void 0 : connector.getProvider())) || userProvidedLibrary || window.ethereum;
                const finalWeb3jsProvider = web3jsProvider || window.ethereum;
                const extendedWeb3Provider = finalWeb3jsProvider && ((_b = (_a = PROVIDER_MAPPING)[chainId]) === null || _b === void 0 ? void 0 : _b.call(_a, finalWeb3jsProvider));
                let finalEthersLibrary;
                try {
                    finalEthersLibrary = new providers$1.Web3Provider(finalWeb3jsProvider, 'any');
                }
                catch (error) {
                    finalEthersLibrary = finalWeb3jsProvider;
                }
                setResult({ library: finalEthersLibrary, provider: extendedWeb3Provider });
            });
        }
        load();
    }, [connector]);
    return result;
}
const useRefetchMinichefSubgraph = () => {
    const { account } = usePangolinWeb3();
    const queryClient = reactQuery.useQueryClient();
    return () => tslib.__awaiter(void 0, void 0, void 0, function* () { return yield queryClient.refetchQueries(['get-minichef-farms-v2', account]); });
};
function useGetBlockTimestamp(blockNumber) {
    const latestBlockNumber = useBlockNumber();
    const _blockNumber = blockNumber !== null && blockNumber !== void 0 ? blockNumber : latestBlockNumber;
    const { provider } = useLibrary();
    const [timestamp, setTimestamp] = React.useState(undefined);
    const getTimestamp = React.useMemo(() => tslib.__awaiter(this, void 0, void 0, function* () {
        if (!_blockNumber || !provider)
            return;
        const result = yield (provider === null || provider === void 0 ? void 0 : provider.getBlockTimestamp(_blockNumber));
        return result;
    }), [_blockNumber, provider]);
    React.useEffect(() => {
        const getResult = () => tslib.__awaiter(this, void 0, void 0, function* () {
            const result = yield getTimestamp;
            setTimestamp(result);
        });
        getResult();
    }, [_blockNumber, getTimestamp]);
    return timestamp;
}

const getTokenLogoURL = (address, chainId, size = 24) => `${PANGOLIN_TOKENS_REPO_RAW_BASE_URL}/main/assets/${chainId}/${address}/logo_${size}.png`;

const BAD_SRCS = {};
const Logo$1 = (_a) => {
    var { srcs, alt } = _a, rest = tslib.__rest(_a, ["srcs", "alt"]);
    const [, refresh] = React.useState(0);
    const src = srcs.find((srcVal) => !BAD_SRCS[srcVal]);
    if (src) {
        return (jsxRuntime.jsx("img", Object.assign({}, rest, { alt: alt, src: src, onError: () => {
                BAD_SRCS[src] = true;
                refresh((i) => i + 1);
            } })));
    }
    return jsxRuntime.jsx(reactFeather.HelpCircle, Object.assign({}, rest));
};

const StyledLogo = styled__default["default"](Logo$1) `
  width: ${({ size }) => size};
  height: ${({ size }) => size};
  border-radius: ${({ size }) => size};
  /* box-shadow: 0px 6px 10px rgba(0, 0, 0, 0.075); */
`;

function CurrencyLogo({ currency, size = 24, style, imageSize = size, }) {
    var _a;
    const chainId = useChainId();
    const srcs = React.useMemo(() => {
        if (currency === sdk.CAVAX[sdk.ChainId.AVALANCHE] ||
            currency === sdk.CAVAX[sdk.ChainId.WAGMI] ||
            currency === sdk.CAVAX[sdk.ChainId.COSTON] ||
            currency === sdk.CAVAX[sdk.ChainId.SONGBIRD] ||
            currency === sdk.CAVAX[sdk.ChainId.NEAR_TESTNET] ||
            currency === sdk.CAVAX[sdk.ChainId.NEAR_MAINNET])
            return [];
        if (currency instanceof sdk.Token || !!currency.address) {
            const primarySrc = getTokenLogoURL(currency === null || currency === void 0 ? void 0 : currency.address, chainId, imageSize);
            return [primarySrc];
        }
        return [];
    }, [currency]);
    if (deepEqual__default["default"](currency, sdk.CAVAX[sdk.ChainId.AVALANCHE])) {
        return jsxRuntime.jsx(AvaxLogo, { size: `${size}px` });
    }
    else if (deepEqual__default["default"](currency, sdk.CAVAX[sdk.ChainId.WAGMI])) {
        return jsxRuntime.jsx("img", { src: WgmiLogo, width: `${size}px`, height: `${size}px` });
    }
    else if (deepEqual__default["default"](currency, sdk.CAVAX[sdk.ChainId.COSTON])) {
        return jsxRuntime.jsx(CflrLogo, { size: `${size}px` });
    }
    else if (deepEqual__default["default"](currency, sdk.CAVAX[sdk.ChainId.NEAR_TESTNET]) || deepEqual__default["default"](currency, sdk.CAVAX[sdk.ChainId.NEAR_MAINNET])) {
        return jsxRuntime.jsx("img", { src: NearLogo, width: `${size}px`, height: `${size}px` });
    }
    else if (deepEqual__default["default"](currency, sdk.CAVAX[sdk.ChainId.SONGBIRD])) {
        return jsxRuntime.jsx("img", { src: SongBirdLogo, width: `${size}px`, height: `${size}px` });
    }
    return jsxRuntime.jsx(StyledLogo, { size: `${size}px`, srcs: srcs, alt: `${(_a = currency === null || currency === void 0 ? void 0 : currency.symbol) !== null && _a !== void 0 ? _a : 'token'} logo`, style: style });
}

const Wrapper$d = styled__default["default"].div `
  position: relative;
  display: flex;
  flex-direction: row;
  align-items: center;
  margin-right: ${({ sizeraw, margin }) => margin && (sizeraw / 3 + 8).toString() + 'px'};
`;
const HigherLogo = styled__default["default"](CurrencyLogo) `
  z-index: 2;
`;
const CoveredLogo$1 = styled__default["default"](CurrencyLogo) `
  position: absolute;
  left: ${({ sizeraw }) => '-' + (sizeraw / 2).toString() + 'px'} !important;
`;

const DoubleCurrencyLogo = ({ currency0, currency1, size = 24, margin = false }) => {
    return (jsxRuntime.jsxs(Wrapper$d, Object.assign({ sizeraw: size, margin: margin }, { children: [currency0 && jsxRuntime.jsx(HigherLogo, { currency: currency0, size: size }), currency1 && (jsxRuntime.jsx(Box, Object.assign({ ml: '-5px', display: 'flex' }, { children: jsxRuntime.jsx(CoveredLogo$1, { currency: currency1, size: size, sizeraw: size }) })))] })));
};

const CurrencySelect = styled__default["default"].button `
  align-items: center;
  height: 100%;
  font-size: 20px;
  font-weight: 500;
  background-color: ${({ selected, theme }) => { var _a, _b; return selected ? (_a = theme.currencySelect) === null || _a === void 0 ? void 0 : _a.selectedBackgroundColor : (_b = theme.currencySelect) === null || _b === void 0 ? void 0 : _b.defaultBackgroundColor; }};
  color: ${({ selected, theme }) => { var _a, _b; return selected ? (_a = theme.currencySelect) === null || _a === void 0 ? void 0 : _a.selectedText : (_b = theme.currencySelect) === null || _b === void 0 ? void 0 : _b.defaultText; }};
  border-radius: 12px;
  box-shadow: ${({ selected }) => (selected ? 'none' : '0px 6px 10px rgba(0, 0, 0, 0.075)')};
  outline: none;
  cursor: pointer;
  user-select: none;
  border: none;
  padding: 0 0.5rem;

  /* :focus,
  :hover {
    background-color: ${({ selected, theme }) => (selected ? theme.bg2 : polished.darken(0.05, theme.primary))};
  } */

  ${({ buttonStyle }) => buttonStyle}
`;
const Aligner = styled__default["default"].span `
  display: flex;
  align-items: center;
  justify-content: space-between;
  color: inherit;
  svg {
    stroke: ${({ active, theme }) => { var _a, _b; return (active ? (_a = theme.currencySelect) === null || _a === void 0 ? void 0 : _a.selectedText : (_b = theme.currencySelect) === null || _b === void 0 ? void 0 : _b.defaultText); }};
  }
`;
const StyledTokenName = styled__default["default"].span `
  ${({ active }) => (active ? '  margin: 0 0.25rem 0 0.75rem;' : '  margin: 0 0.25rem 0 0.25rem;')}
  font-size:  ${({ active }) => (active ? '20px' : '16px')};
  color: inherit;
`;

const CurrencyInput = (_a) => {
    var { buttonStyle, pair, currency, isShowTextInput = true, onTokenClick } = _a, rest = tslib.__rest(_a, ["buttonStyle", "pair", "currency", "isShowTextInput", "onTokenClick"]);
    const renderCurrency = () => {
        if (pair) {
            return jsxRuntime.jsx(DoubleCurrencyLogo, { currency0: pair.token0, currency1: pair.token1, size: 24, margin: true });
        }
        else if (currency) {
            return jsxRuntime.jsx(CurrencyLogo, { currency: currency, size: 24, imageSize: 48 });
        }
        else {
            return null;
        }
    };
    const renderStyletoken = () => {
        if (pair) {
            return (jsxRuntime.jsxs(StyledTokenName, Object.assign({ className: "pair-name-container" }, { children: [pair === null || pair === void 0 ? void 0 : pair.token0.symbol, ":", pair === null || pair === void 0 ? void 0 : pair.token1.symbol] })));
        }
        else
            return (jsxRuntime.jsx(StyledTokenName, Object.assign({ className: "token-symbol-container", active: Boolean(currency && currency.symbol) }, { children: (currency && currency.symbol && currency.symbol.length > 20
                    ? currency.symbol.slice(0, 4) +
                        '...' +
                        currency.symbol.slice(currency.symbol.length - 5, currency.symbol.length)
                    : currency === null || currency === void 0 ? void 0 : currency.symbol) || 'Select Token' })));
    };
    const addonAfter = () => {
        return (jsxRuntime.jsx(CurrencySelect, Object.assign({ selected: !!currency, className: "open-currency-select-button", onClick: () => {
                onTokenClick && onTokenClick();
            }, buttonStyle: buttonStyle }, { children: jsxRuntime.jsxs(Aligner, Object.assign({ active: Boolean(currency && currency.symbol) }, { children: [renderCurrency(), renderStyletoken(), jsxRuntime.jsx(reactFeather.ChevronDown, { color: !Boolean(currency && currency.symbol) ? 'black' : undefined })] })) })));
    };
    return jsxRuntime.jsxs(Box, { children: [isShowTextInput ? jsxRuntime.jsx(TextInput, Object.assign({}, rest, { addonAfter: addonAfter() })) : addonAfter(), " "] });
};

const Tooltip = (props) => {
    return jsxRuntime.jsx(ReactTooltip__default["default"], Object.assign({}, props));
};

const Root$l = styled__default["default"].div `
  width: 100%;
  position: relative;
`;

const Collapsed = (props) => {
    const { getCollapseProps, getToggleProps, isExpanded } = useCollapse__default["default"]();
    return (jsxRuntime.jsxs(Root$l, { children: [jsxRuntime.jsx("div", Object.assign({}, getToggleProps(), { children: isExpanded ? props.collapse || 'Collapse' : props.expand || 'Expand' })), jsxRuntime.jsx("section", Object.assign({}, getCollapseProps(), { children: props.children }))] }));
};

const Root$k = styled__default["default"].div `
  flex-direction: row;
  display: inline-flex;
  background: ${({ theme }) => { var _a; return (_a = theme.toggleButton) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  border-radius: 4px;
  align-items: center;
  padding: 2px;
  width: 100%;
  box-sizing: border-box;
`;
const TextButton = styled__default["default"].div `
  margin-right: 4px;
  background: ${({ theme, selected }) => { var _a, _b; return selected ? (_a = theme.toggleButton) === null || _a === void 0 ? void 0 : _a.selectedColor : (_b = theme.toggleButton) === null || _b === void 0 ? void 0 : _b.backgroundColor; }};
  color: ${({ theme }) => { var _a; return (_a = theme.toggleButton) === null || _a === void 0 ? void 0 : _a.fontColor; }};
  border-radius: 4px;
  padding: 3px 5px;
  cursor: pointer;
  text-align: center;
  width: 100%;

  &:last-child {
    margin-right: 0px;
  }
`;

const ToggleButtons = (props) => {
    const { value, onChange, options } = props;
    return (jsxRuntime.jsx(Root$k, { children: (options || []).map((option, i) => (jsxRuntime.jsx(TextButton, Object.assign({ selected: option === value, onClick: () => {
                onChange && onChange(option);
            } }, { children: option }), i))) }));
};

const PendingWrapper = styled__default["default"](Box) `
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  height: ${({ height }) => height};
`;
const Loader = (props) => {
    const { size, label, height } = props;
    return (jsxRuntime.jsx(PendingWrapper, Object.assign({ height: height || '100%' }, { children: jsxRuntime.jsxs(Box, Object.assign({ mb: '15px', display: "flex", alignItems: "center", flexDirection: "column" }, { children: [jsxRuntime.jsxs(Box, Object.assign({ width: size, height: size, position: "relative", display: "flex", alignItems: "center", justifyContent: "center" }, { children: [jsxRuntime.jsx(Loading, {}), jsxRuntime.jsx(Box, Object.assign({ position: "absolute" }, { children: jsxRuntime.jsx(LogoIcon, {}) }))] })), label && (jsxRuntime.jsx(Text, Object.assign({ color: "loader.text", fontWeight: 500, fontSize: 20, textAlign: "center", mt: 10 }, { children: label })))] })) })));
};

/**
 * Token instances created from token info.
 */
class WrappedTokenInfo extends sdk.Token {
    constructor(tokenInfo, tags) {
        super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name);
        this.tokenInfo = tokenInfo;
        this.tags = tags;
    }
    get logoURI() {
        return this.tokenInfo.logoURI;
    }
}
/**
 * An empty result, useful as a default.
 */
const EMPTY_LIST = {
    [sdk.ChainId.FUJI]: {},
    [sdk.ChainId.AVALANCHE]: {},
    [sdk.ChainId.WAGMI]: {},
    [sdk.ChainId.COSTON]: {},
    [sdk.ChainId.SONGBIRD]: {},
    [sdk.ChainId.NEAR_MAINNET]: {},
    [sdk.ChainId.NEAR_TESTNET]: {},
};
const listCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;
function listToTokenMap(list) {
    const result = listCache === null || listCache === void 0 ? void 0 : listCache.get(list);
    if (result)
        return result;
    const map = list.tokens.reduce((tokenMap, tokenInfo) => {
        var _a, _b, _c, _d;
        const tags = (_c = (_b = (_a = tokenInfo.tags) === null || _a === void 0 ? void 0 : _a.map((tagId) => {
            var _a;
            if (!((_a = list.tags) === null || _a === void 0 ? void 0 : _a[tagId]))
                return undefined;
            return Object.assign(Object.assign({}, list.tags[tagId]), { id: tagId });
        })) === null || _b === void 0 ? void 0 : _b.filter((x) => Boolean(x))) !== null && _c !== void 0 ? _c : [];
        if (!sdk.CHAINS[tokenInfo.chainId]) {
            return tokenMap;
        }
        const token = new WrappedTokenInfo(tokenInfo, tags);
        if (((_d = tokenMap === null || tokenMap === void 0 ? void 0 : tokenMap[token.chainId]) === null || _d === void 0 ? void 0 : _d[token.address]) !== undefined)
            throw Error('Duplicate tokens.');
        return Object.assign(Object.assign({}, tokenMap), { [token.chainId]: Object.assign(Object.assign({}, tokenMap[token.chainId]), { [token.address]: token }) });
    }, Object.assign({}, EMPTY_LIST));
    listCache === null || listCache === void 0 ? void 0 : listCache.set(list, map);
    return map;
}
function useTokenList(urls) {
    const lists = useSelector((state) => state.plists.byUrl);
    const tokenList = {};
    return React.useMemo(() => {
        [].concat(urls || []).forEach((url) => {
            var _a;
            const current = (_a = lists[url]) === null || _a === void 0 ? void 0 : _a.current;
            if (url && current) {
                try {
                    const data = listToTokenMap(current);
                    for (const [chainId, tokens] of Object.entries(data)) {
                        tokenList[chainId] = tokenList[chainId] || {};
                        tokenList[chainId] = Object.assign(Object.assign({}, tokenList[chainId]), tokens);
                    }
                }
                catch (error) {
                    console.error('Could not show token list due to error', error);
                }
            }
        });
        return tokenList;
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [lists, urls]);
}
function useSelectedListUrl() {
    return useSelector((state) => { var _a; return [].concat(((_a = state === null || state === void 0 ? void 0 : state.plists) === null || _a === void 0 ? void 0 : _a.selectedListUrl) || []); });
}
function useSelectedTokenList() {
    return useTokenList(useSelectedListUrl());
}
function useSelectedListInfo() {
    var _a, _b, _c, _d, _e;
    const selectedListUrl = useSelectedListUrl();
    const firstSelectedUrl = (_a = (selectedListUrl || [])) === null || _a === void 0 ? void 0 : _a[0];
    const listsByUrl = useSelector((state) => state.plists.byUrl);
    const list = firstSelectedUrl ? listsByUrl[firstSelectedUrl] : undefined;
    return {
        current: (_b = list === null || list === void 0 ? void 0 : list.current) !== null && _b !== void 0 ? _b : null,
        pending: (_c = list === null || list === void 0 ? void 0 : list.pendingUpdate) !== null && _c !== void 0 ? _c : null,
        loading: (list === null || list === void 0 ? void 0 : list.loadingRequestId) !== null,
        multipleSelected: ((_d = (selectedListUrl || [])) === null || _d === void 0 ? void 0 : _d.length) > 1,
        selectedCount: (_e = (selectedListUrl || [])) === null || _e === void 0 ? void 0 : _e.length,
    };
}
function useIsSelectedAEBToken() {
    const selectedOutputToken = useSelector((state) => state.pswap.OUTPUT);
    return AEB_TOKENS.some((tokenAddress) => tokenAddress === (selectedOutputToken === null || selectedOutputToken === void 0 ? void 0 : selectedOutputToken.currencyId));
}

function isMethodArg(x) {
    return ['string', 'number'].indexOf(typeof x) !== -1;
}
function isValidMethodArgs(x) {
    return (x === undefined ||
        (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg)))));
}
const INVALID_RESULT = { valid: false, blockNumber: undefined, data: undefined };
// use this options object
const NEVER_RELOAD = {
    blocksPerFetch: Infinity,
};
// the lowest level call for subscribing to contract data
function useCallsData(calls, options) {
    const { chainId } = usePangolinWeb3();
    const callResults = useSelector((state) => state.pmulticall.callResults);
    const dispatch = useDispatch();
    const serializedCallKeys = React.useMemo(() => {
        var _a, _b, _c;
        return JSON.stringify((_c = (_b = (_a = calls === null || calls === void 0 ? void 0 : calls.filter((c) => Boolean(c))) === null || _a === void 0 ? void 0 : _a.map(toCallKey)) === null || _b === void 0 ? void 0 : _b.sort()) !== null && _c !== void 0 ? _c : []);
    }, [calls]);
    // update listeners when there is an actual change that persists for at least 100ms
    React.useEffect(() => {
        const callKeys = JSON.parse(serializedCallKeys);
        if (!chainId || callKeys.length === 0)
            return undefined;
        const calls = callKeys.map((key) => parseCallKey(key));
        dispatch(addMulticallListeners({
            chainId,
            calls,
            options,
        }));
        return () => {
            dispatch(removeMulticallListeners({
                chainId,
                calls,
                options,
            }));
        };
    }, [chainId, dispatch, options, serializedCallKeys]);
    return React.useMemo(() => calls.map((call) => {
        var _a;
        if (!chainId || !call)
            return INVALID_RESULT;
        const result = (_a = callResults[chainId]) === null || _a === void 0 ? void 0 : _a[toCallKey(call)];
        let data;
        if ((result === null || result === void 0 ? void 0 : result.data) && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {
            data = result.data;
        }
        return { valid: true, data, blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber };
    }), [callResults, calls, chainId]);
}
const INVALID_CALL_STATE = { valid: false, result: undefined, loading: false, syncing: false, error: false };
const LOADING_CALL_STATE = { valid: true, result: undefined, loading: true, syncing: true, error: false };
function toCallState(callResult, contractInterface, fragment, latestBlockNumber) {
    if (!callResult)
        return INVALID_CALL_STATE;
    const { valid, data, blockNumber } = callResult;
    if (!valid)
        return INVALID_CALL_STATE;
    if (valid && !blockNumber)
        return LOADING_CALL_STATE;
    if (!contractInterface || !fragment || !latestBlockNumber)
        return LOADING_CALL_STATE;
    const success = data && data.length > 2;
    const syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;
    let result = undefined;
    if (success && data) {
        try {
            result = contractInterface.decodeFunctionResult(fragment, data);
        }
        catch (error) {
            console.debug('Result data parsing failed', fragment, data);
            return {
                valid: true,
                loading: false,
                error: true,
                syncing,
                result,
            };
        }
    }
    return {
        valid: true,
        loading: false,
        syncing,
        result: result,
        error: !success,
    };
}
function useSingleContractMultipleData(contract, methodName, callInputs, options) {
    const fragment = React.useMemo(() => { var _a; return (_a = contract === null || contract === void 0 ? void 0 : contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(methodName); }, [contract, methodName]);
    const calls = React.useMemo(() => contract && fragment && callInputs && callInputs.length > 0
        ? callInputs.map((inputs) => {
            return {
                address: contract.address,
                callData: contract.interface.encodeFunctionData(fragment, inputs),
            };
        })
        : [], [callInputs, contract, fragment]);
    const results = useCallsData(calls, options);
    const latestBlockNumber = useBlockNumber();
    return React.useMemo(() => {
        return results.map((result) => toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber));
    }, [fragment, contract, results, latestBlockNumber]);
}
function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options) {
    const fragment = React.useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);
    const callData = React.useMemo(() => fragment && isValidMethodArgs(callInputs)
        ? contractInterface.encodeFunctionData(fragment, callInputs)
        : undefined, [callInputs, contractInterface, fragment]);
    const calls = React.useMemo(() => fragment && addresses && addresses.length > 0 && callData
        ? addresses.map((address) => {
            return address && callData
                ? {
                    address,
                    callData,
                }
                : undefined;
        })
        : [], [addresses, callData, fragment]);
    const results = useCallsData(calls, options);
    const latestBlockNumber = useBlockNumber();
    return React.useMemo(() => {
        return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber));
    }, [fragment, results, contractInterface, latestBlockNumber]);
}
function useSingleCallResult(contract, methodName, inputs, options) {
    const fragment = React.useMemo(() => { var _a; return (_a = contract === null || contract === void 0 ? void 0 : contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(methodName); }, [contract, methodName]);
    const calls = React.useMemo(() => {
        return contract && fragment && isValidMethodArgs(inputs)
            ? [
                {
                    address: contract.address,
                    callData: contract.interface.encodeFunctionData(fragment, inputs),
                },
            ]
            : [];
    }, [contract, fragment, inputs]);
    const result = useCallsData(calls, options)[0];
    const latestBlockNumber = useBlockNumber();
    return React.useMemo(() => {
        return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);
    }, [result, contract, fragment, latestBlockNumber]);
}

function serializeToken(token) {
    return {
        chainId: token.chainId,
        address: token.address,
        decimals: token.decimals,
        symbol: token.symbol,
        name: token.name,
    };
}
function deserializeToken(serializedToken) {
    return new sdk.Token(serializedToken.chainId, serializedToken.address, serializedToken.decimals, serializedToken.symbol, serializedToken.name);
}
function useUserSlippageTolerance() {
    const dispatch = useDispatch();
    const userSlippageTolerance = useSelector((state) => {
        return state.puser.userSlippageTolerance;
    });
    const setUserSlippageTolerance = React.useCallback((userSlippageTolerance) => {
        dispatch(updateUserSlippageTolerance({ userSlippageTolerance: userSlippageTolerance }));
    }, [dispatch]);
    return [userSlippageTolerance, setUserSlippageTolerance];
}
function useUserAddedTokens() {
    const { chainId } = usePangolinWeb3();
    const serializedTokensMap = useSelector(({ puser: { tokens } }) => tokens);
    return React.useMemo(() => {
        var _a;
        if (!chainId)
            return [];
        return Object.values((_a = serializedTokensMap[chainId]) !== null && _a !== void 0 ? _a : {}).map(deserializeToken);
    }, [serializedTokensMap, chainId]);
}
function useIsExpertMode() {
    return useSelector((state) => state.puser.userExpertMode);
}
function useExpertModeManager() {
    const dispatch = useDispatch();
    const expertMode = useIsExpertMode();
    const setExpertMode = React.useCallback((value) => {
        dispatch(updateUserExpertMode({ userExpertMode: value }));
    }, [dispatch]);
    return [expertMode, setExpertMode];
}
function useUserDeadline() {
    const dispatch = useDispatch();
    const userDeadline = useSelector((state) => state.puser.userDeadline);
    const setUserDeadline = React.useCallback((userDeadline) => {
        dispatch(updateUserDeadline({ userDeadline: userDeadline }));
    }, [dispatch]);
    return [userDeadline, setUserDeadline];
}
/**
 * Given two tokens return the liquidity token that represents its liquidity shares
 * @param tokenA one of the two tokens
 * @param tokenB the other token
 */
function toV2LiquidityToken([tokenA, tokenB], chainId) {
    return new sdk.Token(tokenA.chainId, sdk.Pair.getAddress(tokenA, tokenB, chainId), 18, 'ARL', 'Arcanum Liquidity');
}
/**
 * Returns all the pairs of tokens that are tracked by the user for the current chain ID.
 */
function useTrackedTokenPairs() {
    const { chainId } = usePangolinWeb3();
    const tokens = useAllTokens();
    // pinned pairs
    const pinnedPairs = React.useMemo(() => { var _a; return (chainId ? (_a = PINNED_PAIRS[chainId]) !== null && _a !== void 0 ? _a : [] : []); }, [chainId]);
    // pairs for every token against every base
    const generatedPairs = React.useMemo(() => chainId
        ? flatMap__default["default"](Object.keys(tokens), (tokenAddress) => {
            var _a;
            const token = tokens[tokenAddress];
            // for each token on the current chain,
            return (
            // loop though all bases on the current chain
            ((_a = BASES_TO_TRACK_LIQUIDITY_FOR[chainId]) !== null && _a !== void 0 ? _a : [])
                // to construct pairs of the given token with each base
                .map((base) => {
                if (base.address === token.address) {
                    return null;
                }
                else {
                    return [base, token];
                }
            })
                .filter((p) => p !== null));
        })
        : [], [tokens, chainId]);
    // pairs saved by users
    const savedSerializedPairs = useSelector(({ puser: { pairs } }) => pairs);
    const userPairs = React.useMemo(() => {
        if (!chainId || !savedSerializedPairs)
            return [];
        const forChain = savedSerializedPairs[chainId];
        if (!forChain)
            return [];
        return Object.keys(forChain).map((pairId) => {
            return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)];
        });
    }, [savedSerializedPairs, chainId]);
    const combinedList = React.useMemo(() => userPairs.concat(generatedPairs).concat(pinnedPairs), [generatedPairs, pinnedPairs, userPairs]);
    return React.useMemo(() => {
        // dedupes pairs of tokens in the combined list
        const keyed = combinedList.reduce((memo, [tokenA, tokenB]) => {
            const sorted = tokenA.sortsBefore(tokenB);
            const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`;
            if (memo[key])
                return memo;
            memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA];
            return memo;
        }, {});
        return Object.keys(keyed).map((key) => keyed[key]);
    }, [combinedList]);
}
function serializePair(pair) {
    return {
        token0: serializeToken(pair.token0),
        token1: serializeToken(pair.token1),
    };
}
function usePairAdder() {
    const dispatch = useDispatch();
    return React.useCallback((pair) => {
        dispatch(addSerializedPair({ serializedPair: serializePair(pair) }));
    }, [dispatch]);
}

function wrappedCurrency(currency, chainId) {
    return chainId && currency === sdk.CAVAX[chainId] ? sdk.WAVAX[chainId] : currency instanceof sdk.Token ? currency : undefined;
}
function wrappedCurrencyAmount(currencyAmount, chainId) {
    const token = currencyAmount && chainId ? wrappedCurrency(currencyAmount.currency, chainId) : undefined;
    return token && currencyAmount ? new sdk.TokenAmount(token, currencyAmount.raw) : undefined;
}
function convertToPangolinToken(token) {
    return new sdk.Token(token.chainId, token.address, token.decimals, token === null || token === void 0 ? void 0 : token.symbol, token === null || token === void 0 ? void 0 : token.name);
}
function wrappedGelatoCurrency(currency, chainId) {
    return chainId && !(currency === null || currency === void 0 ? void 0 : currency.isToken)
        ? sdk.WAVAX[chainId]
        : currency.isToken
            ? convertToPangolinToken(currency)
            : undefined;
}
function unwrappedToken(token, chainId) {
    var _a;
    if ((_a = token === null || token === void 0 ? void 0 : token.equals) === null || _a === void 0 ? void 0 : _a.call(token, sdk.WAVAX[token.chainId]))
        return sdk.CAVAX[chainId];
    return token;
}

const usePairsHook = {
    [sdk.ChainId.FUJI]: usePairs,
    [sdk.ChainId.AVALANCHE]: usePairs,
    [sdk.ChainId.WAGMI]: usePairs,
    [sdk.ChainId.COSTON]: usePairs,
    [sdk.ChainId.SONGBIRD]: usePairs,
    [sdk.ChainId.NEAR_MAINNET]: useNearPairs,
    [sdk.ChainId.NEAR_TESTNET]: useNearPairs,
};

const PAIR_INTERFACE = new abi$1.Interface(IPangolinPair__default["default"].abi);
var PairState;
(function (PairState) {
    PairState[PairState["LOADING"] = 0] = "LOADING";
    PairState[PairState["NOT_EXISTS"] = 1] = "NOT_EXISTS";
    PairState[PairState["EXISTS"] = 2] = "EXISTS";
    PairState[PairState["INVALID"] = 3] = "INVALID";
})(PairState || (PairState = {}));
var PoolType$1;
(function (PoolType) {
    PoolType["SIMPLE_POOL"] = "SIMPLE_POOL";
    PoolType["STABLE_SWAP"] = "STABLE_SWAP";
    PoolType["RATED_SWAP"] = "RATED_SWAP";
})(PoolType$1 || (PoolType$1 = {}));
function usePairs(currencies) {
    const chainId = useChainId();
    const tokens = React.useMemo(() => currencies.map(([currencyA, currencyB]) => [
        wrappedCurrency(currencyA, chainId),
        wrappedCurrency(currencyB, chainId),
    ]), [chainId, currencies]);
    const pairAddresses = React.useMemo(() => tokens.map(([tokenA, tokenB]) => {
        return tokenA && tokenB && !tokenA.equals(tokenB)
            ? sdk.Pair.getAddress(tokenA, tokenB, chainId ? chainId : sdk.ChainId.AVALANCHE)
            : undefined;
    }), [tokens, chainId]);
    const results = useMultipleContractSingleData(pairAddresses, PAIR_INTERFACE, 'getReserves');
    return React.useMemo(() => {
        return results.map((result, i) => {
            const { result: reserves, loading } = result;
            const tokenA = tokens[i][0];
            const tokenB = tokens[i][1];
            if (loading)
                return [PairState.LOADING, null];
            if (!tokenA || !tokenB || tokenA.equals(tokenB))
                return [PairState.INVALID, null];
            if (!reserves)
                return [PairState.NOT_EXISTS, null];
            const { reserve0, reserve1 } = reserves;
            const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
            return [
                PairState.EXISTS,
                new sdk.Pair(new sdk.TokenAmount(token0, reserve0.toString()), new sdk.TokenAmount(token1, reserve1.toString()), chainId ? chainId : sdk.ChainId.AVALANCHE),
            ];
        });
    }, [results, tokens, chainId]);
}
function usePair(tokenA, tokenB) {
    const chainId = useChainId();
    const tokens = React.useMemo(() => [[tokenA, tokenB]], [tokenA, tokenB]);
    const usePairs_ = usePairsHook[chainId];
    return usePairs_(tokens)[0];
}
function useGetNearAllPool() {
    const chainId = useChainId();
    return reactQuery.useQuery(['get-near-pools'], () => tslib.__awaiter(this, void 0, void 0, function* () {
        return nearFn.getAllPools(chainId);
    }));
}
function useNearPairs(currencies) {
    const chainId = useChainId();
    const tokens = React.useMemo(() => currencies.map(([currencyA, currencyB]) => [
        wrappedCurrency(currencyA, chainId),
        wrappedCurrency(currencyB, chainId),
    ]), [chainId, currencies]);
    const allPools = useGetNearAllPool();
    return React.useMemo(() => {
        if (allPools && !allPools.isLoading && tokens) {
            const results = allPools.data || [];
            return tokens.map(([tokenA, tokenB]) => {
                let indexOfToken0 = 0;
                let indexOfToken1 = 1;
                let reserveAmounts = [];
                if (!tokenA || !tokenB || tokenA.equals(tokenB))
                    return [PairState.INVALID, null];
                const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
                const filterResults = results.filter((v) => {
                    if ((v === null || v === void 0 ? void 0 : v.pool_kind) !== PoolType$1.SIMPLE_POOL)
                        return false;
                    const tokenIds = (v === null || v === void 0 ? void 0 : v.token_account_ids) || [];
                    if (tokenIds.includes(token0 === null || token0 === void 0 ? void 0 : token0.address) && tokenIds.includes(token1 === null || token1 === void 0 ? void 0 : token1.address)) {
                        return true;
                    }
                });
                const result = filterResults === null || filterResults === void 0 ? void 0 : filterResults[0];
                if (result) {
                    const tokenIds = result.token_account_ids || [];
                    indexOfToken0 = tokenIds.findIndex((element) => element.includes(token0 === null || token0 === void 0 ? void 0 : token0.address));
                    indexOfToken1 = tokenIds.findIndex((element) => element.includes(token1 === null || token1 === void 0 ? void 0 : token1.address));
                    reserveAmounts = result.amounts || [];
                }
                if (reserveAmounts.length === 0)
                    return [PairState.NOT_EXISTS, null];
                return [
                    PairState.EXISTS,
                    new sdk.Pair(new sdk.TokenAmount(token0, reserveAmounts[indexOfToken0].toString()), new sdk.TokenAmount(token1, reserveAmounts[indexOfToken1].toString()), chainId ? chainId : sdk.ChainId.AVALANCHE),
                ];
            });
        }
        return [[PairState.LOADING, null]];
    }, [allPools === null || allPools === void 0 ? void 0 : allPools.data, allPools === null || allPools === void 0 ? void 0 : allPools.isLoading, tokens, chainId]);
}
function useGetNearPoolId(tokenA, tokenB) {
    const allPools = useGetNearAllPool();
    return React.useMemo(() => {
        if (!(allPools === null || allPools === void 0 ? void 0 : allPools.isLoading)) {
            const results = (allPools === null || allPools === void 0 ? void 0 : allPools.data) || [];
            return results.findIndex((element) => {
                if ((element === null || element === void 0 ? void 0 : element.pool_kind) !== PoolType$1.SIMPLE_POOL)
                    return false;
                const tokenIds = (element === null || element === void 0 ? void 0 : element.token_account_ids) || [];
                if (tokenIds.includes(tokenA === null || tokenA === void 0 ? void 0 : tokenA.address) && tokenIds.includes(tokenB === null || tokenB === void 0 ? void 0 : tokenB.address)) {
                    return true;
                }
                return false;
            });
        }
        return null;
    }, [allPools === null || allPools === void 0 ? void 0 : allPools.data, allPools === null || allPools === void 0 ? void 0 : allPools.isLoading, tokenA, tokenB]);
}

class Cache {
    constructor() {
        this.options = {
            // how long to live in ms
            ttl: 1000 * 60 * 5,
            max: 1000,
        };
        this.cache = new LRUCache__default["default"](this.options);
    }
    get(key) {
        return this.cache.get(key);
    }
    set(key, value, ttl = 1000 * 60 * 5) {
        this.cache.set(key, value, ttl);
    }
    has(key) {
        return this.cache.has(key);
    }
}
const cache = new Cache();

class Near {
    constructor() {
        this.getAccountId = () => {
            var _a, _b, _c;
            return (_c = (_b = (_a = near === null || near === void 0 ? void 0 : near.wallet) === null || _a === void 0 ? void 0 : _a.account) === null || _b === void 0 ? void 0 : _b.call(_a)) === null || _c === void 0 ? void 0 : _c.accountId;
        };
        this.getTransaction = (hash) => tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const accountId = this.getAccountId();
                const provider = yield near.getProvider();
                return provider === null || provider === void 0 ? void 0 : provider.txStatus(hash, accountId);
            }
            catch (error) {
                console.log(error);
                return undefined;
            }
        });
        this.getTranctionSummary = (tx) => {
            var _a, _b, _c, _d;
            let summary = '';
            const methodName = (_d = (_c = (_b = (_a = tx.transaction) === null || _a === void 0 ? void 0 : _a.actions) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.FunctionCall) === null || _d === void 0 ? void 0 : _d.method_name;
            if (methodName === 'ft_transfer_call') {
                summary = 'Swap successful';
            }
            else if (methodName === 'add_liquidity') {
                summary = 'Add Liquidity successful';
            }
            else if (methodName === 'remove_liquidity') {
                summary = 'Remove Liquidity successful';
            }
            return summary;
        };
        this.getGas = (gas) => (gas ? new BN__default["default"](gas) : new BN__default["default"]('100000000000000'));
        this.getAmount = (amount) => {
            if (amount) {
                const parseAmount = nearApiJs.utils.format.parseNearAmount(amount);
                return parseAmount ? new BN__default["default"](parseAmount) : new BN__default["default"]('0');
            }
            else {
                return new BN__default["default"]('0');
            }
        };
    }
    viewFunction(tokenId, { methodName, args, }) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return near.wallet.account().viewFunction(tokenId, methodName, args);
        });
    }
    getMetadata(tokenAddress) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (cache.has(`near:token_metadata:${tokenAddress}`)) {
                    return cache.get(`near:token_metadata:${tokenAddress}`);
                }
                const metadata = yield this.viewFunction(tokenAddress, {
                    methodName: 'ft_metadata',
                });
                const tokenMetadata = Object.assign({ id: tokenAddress }, metadata);
                cache.set(`near:token_metadata:${tokenAddress}`, tokenMetadata);
                return tokenMetadata;
            }
            catch (err) {
                return {
                    id: tokenAddress,
                    name: tokenAddress,
                    symbol: tokenAddress === null || tokenAddress === void 0 ? void 0 : tokenAddress.split('.')[0].slice(0, 8),
                    decimals: 6,
                    icon: '',
                };
            }
        });
    }
    getTokenBalance(tokenAddress, account) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (cache.has(`near:token_balance:${tokenAddress}`)) {
                return cache.get(`near:token_balance:${tokenAddress}`);
            }
            const tokenBalance = this.viewFunction(tokenAddress, {
                methodName: 'ft_balance_of',
                args: {
                    account_id: account,
                },
            });
            cache.set(`near:token_balance:${tokenAddress}`, tokenBalance, 1000 * 60);
            return tokenBalance;
        });
    }
    getTotalSupply(tokenAddress) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (cache.has(`near:total_supply:${tokenAddress}`)) {
                return cache.get(`near:total_supply:${tokenAddress}`);
            }
            const totalSupply = this.viewFunction(tokenAddress, {
                methodName: 'ft_total_supply',
                args: {},
            });
            cache.set(`near:total_supply:${tokenAddress}`, totalSupply, 1000 * 60);
            return totalSupply;
        });
    }
    getExchangeContract(deployer, exchange) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const contract = new nearApiJs.Contract(deployer, exchange, {
                viewMethods: ['get_pools', 'get_number_of_pools'],
                changeMethods: [],
            });
            return contract;
        });
    }
    getAllPools(chainId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (cache.has('near:pools')) {
                return cache.get('near:pools');
            }
            const deployer = yield near.wallet.account();
            const contract = yield this.getExchangeContract(deployer, NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId]);
            const numberOfPools = yield contract.get_number_of_pools();
            const pools = contract.get_pools({
                from_index: 0,
                limit: numberOfPools,
            });
            cache.set('near:pools', pools);
            return pools;
        });
    }
    getPoolId(chainId, tokenA, tokenB) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const results = yield this.getAllPools(chainId);
            return results.findIndex((element) => {
                if ((element === null || element === void 0 ? void 0 : element.pool_kind) !== PoolType$1.SIMPLE_POOL)
                    return false;
                const tokenIds = (element === null || element === void 0 ? void 0 : element.token_account_ids) || [];
                if (tokenIds.includes(tokenA === null || tokenA === void 0 ? void 0 : tokenA.address) && tokenIds.includes(tokenB === null || tokenB === void 0 ? void 0 : tokenB.address)) {
                    return true;
                }
                return false;
            });
        });
    }
    getPool(chainId, tokenA, tokenB) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (cache.has(`near:pool:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`)) {
                return cache.get(`near:pool:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`);
            }
            const poolId = yield this.getPoolId(chainId, tokenA, tokenB);
            const result = yield this.viewFunction(NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId], {
                methodName: 'get_pool',
                args: { pool_id: poolId },
            });
            const pool = Object.assign(Object.assign({}, result), { id: poolId });
            cache.set(`near:pool:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`, pool, 1000 * 60);
            return pool;
        });
    }
    getSharesInPool(chainId, tokenA, tokenB) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (cache.has(`near:pool_shares:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`)) {
                return cache.get(`near:pool_shares:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`);
            }
            const poolId = yield this.getPoolId(chainId, tokenA, tokenB);
            const poolShares = this.viewFunction(NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId], {
                methodName: 'get_pool_shares',
                args: { pool_id: poolId, account_id: this.getAccountId() },
            });
            cache.set(`near:pool_shares:${tokenA === null || tokenA === void 0 ? void 0 : tokenA.address}-${tokenB === null || tokenB === void 0 ? void 0 : tokenB.address}`, poolShares, 1000 * 60);
            return poolShares;
        });
    }
    getStorageBalance(contractId, account = this.getAccountId()) {
        return this.viewFunction(contractId, {
            methodName: 'storage_balance_of',
            args: { account_id: account },
        });
    }
    needDepositStorage(contractId, account = this.getAccountId()) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const storage = yield this.viewFunction(contractId, {
                methodName: 'get_user_storage_state',
                args: { account_id: account },
            });
            return new BN__default["default"](storage === null || storage === void 0 ? void 0 : storage.deposit).lte(new BN__default["default"](storage === null || storage === void 0 ? void 0 : storage.usage));
        });
    }
    checkUserNeedsStorageDeposit(chainId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let storageNeeded = 0;
            const needDeposit = yield nearFn.needDepositStorage(NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId]);
            if (needDeposit) {
                storageNeeded = Number('0.01');
            }
            else {
                const balance = yield this.getStorageBalance(NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId]);
                if (!balance) {
                    storageNeeded = Number(storageNeeded) + Number(NEAR_ACCOUNT_MIN_STORAGE_AMOUNT);
                }
                if (new BN__default["default"]((balance === null || balance === void 0 ? void 0 : balance.available) || '0').lt(NEAR_MIN_DEPOSIT_PER_TOKEN)) {
                    storageNeeded = Number(storageNeeded) + Number(NEAR_STORAGE_PER_TOKEN);
                }
            }
            return storageNeeded ? storageNeeded.toString() : '';
        });
    }
    getWhitelistedTokens(chainId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let userWhitelist = [];
            const contractId = NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId];
            const accountId = this.getAccountId();
            const globalWhitelist = yield this.viewFunction(contractId, {
                methodName: 'get_whitelisted_tokens',
                args: {},
            });
            userWhitelist = yield this.viewFunction(contractId, {
                methodName: 'get_user_whitelisted_tokens',
                args: { account_id: accountId },
            });
            return [...new Set([...globalWhitelist, ...userWhitelist])];
        });
    }
    createNearTransaction({ receiverId, actions, nonceOffset = 1, }) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const accountId = yield near.wallet.getAccountId();
            const walletAccount = yield near.wallet.account();
            const localKey = yield walletAccount.connection.signer.getPublicKey(accountId, near.wallet._networkId);
            const accessKey = yield walletAccount.accessKeyForTransaction(receiverId, actions, localKey);
            if (!accessKey) {
                throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);
            }
            const block = yield walletAccount.connection.provider.block({ finality: 'final' });
            const blockHash = borsh.baseDecode(block.header.hash);
            const publicKey = nearApiJs.utils.PublicKey.from(accessKey.public_key);
            const nonce = accessKey.access_key.nonce + nonceOffset;
            return nearApiJs.transactions.createTransaction(accountId, publicKey, receiverId, nonce, actions, blockHash);
        });
    }
    executeMultipleTransactions(allTransactions, callbackUrl) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const currentTransactions = yield Promise.all(allTransactions.map((t, i) => {
                return this.createNearTransaction({
                    receiverId: t.receiverId,
                    nonceOffset: i + 1,
                    actions: t.functionCalls.map((fc) => nearApiJs.transactions.functionCall(fc.methodName, (fc === null || fc === void 0 ? void 0 : fc.args) ? fc === null || fc === void 0 ? void 0 : fc.args : {}, this.getGas(fc.gas), this.getAmount(fc === null || fc === void 0 ? void 0 : fc.amount))),
                });
            }));
            return near.wallet.requestSignTransactions(currentTransactions, callbackUrl);
        });
    }
    storageDepositAction({ accountId = nearFn.getAccountId(), registrationOnly = false, amount, }) {
        return {
            methodName: 'storage_deposit',
            args: {
                account_id: accountId,
                registration_only: registrationOnly,
            },
            amount,
        };
    }
    nearDepositAction(amount) {
        return {
            methodName: 'near_deposit',
            args: {},
            amount,
        };
    }
    nearWithdrawAction(amount) {
        return {
            methodName: 'near_withdraw',
            args: { amount: amount },
            amount: ONE_YOCTO_NEAR,
        };
    }
    registerTokenAction(tokenId) {
        return {
            methodName: 'register_tokens',
            args: { token_ids: [tokenId] },
            amount: ONE_YOCTO_NEAR,
        };
    }
    withdrawAction({ tokenId, amount, unregister = false }) {
        return {
            methodName: 'withdraw',
            args: { token_id: tokenId, amount, unregister },
            amount: ONE_YOCTO_NEAR,
        };
    }
    getYourPools() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return fetch(NEAR_API_BASE_URL + '/liquidity-pools/' + nearFn.getAccountId(), {
                method: 'GET',
                headers: { 'Content-type': 'application/json; charset=UTF-8' },
            })
                .then((res) => res.json())
                .then((pools) => {
                return pools;
            });
        });
    }
}
const nearFn = new Near();
/* eslint-enable max-lines */

var ERC20_ABI = [
	{
		constant: true,
		inputs: [
		],
		name: "name",
		outputs: [
			{
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_spender",
				type: "address"
			},
			{
				name: "_value",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_from",
				type: "address"
			},
			{
				name: "_to",
				type: "address"
			},
			{
				name: "_value",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "decimals",
		outputs: [
			{
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_owner",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				name: "balance",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "_to",
				type: "address"
			},
			{
				name: "_value",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "_owner",
				type: "address"
			},
			{
				name: "_spender",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	}
];

var ERC20_BYTES32_ABI = [
	{
		constant: true,
		inputs: [
		],
		name: "name",
		outputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				name: "",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];

const ERC20_INTERFACE = new abi$1.Interface(ERC20_ABI);
const ERC20_BYTES32_INTERFACE = new abi$1.Interface(ERC20_BYTES32_ABI);

var _format = "hh-sol-artifact-1";
var contractName = "PangoChef";
var sourceName = "contracts/staking-positions/PangoChef.sol";
var abi = [
	{
		inputs: [
			{
				internalType: "address",
				name: "newRewardsToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "newAdmin",
				type: "address"
			},
			{
				internalType: "contract IPangolinFactory",
				name: "newFactory",
				type: "address"
			},
			{
				internalType: "address",
				name: "newWrappedNativeToken",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
		],
		name: "FailedTransfer",
		type: "error"
	},
	{
		inputs: [
		],
		name: "HighSlippage",
		type: "error"
	},
	{
		inputs: [
		],
		name: "InsufficientBalance",
		type: "error"
	},
	{
		inputs: [
		],
		name: "InvalidAmount",
		type: "error"
	},
	{
		inputs: [
		],
		name: "InvalidToken",
		type: "error"
	},
	{
		inputs: [
		],
		name: "InvalidType",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Locked",
		type: "error"
	},
	{
		inputs: [
		],
		name: "MismatchedArrayLengths",
		type: "error"
	},
	{
		inputs: [
		],
		name: "NoEffect",
		type: "error"
	},
	{
		inputs: [
		],
		name: "NonExistentToken",
		type: "error"
	},
	{
		inputs: [
		],
		name: "NullInput",
		type: "error"
	},
	{
		inputs: [
		],
		name: "OutOfBounds",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Overflow",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Reentrancy",
		type: "error"
	},
	{
		inputs: [
		],
		name: "TooEarly",
		type: "error"
	},
	{
		inputs: [
		],
		name: "TooLate",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Underflow",
		type: "error"
	},
	{
		inputs: [
		],
		name: "UnprivilegedCaller",
		type: "error"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "newDuration",
				type: "uint256"
			}
		],
		name: "PeriodDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
		],
		name: "PeriodEnded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "tokenOrRecipient",
				type: "address"
			}
		],
		name: "PoolInitialized",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "reward",
				type: "uint256"
			}
		],
		name: "RewardAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "rewarder",
				type: "address"
			}
		],
		name: "RewarderSet",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "previousAdminRole",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "newAdminRole",
				type: "bytes32"
			}
		],
		name: "RoleAdminChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "RoleGranted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "RoleRevoked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "userId",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "reward",
				type: "uint256"
			}
		],
		name: "Staked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "newWeight",
				type: "uint256"
			}
		],
		name: "WeightSet",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "address",
				name: "userId",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "reward",
				type: "uint256"
			}
		],
		name: "Withdrawn",
		type: "event"
	},
	{
		inputs: [
		],
		name: "DEFAULT_ADMIN_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "addReward",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			}
		],
		name: "claim",
		outputs: [
			{
				internalType: "uint256",
				name: "reward",
				type: "uint256"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				components: [
					{
						internalType: "uint256",
						name: "minPairAmount",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "maxPairAmount",
						type: "uint256"
					}
				],
				internalType: "struct PangoChef.Slippage",
				name: "slippage",
				type: "tuple"
			}
		],
		name: "compound",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				components: [
					{
						internalType: "uint256",
						name: "minPairAmount",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "maxPairAmount",
						type: "uint256"
					}
				],
				internalType: "struct PangoChef.Slippage",
				name: "slippage",
				type: "tuple"
			}
		],
		name: "compoundToPoolZero",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			}
		],
		name: "emergencyExitLevel1",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			}
		],
		name: "emergencyExitLevel2",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "endPeriod",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "factory",
		outputs: [
			{
				internalType: "contract IPangolinFactory",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			}
		],
		name: "getRoleAdmin",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "index",
				type: "uint256"
			}
		],
		name: "getRoleMember",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			}
		],
		name: "getRoleMemberCount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "userId",
				type: "address"
			}
		],
		name: "getUser",
		outputs: [
			{
				components: [
					{
						components: [
							{
								internalType: "uint104",
								name: "balance",
								type: "uint104"
							},
							{
								internalType: "uint152",
								name: "sumOfEntryTimes",
								type: "uint152"
							}
						],
						internalType: "struct PangoChef.ValueVariables",
						name: "valueVariables",
						type: "tuple"
					},
					{
						components: [
							{
								internalType: "uint256",
								name: "idealPosition",
								type: "uint256"
							},
							{
								internalType: "uint256",
								name: "rewardPerValue",
								type: "uint256"
							}
						],
						internalType: "struct PangoChef.RewardSummations",
						name: "rewardSummationsPaid",
						type: "tuple"
					},
					{
						internalType: "uint152",
						name: "previousValues",
						type: "uint152"
					},
					{
						internalType: "uint48",
						name: "lastUpdate",
						type: "uint48"
					},
					{
						internalType: "bool",
						name: "isLockingPoolZero",
						type: "bool"
					},
					{
						internalType: "uint96",
						name: "stashedRewards",
						type: "uint96"
					}
				],
				internalType: "struct PangoChef.User",
				name: "",
				type: "tuple"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "grantRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			}
		],
		name: "harvest",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "hasRole",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "tokenOrRecipient",
				type: "address"
			},
			{
				internalType: "enum PangoChef.PoolType",
				name: "poolType",
				type: "uint8"
			}
		],
		name: "initializePool",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "lastTimeRewarderCallFailed",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "lastUpdate",
		outputs: [
			{
				internalType: "uint48",
				name: "",
				type: "uint48"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "periodDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "periodFinish",
		outputs: [
			{
				internalType: "uint48",
				name: "",
				type: "uint48"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "poolRewardInfos",
		outputs: [
			{
				internalType: "uint32",
				name: "weight",
				type: "uint32"
			},
			{
				internalType: "uint96",
				name: "stashedRewards",
				type: "uint96"
			},
			{
				internalType: "uint128",
				name: "rewardPerWeightPaid",
				type: "uint128"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			}
		],
		name: "poolRewardRate",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "poolZeroLockCount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "pools",
		outputs: [
			{
				internalType: "address",
				name: "tokenOrRecipient",
				type: "address"
			},
			{
				internalType: "enum PangoChef.PoolType",
				name: "poolType",
				type: "uint8"
			},
			{
				internalType: "contract IRewarder",
				name: "rewarder",
				type: "address"
			},
			{
				internalType: "address",
				name: "rewardPair",
				type: "address"
			},
			{
				components: [
					{
						internalType: "uint104",
						name: "balance",
						type: "uint104"
					},
					{
						internalType: "uint152",
						name: "sumOfEntryTimes",
						type: "uint152"
					}
				],
				internalType: "struct PangoChef.ValueVariables",
				name: "valueVariables",
				type: "tuple"
			},
			{
				components: [
					{
						internalType: "uint256",
						name: "idealPosition",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "rewardPerValue",
						type: "uint256"
					}
				],
				internalType: "struct PangoChef.RewardSummations",
				name: "rewardSummationsStored",
				type: "tuple"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "poolsLength",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "renounceRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "revokeRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "rewardPerWeightStored",
		outputs: [
			{
				internalType: "uint128",
				name: "",
				type: "uint128"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "rewardRate",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "rewardsToken",
		outputs: [
			{
				internalType: "contract ERC20",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "newDuration",
				type: "uint256"
			}
		],
		name: "setPeriodDuration",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "rewarder",
				type: "address"
			}
		],
		name: "setRewarder",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256[]",
				name: "poolIds",
				type: "uint256[]"
			},
			{
				internalType: "uint32[]",
				name: "weights",
				type: "uint32[]"
			}
		],
		name: "setWeights",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "stake",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "userId",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "stakeTo",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "interfaceId",
				type: "bytes4"
			}
		],
		name: "supportsInterface",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "totalRewardAdded",
		outputs: [
			{
				internalType: "uint96",
				name: "",
				type: "uint96"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "totalWeight",
		outputs: [
			{
				internalType: "uint32",
				name: "",
				type: "uint32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "userId",
				type: "address"
			}
		],
		name: "userPendingRewards",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "userId",
				type: "address"
			}
		],
		name: "userRewardRate",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "poolId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "withdraw",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "wrappedNativeToken",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	}
];
var bytecode = "0x60e06040526201518060055560016006556000600a553480156200002257600080fd5b5060405162004b0238038062004b028339810160408190526200004591620004f0565b83836001600160a01b0381166200006f57604051632505ecc360e11b815260040160405180910390fd5b6001600160a01b038216608052620000896000826200023d565b620000b57f0914bb97ca83e85ef385857d9d418f187ff630589e0c9f44db92976d8e4519cb826200023d565b620000e17f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff826200023d565b5050600080805260026020527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b80546103e863ffffffff199091161790556004805463ffffffff60901b1916607d60931b17815560405163e6a4390560e01b81526001600160a01b038781169282019290925283821660248201529084169063e6a4390590604401602060405180830381865afa15801562000187573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001ad919062000558565b90506001600160a01b038116620001d757604051632505ecc360e11b815260040160405180910390fd5b620001e481600162000280565b506000805260076020527f6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6e180546001600160a01b0319166001600160a01b03928316908117909155911660a05260c05250620005bd9050565b620002548282620003c460201b6200186d1760201c565b60008281526001602090815260409091206200027b9183906200190b62000465821b17901c565b505050565b600a80546000918262000293836200057f565b9091555090506001600160a01b0383161580620002c457506000826002811115620002c257620002c2620005a7565b145b15620002e357604051632505ecc360e11b815260040160405180910390fd5b6001826002811115620002fa57620002fa620005a7565b1480156200031057506001600160a01b0383163b155b156200032f5760405163c1ab6dc160e01b815260040160405180910390fd5b600081815260076020526040902080546001600160a01b0385166001600160a01b0319821681178355849183916001600160a81b031990911617600160a01b836002811115620003835762000383620005a7565b02179055506040516001600160a01b0385169083907f3d82013e0d368d05bfb8b953d35bffd6eec15520773228de41146f306a241aec90600090a350505050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1662000461576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620004203390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45b5050565b60006200047c836001600160a01b03841662000485565b90505b92915050565b6000818152600183016020526040812054620004ce575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556200047f565b5060006200047f565b6001600160a01b0381168114620004ed57600080fd5b50565b600080600080608085870312156200050757600080fd5b84516200051481620004d7565b60208601519094506200052781620004d7565b60408601519093506200053a81620004d7565b60608601519092506200054d81620004d7565b939692955090935050565b6000602082840312156200056b57600080fd5b81516200057881620004d7565b9392505050565b600060018201620005a057634e487b7160e01b600052601160045260246000fd5b5060010190565b634e487b7160e01b600052602160045260246000fd5b60805160a05160c0516144d66200062c60003960008181610374015261313f0152600081816109b10152613456015260008181610a2501528181610dd3015281816112ed015281816114e30152818161243a01528181613059015281816134ea015261352b01526144d66000f3fe6080604052600436106102dc5760003560e01c80637b0a47ee11610184578063c45a0155116100d6578063d61f06801161008a578063ebe2b12b11610064578063ebe2b12b14610aba578063f2d1e1cd14610ad9578063f851844b14610af957600080fd5b8063d61f068014610a67578063d97f8ed614610a87578063ddc6326214610a9a57600080fd5b8063cea84402116100bb578063cea84402146109f3578063d1af0c7d14610a13578063d547741f14610a4757600080fd5b8063c45a01551461099f578063ca15c873146109d357600080fd5b806396c82e5711610138578063b470aade11610112578063b470aade1461091f578063c046371114610935578063c348dac11461097257600080fd5b806396c82e5714610801578063a217fddf1461083a578063ac4afa381461084f57600080fd5b806382f084d31161016957806382f084d31461077d5780639010d07c1461079d57806391d14854146107bd57600080fd5b80637b0a47ee146107485780637c2d6e011461075d57600080fd5b8063379607f51161023d57806359b02eb3116101f15780636bc9f703116101cb5780636bc9f7031461066257806374de4ec4146107085780637b0472f01461072857600080fd5b806359b02eb3146105f55780635faa65ff14610615578063677f93261461062a57600080fd5b806343de32071161022257806343de320714610595578063441a3e70146105b557806354f8c475146105d557600080fd5b8063379607f51461055557806343d5599e1461057557600080fd5b8063257664a4116102945780632f2ff15d116102795780632f2ff15d146104cb5780633228dd59146104eb57806336568abe1461053557600080fd5b8063257664a4146104015780632716ae66146104b657600080fd5b806317fcb39b116102c557806317fcb39b14610362578063190d8ef4146103ae578063248a9ca3146103c357600080fd5b806301ffc9a7146102e1578063098b885814610316575b600080fd5b3480156102ed57600080fd5b506103016102fc366004613d15565b610b19565b60405190151581526020015b60405180910390f35b34801561032257600080fd5b5060045461034590660100000000000090046bffffffffffffffffffffffff1681565b6040516bffffffffffffffffffffffff909116815260200161030d565b34801561036e57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161030d565b6103c16103bc366004613d57565b610b75565b005b3480156103cf57600080fd5b506103f36103de366004613d8f565b60009081526020819052604090206001015490565b60405190815260200161030d565b34801561040d57600080fd5b5061042161041c366004613dbd565b610bb6565b60405161030d9190815180516001600160681b031682526020908101516001600160981b031690820152610100810160208381015180516040850152908101516060840152506001600160981b03604084015116608083015265ffffffffffff60608401511660a08301526080830151151560c08301526bffffffffffffffffffffffff60a08401511660e083015292915050565b3480156104c257600080fd5b50600a546103f3565b3480156104d757600080fd5b506103c16104e6366004613dbd565b610c96565b3480156104f757600080fd5b50600354610514906fffffffffffffffffffffffffffffffff1681565b6040516fffffffffffffffffffffffffffffffff909116815260200161030d565b34801561054157600080fd5b506103c1610550366004613dbd565b610cc0565b34801561056157600080fd5b506103f3610570366004613d8f565b610d51565b34801561058157600080fd5b506103c1610590366004613ded565b610e46565b3480156105a157600080fd5b506103c16105b0366004613dbd565b610e72565b3480156105c157600080fd5b506103c16105d0366004613e25565b610f11565b3480156105e157600080fd5b506103c16105f0366004613e93565b610f23565b34801561060157600080fd5b506103f3610610366004613dbd565b6111c8565b34801561062157600080fd5b506103c1611212565b34801561063657600080fd5b506103f3610645366004613dbd565b600960209081526000928352604080842090915290825290205481565b34801561066e57600080fd5b506106c761067d366004613d8f565b60026020526000908152604090205463ffffffff81169064010000000081046bffffffffffffffffffffffff1690600160801b90046fffffffffffffffffffffffffffffffff1683565b6040805163ffffffff90941684526bffffffffffffffffffffffff90921660208401526fffffffffffffffffffffffffffffffff169082015260600161030d565b34801561071457600080fd5b506103c1610723366004613d8f565b611349565b34801561073457600080fd5b506103c1610743366004613e25565b61154c565b34801561075457600080fd5b506103f3611578565b34801561076957600080fd5b506103c1610778366004613d8f565b6115bd565b34801561078957600080fd5b506103f3610798366004613dbd565b611693565b3480156107a957600080fd5b506103966107b8366004613e25565b61170c565b3480156107c957600080fd5b506103016107d8366004613dbd565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b34801561080d57600080fd5b5060045461082590600160901b900463ffffffff1681565b60405163ffffffff909116815260200161030d565b34801561084657600080fd5b506103f3600081565b34801561085b57600080fd5b5061090d61086a366004613d8f565b6007602090815260009182526040918290208054600182015460028301548551808701875260038501546001600160681b03811682526d010000000000000000000000000090046001600160981b031681870152865180880190975260048501548752600590940154948601949094526001600160a01b03808316957401000000000000000000000000000000000000000090930460ff16949181169391169186565b60405161030d96959493929190613f15565b34801561092b57600080fd5b506103f360055481565b34801561094157600080fd5b5060035461095b90600160801b900465ffffffffffff1681565b60405165ffffffffffff909116815260200161030d565b34801561097e57600080fd5b506103f361098d366004613f98565b60086020526000908152604090205481565b3480156109ab57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b3480156109df57600080fd5b506103f36109ee366004613d8f565b61172b565b3480156109ff57600080fd5b506103c1610a0e366004613d8f565b611742565b348015610a1f57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b348015610a5357600080fd5b506103c1610a62366004613dbd565b611762565b348015610a7357600080fd5b506103c1610a82366004613fb5565b611787565b6103c1610a95366004613d57565b6117bb565b348015610aa657600080fd5b506103c1610ab5366004613d8f565b6117e9565b348015610ac657600080fd5b5060045461095b9065ffffffffffff1681565b348015610ae557600080fd5b506103f3610af4366004613d8f565b6117ff565b348015610b0557600080fd5b506103c1610b14366004613d8f565b611855565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5a05180f000000000000000000000000000000000000000000000000000000001480610b6f5750610b6f82611920565b92915050565b610b7d6119b7565b60026006556000610b8d836119f5565b9050610bac600033836002610ba736889003880188613ffd565b611c3f565b5050600160065550565b610bbe613cb2565b5060008281526007602090815260408083206001600160a01b038516845260060182529182902082516101008101845281546001600160681b03811660c083019081526d01000000000000000000000000009091046001600160981b0390811660e0840152908252845180860186526001840154815260028401548186015293820193909352600382015492831693810193909352600160981b820465ffffffffffff166060840152600160c81b90910460ff1615156080830152600401546bffffffffffffffffffffffff1660a082015292915050565b600082815260208190526040902060010154610cb1816120f1565b610cbb83836120fb565b505050565b6001600160a01b0381163314610d435760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c66000000000000000000000000000000000060648201526084015b60405180910390fd5b610d4d828261211d565b5050565b6000610d5b6119b7565b6000828152600760205260409020610d728161213f565b80546001600160a01b03163314610db5576040517f38c5856200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610dbe8361218e565b91508115610dfa57610dfa6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633846121dc565b6000336001600160a01b0316847f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace85604051610e3891815260200190565b60405180910390a450919050565b610e4e6119b7565b610cbb83838360006040518060400160405280600081526020016000815250611c3f565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff610e9c816120f1565b6000838152600760205260409020610eb381612281565b60018101805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03851690811790915560405185907f865fdcfd963a9e21f0dbb101fecee79dda3ecc602d0fe55e29268c843f2a3b7c90600090a350505050565b610f196119b7565b610d4d8282612288565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff610f4d816120f1565b610f55612552565b83828114610f8f576040517f568efce200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610f9a600a5490565b90506000805b8381101561111b576000898983818110610fbc57610fbc61405a565b9050602002013590506000888884818110610fd957610fd961405a565b9050602002016020810190610fee9190614082565b63ffffffff16905084821061101657604051632d0483c560e21b815260040160405180910390fd5b6000828152600260205260409020805463ffffffff1680830361104c576040516324d0659d60e11b815260040160405180910390fd5b61105681846140b5565b6110609087614129565b955061106b826125db565b82547fffffffffffffffffffffffffffffffff00000000000000000000000000000000166401000000006bffffffffffffffffffffffff92909216919091027fffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000161763ffffffff841617825560405183815284907f645b3dc30fbdcc9749f62868ae25c191ff0090b1c21905c2793ec7159856e4389060200160405180910390a284600101945050505050610fa0565b5060045460009061113a908390600160901b900463ffffffff16614129565b90506000811361115d57604051632d0483c560e21b815260040160405180910390fd5b63ffffffff81111561118257604051632d0483c560e21b815260040160405180910390fd5b6004805463ffffffff909216600160901b027fffffffffffffffffffff00000000ffffffffffffffffffffffffffffffffffff9092169190911790555050505050505050565b60008281526007602090815260408083206001600160a01b0385168452600681019092528220826111fc8684846001612615565b90506112088183612735565b9695505050505050565b600061121d816120f1565b60045465ffffffffffff164210611260576040517fecdd1c2900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600354600480547fffffffffffffffffffffffffffff0000000000000000000000000000000000008116600160b01b90930469ffffffffffffffffffff164265ffffffffffff808416829003929092026601000000000000938490046bffffffffffffffffffffffff9081168290031690930265ffffffffffff191694909417931692909217905561131c7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633836121dc565b6040517fac02d07d013ae7c7e3ee940f8df0877c2ab1103bf87ab258ce31665f7111f09290600090a15050565b7f0914bb97ca83e85ef385857d9d418f187ff630589e0c9f44db92976d8e4519cb611373816120f1565b61137b612552565b6005546bffffffffffffffffffffffff8311156113c4576040517f35278d1200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600460068282829054906101000a90046bffffffffffffffffffffffff166113ed919061419d565b82546bffffffffffffffffffffffff9182166101009390930a92830291909202199091161790555060045460009065ffffffffffff1642106114325750808304611463565b506003546004544265ffffffffffff9091160369ffffffffffffffffffff600160b01b909204919091160283018190045b80600003611484576040516324d0659d60e11b815260040160405180910390fd5b6003805475ffffffffffffffffffffffffffffffffffffffffffff16600160b01b69ffffffffffffffffffff8416021790556114c082426141cd565b6004805465ffffffffffff191665ffffffffffff929092169190911790556115137f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163330876127f7565b6040518481527fde88a922e0d3b88b24e9623efeb464919c6bf9f66857a65e2bfcf2ce87a9433d9060200160405180910390a150505050565b6115546119b7565b610d4d82338360006040518060400160405280600081526020016000815250611c3f565b6004546000904265ffffffffffff909116106115a957600354600160b01b900469ffffffffffffffffffff166115ac565b60005b69ffffffffffffffffffff16905090565b60006115c8816120f1565b6004544265ffffffffffff909116111561160e576040517f085de62500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6201000182101561163257604051632d0483c560e21b815260040160405180910390fd5b63ffffffff82111561165757604051632d0483c560e21b815260040160405180910390fd5b60058290556040518281527fbd6eb9cf4d6e2902587c57e3163aaafdb46e3b3f2086bdfa75c790228930a9d79060200160405180910390a15050565b6000828152600760205260408120816116ae600383016128a3565b6001600160a01b03851660009081526006840160205260408120919250906116d5906128a3565b905080156117005781816116e7611578565b6116f191906141e5565b6116fb9190614204565b611208565b50600095945050505050565b600082815260016020526040812061172490836128e0565b9392505050565b6000818152600160205260408120610b6f906128ec565b61174a6119b7565b600260065561175a8160006128f6565b506001600655565b60008281526020819052604090206001015461177d816120f1565b610cbb838361211d565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff6117b1816120f1565b610cbb8383612cef565b6117c36119b7565b60026006556117e0823360006001610ba736879003870187613ffd565b50506001600655565b6117f16119b7565b6117fc816000612288565b50565b60008181526002602052604081205463ffffffff16801561184c57600454600160901b900463ffffffff1681611833611578565b61183d91906141e5565b6118479190614204565b611724565b60009392505050565b61185d6119b7565b600260065561175a8160016128f6565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610d4d576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556118c73390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000611724836001600160a01b038416612e73565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b000000000000000000000000000000000000000000000000000000001480610b6f57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614610b6f565b6006546002036119f3576040517fab143c0600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6000818152600760209081526040808320338452600681019092528220611a1b82612281565b611a258483612ec2565b5083600003611a475760405163b968846160e01b815260040160405180910390fd5b611a5081612f28565b611a5b848383612f84565b6004820180546bffffffffffffffffffffffff1916905592506000839003611a96576040516324d0659d60e11b815260040160405180910390fd5b805460038201546001600160681b0390911690611ac290600160981b900465ffffffffffff1642614226565b611acc90826141e5565b600383018054600090611ae99084906001600160981b031661423d565b92506101000a8154816001600160981b0302191690836001600160981b03160217905550611b66838360038101805465ffffffffffff4216600160981b027fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffffff90911617905560048201546001820155600590910154600290910155565b6000336001600160a01b0316867f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace87604051611ba491815260200190565b60405180910390a460018301546001600160a01b03168015611c36576040516344af0fa760e01b8152600481018790523360248201819052604482015260648101869052608481018390526001600160a01b038216906344af0fa79060a401600060405180830381600087803b158015611c1d57600080fd5b505af1158015611c31573d6000803e3d6000fd5b505050505b50505050919050565b60008581526007602090815260408083206001600160a01b038816845260068101909252909120611c6f82612281565b6003820180546001600160681b03168015611c9057611c8e8985612ec2565b505b6000611c9d8a8686612f84565b9050600080886002811115611cb457611cb4613eff565b03611cee57506004840180546bffffffffffffffffffffffff19166bffffffffffffffffffffffff92909216919091179055600087611db6565b6002886002811115611d0257611d02613eff565b03611d58578a15611d1557611d1561425f565b611d20868a89612fa9565b6004860180546bffffffffffffffffffffffff19166bffffffffffffffffffffffff9490941693909317909255909750600090611db6565b6001886002811115611d6c57611d6c613eff565b14611d7957611d7961425f565b8815611d8757611d8761425f565b611d908661330b565b50611d9c868389612fa9565b6004860180546bffffffffffffffffffffffff1916905598505b88600003611dd7576040516324d0659d60e11b815260040160405180910390fd5b600080611de48b866141cd565b90506001600160681b03811115611e27576040517f35278d1200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008b420290508087600001600d8282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b03160217905550818760000160006101000a8154816001600160681b0302191690836001600160681b03160217905550600088600001905060008160000160009054906101000a90046001600160681b03166001600160681b031690508d81019450848260000160006101000a8154816001600160681b0302191690836001600160681b031602179055508282600001600d8282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b031602179055508960030160139054906101000a900465ffffffffffff1665ffffffffffff16420381028a60030160008282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b0316021790555050505050611ff4878760038101805465ffffffffffff4216600160981b027fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffffff90911617905560048201546001820155600590910154600290910155565b8115612011578654612011906001600160a01b03163330856127f7565b898b6001600160a01b03168d7f17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a328660405161204e91815260200190565b60405180910390a460018701546001600160a01b031680156120e2576040516344af0fa760e01b8152600481018e90526001600160a01b038d811660248301819052604483015260648201869052608482018490528216906344af0fa79060a401600060405180830381600087803b1580156120c957600080fd5b505af11580156120dd573d6000803e3d6000fd5b505050505b50505050505050505050505050565b6117fc81336135b6565b612105828261186d565b6000828152600160205260409020610cbb908261190b565b6121278282613634565b6000828152600160205260409020610cbb90826136b3565b60025b815474010000000000000000000000000000000000000000900460ff16600281111561217057612170613eff565b146117fc5760405163b968846160e01b815260040160405180910390fd5b6000612198612552565b60008281526002602052604090206121af816125db565b81547fffffffffffffffffffffffffffffffff000000000000000000000000ffffffff1690915592915050565b60006040517fa9059cbb000000000000000000000000000000000000000000000000000000008152836004820152826024820152602060006044836000895af13d15601f3d116001600051141617169150508061227b5760405162461bcd60e51b815260206004820152600f60248201527f5452414e534645525f4641494c454400000000000000000000000000000000006044820152606401610d3a565b50505050565b6001612142565b6000828152600760209081526040808320338452600681019092529091206122af82612281565b6122b98483612ec2565b506122c484826136c8565b805481906001600160681b03168085111561230b576040517ff4d678b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000612318878686612f84565b6004850180546bffffffffffffffffffffffff1916905590508515801561233d575080155b1561235b576040516324d0659d60e11b815260040160405180910390fd5b600385810180546001600160681b038082168a900381166cffffffffffffffffffffffffff19909216821780845587546001600160981b036d0100000000000000000000000000918290048116928290048116428e8b03818102928301959095038316840290961790965594909416909302908316178655918601805465ffffffffffff909316600160981b027fffffffffffffff000000000000000000000000000000000000000000000000009093169290921790915560048601546001860155600586015460028601558115612461576124616001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633846121dc565b861561247d57855461247d906001600160a01b031633896121dc565b86336001600160a01b0316897f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace856040516124ba91815260200190565b60405180910390a460018601546001600160a01b03168015612547576040516344af0fa760e01b8152600481018a90523360248201819052604482015260648101849052608481018390526001600160a01b038216906344af0fa79060a401600060405180830381600087803b15801561253357600080fd5b505af11580156120e2573d6000803e3d6000fd5b505050505050505050565b61255a61376e565b6003805460009061257e9084906fffffffffffffffffffffffffffffffff16614275565b92506101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff16021790555042600360106101000a81548165ffffffffffff021916908365ffffffffffff160217905550565b6000806125e983600061379a565b6003548454600160801b6fffffffffffffffffffffffffffffffff928316029116179093555090919050565b60408051808201909152600080825260208201526003830154600160981b900465ffffffffffff1660000361265e5750604080518082019091526000808252602082015261272d565b600183016004850183156126f4576000878152600260205260408120612684908661379a565b9050600080612693898461384a565b91509150604051806040016040528086600001548487600001546126b791906141cd565b6126c19190614226565b815260200186600101548387600101546126db91906141cd565b6126e59190614226565b8152509550505050505061272d565b6040805180820190915282548254829161270d91614226565b8152602001836001015483600101546127269190614226565b9052925050505b949350505050565b6003810154600090600160981b900465ffffffffffff16156127ee5760038201546020840151600160801b91612776916001600160981b03909116906141e5565b8354600385015460208701516001600160681b03909216916127a791600160981b900465ffffffffffff16906141e5565b86516127b39190614226565b6127bd91906141e5565b6127c791906141cd565b6127d19190614204565b600483015461184791906bffffffffffffffffffffffff166141cd565b50600092915050565b60006040517f23b872dd0000000000000000000000000000000000000000000000000000000081528460048201528360248201528260448201526020600060648360008a5af13d15601f3d116001600051141617169150508061289c5760405162461bcd60e51b815260206004820152601460248201527f5452414e534645525f46524f4d5f4641494c45440000000000000000000000006044820152606401610d3a565b5050505050565b80546000906001600160981b036d0100000000000000000000000000820416906128d6906001600160681b0316426141e5565b610b6f9190614226565b600061172483836138ad565b6000610b6f825490565b60008281526007602090815260408083203384526006810190925290912061291d82612281565b61292784826136c8565b8054600383019082906001600160681b0316600081900361295b576040516324d0659d60e11b815260040160405180910390fd5b82546001600160681b03808216839003166cffffffffffffffffffffffffff19909116811780855583546001600160981b036d01000000000000000000000000009182900481169282900481169290920390911602178355600087815260076020908152604080832033845260060190915281208181556001810182905560028101919091556003810180547fffffffffffff000000000000000000000000000000000000000000000000000016905560040180546bffffffffffffffffffffffff191690558515612a9a578454612a46906001600160a01b0316336001600160681b0384166121dc565b806001600160681b0316336001600160a01b0316887f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace6000604051612a8d91815260200190565b60405180910390a4612bf7565b8454604080513360248201526001600160681b03841660448083019190915282518083039091018152606490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb00000000000000000000000000000000000000000000000000000000179052905160009283926001600160a01b0390911691612b2f91906142cc565b6000604051808303816000865af19150503d8060008114612b6c576040519150601f19603f3d011682016040523d82523d6000602084013e612b71565b606091505b5091509150818015612b84575060008151115b8015612b9f575080806020019051810190612b9f91906142e8565b15612bf457826001600160681b0316336001600160a01b03168a7f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace6000604051612beb91815260200190565b60405180910390a45b50505b600185015460408051602481018a90523360448201819052606482015260006084820181905260a48083018290528351808403909101815260c490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166344af0fa760e01b179052915191926001600160a01b031691612c7d91906142cc565b6000604051808303816000865af19150503d8060008114612cba576040519150601f19603f3d011682016040523d82523d6000602084013e612cbf565b606091505b5050905080612ce557600088815260096020908152604080832033845290915290204290555b5050505050505050565b600a805460009182612d008361430a565b9091555090506001600160a01b0383161580612d2d57506000826002811115612d2b57612d2b613eff565b145b15612d64576040517f4a0bd98600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001826002811115612d7857612d78613eff565b148015612d8d57506001600160a01b0383163b155b15612dab5760405163c1ab6dc160e01b815260040160405180910390fd5b600081815260076020526040902080546001600160a01b03851673ffffffffffffffffffffffffffffffffffffffff19821681178355849183917fffffffffffffffffffffff0000000000000000000000000000000000000000009091161774010000000000000000000000000000000000000000836002811115612e3257612e32613eff565b02179055506040516001600160a01b0385169083907f3d82013e0d368d05bfb8b953d35bffd6eec15520773228de41146f306a241aec90600090a350505050565b6000818152600183016020526040812054612eba57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610b6f565b506000610b6f565b600080612ece8461218e565b9050600080612edd858461384a565b91509150600085600401905082816000016000828254612efd91906141cd565b9250508190555081816001016000828254612f1891906141cd565b9091555093979650505050505050565b6003810154600160c81b900460ff166117fc57336000908152600860205260409020805460010190556003810180547fffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffff16600160c81b17905550565b600080612f948585856000612615565b9050612fa08184612735565b95945050505050565b82546002840154604080517f0902f1ac00000000000000000000000000000000000000000000000000000000815290516000936001600160a01b03908116931691849182918591630902f1ac916004808201926060929091908290030181865afa15801561301b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061303f9190614342565b506dffffffffffffffffffffffffffff91821693501690507f000000000000000000000000000000000000000000000000000000000000000060006001600160a01b03808616908316106130a757826130988a866141e5565b6130a29190614204565b6130bc565b836130b28a856141e5565b6130bc9190614204565b905087602001518111156130fc576040517f4c9b2c5900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8751811015613137576040517f4c9b2c5900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3415613251577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316856001600160a01b03161461318f5760405163c1ab6dc160e01b815260040160405180910390fd5b876020015134146131cc576040517f2c5211c600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b846001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561320757600080fd5b505af115801561321b573d6000803e3d6000fd5b50613236935050506001600160a01b038716905087836121dc565b3481810390821461324b5761324b33826138d7565b50613266565b6132666001600160a01b0386163388846127f7565b61327a6001600160a01b038316878b6121dc565b6040517f6a6278420000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03871690636a627842906024016020604051808303816000875af11580156132d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132fd9190614389565b9a9950505050505050505050565b60028101546001600160a01b0316806135b1578154604080517f0dfe168100000000000000000000000000000000000000000000000000000000815290516001600160a01b03909216916000918391630dfe1681916004808201926020929091908290030181865afa158015613385573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133a991906143a2565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156133eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061340f91906143a2565b6040517fe6a439050000000000000000000000000000000000000000000000000000000081526001600160a01b0384811660048301528083166024830152919250818516917f0000000000000000000000000000000000000000000000000000000000000000169063e6a4390590604401602060405180830381865afa15801561349d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134c191906143a2565b6001600160a01b0316146134e85760405163c1ab6dc160e01b815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316826001600160a01b03160361352957809350613583565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b03160361356a57819350613583565b60405163b968846160e01b815260040160405180910390fd5b50505060028201805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383161790555b919050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610d4d576135f2816001600160a01b03166014613932565b6135fd836020613932565b60405160200161360e9291906143bf565b60408051601f198184030181529082905262461bcd60e51b8252610d3a91600401614440565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1615610d4d576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6000611724836001600160a01b038416613b5b565b81600003613717573360009081526008602052604090205415610d4d576040517f0f2e5b6c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6003810154600160c81b900460ff1615610d4d57336000908152600860205260409020805460001901905560030180547fffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffff16905550565b600080613779613c4e565b60045463ffffffff600160901b909104166401000000009091020492915050565b600080826137bc576003546fffffffffffffffffffffffffffffffff166137db565b6137c461376e565b6003546fffffffffffffffffffffffffffffffff16015b84546fffffffffffffffffffffffffffffffff9182169250600160801b81049091168203906401000000009063ffffffff16820286546bffffffffffffffffffffffff6401000000009091048116929091049190910193508311156138425761384261425f565b505092915050565b600080600061385b856003016128a3565b905080156138a55780600160801b61387342876141e5565b61387d91906141e5565b6138879190614204565b925080613898600160801b866141e5565b6138a29190614204565b91505b509250929050565b60008260000182815481106138c4576138c461405a565b9060005260206000200154905092915050565b600080600080600085875af1905080610cbb5760405162461bcd60e51b815260206004820152601360248201527f4554485f5452414e534645525f4641494c4544000000000000000000000000006044820152606401610d3a565b606060006139418360026141e5565b61394c9060026141cd565b67ffffffffffffffff81111561396457613964613fe7565b6040519080825280601f01601f19166020018201604052801561398e576020820181803683370190505b5090507f3000000000000000000000000000000000000000000000000000000000000000816000815181106139c5576139c561405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110613a2857613a2861405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506000613a648460026141e5565b613a6f9060016141cd565b90505b6001811115613b0c577f303132333435363738396162636465660000000000000000000000000000000085600f1660108110613ab057613ab061405a565b1a60f81b828281518110613ac657613ac661405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060049490941c93613b0581614473565b9050613a72565b5083156117245760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610d3a565b60008181526001830160205260408120548015613c44576000613b7f600183614226565b8554909150600090613b9390600190614226565b9050818114613bf8576000866000018281548110613bb357613bb361405a565b9060005260206000200154905080876000018481548110613bd657613bd661405a565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613c0957613c0961448a565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610b6f565b6000915050610b6f565b60045460009065ffffffffffff1681428210613c6a5742613c6c565b815b600354909150600160801b900465ffffffffffff1680821115613ca857600354600160b01b900469ffffffffffffffffffff1691030292915050565b6000935050505090565b604080516101008101909152600060c0820181815260e083019190915281908152602001613cf3604051806040016040528060008152602001600081525090565b8152600060208201819052604082018190526060820181905260809091015290565b600060208284031215613d2757600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461172457600080fd5b6000808284036060811215613d6b57600080fd5b833592506040601f1982011215613d8157600080fd5b506020830190509250929050565b600060208284031215613da157600080fd5b5035919050565b6001600160a01b03811681146117fc57600080fd5b60008060408385031215613dd057600080fd5b823591506020830135613de281613da8565b809150509250929050565b600080600060608486031215613e0257600080fd5b833592506020840135613e1481613da8565b929592945050506040919091013590565b60008060408385031215613e3857600080fd5b50508035926020909101359150565b60008083601f840112613e5957600080fd5b50813567ffffffffffffffff811115613e7157600080fd5b6020830191508360208260051b8501011115613e8c57600080fd5b9250929050565b60008060008060408587031215613ea957600080fd5b843567ffffffffffffffff80821115613ec157600080fd5b613ecd88838901613e47565b90965094506020870135915080821115613ee657600080fd5b50613ef387828801613e47565b95989497509550505050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b03878116825261010082019060038810613f4657634e487b7160e01b600052602160045260246000fd5b602083810198909852958616604083015293909416606085015281516001600160681b03166080850152908401516001600160981b031660a0840152805160c08401529092015160e090910152919050565b600060208284031215613faa57600080fd5b813561172481613da8565b60008060408385031215613fc857600080fd5b8235613fd381613da8565b9150602083013560038110613de257600080fd5b634e487b7160e01b600052604160045260246000fd5b60006040828403121561400f57600080fd5b6040516040810181811067ffffffffffffffff8211171561404057634e487b7160e01b600052604160045260246000fd5b604052823581526020928301359281019290925250919050565b634e487b7160e01b600052603260045260246000fd5b63ffffffff811681146117fc57600080fd5b60006020828403121561409457600080fd5b813561172481614070565b634e487b7160e01b600052601160045260246000fd5b6000808312837f8000000000000000000000000000000000000000000000000000000000000000018312811516156140ef576140ef61409f565b837f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0183138116156141235761412361409f565b50500390565b6000808212827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038413811516156141635761416361409f565b827f80000000000000000000000000000000000000000000000000000000000000000384128116156141975761419761409f565b50500190565b60006bffffffffffffffffffffffff8083168185168083038211156141c4576141c461409f565b01949350505050565b600082198211156141e0576141e061409f565b500190565b60008160001904831182151516156141ff576141ff61409f565b500290565b60008261422157634e487b7160e01b600052601260045260246000fd5b500490565b6000828210156142385761423861409f565b500390565b60006001600160981b038083168185168083038211156141c4576141c461409f565b634e487b7160e01b600052600160045260246000fd5b60006fffffffffffffffffffffffffffffffff8083168185168083038211156141c4576141c461409f565b60005b838110156142bb5781810151838201526020016142a3565b8381111561227b5750506000910152565b600082516142de8184602087016142a0565b9190910192915050565b6000602082840312156142fa57600080fd5b8151801515811461172457600080fd5b6000600019820361431d5761431d61409f565b5060010190565b80516dffffffffffffffffffffffffffff811681146135b157600080fd5b60008060006060848603121561435757600080fd5b61436084614324565b925061436e60208501614324565b9150604084015161437e81614070565b809150509250925092565b60006020828403121561439b57600080fd5b5051919050565b6000602082840312156143b457600080fd5b815161172481613da8565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516143f78160178501602088016142a0565b7f206973206d697373696e6720726f6c652000000000000000000000000000000060179184019182015283516144348160288401602088016142a0565b01602801949350505050565b602081526000825180602084015261445f8160408501602087016142a0565b601f01601f19169190910160400192915050565b6000816144825761448261409f565b506000190190565b634e487b7160e01b600052603160045260246000fdfea264697066735822122027f9d01da3d32717fd6b88a18cc73e225ef20368c4daca229be32bbe8a0d60d964736f6c634300080f0033";
var deployedBytecode = "0x6080604052600436106102dc5760003560e01c80637b0a47ee11610184578063c45a0155116100d6578063d61f06801161008a578063ebe2b12b11610064578063ebe2b12b14610aba578063f2d1e1cd14610ad9578063f851844b14610af957600080fd5b8063d61f068014610a67578063d97f8ed614610a87578063ddc6326214610a9a57600080fd5b8063cea84402116100bb578063cea84402146109f3578063d1af0c7d14610a13578063d547741f14610a4757600080fd5b8063c45a01551461099f578063ca15c873146109d357600080fd5b806396c82e5711610138578063b470aade11610112578063b470aade1461091f578063c046371114610935578063c348dac11461097257600080fd5b806396c82e5714610801578063a217fddf1461083a578063ac4afa381461084f57600080fd5b806382f084d31161016957806382f084d31461077d5780639010d07c1461079d57806391d14854146107bd57600080fd5b80637b0a47ee146107485780637c2d6e011461075d57600080fd5b8063379607f51161023d57806359b02eb3116101f15780636bc9f703116101cb5780636bc9f7031461066257806374de4ec4146107085780637b0472f01461072857600080fd5b806359b02eb3146105f55780635faa65ff14610615578063677f93261461062a57600080fd5b806343de32071161022257806343de320714610595578063441a3e70146105b557806354f8c475146105d557600080fd5b8063379607f51461055557806343d5599e1461057557600080fd5b8063257664a4116102945780632f2ff15d116102795780632f2ff15d146104cb5780633228dd59146104eb57806336568abe1461053557600080fd5b8063257664a4146104015780632716ae66146104b657600080fd5b806317fcb39b116102c557806317fcb39b14610362578063190d8ef4146103ae578063248a9ca3146103c357600080fd5b806301ffc9a7146102e1578063098b885814610316575b600080fd5b3480156102ed57600080fd5b506103016102fc366004613d15565b610b19565b60405190151581526020015b60405180910390f35b34801561032257600080fd5b5060045461034590660100000000000090046bffffffffffffffffffffffff1681565b6040516bffffffffffffffffffffffff909116815260200161030d565b34801561036e57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161030d565b6103c16103bc366004613d57565b610b75565b005b3480156103cf57600080fd5b506103f36103de366004613d8f565b60009081526020819052604090206001015490565b60405190815260200161030d565b34801561040d57600080fd5b5061042161041c366004613dbd565b610bb6565b60405161030d9190815180516001600160681b031682526020908101516001600160981b031690820152610100810160208381015180516040850152908101516060840152506001600160981b03604084015116608083015265ffffffffffff60608401511660a08301526080830151151560c08301526bffffffffffffffffffffffff60a08401511660e083015292915050565b3480156104c257600080fd5b50600a546103f3565b3480156104d757600080fd5b506103c16104e6366004613dbd565b610c96565b3480156104f757600080fd5b50600354610514906fffffffffffffffffffffffffffffffff1681565b6040516fffffffffffffffffffffffffffffffff909116815260200161030d565b34801561054157600080fd5b506103c1610550366004613dbd565b610cc0565b34801561056157600080fd5b506103f3610570366004613d8f565b610d51565b34801561058157600080fd5b506103c1610590366004613ded565b610e46565b3480156105a157600080fd5b506103c16105b0366004613dbd565b610e72565b3480156105c157600080fd5b506103c16105d0366004613e25565b610f11565b3480156105e157600080fd5b506103c16105f0366004613e93565b610f23565b34801561060157600080fd5b506103f3610610366004613dbd565b6111c8565b34801561062157600080fd5b506103c1611212565b34801561063657600080fd5b506103f3610645366004613dbd565b600960209081526000928352604080842090915290825290205481565b34801561066e57600080fd5b506106c761067d366004613d8f565b60026020526000908152604090205463ffffffff81169064010000000081046bffffffffffffffffffffffff1690600160801b90046fffffffffffffffffffffffffffffffff1683565b6040805163ffffffff90941684526bffffffffffffffffffffffff90921660208401526fffffffffffffffffffffffffffffffff169082015260600161030d565b34801561071457600080fd5b506103c1610723366004613d8f565b611349565b34801561073457600080fd5b506103c1610743366004613e25565b61154c565b34801561075457600080fd5b506103f3611578565b34801561076957600080fd5b506103c1610778366004613d8f565b6115bd565b34801561078957600080fd5b506103f3610798366004613dbd565b611693565b3480156107a957600080fd5b506103966107b8366004613e25565b61170c565b3480156107c957600080fd5b506103016107d8366004613dbd565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b34801561080d57600080fd5b5060045461082590600160901b900463ffffffff1681565b60405163ffffffff909116815260200161030d565b34801561084657600080fd5b506103f3600081565b34801561085b57600080fd5b5061090d61086a366004613d8f565b6007602090815260009182526040918290208054600182015460028301548551808701875260038501546001600160681b03811682526d010000000000000000000000000090046001600160981b031681870152865180880190975260048501548752600590940154948601949094526001600160a01b03808316957401000000000000000000000000000000000000000090930460ff16949181169391169186565b60405161030d96959493929190613f15565b34801561092b57600080fd5b506103f360055481565b34801561094157600080fd5b5060035461095b90600160801b900465ffffffffffff1681565b60405165ffffffffffff909116815260200161030d565b34801561097e57600080fd5b506103f361098d366004613f98565b60086020526000908152604090205481565b3480156109ab57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b3480156109df57600080fd5b506103f36109ee366004613d8f565b61172b565b3480156109ff57600080fd5b506103c1610a0e366004613d8f565b611742565b348015610a1f57600080fd5b506103967f000000000000000000000000000000000000000000000000000000000000000081565b348015610a5357600080fd5b506103c1610a62366004613dbd565b611762565b348015610a7357600080fd5b506103c1610a82366004613fb5565b611787565b6103c1610a95366004613d57565b6117bb565b348015610aa657600080fd5b506103c1610ab5366004613d8f565b6117e9565b348015610ac657600080fd5b5060045461095b9065ffffffffffff1681565b348015610ae557600080fd5b506103f3610af4366004613d8f565b6117ff565b348015610b0557600080fd5b506103c1610b14366004613d8f565b611855565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f5a05180f000000000000000000000000000000000000000000000000000000001480610b6f5750610b6f82611920565b92915050565b610b7d6119b7565b60026006556000610b8d836119f5565b9050610bac600033836002610ba736889003880188613ffd565b611c3f565b5050600160065550565b610bbe613cb2565b5060008281526007602090815260408083206001600160a01b038516845260060182529182902082516101008101845281546001600160681b03811660c083019081526d01000000000000000000000000009091046001600160981b0390811660e0840152908252845180860186526001840154815260028401548186015293820193909352600382015492831693810193909352600160981b820465ffffffffffff166060840152600160c81b90910460ff1615156080830152600401546bffffffffffffffffffffffff1660a082015292915050565b600082815260208190526040902060010154610cb1816120f1565b610cbb83836120fb565b505050565b6001600160a01b0381163314610d435760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c66000000000000000000000000000000000060648201526084015b60405180910390fd5b610d4d828261211d565b5050565b6000610d5b6119b7565b6000828152600760205260409020610d728161213f565b80546001600160a01b03163314610db5576040517f38c5856200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610dbe8361218e565b91508115610dfa57610dfa6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633846121dc565b6000336001600160a01b0316847f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace85604051610e3891815260200190565b60405180910390a450919050565b610e4e6119b7565b610cbb83838360006040518060400160405280600081526020016000815250611c3f565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff610e9c816120f1565b6000838152600760205260409020610eb381612281565b60018101805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03851690811790915560405185907f865fdcfd963a9e21f0dbb101fecee79dda3ecc602d0fe55e29268c843f2a3b7c90600090a350505050565b610f196119b7565b610d4d8282612288565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff610f4d816120f1565b610f55612552565b83828114610f8f576040517f568efce200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610f9a600a5490565b90506000805b8381101561111b576000898983818110610fbc57610fbc61405a565b9050602002013590506000888884818110610fd957610fd961405a565b9050602002016020810190610fee9190614082565b63ffffffff16905084821061101657604051632d0483c560e21b815260040160405180910390fd5b6000828152600260205260409020805463ffffffff1680830361104c576040516324d0659d60e11b815260040160405180910390fd5b61105681846140b5565b6110609087614129565b955061106b826125db565b82547fffffffffffffffffffffffffffffffff00000000000000000000000000000000166401000000006bffffffffffffffffffffffff92909216919091027fffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000161763ffffffff841617825560405183815284907f645b3dc30fbdcc9749f62868ae25c191ff0090b1c21905c2793ec7159856e4389060200160405180910390a284600101945050505050610fa0565b5060045460009061113a908390600160901b900463ffffffff16614129565b90506000811361115d57604051632d0483c560e21b815260040160405180910390fd5b63ffffffff81111561118257604051632d0483c560e21b815260040160405180910390fd5b6004805463ffffffff909216600160901b027fffffffffffffffffffff00000000ffffffffffffffffffffffffffffffffffff9092169190911790555050505050505050565b60008281526007602090815260408083206001600160a01b0385168452600681019092528220826111fc8684846001612615565b90506112088183612735565b9695505050505050565b600061121d816120f1565b60045465ffffffffffff164210611260576040517fecdd1c2900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600354600480547fffffffffffffffffffffffffffff0000000000000000000000000000000000008116600160b01b90930469ffffffffffffffffffff164265ffffffffffff808416829003929092026601000000000000938490046bffffffffffffffffffffffff9081168290031690930265ffffffffffff191694909417931692909217905561131c7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633836121dc565b6040517fac02d07d013ae7c7e3ee940f8df0877c2ab1103bf87ab258ce31665f7111f09290600090a15050565b7f0914bb97ca83e85ef385857d9d418f187ff630589e0c9f44db92976d8e4519cb611373816120f1565b61137b612552565b6005546bffffffffffffffffffffffff8311156113c4576040517f35278d1200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600460068282829054906101000a90046bffffffffffffffffffffffff166113ed919061419d565b82546bffffffffffffffffffffffff9182166101009390930a92830291909202199091161790555060045460009065ffffffffffff1642106114325750808304611463565b506003546004544265ffffffffffff9091160369ffffffffffffffffffff600160b01b909204919091160283018190045b80600003611484576040516324d0659d60e11b815260040160405180910390fd5b6003805475ffffffffffffffffffffffffffffffffffffffffffff16600160b01b69ffffffffffffffffffff8416021790556114c082426141cd565b6004805465ffffffffffff191665ffffffffffff929092169190911790556115137f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163330876127f7565b6040518481527fde88a922e0d3b88b24e9623efeb464919c6bf9f66857a65e2bfcf2ce87a9433d9060200160405180910390a150505050565b6115546119b7565b610d4d82338360006040518060400160405280600081526020016000815250611c3f565b6004546000904265ffffffffffff909116106115a957600354600160b01b900469ffffffffffffffffffff166115ac565b60005b69ffffffffffffffffffff16905090565b60006115c8816120f1565b6004544265ffffffffffff909116111561160e576040517f085de62500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6201000182101561163257604051632d0483c560e21b815260040160405180910390fd5b63ffffffff82111561165757604051632d0483c560e21b815260040160405180910390fd5b60058290556040518281527fbd6eb9cf4d6e2902587c57e3163aaafdb46e3b3f2086bdfa75c790228930a9d79060200160405180910390a15050565b6000828152600760205260408120816116ae600383016128a3565b6001600160a01b03851660009081526006840160205260408120919250906116d5906128a3565b905080156117005781816116e7611578565b6116f191906141e5565b6116fb9190614204565b611208565b50600095945050505050565b600082815260016020526040812061172490836128e0565b9392505050565b6000818152600160205260408120610b6f906128ec565b61174a6119b7565b600260065561175a8160006128f6565b506001600655565b60008281526020819052604090206001015461177d816120f1565b610cbb838361211d565b7f6077685936c8169d09204a1d97db12e41713588c38e1d29a61867d3dcee98aff6117b1816120f1565b610cbb8383612cef565b6117c36119b7565b60026006556117e0823360006001610ba736879003870187613ffd565b50506001600655565b6117f16119b7565b6117fc816000612288565b50565b60008181526002602052604081205463ffffffff16801561184c57600454600160901b900463ffffffff1681611833611578565b61183d91906141e5565b6118479190614204565b611724565b60009392505050565b61185d6119b7565b600260065561175a8160016128f6565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610d4d576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556118c73390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000611724836001600160a01b038416612e73565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b000000000000000000000000000000000000000000000000000000001480610b6f57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614610b6f565b6006546002036119f3576040517fab143c0600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6000818152600760209081526040808320338452600681019092528220611a1b82612281565b611a258483612ec2565b5083600003611a475760405163b968846160e01b815260040160405180910390fd5b611a5081612f28565b611a5b848383612f84565b6004820180546bffffffffffffffffffffffff1916905592506000839003611a96576040516324d0659d60e11b815260040160405180910390fd5b805460038201546001600160681b0390911690611ac290600160981b900465ffffffffffff1642614226565b611acc90826141e5565b600383018054600090611ae99084906001600160981b031661423d565b92506101000a8154816001600160981b0302191690836001600160981b03160217905550611b66838360038101805465ffffffffffff4216600160981b027fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffffff90911617905560048201546001820155600590910154600290910155565b6000336001600160a01b0316867f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace87604051611ba491815260200190565b60405180910390a460018301546001600160a01b03168015611c36576040516344af0fa760e01b8152600481018790523360248201819052604482015260648101869052608481018390526001600160a01b038216906344af0fa79060a401600060405180830381600087803b158015611c1d57600080fd5b505af1158015611c31573d6000803e3d6000fd5b505050505b50505050919050565b60008581526007602090815260408083206001600160a01b038816845260068101909252909120611c6f82612281565b6003820180546001600160681b03168015611c9057611c8e8985612ec2565b505b6000611c9d8a8686612f84565b9050600080886002811115611cb457611cb4613eff565b03611cee57506004840180546bffffffffffffffffffffffff19166bffffffffffffffffffffffff92909216919091179055600087611db6565b6002886002811115611d0257611d02613eff565b03611d58578a15611d1557611d1561425f565b611d20868a89612fa9565b6004860180546bffffffffffffffffffffffff19166bffffffffffffffffffffffff9490941693909317909255909750600090611db6565b6001886002811115611d6c57611d6c613eff565b14611d7957611d7961425f565b8815611d8757611d8761425f565b611d908661330b565b50611d9c868389612fa9565b6004860180546bffffffffffffffffffffffff1916905598505b88600003611dd7576040516324d0659d60e11b815260040160405180910390fd5b600080611de48b866141cd565b90506001600160681b03811115611e27576040517f35278d1200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008b420290508087600001600d8282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b03160217905550818760000160006101000a8154816001600160681b0302191690836001600160681b03160217905550600088600001905060008160000160009054906101000a90046001600160681b03166001600160681b031690508d81019450848260000160006101000a8154816001600160681b0302191690836001600160681b031602179055508282600001600d8282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b031602179055508960030160139054906101000a900465ffffffffffff1665ffffffffffff16420381028a60030160008282829054906101000a90046001600160981b03160192506101000a8154816001600160981b0302191690836001600160981b0316021790555050505050611ff4878760038101805465ffffffffffff4216600160981b027fffffffffffffff000000000000ffffffffffffffffffffffffffffffffffffff90911617905560048201546001820155600590910154600290910155565b8115612011578654612011906001600160a01b03163330856127f7565b898b6001600160a01b03168d7f17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a328660405161204e91815260200190565b60405180910390a460018701546001600160a01b031680156120e2576040516344af0fa760e01b8152600481018e90526001600160a01b038d811660248301819052604483015260648201869052608482018490528216906344af0fa79060a401600060405180830381600087803b1580156120c957600080fd5b505af11580156120dd573d6000803e3d6000fd5b505050505b50505050505050505050505050565b6117fc81336135b6565b612105828261186d565b6000828152600160205260409020610cbb908261190b565b6121278282613634565b6000828152600160205260409020610cbb90826136b3565b60025b815474010000000000000000000000000000000000000000900460ff16600281111561217057612170613eff565b146117fc5760405163b968846160e01b815260040160405180910390fd5b6000612198612552565b60008281526002602052604090206121af816125db565b81547fffffffffffffffffffffffffffffffff000000000000000000000000ffffffff1690915592915050565b60006040517fa9059cbb000000000000000000000000000000000000000000000000000000008152836004820152826024820152602060006044836000895af13d15601f3d116001600051141617169150508061227b5760405162461bcd60e51b815260206004820152600f60248201527f5452414e534645525f4641494c454400000000000000000000000000000000006044820152606401610d3a565b50505050565b6001612142565b6000828152600760209081526040808320338452600681019092529091206122af82612281565b6122b98483612ec2565b506122c484826136c8565b805481906001600160681b03168085111561230b576040517ff4d678b800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000612318878686612f84565b6004850180546bffffffffffffffffffffffff1916905590508515801561233d575080155b1561235b576040516324d0659d60e11b815260040160405180910390fd5b600385810180546001600160681b038082168a900381166cffffffffffffffffffffffffff19909216821780845587546001600160981b036d0100000000000000000000000000918290048116928290048116428e8b03818102928301959095038316840290961790965594909416909302908316178655918601805465ffffffffffff909316600160981b027fffffffffffffff000000000000000000000000000000000000000000000000009093169290921790915560048601546001860155600586015460028601558115612461576124616001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633846121dc565b861561247d57855461247d906001600160a01b031633896121dc565b86336001600160a01b0316897f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace856040516124ba91815260200190565b60405180910390a460018601546001600160a01b03168015612547576040516344af0fa760e01b8152600481018a90523360248201819052604482015260648101849052608481018390526001600160a01b038216906344af0fa79060a401600060405180830381600087803b15801561253357600080fd5b505af11580156120e2573d6000803e3d6000fd5b505050505050505050565b61255a61376e565b6003805460009061257e9084906fffffffffffffffffffffffffffffffff16614275565b92506101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff16021790555042600360106101000a81548165ffffffffffff021916908365ffffffffffff160217905550565b6000806125e983600061379a565b6003548454600160801b6fffffffffffffffffffffffffffffffff928316029116179093555090919050565b60408051808201909152600080825260208201526003830154600160981b900465ffffffffffff1660000361265e5750604080518082019091526000808252602082015261272d565b600183016004850183156126f4576000878152600260205260408120612684908661379a565b9050600080612693898461384a565b91509150604051806040016040528086600001548487600001546126b791906141cd565b6126c19190614226565b815260200186600101548387600101546126db91906141cd565b6126e59190614226565b8152509550505050505061272d565b6040805180820190915282548254829161270d91614226565b8152602001836001015483600101546127269190614226565b9052925050505b949350505050565b6003810154600090600160981b900465ffffffffffff16156127ee5760038201546020840151600160801b91612776916001600160981b03909116906141e5565b8354600385015460208701516001600160681b03909216916127a791600160981b900465ffffffffffff16906141e5565b86516127b39190614226565b6127bd91906141e5565b6127c791906141cd565b6127d19190614204565b600483015461184791906bffffffffffffffffffffffff166141cd565b50600092915050565b60006040517f23b872dd0000000000000000000000000000000000000000000000000000000081528460048201528360248201528260448201526020600060648360008a5af13d15601f3d116001600051141617169150508061289c5760405162461bcd60e51b815260206004820152601460248201527f5452414e534645525f46524f4d5f4641494c45440000000000000000000000006044820152606401610d3a565b5050505050565b80546000906001600160981b036d0100000000000000000000000000820416906128d6906001600160681b0316426141e5565b610b6f9190614226565b600061172483836138ad565b6000610b6f825490565b60008281526007602090815260408083203384526006810190925290912061291d82612281565b61292784826136c8565b8054600383019082906001600160681b0316600081900361295b576040516324d0659d60e11b815260040160405180910390fd5b82546001600160681b03808216839003166cffffffffffffffffffffffffff19909116811780855583546001600160981b036d01000000000000000000000000009182900481169282900481169290920390911602178355600087815260076020908152604080832033845260060190915281208181556001810182905560028101919091556003810180547fffffffffffff000000000000000000000000000000000000000000000000000016905560040180546bffffffffffffffffffffffff191690558515612a9a578454612a46906001600160a01b0316336001600160681b0384166121dc565b806001600160681b0316336001600160a01b0316887f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace6000604051612a8d91815260200190565b60405180910390a4612bf7565b8454604080513360248201526001600160681b03841660448083019190915282518083039091018152606490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb00000000000000000000000000000000000000000000000000000000179052905160009283926001600160a01b0390911691612b2f91906142cc565b6000604051808303816000865af19150503d8060008114612b6c576040519150601f19603f3d011682016040523d82523d6000602084013e612b71565b606091505b5091509150818015612b84575060008151115b8015612b9f575080806020019051810190612b9f91906142e8565b15612bf457826001600160681b0316336001600160a01b03168a7f1c84cc0f96161bdafea718a9094dd21c21d1fb2f9ca2ebb9bd4e39918efbaace6000604051612beb91815260200190565b60405180910390a45b50505b600185015460408051602481018a90523360448201819052606482015260006084820181905260a48083018290528351808403909101815260c490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166344af0fa760e01b179052915191926001600160a01b031691612c7d91906142cc565b6000604051808303816000865af19150503d8060008114612cba576040519150601f19603f3d011682016040523d82523d6000602084013e612cbf565b606091505b5050905080612ce557600088815260096020908152604080832033845290915290204290555b5050505050505050565b600a805460009182612d008361430a565b9091555090506001600160a01b0383161580612d2d57506000826002811115612d2b57612d2b613eff565b145b15612d64576040517f4a0bd98600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001826002811115612d7857612d78613eff565b148015612d8d57506001600160a01b0383163b155b15612dab5760405163c1ab6dc160e01b815260040160405180910390fd5b600081815260076020526040902080546001600160a01b03851673ffffffffffffffffffffffffffffffffffffffff19821681178355849183917fffffffffffffffffffffff0000000000000000000000000000000000000000009091161774010000000000000000000000000000000000000000836002811115612e3257612e32613eff565b02179055506040516001600160a01b0385169083907f3d82013e0d368d05bfb8b953d35bffd6eec15520773228de41146f306a241aec90600090a350505050565b6000818152600183016020526040812054612eba57508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155610b6f565b506000610b6f565b600080612ece8461218e565b9050600080612edd858461384a565b91509150600085600401905082816000016000828254612efd91906141cd565b9250508190555081816001016000828254612f1891906141cd565b9091555093979650505050505050565b6003810154600160c81b900460ff166117fc57336000908152600860205260409020805460010190556003810180547fffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffff16600160c81b17905550565b600080612f948585856000612615565b9050612fa08184612735565b95945050505050565b82546002840154604080517f0902f1ac00000000000000000000000000000000000000000000000000000000815290516000936001600160a01b03908116931691849182918591630902f1ac916004808201926060929091908290030181865afa15801561301b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061303f9190614342565b506dffffffffffffffffffffffffffff91821693501690507f000000000000000000000000000000000000000000000000000000000000000060006001600160a01b03808616908316106130a757826130988a866141e5565b6130a29190614204565b6130bc565b836130b28a856141e5565b6130bc9190614204565b905087602001518111156130fc576040517f4c9b2c5900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8751811015613137576040517f4c9b2c5900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3415613251577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316856001600160a01b03161461318f5760405163c1ab6dc160e01b815260040160405180910390fd5b876020015134146131cc576040517f2c5211c600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b846001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561320757600080fd5b505af115801561321b573d6000803e3d6000fd5b50613236935050506001600160a01b038716905087836121dc565b3481810390821461324b5761324b33826138d7565b50613266565b6132666001600160a01b0386163388846127f7565b61327a6001600160a01b038316878b6121dc565b6040517f6a6278420000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03871690636a627842906024016020604051808303816000875af11580156132d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132fd9190614389565b9a9950505050505050505050565b60028101546001600160a01b0316806135b1578154604080517f0dfe168100000000000000000000000000000000000000000000000000000000815290516001600160a01b03909216916000918391630dfe1681916004808201926020929091908290030181865afa158015613385573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133a991906143a2565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156133eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061340f91906143a2565b6040517fe6a439050000000000000000000000000000000000000000000000000000000081526001600160a01b0384811660048301528083166024830152919250818516917f0000000000000000000000000000000000000000000000000000000000000000169063e6a4390590604401602060405180830381865afa15801561349d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134c191906143a2565b6001600160a01b0316146134e85760405163c1ab6dc160e01b815260040160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316826001600160a01b03160361352957809350613583565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316816001600160a01b03160361356a57819350613583565b60405163b968846160e01b815260040160405180910390fd5b50505060028201805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383161790555b919050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610d4d576135f2816001600160a01b03166014613932565b6135fd836020613932565b60405160200161360e9291906143bf565b60408051601f198184030181529082905262461bcd60e51b8252610d3a91600401614440565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1615610d4d576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6000611724836001600160a01b038416613b5b565b81600003613717573360009081526008602052604090205415610d4d576040517f0f2e5b6c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6003810154600160c81b900460ff1615610d4d57336000908152600860205260409020805460001901905560030180547fffffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffff16905550565b600080613779613c4e565b60045463ffffffff600160901b909104166401000000009091020492915050565b600080826137bc576003546fffffffffffffffffffffffffffffffff166137db565b6137c461376e565b6003546fffffffffffffffffffffffffffffffff16015b84546fffffffffffffffffffffffffffffffff9182169250600160801b81049091168203906401000000009063ffffffff16820286546bffffffffffffffffffffffff6401000000009091048116929091049190910193508311156138425761384261425f565b505092915050565b600080600061385b856003016128a3565b905080156138a55780600160801b61387342876141e5565b61387d91906141e5565b6138879190614204565b925080613898600160801b866141e5565b6138a29190614204565b91505b509250929050565b60008260000182815481106138c4576138c461405a565b9060005260206000200154905092915050565b600080600080600085875af1905080610cbb5760405162461bcd60e51b815260206004820152601360248201527f4554485f5452414e534645525f4641494c4544000000000000000000000000006044820152606401610d3a565b606060006139418360026141e5565b61394c9060026141cd565b67ffffffffffffffff81111561396457613964613fe7565b6040519080825280601f01601f19166020018201604052801561398e576020820181803683370190505b5090507f3000000000000000000000000000000000000000000000000000000000000000816000815181106139c5576139c561405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110613a2857613a2861405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506000613a648460026141e5565b613a6f9060016141cd565b90505b6001811115613b0c577f303132333435363738396162636465660000000000000000000000000000000085600f1660108110613ab057613ab061405a565b1a60f81b828281518110613ac657613ac661405a565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060049490941c93613b0581614473565b9050613a72565b5083156117245760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610d3a565b60008181526001830160205260408120548015613c44576000613b7f600183614226565b8554909150600090613b9390600190614226565b9050818114613bf8576000866000018281548110613bb357613bb361405a565b9060005260206000200154905080876000018481548110613bd657613bd661405a565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080613c0957613c0961448a565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050610b6f565b6000915050610b6f565b60045460009065ffffffffffff1681428210613c6a5742613c6c565b815b600354909150600160801b900465ffffffffffff1680821115613ca857600354600160b01b900469ffffffffffffffffffff1691030292915050565b6000935050505090565b604080516101008101909152600060c0820181815260e083019190915281908152602001613cf3604051806040016040528060008152602001600081525090565b8152600060208201819052604082018190526060820181905260809091015290565b600060208284031215613d2757600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461172457600080fd5b6000808284036060811215613d6b57600080fd5b833592506040601f1982011215613d8157600080fd5b506020830190509250929050565b600060208284031215613da157600080fd5b5035919050565b6001600160a01b03811681146117fc57600080fd5b60008060408385031215613dd057600080fd5b823591506020830135613de281613da8565b809150509250929050565b600080600060608486031215613e0257600080fd5b833592506020840135613e1481613da8565b929592945050506040919091013590565b60008060408385031215613e3857600080fd5b50508035926020909101359150565b60008083601f840112613e5957600080fd5b50813567ffffffffffffffff811115613e7157600080fd5b6020830191508360208260051b8501011115613e8c57600080fd5b9250929050565b60008060008060408587031215613ea957600080fd5b843567ffffffffffffffff80821115613ec157600080fd5b613ecd88838901613e47565b90965094506020870135915080821115613ee657600080fd5b50613ef387828801613e47565b95989497509550505050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b03878116825261010082019060038810613f4657634e487b7160e01b600052602160045260246000fd5b602083810198909852958616604083015293909416606085015281516001600160681b03166080850152908401516001600160981b031660a0840152805160c08401529092015160e090910152919050565b600060208284031215613faa57600080fd5b813561172481613da8565b60008060408385031215613fc857600080fd5b8235613fd381613da8565b9150602083013560038110613de257600080fd5b634e487b7160e01b600052604160045260246000fd5b60006040828403121561400f57600080fd5b6040516040810181811067ffffffffffffffff8211171561404057634e487b7160e01b600052604160045260246000fd5b604052823581526020928301359281019290925250919050565b634e487b7160e01b600052603260045260246000fd5b63ffffffff811681146117fc57600080fd5b60006020828403121561409457600080fd5b813561172481614070565b634e487b7160e01b600052601160045260246000fd5b6000808312837f8000000000000000000000000000000000000000000000000000000000000000018312811516156140ef576140ef61409f565b837f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0183138116156141235761412361409f565b50500390565b6000808212827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038413811516156141635761416361409f565b827f80000000000000000000000000000000000000000000000000000000000000000384128116156141975761419761409f565b50500190565b60006bffffffffffffffffffffffff8083168185168083038211156141c4576141c461409f565b01949350505050565b600082198211156141e0576141e061409f565b500190565b60008160001904831182151516156141ff576141ff61409f565b500290565b60008261422157634e487b7160e01b600052601260045260246000fd5b500490565b6000828210156142385761423861409f565b500390565b60006001600160981b038083168185168083038211156141c4576141c461409f565b634e487b7160e01b600052600160045260246000fd5b60006fffffffffffffffffffffffffffffffff8083168185168083038211156141c4576141c461409f565b60005b838110156142bb5781810151838201526020016142a3565b8381111561227b5750506000910152565b600082516142de8184602087016142a0565b9190910192915050565b6000602082840312156142fa57600080fd5b8151801515811461172457600080fd5b6000600019820361431d5761431d61409f565b5060010190565b80516dffffffffffffffffffffffffffff811681146135b157600080fd5b60008060006060848603121561435757600080fd5b61436084614324565b925061436e60208501614324565b9150604084015161437e81614070565b809150509250925092565b60006020828403121561439b57600080fd5b5051919050565b6000602082840312156143b457600080fd5b815161172481613da8565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516143f78160178501602088016142a0565b7f206973206d697373696e6720726f6c652000000000000000000000000000000060179184019182015283516144348160288401602088016142a0565b01602801949350505050565b602081526000825180602084015261445f8160408501602087016142a0565b601f01601f19169190910160400192915050565b6000816144825761448261409f565b506000190190565b634e487b7160e01b600052603160045260246000fdfea264697066735822122027f9d01da3d32717fd6b88a18cc73e225ef20368c4daca229be32bbe8a0d60d964736f6c634300080f0033";
var linkReferences = {
};
var deployedLinkReferences = {
};
var PANGOCHEF_ABI = {
	_format: _format,
	contractName: contractName,
	sourceName: sourceName,
	abi: abi,
	bytecode: bytecode,
	deployedBytecode: deployedBytecode,
	linkReferences: linkReferences,
	deployedLinkReferences: deployedLinkReferences
};

var REWARDERVIAMULTIPLIER_ABI = [
	{
		inputs: [
			{
				internalType: "contract IERC20[]",
				name: "_rewardTokens",
				type: "address[]"
			},
			{
				internalType: "uint256[]",
				name: "_rewardMultipliers",
				type: "uint256[]"
			},
			{
				internalType: "uint256",
				name: "_baseRewardTokenDecimals",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "_chefV2",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
		],
		name: "getRewardMultipliers",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getRewardTokens",
		outputs: [
			{
				internalType: "contract IERC20[]",
				name: "",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "rewardAmount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "onReward",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "rewardAmount",
				type: "uint256"
			}
		],
		name: "pendingTokens",
		outputs: [
			{
				internalType: "contract IERC20[]",
				name: "tokens",
				type: "address[]"
			},
			{
				internalType: "uint256[]",
				name: "amounts",
				type: "uint256[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "rewardAmount",
				type: "uint256"
			}
		],
		name: "pendingTokensDebt",
		outputs: [
			{
				internalType: "contract IERC20[]",
				name: "tokens",
				type: "address[]"
			},
			{
				internalType: "uint256[]",
				name: "amounts",
				type: "uint256[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "rewardMultipliers",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "rewardTokens",
		outputs: [
			{
				internalType: "contract IERC20",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	}
];

const REWARDER_VIA_MULTIPLIER_INTERFACE = new abi$1.Interface(REWARDERVIAMULTIPLIER_ABI);

var SarStaking = [
	{
		inputs: [
			{
				internalType: "address",
				name: "newRewardsToken",
				type: "address"
			},
			{
				internalType: "address",
				name: "newAdmin",
				type: "address"
			},
			{
				internalType: "contract ITokenMetadata",
				name: "newTokenMetadata",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		inputs: [
		],
		name: "FailedTransfer",
		type: "error"
	},
	{
		inputs: [
		],
		name: "HighSlippage",
		type: "error"
	},
	{
		inputs: [
		],
		name: "InsufficientBalance",
		type: "error"
	},
	{
		inputs: [
		],
		name: "InvalidAmount",
		type: "error"
	},
	{
		inputs: [
		],
		name: "InvalidToken",
		type: "error"
	},
	{
		inputs: [
		],
		name: "InvalidType",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Locked",
		type: "error"
	},
	{
		inputs: [
		],
		name: "MismatchedArrayLengths",
		type: "error"
	},
	{
		inputs: [
		],
		name: "NoEffect",
		type: "error"
	},
	{
		inputs: [
		],
		name: "NonExistentToken",
		type: "error"
	},
	{
		inputs: [
		],
		name: "NullInput",
		type: "error"
	},
	{
		inputs: [
		],
		name: "OutOfBounds",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Overflow",
		type: "error"
	},
	{
		inputs: [
		],
		name: "TooEarly",
		type: "error"
	},
	{
		inputs: [
		],
		name: "TooLate",
		type: "error"
	},
	{
		inputs: [
		],
		name: "Underflow",
		type: "error"
	},
	{
		inputs: [
		],
		name: "UnprivilegedCaller",
		type: "error"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "approved",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "approved",
				type: "bool"
			}
		],
		name: "ApprovalForAll",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "newApprovalPauseDuration",
				type: "uint256"
			}
		],
		name: "PauseDurationSet",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "newDuration",
				type: "uint256"
			}
		],
		name: "PeriodDurationUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
		],
		name: "PeriodEnded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "reward",
				type: "uint256"
			}
		],
		name: "RewardAdded",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "previousAdminRole",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "newAdminRole",
				type: "bytes32"
			}
		],
		name: "RoleAdminChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "RoleGranted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "RoleRevoked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "reward",
				type: "uint256"
			}
		],
		name: "Staked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "contract ITokenMetadata",
				name: "newTokenMetadata",
				type: "address"
			}
		],
		name: "TokenMetadataSet",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "uint256",
				name: "reward",
				type: "uint256"
			}
		],
		name: "Withdrawn",
		type: "event"
	},
	{
		inputs: [
		],
		name: "DEFAULT_ADMIN_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "addReward",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "approvalPauseDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			}
		],
		name: "burn",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			}
		],
		name: "compound",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			}
		],
		name: "emergencyExit",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "endPeriod",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "getApproved",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			}
		],
		name: "getRoleAdmin",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "index",
				type: "uint256"
			}
		],
		name: "getRoleMember",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			}
		],
		name: "getRoleMemberCount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "grantRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			}
		],
		name: "harvest",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "hasRole",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "address",
				name: "operator",
				type: "address"
			}
		],
		name: "isApprovedForAll",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "lastUpdate",
		outputs: [
			{
				internalType: "uint40",
				name: "",
				type: "uint40"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "mint",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256[]",
				name: "positionIds",
				type: "uint256[]"
			},
			{
				internalType: "uint256[]",
				name: "amounts",
				type: "uint256[]"
			}
		],
		name: "multiStake",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256[]",
				name: "positionIds",
				type: "uint256[]"
			},
			{
				internalType: "uint256[]",
				name: "amounts",
				type: "uint256[]"
			}
		],
		name: "multiWithdraw",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "name",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "ownerOf",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "periodDuration",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "periodFinish",
		outputs: [
			{
				internalType: "uint40",
				name: "",
				type: "uint40"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			}
		],
		name: "positionPendingRewards",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			}
		],
		name: "positionRewardRate",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "positions",
		outputs: [
			{
				components: [
					{
						internalType: "uint96",
						name: "balance",
						type: "uint96"
					},
					{
						internalType: "uint160",
						name: "sumOfEntryTimes",
						type: "uint160"
					}
				],
				internalType: "struct PangolinStakingPositions.ValueVariables",
				name: "valueVariables",
				type: "tuple"
			},
			{
				components: [
					{
						internalType: "uint256",
						name: "idealPosition",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "rewardPerValue",
						type: "uint256"
					}
				],
				internalType: "struct PangolinStakingPositions.RewardSummations",
				name: "rewardSummationsPaid",
				type: "tuple"
			},
			{
				internalType: "uint160",
				name: "previousValues",
				type: "uint160"
			},
			{
				internalType: "uint48",
				name: "lastUpdate",
				type: "uint48"
			},
			{
				internalType: "uint48",
				name: "lastDevaluation",
				type: "uint48"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "renounceRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "revokeRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "rewardRate",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "rewardSummationsStored",
		outputs: [
			{
				internalType: "uint256",
				name: "idealPosition",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "rewardPerValue",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "rewardsToken",
		outputs: [
			{
				internalType: "contract IERC20",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "safeTransferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			},
			{
				internalType: "bytes",
				name: "data",
				type: "bytes"
			}
		],
		name: "safeTransferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "operator",
				type: "address"
			},
			{
				internalType: "bool",
				name: "approved",
				type: "bool"
			}
		],
		name: "setApprovalForAll",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "newApprovalPauseDuration",
				type: "uint256"
			}
		],
		name: "setApprovalPauseDuration",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "newDuration",
				type: "uint256"
			}
		],
		name: "setPeriodDuration",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "contract ITokenMetadata",
				name: "newTokenMetadata",
				type: "address"
			}
		],
		name: "setTokenMetadata",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "stake",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes4",
				name: "interfaceId",
				type: "bytes4"
			}
		],
		name: "supportsInterface",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "index",
				type: "uint256"
			}
		],
		name: "tokenByIndex",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "tokenMetadata",
		outputs: [
			{
				internalType: "contract ITokenMetadata",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "index",
				type: "uint256"
			}
		],
		name: "tokenOfOwnerByIndex",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "tokenURI",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "from",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "to",
				type: "uint256"
			}
		],
		name: "tokensOfOwnerByIndex",
		outputs: [
			{
				internalType: "uint256[]",
				name: "",
				type: "uint256[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "totalRewardAdded",
		outputs: [
			{
				internalType: "uint96",
				name: "",
				type: "uint96"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "totalValueVariables",
		outputs: [
			{
				internalType: "uint96",
				name: "balance",
				type: "uint96"
			},
			{
				internalType: "uint160",
				name: "sumOfEntryTimes",
				type: "uint160"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "tokenId",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "positionId",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "withdraw",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

var WETH_ABI = [
	{
		constant: true,
		inputs: [
		],
		name: "name",
		outputs: [
			{
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "guy",
				type: "address"
			},
			{
				name: "wad",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "src",
				type: "address"
			},
			{
				name: "dst",
				type: "address"
			},
			{
				name: "wad",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "wad",
				type: "uint256"
			}
		],
		name: "withdraw",
		outputs: [
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "decimals",
		outputs: [
			{
				name: "",
				type: "uint8"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				name: "",
				type: "string"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: false,
		inputs: [
			{
				name: "dst",
				type: "address"
			},
			{
				name: "wad",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				name: "",
				type: "bool"
			}
		],
		payable: false,
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		constant: false,
		inputs: [
		],
		name: "deposit",
		outputs: [
		],
		payable: true,
		stateMutability: "payable",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "",
				type: "address"
			},
			{
				name: "",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				name: "",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		payable: true,
		stateMutability: "payable",
		type: "fallback"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "src",
				type: "address"
			},
			{
				indexed: true,
				name: "guy",
				type: "address"
			},
			{
				indexed: false,
				name: "wad",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "src",
				type: "address"
			},
			{
				indexed: true,
				name: "dst",
				type: "address"
			},
			{
				indexed: false,
				name: "wad",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "dst",
				type: "address"
			},
			{
				indexed: false,
				name: "wad",
				type: "uint256"
			}
		],
		name: "Deposit",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				name: "src",
				type: "address"
			},
			{
				indexed: false,
				name: "wad",
				type: "uint256"
			}
		],
		name: "Withdrawal",
		type: "event"
	}
];

var MULTICALL_ABI = [
	{
		constant: true,
		inputs: [
		],
		name: "getCurrentBlockTimestamp",
		outputs: [
			{
				name: "timestamp",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				components: [
					{
						name: "target",
						type: "address"
					},
					{
						name: "callData",
						type: "bytes"
					}
				],
				name: "calls",
				type: "tuple[]"
			}
		],
		name: "aggregate",
		outputs: [
			{
				name: "blockNumber",
				type: "uint256"
			},
			{
				name: "returnData",
				type: "bytes[]"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getLastBlockHash",
		outputs: [
			{
				name: "blockHash",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "addr",
				type: "address"
			}
		],
		name: "getEthBalance",
		outputs: [
			{
				name: "balance",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getCurrentBlockDifficulty",
		outputs: [
			{
				name: "difficulty",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getCurrentBlockGasLimit",
		outputs: [
			{
				name: "gaslimit",
				type: "uint256"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
		],
		name: "getCurrentBlockCoinbase",
		outputs: [
			{
				name: "coinbase",
				type: "address"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	},
	{
		constant: true,
		inputs: [
			{
				name: "blockNumber",
				type: "uint256"
			}
		],
		name: "getBlockHash",
		outputs: [
			{
				name: "blockHash",
				type: "bytes32"
			}
		],
		payable: false,
		stateMutability: "view",
		type: "function"
	}
];

const MULTICALL_NETWORKS = {
    [sdk.ChainId.FUJI]: sdk.CHAINS[sdk.ChainId.FUJI].contracts.multicall,
    [sdk.ChainId.AVALANCHE]: sdk.CHAINS[sdk.ChainId.AVALANCHE].contracts.multicall,
    [sdk.ChainId.WAGMI]: sdk.CHAINS[sdk.ChainId.WAGMI].contracts.multicall,
    [sdk.ChainId.COSTON]: sdk.CHAINS[sdk.ChainId.COSTON].contracts.multicall,
    [sdk.ChainId.SONGBIRD]: sdk.CHAINS[sdk.ChainId.SONGBIRD].contracts.multicall,
    [sdk.ChainId.NEAR_MAINNET]: '',
    [sdk.ChainId.NEAR_TESTNET]: '',
};

// returns null on errors
function useContract(address, ABI, withSignerIfPossible = true) {
    const { account } = usePangolinWeb3();
    const { library } = useLibrary();
    return React.useMemo(() => {
        if (!address || address === ZERO_ADDRESS || !ABI || !library)
            return null;
        try {
            return getContract(address, ABI, library, withSignerIfPossible && account ? account : undefined);
        }
        catch (error) {
            console.error('Failed to get contract', error);
            return null;
        }
    }, [address, ABI, library, withSignerIfPossible, account]);
}
function useTokenContract(tokenAddress, withSignerIfPossible) {
    return useContract(tokenAddress, ERC20_ABI, withSignerIfPossible);
}
function useBytes32TokenContract(tokenAddress, withSignerIfPossible) {
    return useContract(tokenAddress, ERC20_BYTES32_ABI, withSignerIfPossible);
}
function useWETHContract(withSignerIfPossible) {
    var _a;
    const { chainId } = usePangolinWeb3();
    return useContract(chainId ? (_a = sdk.WAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.address : undefined, WETH_ABI, withSignerIfPossible);
}
function useMulticallContract() {
    const { chainId } = usePangolinWeb3();
    return useContract(chainId && MULTICALL_NETWORKS[chainId], MULTICALL_ABI, false);
}
function useStakingContract(stakingAddress, withSignerIfPossible) {
    const chainId = useChainId();
    return useContract(stakingAddress, stakingAddress === MINICHEF_ADDRESS[chainId] ? MiniChefV2__default["default"].abi : StakingRewards__default["default"].abi, withSignerIfPossible);
}
function useMiniChefContract() {
    const chainId = useChainId();
    return useContract(MINICHEF_ADDRESS[chainId], MiniChefV2__default["default"].abi, true);
}
function useRewardViaMultiplierContract(address, withSignerIfPossible) {
    return useContract(address, REWARDER_VIA_MULTIPLIER_INTERFACE, withSignerIfPossible);
}
function usePairContract(pairAddress, withSignerIfPossible) {
    return useContract(pairAddress, IPangolinPair__default["default"].abi, withSignerIfPossible);
}
function useSarStakingContract() {
    const chainId = useChainId();
    return useContract(SAR_STAKING_ADDRESS[chainId], SarStaking, true);
}
function usePangoChefContract() {
    const chainId = useChainId();
    return useContract(PANGOCHEF_ADDRESS[chainId], PANGOCHEF_ABI.abi, true);
}

function useAllTokens() {
    const chainId = useChainId();
    const userAddedTokens = useUserAddedTokens();
    const allTokens = useSelectedTokenList();
    return React.useMemo(() => {
        if (!chainId)
            return {};
        return (userAddedTokens
            // reduce into all ALL_TOKENS filtered by the current chain
            .reduce((tokenMap, token) => {
            tokenMap[token.address] = token;
            return tokenMap;
        }, Object.assign({}, allTokens[chainId])));
    }, [chainId, userAddedTokens, allTokens]);
}
// parse a name or symbol from a token response
const BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;
function parseStringOrBytes32(str, bytes32, defaultValue) {
    return str && str.length > 0
        ? str
        : bytes32 && BYTES32_REGEX.test(bytes32)
            ? strings.parseBytes32String(bytes32)
            : defaultValue;
}
// undefined if invalid or does not exist
// null if loading
// otherwise returns the token
function useToken(tokenAddress) {
    const chainId = useChainId();
    const tokens = useAllTokens();
    const address = isAddress(tokenAddress);
    const tokenContract = useTokenContract(address ? address : undefined, false);
    const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);
    const token = address ? tokens[address] : undefined;
    const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);
    const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);
    const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);
    const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);
    const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);
    return React.useMemo(() => {
        var _a, _b, _c, _d;
        if (token)
            return token;
        if (!chainId || !address)
            return undefined;
        if (decimals.loading || symbol.loading || tokenName.loading)
            return null;
        if (decimals.result) {
            return new sdk.Token(chainId, address, decimals.result[0], parseStringOrBytes32((_a = symbol.result) === null || _a === void 0 ? void 0 : _a[0], (_b = symbolBytes32.result) === null || _b === void 0 ? void 0 : _b[0], 'UNKNOWN'), parseStringOrBytes32((_c = tokenName.result) === null || _c === void 0 ? void 0 : _c[0], (_d = tokenNameBytes32.result) === null || _d === void 0 ? void 0 : _d[0], 'Unknown Token'));
        }
        return undefined;
    }, [
        address,
        chainId,
        decimals.loading,
        decimals.result,
        symbol.loading,
        symbol.result,
        symbolBytes32.result,
        token,
        tokenName.loading,
        tokenName.result,
        tokenNameBytes32.result,
    ]);
}
function useNearToken(tokenAddress) {
    const [tokenData, setTokenData] = React.useState();
    const chainId = useChainId();
    const tokens = useAllTokens();
    const address = tokenAddress;
    const token = address ? tokens[address] : undefined;
    React.useEffect(() => {
        function getTokenData() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (address) {
                    const tokenMetaData = yield nearFn.getMetadata(address);
                    setTokenData(tokenMetaData);
                }
            });
        }
        getTokenData();
    }, [address]);
    return React.useMemo(() => {
        if (token)
            return token;
        if (!chainId || !address)
            return undefined;
        if (tokenData) {
            return new sdk.Token(chainId, address, tokenData === null || tokenData === void 0 ? void 0 : tokenData.decimals, tokenData === null || tokenData === void 0 ? void 0 : tokenData.symbol, tokenData === null || tokenData === void 0 ? void 0 : tokenData.name);
        }
        return undefined;
    }, [address, chainId, token, tokenData]);
}
function useTokens(tokensAddress = []) {
    const chainId = useChainId();
    const tokens = useAllTokens();
    const tokensName = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'name', undefined, NEVER_RELOAD);
    const tokensNameBytes32 = useMultipleContractSingleData(tokensAddress, ERC20_BYTES32_INTERFACE, 'name', undefined, NEVER_RELOAD);
    const symbols = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'symbol', undefined, NEVER_RELOAD);
    const symbolsBytes32 = useMultipleContractSingleData(tokensAddress, ERC20_BYTES32_INTERFACE, 'symbol', undefined, NEVER_RELOAD);
    const decimals = useMultipleContractSingleData(tokensAddress, ERC20_INTERFACE, 'decimals', undefined, NEVER_RELOAD);
    return React.useMemo(() => {
        if (!tokensAddress || (tokensAddress === null || tokensAddress === void 0 ? void 0 : tokensAddress.length) === 0)
            return [];
        if (!chainId)
            return [];
        return tokensAddress.reduce((acc, tokenAddress, index) => {
            var _a, _b, _c, _d, _e;
            const tokenName = tokensName === null || tokensName === void 0 ? void 0 : tokensName[index];
            const tokenNameBytes32 = tokensNameBytes32 === null || tokensNameBytes32 === void 0 ? void 0 : tokensNameBytes32[index];
            const symbol = symbols === null || symbols === void 0 ? void 0 : symbols[index];
            const symbolBytes32 = symbolsBytes32 === null || symbolsBytes32 === void 0 ? void 0 : symbolsBytes32[index];
            const decimal = decimals === null || decimals === void 0 ? void 0 : decimals[index];
            const address = isAddress(tokenAddress);
            if (!!address && tokens[address]) {
                // if we have user tokens already
                acc.push(tokens[address]);
            }
            else if ((tokenName === null || tokenName === void 0 ? void 0 : tokenName.loading) === false &&
                (tokenNameBytes32 === null || tokenNameBytes32 === void 0 ? void 0 : tokenNameBytes32.loading) === false &&
                (symbol === null || symbol === void 0 ? void 0 : symbol.loading) === false &&
                (symbolBytes32 === null || symbolBytes32 === void 0 ? void 0 : symbolBytes32.loading) === false &&
                (decimal === null || decimal === void 0 ? void 0 : decimal.loading) === false &&
                address) {
                const token = new sdk.Token(chainId, tokenAddress, (_a = decimal === null || decimal === void 0 ? void 0 : decimal.result) === null || _a === void 0 ? void 0 : _a[0], parseStringOrBytes32((_b = symbol.result) === null || _b === void 0 ? void 0 : _b[0], (_c = symbolBytes32.result) === null || _c === void 0 ? void 0 : _c[0], 'UNKNOWN'), parseStringOrBytes32((_d = tokenName.result) === null || _d === void 0 ? void 0 : _d[0], (_e = tokenNameBytes32.result) === null || _e === void 0 ? void 0 : _e[0], 'Unknown Token'));
                acc.push(token);
            }
            return acc;
        }, []);
    }, [chainId, decimals, symbols, symbolsBytes32, tokensName, tokensNameBytes32, tokens, tokensAddress]);
}
const fetchNearTokenMetadata = (address) => () => {
    return nearFn.getMetadata(address);
};
function useNearTokens(tokensAddress = []) {
    const chainId = useChainId();
    const tokens = useAllTokens();
    const queryParameter = React.useMemo(() => {
        var _a;
        return ((_a = tokensAddress === null || tokensAddress === void 0 ? void 0 : tokensAddress.map((address) => {
            return { queryKey: ['token', address], queryFn: fetchNearTokenMetadata(address) };
        })) !== null && _a !== void 0 ? _a : []);
    }, [tokensAddress]);
    const results = reactQuery.useQueries(queryParameter);
    return React.useMemo(() => {
        if (!tokensAddress || (tokensAddress === null || tokensAddress === void 0 ? void 0 : tokensAddress.length) === 0)
            return [];
        if (!chainId)
            return [];
        return results.reduce((acc, result) => {
            const tokenData = result === null || result === void 0 ? void 0 : result.data;
            if (tokenData && (result === null || result === void 0 ? void 0 : result.isLoading) === false) {
                if (!!(tokenData === null || tokenData === void 0 ? void 0 : tokenData.id) && tokens[tokenData === null || tokenData === void 0 ? void 0 : tokenData.id]) {
                    // if we have user tokens already
                    acc.push(tokens[tokenData === null || tokenData === void 0 ? void 0 : tokenData.id]);
                }
                else {
                    const token = new sdk.Token(chainId, tokenData === null || tokenData === void 0 ? void 0 : tokenData.id, tokenData === null || tokenData === void 0 ? void 0 : tokenData.decimals, tokenData === null || tokenData === void 0 ? void 0 : tokenData.symbol, tokenData === null || tokenData === void 0 ? void 0 : tokenData.name);
                    acc.push(token);
                }
            }
            return acc;
        }, []);
    }, [results, tokens]);
}
function useCurrency(currencyId) {
    var _a;
    const chainId = useChainId();
    const isAVAX = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === ((_a = sdk.CAVAX[chainId].symbol) === null || _a === void 0 ? void 0 : _a.toUpperCase());
    const useToken_ = useTokenHook[chainId];
    const token = useToken_(isAVAX ? undefined : currencyId);
    return isAVAX ? chainId && sdk.CAVAX[chainId] : token;
}
function useCoinGeckoTokenPrice(coin) {
    const [result, setResult] = React.useState({});
    React.useEffect(() => {
        const getCoinPriceData = () => tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const chain = coin.chainId === 43113 ? sdk.CHAINS[sdk.ChainId.AVALANCHE] : sdk.CHAINS[coin.chainId];
                const url = `${COINGEKO_BASE_URL}/simple/token_price/${chain.coingecko_id}?contract_addresses=${coin.address.toLowerCase()}&vs_currencies=usd`;
                const response = yield fetch(url);
                const data = yield response.json();
                setResult({
                    tokenUsdPrice: (_a = data === null || data === void 0 ? void 0 : data[coin.address.toLowerCase()]) === null || _a === void 0 ? void 0 : _a.usd,
                });
            }
            catch (error) {
                console.error('coingecko api error', error);
            }
        });
        getCoinPriceData();
    }, [coin]);
    return result;
}
function useCoinGeckoTokenPriceChart(coin, days = '7') {
    const [result, setResult] = React.useState([]);
    React.useEffect(() => {
        const getCoinData = () => tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            try {
                const chain = coin.chainId === 43113 ? sdk.CHAINS[sdk.ChainId.AVALANCHE] : sdk.CHAINS[coin.chainId];
                const url = `${COINGEKO_BASE_URL}/coins/${chain.coingecko_id}/contract/${coin.address.toLowerCase()}/market_chart/?vs_currency=usd&days=${days}`;
                const response = yield fetch(url);
                const data = yield response.json();
                const formattedHistory = [];
                const priceData = (data === null || data === void 0 ? void 0 : data.prices) || [];
                // for each hour, construct the open and close price
                for (let i = 0; i < priceData.length - 1; i++) {
                    formattedHistory.push({
                        timestamp: (((_a = priceData[i]) === null || _a === void 0 ? void 0 : _a[0]) / 1000).toFixed(0),
                        priceUSD: parseFloat((_b = priceData[i]) === null || _b === void 0 ? void 0 : _b[1]),
                    });
                }
                setResult(formattedHistory);
            }
            catch (error) {
                console.error('coingecko api error', error);
            }
        });
        getCoinData();
    }, [coin, days]);
    return result;
}
/**
 * Get the coingecko data for a token
 * @param coin - Token or Currency
 * @returns CoingeckoData of token if exist in coingecko else null
 * */
function useCoinGeckoTokenData(coin) {
    const chain = sdk.CHAINS[coin.chainId];
    return reactQuery.useQuery(['coingeckoToken', coin.address, chain.name], () => tslib.__awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (!chain.coingecko_id) {
            return null;
        }
        const response = yield fetch(`${COINGECKO_API}/coins/${chain.coingecko_id}/contract/${coin.address.toLowerCase()}`);
        const data = yield response.json();
        return {
            coinId: data === null || data === void 0 ? void 0 : data.id,
            homePage: (_a = data === null || data === void 0 ? void 0 : data.links) === null || _a === void 0 ? void 0 : _a.homepage[0],
            description: (_b = data === null || data === void 0 ? void 0 : data.description) === null || _b === void 0 ? void 0 : _b.en,
        };
    }));
}
function useCoinGeckoCurrencyPrice(chainId) {
    const currencyId = COINGECKO_CURRENCY_ID[chainId];
    return reactQuery.useQuery(['coingeckoCurrencyPrice', chainId], () => tslib.__awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (!currencyId) {
            return 0;
        }
        try {
            const response = yield axios__default["default"].get(`${COINGECKO_API}/simple/price?ids=${currencyId}&vs_currencies=usd`);
            const data = response.data;
            if (!data)
                return 0;
            return (_b = (_a = data[currencyId]) === null || _a === void 0 ? void 0 : _a.usd) !== null && _b !== void 0 ? _b : 0;
        }
        catch (error) {
            return 0;
        }
    }));
}

function useTokenAllowance(token, owner, spender) {
    const contract = useTokenContract(token === null || token === void 0 ? void 0 : token.address, false);
    const inputs = React.useMemo(() => [owner, spender], [owner, spender]);
    const allowance = useSingleCallResult(contract, 'allowance', inputs).result;
    return React.useMemo(() => (token && allowance ? new sdk.TokenAmount(token, allowance.toString()) : undefined), [token, allowance]);
}

// helper that can take a ethers library transaction response and add it to the list of transactions
function useTransactionAdder() {
    const { chainId, account } = usePangolinWeb3();
    const dispatch = useDispatch();
    return React.useCallback((response, { summary, approval, claim, } = {}) => {
        if (!account)
            return;
        if (!chainId)
            return;
        const { hash } = response;
        if (!hash) {
            throw Error('No transaction hash found.');
        }
        dispatch(addTransaction({ hash, from: account, chainId, approval, summary, claim }));
    }, [dispatch, chainId, account]);
}
function useAllTransactionsClearer() {
    const chainId = useChainId();
    const dispatch = useDispatch();
    return React.useCallback(() => {
        dispatch(clearAllTransactions({ chainId }));
    }, [chainId, dispatch]);
}
// returns all the transactions for the current chain
function useAllTransactions() {
    var _a;
    const { chainId } = usePangolinWeb3();
    const state = useSelector((state) => state.ptransactions);
    return chainId ? (_a = state[chainId]) !== null && _a !== void 0 ? _a : {} : {};
}
/**
 * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)
 * @param tx to check for recency
 */
function isTransactionRecent(tx) {
    return new Date().getTime() - tx.addedTime < 86400000;
}
// returns whether a token has a pending approval transaction
function useHasPendingApproval(tokenAddress, spender) {
    const allTransactions = useAllTransactions();
    return React.useMemo(() => typeof tokenAddress === 'string' &&
        typeof spender === 'string' &&
        Object.keys(allTransactions).some((hash) => {
            const tx = allTransactions[hash];
            if (!tx)
                return false;
            if (tx.receipt) {
                return false;
            }
            else {
                const approval = tx.approval;
                if (!approval)
                    return false;
                return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx);
            }
        }), [allTransactions, spender, tokenAddress]);
}

const ONE_HUNDRED_PERCENT = new sdk.Percent(sdk.JSBI.BigInt(1000), sdk.JSBI.BigInt(1000));
// computes price breakdown for the trade
function computeTradePriceBreakdown(trade) {
    // for each hop in our trade, take away the x*y=k price impact from swap fees
    // the following example assumes swap fees of 0.3% but this is determined by the pair
    // e.g. for 3 tokens/2 hops: 1 - ((1 - .03) * (1-.03))
    const realizedLPFee = !trade
        ? undefined
        : ONE_HUNDRED_PERCENT.subtract(trade.route.pools.reduce((currentFee, pool) => currentFee.multiply(new sdk.Percent(pool.swapFeeCoefficient, pool.swapFeeDivisor)), ONE_HUNDRED_PERCENT));
    // remove lp fees from price impact
    const priceImpactWithoutFeeFraction = trade && realizedLPFee ? trade.priceImpact.subtract(realizedLPFee) : undefined;
    // the x*y=k impact
    const priceImpactWithoutFeePercent = priceImpactWithoutFeeFraction
        ? new sdk.Percent(priceImpactWithoutFeeFraction === null || priceImpactWithoutFeeFraction === void 0 ? void 0 : priceImpactWithoutFeeFraction.numerator, priceImpactWithoutFeeFraction === null || priceImpactWithoutFeeFraction === void 0 ? void 0 : priceImpactWithoutFeeFraction.denominator)
        : undefined;
    // the amount of the input that accrues to LPs
    const realizedLPFeeAmount = realizedLPFee &&
        trade &&
        (trade.inputAmount instanceof sdk.TokenAmount
            ? new sdk.TokenAmount(trade.inputAmount.token, realizedLPFee.multiply(trade.inputAmount.raw).quotient)
            : sdk.CurrencyAmount.ether(realizedLPFee.multiply(trade.inputAmount.raw).quotient));
    const feeAmount = !trade
        ? undefined
        : trade.outputAmount instanceof sdk.TokenAmount
            ? new sdk.TokenAmount(trade.outputAmount.token, trade.fee.multiply(trade.outputAmount.raw).quotient)
            : sdk.CurrencyAmount.ether(trade.fee.multiply(trade.outputAmount.raw).quotient);
    return {
        priceImpactWithoutFee: priceImpactWithoutFeePercent,
        realizedLPFee,
        realizedLPFeeAmount,
        daasFeeAmount: feeAmount,
    };
}
// computes the minimum amount out and maximum amount in for a trade given a user specified allowed slippage in bips
function computeSlippageAdjustedAmounts(trade, allowedSlippage) {
    const pct = basisPointsToPercent(allowedSlippage);
    return {
        [Field.INPUT]: trade === null || trade === void 0 ? void 0 : trade.maximumAmountIn(pct),
        [Field.OUTPUT]: trade === null || trade === void 0 ? void 0 : trade.minimumAmountOut(pct),
    };
}
function warningSeverity(priceImpact) {
    if (!(priceImpact === null || priceImpact === void 0 ? void 0 : priceImpact.lessThan(BLOCKED_PRICE_IMPACT_NON_EXPERT)))
        return 4;
    if (!(priceImpact === null || priceImpact === void 0 ? void 0 : priceImpact.lessThan(ALLOWED_PRICE_IMPACT_HIGH)))
        return 3;
    if (!(priceImpact === null || priceImpact === void 0 ? void 0 : priceImpact.lessThan(ALLOWED_PRICE_IMPACT_MEDIUM)))
        return 2;
    if (!(priceImpact === null || priceImpact === void 0 ? void 0 : priceImpact.lessThan(ALLOWED_PRICE_IMPACT_LOW)))
        return 1;
    return 0;
}

var ApprovalState;
(function (ApprovalState) {
    ApprovalState[ApprovalState["UNKNOWN"] = 0] = "UNKNOWN";
    ApprovalState[ApprovalState["NOT_APPROVED"] = 1] = "NOT_APPROVED";
    ApprovalState[ApprovalState["PENDING"] = 2] = "PENDING";
    ApprovalState[ApprovalState["APPROVED"] = 3] = "APPROVED";
})(ApprovalState || (ApprovalState = {}));
// returns a variable indicating the state of the approval and a function which approves if necessary or early returns
function useApproveCallback(chainId, amountToApprove, spender) {
    const { account } = usePangolinWeb3();
    const token = amountToApprove instanceof sdk.TokenAmount ? amountToApprove.token : undefined;
    const currentAllowance = useTokenAllowance(token, account !== null && account !== void 0 ? account : undefined, spender);
    const pendingApproval = useHasPendingApproval(token === null || token === void 0 ? void 0 : token.address, spender);
    // check the current approval status
    const approvalState = React.useMemo(() => {
        if (!amountToApprove || !spender)
            return ApprovalState.UNKNOWN;
        if (amountToApprove.currency === sdk.CAVAX[chainId])
            return ApprovalState.APPROVED;
        // we might not have enough data to know whether or not we need to approve
        if (!currentAllowance)
            return ApprovalState.UNKNOWN;
        // amountToApprove will be defined if currentAllowance is
        return currentAllowance.lessThan(amountToApprove)
            ? pendingApproval
                ? ApprovalState.PENDING
                : ApprovalState.NOT_APPROVED
            : ApprovalState.APPROVED;
    }, [amountToApprove, currentAllowance, pendingApproval, spender]);
    const tokenContract = useTokenContract(token === null || token === void 0 ? void 0 : token.address);
    const addTransaction = useTransactionAdder();
    const approve = React.useCallback(() => tslib.__awaiter(this, void 0, void 0, function* () {
        if (approvalState !== ApprovalState.NOT_APPROVED) {
            console.error('approve was called unnecessarily');
            return;
        }
        if (!token) {
            console.error('no token');
            return;
        }
        if (!tokenContract) {
            console.error('tokenContract is null');
            return;
        }
        if (!amountToApprove) {
            console.error('missing amount to approve');
            return;
        }
        if (!spender) {
            console.error('no spender');
            return;
        }
        let useExact = false;
        const estimatedGas = yield tokenContract.estimateGas.approve(spender, constants.MaxUint256).catch(() => {
            // general fallback for tokens who restrict approval amounts
            useExact = true;
            return tokenContract.estimateGas.approve(spender, amountToApprove.raw.toString());
        });
        try {
            const response = yield tokenContract.approve(spender, useExact ? amountToApprove.raw.toString() : constants.MaxUint256, {
                gasLimit: calculateGasMargin(estimatedGas),
            });
            yield waitForTransaction(response, 1);
            addTransaction(response, {
                summary: 'Approve ' + amountToApprove.currency.symbol,
                approval: { tokenAddress: token.address, spender: spender },
            });
        }
        catch (error) {
            console.debug('Failed to approve token', error);
            throw error;
        }
    }), [approvalState, token, tokenContract, amountToApprove, spender, addTransaction]);
    return [approvalState, approve];
}
function useNearApproveCallback() {
    const approve = React.useCallback(() => tslib.__awaiter(this, void 0, void 0, function* () {
        Promise.resolve(42);
    }), []);
    return [ApprovalState.APPROVED, approve];
}
// wraps useApproveCallback in the context of a swap
function useApproveCallbackFromTrade(chainId, trade, allowedSlippage = 0) {
    const [amountToApprove, routerAddress] = React.useMemo(() => {
        if (!chainId || !trade)
            return [undefined, undefined];
        return [
            computeSlippageAdjustedAmounts(trade, allowedSlippage)[Field.INPUT],
            trade.feeTo === ZERO_ADDRESS ? ROUTER_ADDRESS[chainId] : ROUTER_DAAS_ADDRESS[chainId],
        ];
    }, [trade, allowedSlippage]);
    return useApproveCallback(chainId, amountToApprove, routerAddress);
}
//TODO:  Near Swap Approve dummy hook
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function useApproveCallbackFromNearTrade(_chainId, _trade, _allowedSlippage = 0) {
    const approve = () => {
        return Promise.resolve();
    };
    return [ApprovalState.APPROVED, approve];
}
// wraps useApproveCallback in the context of a swap
function useApproveCallbackFromInputCurrencyAmount(currencyAmountIn) {
    var _a;
    const chainId = useChainId();
    const gelatoLibrary = limitOrdersReact.useGelatoLimitOrdersLib();
    const newCurrencyAmountIn = currencyAmountIn
        ? new sdk.TokenAmount(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.numerator)
        : undefined;
    return useApproveCallback(chainId, newCurrencyAmountIn, (_a = gelatoLibrary === null || gelatoLibrary === void 0 ? void 0 : gelatoLibrary.erc20OrderRouter.address) !== null && _a !== void 0 ? _a : undefined);
}

/**
 * Returns true if the string value is zero in hex
 * @param hexNumberString
 */
function isZero(hexNumberString) {
    return /^0x0*$/.test(hexNumberString);
}

function useAllCommonPairs(currencyA, currencyB) {
    const chainId = useChainId();
    const usePairs = usePairsHook[chainId];
    const bases = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []; // eslint-disable-line react-hooks/exhaustive-deps
    const [tokenA, tokenB] = chainId
        ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]
        : [undefined, undefined];
    const basePairs = React.useMemo(() => flatMap__default["default"](bases, (base) => bases.map((otherBase) => [base, otherBase])).filter(([t0, t1]) => t0.address !== t1.address), [bases]);
    const allPairCombinations = React.useMemo(() => tokenA && tokenB
        ? [
            // the direct pair
            [tokenA, tokenB],
            // token A against all bases
            ...bases.map((base) => [tokenA, base]),
            // token B against all bases
            ...bases.map((base) => [tokenB, base]),
            // each base against all bases
            ...basePairs,
        ]
            .filter((tokens) => Boolean(tokens[0] && tokens[1]))
            .filter(([t0, t1]) => t0.address !== t1.address)
            .filter(([tokenA, tokenB]) => {
            if (!chainId)
                return true;
            const customBases = CUSTOM_BASES[chainId];
            if (!customBases)
                return true;
            const customBasesA = customBases[tokenA.address];
            const customBasesB = customBases[tokenB.address];
            if (!customBasesA && !customBasesB)
                return true;
            if (customBasesA && !customBasesA.find((base) => tokenB.equals(base)))
                return false;
            if (customBasesB && !customBasesB.find((base) => tokenA.equals(base)))
                return false;
            return true;
        })
        : [], [tokenA, tokenB, bases, basePairs, chainId]);
    const allPairs = usePairs(allPairCombinations);
    // only pass along valid pairs, non-duplicated pairs
    return React.useMemo(() => {
        const pairs = Object.values(allPairs
            // filter out invalid pairs
            .filter((result) => Boolean(result[0] === PairState.EXISTS && result[1]))
            // filter out duplicated pairs
            .reduce((memo, [, curr]) => {
            var _a;
            memo[curr.liquidityToken.address] = (_a = memo[curr.liquidityToken.address]) !== null && _a !== void 0 ? _a : curr;
            return memo;
        }, {}));
        const isLoading = allPairs.some((result) => result[0] === PairState.LOADING);
        return { pairs, isLoading };
    }, [allPairs]);
}
/**
 * Returns the best trade for the exact amount of tokens in to the given token out
 */
function useTradeExactIn(currencyAmountIn, currencyOut) {
    const { pairs: allowedPairs, isLoading } = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);
    const [feeTo] = useDaasFeeTo();
    const [feeInfo] = useDaasFeeInfo();
    return React.useMemo(() => {
        if (currencyAmountIn && currencyOut && feeTo && feeInfo && allowedPairs.length > 0 && !isLoading) {
            const trade = sdk.Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 3, maxNumResults: 1 }, { fee: new sdk.Percent(feeInfo.feeTotal.toString(), BIPS_BASE), feeTo })[0];
            return { trade: trade !== null && trade !== void 0 ? trade : null, isLoading: false };
        }
        return { trade: null, isLoading: true };
    }, [allowedPairs, isLoading, currencyAmountIn, currencyOut, feeTo, feeInfo]);
}
/**
 * Returns the best trade for the token in to the exact amount of token out
 */
function useTradeExactOut(currencyIn, currencyAmountOut) {
    const { pairs: allowedPairs, isLoading } = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);
    const [feeTo] = useDaasFeeTo();
    const [feeInfo] = useDaasFeeInfo();
    return React.useMemo(() => {
        if (currencyIn && currencyAmountOut && feeTo && feeInfo && allowedPairs.length > 0 && !isLoading) {
            const trade = sdk.Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 3, maxNumResults: 1 }, { fee: new sdk.Percent(feeInfo.feeTotal.toString(), BIPS_BASE), feeTo })[0];
            return { trade: trade !== null && trade !== void 0 ? trade : null, isLoading: false };
        }
        return { trade: null, isLoading: true };
    }, [allowedPairs, isLoading, currencyIn, currencyAmountOut, feeTo, feeInfo]);
}

function useParsedQueryString() {
    const { href } = window.location || {};
    const search = href === null || href === void 0 ? void 0 : href.substring((href === null || href === void 0 ? void 0 : href.indexOf('?')) + 1);
    return React.useMemo(() => (search && search.length > 1 ? qs.parse(search, { parseArrays: false, ignoreQueryPrefix: true }) : {}), [search]);
}

// import useParsedQueryString from './useParsedQueryString'
var Version;
(function (Version) {
    Version["v1"] = "v1";
    Version["v2"] = "v2";
})(Version || (Version = {}));
const DEFAULT_VERSION = Version.v2;
function useToggledVersion() {
    //TODO
    // const { use } = useParsedQueryString()
    // if (!use || typeof use !== 'string') return Version.v2
    // if (use.toLowerCase() === 'v1') return Version.v1
    return DEFAULT_VERSION;
}

function useGetTransactionSignature() {
    const { provider } = useLibrary();
    const { account } = usePangolinWeb3();
    const getSignature = (data) => tslib.__awaiter(this, void 0, void 0, function* () {
        try {
            const rawSignature = yield provider.execute('eth_signTypedData_v4', [account, data]);
            return utils.splitSignature(rawSignature);
        }
        catch (err) {
            if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                throw err;
            }
        }
    });
    return getSignature;
}

const useTokenBalancesHook = {
    [sdk.ChainId.FUJI]: useTokenBalances,
    [sdk.ChainId.AVALANCHE]: useTokenBalances,
    [sdk.ChainId.WAGMI]: useTokenBalances,
    [sdk.ChainId.COSTON]: useTokenBalances,
    [sdk.ChainId.SONGBIRD]: useTokenBalances,
    [sdk.ChainId.NEAR_MAINNET]: useNearTokenBalances,
    [sdk.ChainId.NEAR_TESTNET]: useNearTokenBalances,
};
const useTokenBalanceHook = {
    [sdk.ChainId.FUJI]: useTokenBalance,
    [sdk.ChainId.AVALANCHE]: useTokenBalance,
    [sdk.ChainId.WAGMI]: useTokenBalance,
    [sdk.ChainId.COSTON]: useTokenBalance,
    [sdk.ChainId.SONGBIRD]: useTokenBalance,
    [sdk.ChainId.NEAR_MAINNET]: useNearTokenBalance,
    [sdk.ChainId.NEAR_TESTNET]: useNearTokenBalance,
};
const useAccountBalanceHook = {
    [sdk.ChainId.FUJI]: useETHBalances,
    [sdk.ChainId.AVALANCHE]: useETHBalances,
    [sdk.ChainId.WAGMI]: useETHBalances,
    [sdk.ChainId.COSTON]: useETHBalances,
    [sdk.ChainId.SONGBIRD]: useETHBalances,
    [sdk.ChainId.NEAR_MAINNET]: useNearBalance,
    [sdk.ChainId.NEAR_TESTNET]: useNearBalance,
};
const useAddLiquidityHook = {
    [sdk.ChainId.FUJI]: useAddLiquidity,
    [sdk.ChainId.AVALANCHE]: useAddLiquidity,
    [sdk.ChainId.WAGMI]: useAddLiquidity,
    [sdk.ChainId.COSTON]: useAddLiquidity,
    [sdk.ChainId.SONGBIRD]: useAddLiquidity,
    [sdk.ChainId.NEAR_MAINNET]: useNearAddLiquidity,
    [sdk.ChainId.NEAR_TESTNET]: useNearAddLiquidity,
};
const useRemoveLiquidityHook = {
    [sdk.ChainId.FUJI]: useRemoveLiquidity,
    [sdk.ChainId.AVALANCHE]: useRemoveLiquidity,
    [sdk.ChainId.WAGMI]: useRemoveLiquidity,
    [sdk.ChainId.COSTON]: useRemoveLiquidity,
    [sdk.ChainId.SONGBIRD]: useRemoveLiquidity,
    [sdk.ChainId.NEAR_MAINNET]: useNearRemoveLiquidity,
    [sdk.ChainId.NEAR_TESTNET]: useNearRemoveLiquidity,
};
const useGetUserLPHook = {
    [sdk.ChainId.FUJI]: useGetUserLP,
    [sdk.ChainId.AVALANCHE]: useGetUserLP,
    [sdk.ChainId.WAGMI]: useGetUserLP,
    [sdk.ChainId.COSTON]: useGetUserLP,
    [sdk.ChainId.SONGBIRD]: useGetUserLP,
    [sdk.ChainId.NEAR_MAINNET]: useGetNearUserLP,
    [sdk.ChainId.NEAR_TESTNET]: useGetNearUserLP,
};

/**
 * Returns a map of the given addresses to their eventually consistent ETH balances.
 */
function useETHBalances(chainId, uncheckedAddresses) {
    const multicallContract = useMulticallContract();
    const addresses = React.useMemo(() => uncheckedAddresses
        ? uncheckedAddresses
            .map(isAddress)
            .filter((a) => a !== false)
            .sort()
        : [], [uncheckedAddresses]);
    const results = useSingleContractMultipleData(multicallContract, 'getEthBalance', addresses.map((address) => [address]));
    return React.useMemo(() => addresses.reduce((memo, address, i) => {
        var _a, _b;
        const value = (_b = (_a = results === null || results === void 0 ? void 0 : results[i]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b[0];
        if (value)
            memo[address] = sdk.CurrencyAmount.ether(sdk.JSBI.BigInt(value.toString()), chainId);
        return memo;
    }, {}), [chainId, addresses, results]);
}
/**
 * Returns a Near Wallet balance.
 */
function useNearBalance(chainId, accounts) {
    const [nearBalance, setNearBalance] = React.useState();
    const nearToken = sdk.WAVAX[chainId];
    React.useEffect(() => {
        function checkNearBalance() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const balance = yield near.getAccountBalance();
                if (balance && (accounts === null || accounts === void 0 ? void 0 : accounts[0])) {
                    const nearTokenBalance = new sdk.TokenAmount(nearToken, balance.available);
                    const container = {};
                    container[accounts === null || accounts === void 0 ? void 0 : accounts[0]] = nearTokenBalance;
                    setNearBalance(container);
                }
            });
        }
        checkNearBalance();
    }, [accounts, chainId]);
    return React.useMemo(() => nearBalance, [nearBalance]);
}
const fetchNearTokenBalance = (token, account) => () => tslib.__awaiter(void 0, void 0, void 0, function* () {
    if (token) {
        const balance = yield nearFn.getTokenBalance(token === null || token === void 0 ? void 0 : token.address, account);
        return new sdk.TokenAmount(token, balance);
    }
    return undefined;
});
const fetchNearPoolShare = (chainId, pair) => () => tslib.__awaiter(void 0, void 0, void 0, function* () {
    if (pair) {
        const share = yield nearFn.getSharesInPool(chainId, pair === null || pair === void 0 ? void 0 : pair.token0, pair === null || pair === void 0 ? void 0 : pair.token1);
        return new sdk.TokenAmount(pair === null || pair === void 0 ? void 0 : pair.liquidityToken, share);
    }
    return undefined;
});
/**
 * Returns a map of token addresses to their eventually consistent token balances for a single account.
 */
function useTokenBalancesWithLoadingIndicator(address, tokens) {
    const validatedTokens = React.useMemo(() => { var _a; return (_a = tokens === null || tokens === void 0 ? void 0 : tokens.filter((t) => isAddress(t === null || t === void 0 ? void 0 : t.address) !== false)) !== null && _a !== void 0 ? _a : []; }, [tokens]);
    const validatedTokenAddresses = React.useMemo(() => validatedTokens.map((vt) => vt.address), [validatedTokens]);
    const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address]);
    const anyLoading = React.useMemo(() => balances.some((callState) => callState.loading), [balances]);
    return [
        React.useMemo(() => address && validatedTokens.length > 0
            ? validatedTokens.reduce((memo, token, i) => {
                var _a, _b;
                const value = (_b = (_a = balances === null || balances === void 0 ? void 0 : balances[i]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b[0];
                const amount = value ? sdk.JSBI.BigInt(value.toString()) : undefined;
                if (amount) {
                    memo[token.address] = new sdk.TokenAmount(token, amount);
                }
                return memo;
            }, {})
            : {}, [address, validatedTokens, balances]),
        anyLoading,
    ];
}
function useTokenBalances(address, tokens) {
    return useTokenBalancesWithLoadingIndicator(address, tokens)[0];
}
function useNearTokenBalances(address, tokensOrPairs) {
    const chainId = useChainId();
    const queryParameter = React.useMemo(() => {
        var _a;
        return ((_a = tokensOrPairs === null || tokensOrPairs === void 0 ? void 0 : tokensOrPairs.map((item) => {
            var _a;
            if (item instanceof sdk.Pair) {
                return {
                    queryKey: ['pair-balance', (_a = item === null || item === void 0 ? void 0 : item.liquidityToken) === null || _a === void 0 ? void 0 : _a.address, address],
                    queryFn: fetchNearPoolShare(chainId, item),
                };
            }
            return {
                queryKey: ['token-balance', item === null || item === void 0 ? void 0 : item.address, address],
                queryFn: fetchNearTokenBalance(item, address),
            };
        })) !== null && _a !== void 0 ? _a : []);
    }, [tokensOrPairs]);
    const results = reactQuery.useQueries(queryParameter);
    return React.useMemo(() => results.reduce((memo, result, i) => {
        var _a;
        const value = result === null || result === void 0 ? void 0 : result.data;
        const token = tokensOrPairs === null || tokensOrPairs === void 0 ? void 0 : tokensOrPairs[i];
        if (token && token instanceof sdk.Token) {
            memo[token === null || token === void 0 ? void 0 : token.address] = value;
        }
        else if (token && token instanceof sdk.Pair) {
            memo[(_a = token === null || token === void 0 ? void 0 : token.liquidityToken) === null || _a === void 0 ? void 0 : _a.address] = value;
        }
        return memo;
    }, {}), [tokensOrPairs, address, results]);
}
// get the balance for a single token/account combo
function useTokenBalance(account, token) {
    const tokenBalances = useTokenBalances(account, [token]);
    if (!token)
        return undefined;
    return tokenBalances[token.address];
}
// get the balance for a single token/account combo
function useNearTokenBalance(account, tokenOrPair) {
    var _a;
    const tokensOrPairs = React.useMemo(() => [tokenOrPair], [tokenOrPair]);
    const tokenBalances = useNearTokenBalances(account, tokensOrPairs);
    if (!tokenOrPair)
        return undefined;
    if (tokenOrPair && tokenOrPair instanceof sdk.Token) {
        return tokenBalances[tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.address];
    }
    else if (tokenOrPair && tokenOrPair instanceof sdk.Pair) {
        return tokenBalances[(_a = tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address];
    }
}
function useCurrencyBalances(chainId, account, currencies) {
    const tokens = React.useMemo(() => { var _a; return (_a = currencies === null || currencies === void 0 ? void 0 : currencies.filter((currency) => currency instanceof sdk.Token)) !== null && _a !== void 0 ? _a : []; }, [currencies]);
    const useTokenBalances_ = useTokenBalancesHook[chainId];
    const useETHBalances_ = useAccountBalanceHook[chainId];
    const tokenBalances = useTokenBalances_(account, tokens);
    const containsETH = React.useMemo(() => { var _a; return (_a = currencies === null || currencies === void 0 ? void 0 : currencies.some((currency) => chainId && currency === sdk.CAVAX[chainId])) !== null && _a !== void 0 ? _a : false; }, [chainId, currencies]);
    const accountArr = React.useMemo(() => [account], [account]);
    const memoArr = React.useMemo(() => [], []);
    const ethBalance = useETHBalances_(chainId, containsETH ? accountArr : memoArr);
    return React.useMemo(() => {
        var _a;
        return (_a = currencies === null || currencies === void 0 ? void 0 : currencies.map((currency) => {
            if (!account || !currency)
                return undefined;
            if (currency instanceof sdk.Token)
                return tokenBalances[currency.address];
            if (currency === sdk.CAVAX[chainId])
                return ethBalance === null || ethBalance === void 0 ? void 0 : ethBalance[account];
            return undefined;
        })) !== null && _a !== void 0 ? _a : [];
    }, [chainId, account, currencies, ethBalance, tokenBalances]);
}
function useCurrencyBalance(chainId, account, currency) {
    const currencyArr = React.useMemo(() => [currency], [currency]);
    return useCurrencyBalances(chainId, account, currencyArr)[0];
}
// mimics useAllBalances
function useAllTokenBalances() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useTokenBalances_ = useTokenBalancesHook[chainId];
    const allTokens = useAllTokens();
    const allTokensArray = React.useMemo(() => Object.values(allTokens !== null && allTokens !== void 0 ? allTokens : {}), [allTokens]);
    const balances = useTokenBalances_(account !== null && account !== void 0 ? account : undefined, allTokensArray);
    return balances !== null && balances !== void 0 ? balances : {};
}
function useAddLiquidity() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const addTransaction = useTransactionAdder();
    const refetchMinichefSubgraph = useRefetchMinichefSubgraph();
    return (data) => tslib.__awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (!chainId || !library || !account)
            return;
        const { parsedAmounts, deadline, noLiquidity, allowedSlippage, currencies } = data;
        const { CURRENCY_A: currencyA, CURRENCY_B: currencyB } = currencies;
        const router = getRouterContract(chainId, library, account);
        const { [Field$1.CURRENCY_A]: parsedAmountA, [Field$1.CURRENCY_B]: parsedAmountB } = parsedAmounts;
        if (!parsedAmountA || !parsedAmountB || !currencyA || !currencyB || !deadline || !router) {
            return;
        }
        const amountsMin = {
            [Field$1.CURRENCY_A]: calculateSlippageAmount(parsedAmountA, noLiquidity ? 0 : allowedSlippage)[0],
            [Field$1.CURRENCY_B]: calculateSlippageAmount(parsedAmountB, noLiquidity ? 0 : allowedSlippage)[0],
        };
        let estimate, method, args, value;
        if (currencyA === sdk.CAVAX[chainId] || currencyB === sdk.CAVAX[chainId]) {
            const tokenBIsETH = currencyB === sdk.CAVAX[chainId];
            estimate = router.estimateGas.addLiquidityAVAX;
            method = router.addLiquidityAVAX;
            args = [
                (_b = (_a = wrappedCurrency(tokenBIsETH ? currencyA : currencyB, chainId)) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : '',
                (tokenBIsETH ? parsedAmountA : parsedAmountB).raw.toString(),
                amountsMin[tokenBIsETH ? Field$1.CURRENCY_A : Field$1.CURRENCY_B].toString(),
                amountsMin[tokenBIsETH ? Field$1.CURRENCY_B : Field$1.CURRENCY_A].toString(),
                account,
                deadline.toHexString(),
            ];
            value = bignumber.BigNumber.from((tokenBIsETH ? parsedAmountB : parsedAmountA).raw.toString());
        }
        else {
            estimate = router.estimateGas.addLiquidity;
            method = router.addLiquidity;
            args = [
                (_d = (_c = wrappedCurrency(currencyA, chainId)) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : '',
                (_f = (_e = wrappedCurrency(currencyB, chainId)) === null || _e === void 0 ? void 0 : _e.address) !== null && _f !== void 0 ? _f : '',
                parsedAmountA.raw.toString(),
                parsedAmountB.raw.toString(),
                amountsMin[Field$1.CURRENCY_A].toString(),
                amountsMin[Field$1.CURRENCY_B].toString(),
                account,
                deadline.toHexString(),
            ];
            value = null;
        }
        try {
            const estimatedGasLimit = yield estimate(...args, value ? { value } : {});
            const response = yield method(...args, Object.assign(Object.assign({}, (value ? { value } : {})), { gasLimit: calculateGasMargin(estimatedGasLimit) }));
            yield waitForTransaction(response, 5);
            addTransaction(response, {
                summary: 'Add ' +
                    ((_g = parsedAmounts[Field$1.CURRENCY_A]) === null || _g === void 0 ? void 0 : _g.toSignificant(3)) +
                    ' ' +
                    ((_h = currencies[Field$1.CURRENCY_A]) === null || _h === void 0 ? void 0 : _h.symbol) +
                    ' and ' +
                    ((_j = parsedAmounts[Field$1.CURRENCY_B]) === null || _j === void 0 ? void 0 : _j.toSignificant(3)) +
                    ' ' +
                    ((_k = currencies[Field$1.CURRENCY_B]) === null || _k === void 0 ? void 0 : _k.symbol),
            });
            yield refetchMinichefSubgraph();
            return response;
        }
        catch (err) {
            const _err = err;
            // we only care if the error is something _other_ than the user rejected the tx
            if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                console.error(_err);
            }
        }
        finally {
            // This is intentional
        }
    });
}
function useNearAddLiquidity() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    return (data) => tslib.__awaiter(this, void 0, void 0, function* () {
        if (!chainId || !library || !account)
            return;
        const depositTransactions = [];
        const { parsedAmounts, deadline, currencies } = data;
        const { CURRENCY_A: currencyA, CURRENCY_B: currencyB } = currencies;
        const { [Field$1.CURRENCY_A]: parsedAmountA, [Field$1.CURRENCY_B]: parsedAmountB } = parsedAmounts;
        const tokenA = currencyA ? wrappedCurrency(currencyA, chainId) : undefined;
        const tokenB = currencyB ? wrappedCurrency(currencyB, chainId) : undefined;
        if (!parsedAmountA || !parsedAmountB || !deadline || !tokenA || !tokenB) {
            throw new Error(`Missing dependency`);
        }
        const poolId = yield nearFn.getPoolId(chainId, tokenA, tokenB);
        const tokens = [tokenA, tokenB];
        const mainAmounts = [parsedAmountA.toFixed(), parsedAmountB.toFixed()];
        const amounts = [
            utils.parseUnits(parsedAmountA.toFixed(), tokenA === null || tokenA === void 0 ? void 0 : tokenA.decimals).toString(),
            utils.parseUnits(parsedAmountB.toFixed(), tokenB === null || tokenB === void 0 ? void 0 : tokenB.decimals).toString(),
        ];
        const exchangeContractId = NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId];
        const wNearContractId = sdk.WAVAX[chainId].address;
        const whitelist = yield nearFn.getWhitelistedTokens(chainId);
        for (let i = 0; i < tokens.length; i++) {
            const currencyId = tokens[i].address;
            depositTransactions.unshift({
                receiverId: currencyId,
                functionCalls: [
                    {
                        methodName: 'ft_transfer_call',
                        args: {
                            receiver_id: exchangeContractId,
                            amount: amounts[i],
                            msg: '',
                        },
                        amount: ONE_YOCTO_NEAR,
                    },
                ],
            });
            const tokenRegistered = yield nearFn.getStorageBalance(currencyId, exchangeContractId);
            if (tokenRegistered === null) {
                depositTransactions.unshift({
                    receiverId: currencyId,
                    functionCalls: [
                        nearFn.storageDepositAction({
                            accountId: exchangeContractId,
                            registrationOnly: true,
                            amount: NEAR_STORAGE_TO_REGISTER_WITH_FT,
                        }),
                    ],
                });
            }
            if (!whitelist.includes(currencyId)) {
                depositTransactions.unshift({
                    receiverId: exchangeContractId,
                    functionCalls: [nearFn.registerTokenAction(currencyId)],
                });
            }
        }
        const neededStorage = yield nearFn.checkUserNeedsStorageDeposit(chainId);
        if (neededStorage) {
            depositTransactions.unshift({
                receiverId: exchangeContractId,
                functionCalls: [nearFn.storageDepositAction({ amount: neededStorage })],
            });
        }
        const actions = [
            {
                methodName: 'add_liquidity',
                args: { pool_id: poolId, amounts },
                amount: NEAR_LP_STORAGE_AMOUNT,
            },
        ];
        const transactions = [
            ...depositTransactions,
            {
                receiverId: exchangeContractId,
                functionCalls: [...actions],
            },
        ];
        if (transactions.length > 0) {
            const wNearTokenIndex = tokens.findIndex((token) => (token === null || token === void 0 ? void 0 : token.address) === wNearContractId);
            if (wNearTokenIndex > -1 && !ONLY_ZEROS.test(mainAmounts[wNearTokenIndex])) {
                transactions.unshift({
                    receiverId: wNearContractId,
                    functionCalls: [nearFn.nearDepositAction(mainAmounts[wNearTokenIndex])],
                });
            }
            if (wNearTokenIndex > -1) {
                const registered = yield nearFn.getStorageBalance(wNearContractId);
                if (registered === null) {
                    transactions.unshift({
                        receiverId: wNearContractId,
                        functionCalls: [
                            nearFn.storageDepositAction({
                                registrationOnly: true,
                                amount: NEAR_STORAGE_TO_REGISTER_WITH_FT,
                            }),
                        ],
                    });
                }
            }
        }
        return nearFn.executeMultipleTransactions(transactions);
    });
}
function useRemoveLiquidity(pair) {
    var _a;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const addTransaction = useTransactionAdder();
    const { t } = reactI18next.useTranslation();
    const [signatureData, setSignatureData] = React.useState(null);
    const getSignature = useGetTransactionSignature();
    const pairContract = usePairContract((_a = pair === null || pair === void 0 ? void 0 : pair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address);
    const refetchMinichefSubgraph = useRefetchMinichefSubgraph();
    const removeLiquidity = (data) => tslib.__awaiter(this, void 0, void 0, function* () {
        var _b, _c;
        if (!chainId || !library || !account || !pair)
            return;
        const { parsedAmounts, deadline, allowedSlippage, approval } = data;
        const router = getRouterContract(chainId, library, account);
        if (!chainId || !library || !account || !deadline || !router)
            throw new Error(t('error.missingDependencies'));
        const { [Field$1.CURRENCY_A]: currencyAmountA, [Field$2.CURRENCY_B]: currencyAmountB } = parsedAmounts;
        const tokenA = pair === null || pair === void 0 ? void 0 : pair.token0;
        const tokenB = pair === null || pair === void 0 ? void 0 : pair.token1;
        const currencyA = tokenA ? unwrappedToken(tokenA, chainId) : undefined;
        const currencyB = tokenB ? unwrappedToken(tokenB, chainId) : undefined;
        if (!currencyAmountA || !currencyAmountB) {
            throw new Error(t('error.missingCurrencyAmounts'));
        }
        const amountsMin = {
            [Field$2.CURRENCY_A]: calculateSlippageAmount(currencyAmountA, allowedSlippage)[0],
            [Field$2.CURRENCY_B]: calculateSlippageAmount(currencyAmountB, allowedSlippage)[0],
        };
        if (!currencyA || !currencyB)
            throw new Error(t('error.missingTokens'));
        const liquidityAmount = parsedAmounts[Field$2.LIQUIDITY];
        if (!liquidityAmount)
            throw new Error(t('error.missingLiquidityAmount'));
        const currencyBIsAVAX = currencyB === sdk.CAVAX[chainId];
        const oneCurrencyIsAVAX = currencyA === sdk.CAVAX[chainId] || currencyBIsAVAX;
        if (!tokenA || !tokenB)
            throw new Error(t('error.couldNotWrap'));
        let methodNames, args;
        // we have approval, use normal remove liquidity
        if (approval === ApprovalState.APPROVED) {
            // removeLiquidityAVAX
            if (oneCurrencyIsAVAX) {
                methodNames = ['removeLiquidityAVAX', 'removeLiquidityAVAXSupportingFeeOnTransferTokens'];
                args = [
                    currencyBIsAVAX ? tokenA.address : tokenB.address,
                    liquidityAmount.raw.toString(),
                    amountsMin[currencyBIsAVAX ? Field$2.CURRENCY_A : Field$2.CURRENCY_B].toString(),
                    amountsMin[currencyBIsAVAX ? Field$2.CURRENCY_B : Field$2.CURRENCY_A].toString(),
                    account,
                    deadline.toHexString(),
                ];
            }
            // removeLiquidity
            else {
                methodNames = ['removeLiquidity'];
                args = [
                    tokenA.address,
                    tokenB.address,
                    liquidityAmount.raw.toString(),
                    amountsMin[Field$2.CURRENCY_A].toString(),
                    amountsMin[Field$2.CURRENCY_B].toString(),
                    account,
                    deadline.toHexString(),
                ];
            }
        }
        // we have a signature, use permit versions of remove liquidity
        else if (signatureData !== null) {
            // removeLiquidityAVAXWithPermit
            if (oneCurrencyIsAVAX) {
                methodNames = ['removeLiquidityAVAXWithPermit', 'removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens'];
                args = [
                    currencyBIsAVAX ? tokenA.address : tokenB.address,
                    liquidityAmount.raw.toString(),
                    amountsMin[currencyBIsAVAX ? Field$2.CURRENCY_A : Field$2.CURRENCY_B].toString(),
                    amountsMin[currencyBIsAVAX ? Field$2.CURRENCY_B : Field$2.CURRENCY_A].toString(),
                    account,
                    signatureData.deadline,
                    false,
                    signatureData.v,
                    signatureData.r,
                    signatureData.s,
                ];
            }
            // removeLiquidityAVAXWithPermit
            else {
                methodNames = ['removeLiquidityWithPermit'];
                args = [
                    tokenA.address,
                    tokenB.address,
                    liquidityAmount.raw.toString(),
                    amountsMin[Field$2.CURRENCY_A].toString(),
                    amountsMin[Field$2.CURRENCY_B].toString(),
                    account,
                    signatureData.deadline,
                    false,
                    signatureData.v,
                    signatureData.r,
                    signatureData.s,
                ];
            }
        }
        else {
            throw new Error(t('error.attemptingToConfirmApproval'));
        }
        const safeGasEstimates = yield Promise.all(methodNames.map((methodName) => router.estimateGas[methodName](...args)
            .then(calculateGasMargin)
            .catch((err) => {
            console.error(`estimateGas failed`, methodName, args, err);
            return undefined;
        })));
        const indexOfSuccessfulEstimation = safeGasEstimates.findIndex((safeGasEstimate) => bignumber.BigNumber.isBigNumber(safeGasEstimate));
        // all estimations failed...
        if (indexOfSuccessfulEstimation === -1) {
            console.error('This transaction would fail. Please contact support.');
        }
        else {
            const methodName = methodNames[indexOfSuccessfulEstimation];
            const safeGasEstimate = safeGasEstimates[indexOfSuccessfulEstimation];
            try {
                const response = yield router[methodName](...args, {
                    gasLimit: safeGasEstimate,
                });
                yield waitForTransaction(response, 5);
                addTransaction(response, {
                    summary: t('removeLiquidity.remove') +
                        ' ' +
                        ((_b = parsedAmounts[Field$2.CURRENCY_A]) === null || _b === void 0 ? void 0 : _b.toSignificant(3)) +
                        ' ' +
                        (currencyA === null || currencyA === void 0 ? void 0 : currencyA.symbol) +
                        ' and ' +
                        ((_c = parsedAmounts[Field$2.CURRENCY_B]) === null || _c === void 0 ? void 0 : _c.toSignificant(3)) +
                        ' ' +
                        (currencyB === null || currencyB === void 0 ? void 0 : currencyB.symbol),
                });
                yield refetchMinichefSubgraph();
                return response;
            }
            catch (err) {
                const _err = err;
                // we only care if the error is something _other_ than the user rejected the tx
                if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                    console.error(_err);
                }
            }
        }
    });
    const onAttemptToApprove = (data1) => tslib.__awaiter(this, void 0, void 0, function* () {
        const { parsedAmounts, deadline, approveCallback } = data1;
        if (!pairContract || !pair || !library || !deadline || !chainId || !account)
            throw new Error(t('earn.missingDependencies'));
        const liquidityAmount = parsedAmounts[Field$2.LIQUIDITY];
        if (!liquidityAmount)
            throw new Error(t('earn.missingLiquidityAmount'));
        // try to gather a signature for permission
        const nonce = yield pairContract.nonces(account);
        const EIP712Domain = [
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
            { name: 'chainId', type: 'uint256' },
            { name: 'verifyingContract', type: 'address' },
        ];
        const domain = {
            name: 'Arcanum Liquidity',
            version: '1',
            chainId: chainId,
            verifyingContract: pair.liquidityToken.address,
        };
        const Permit = [
            { name: 'owner', type: 'address' },
            { name: 'spender', type: 'address' },
            { name: 'value', type: 'uint256' },
            { name: 'nonce', type: 'uint256' },
            { name: 'deadline', type: 'uint256' },
        ];
        const message = {
            owner: account,
            spender: ROUTER_ADDRESS[chainId],
            value: liquidityAmount.raw.toString(),
            nonce: nonce.toHexString(),
            deadline: deadline.toNumber(),
        };
        const data = JSON.stringify({
            types: {
                EIP712Domain,
                Permit,
            },
            domain,
            primaryType: 'Permit',
            message,
        });
        try {
            const signature = yield getSignature(data);
            setSignatureData({
                v: signature.v,
                r: signature.r,
                s: signature.s,
                deadline: deadline.toNumber(),
            });
        }
        catch (err) {
            approveCallback();
        }
    });
    return { removeLiquidity, onAttemptToApprove, signatureData, setSignatureData };
}
function useNearRemoveLiquidity(pair) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const { t } = reactI18next.useTranslation();
    const removeLiquidity = (data) => tslib.__awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (!chainId || !library || !account)
            return;
        let transactions = [];
        const withDrawTransactions = [];
        const { parsedAmounts, deadline, allowedSlippage } = data;
        if (!chainId || !library || !account || !deadline)
            throw new Error(t('error.missingDependencies'));
        const { [Field$1.CURRENCY_A]: currencyAmountA, [Field$2.CURRENCY_B]: currencyAmountB } = parsedAmounts;
        const tokenA = pair === null || pair === void 0 ? void 0 : pair.token0;
        const tokenB = pair === null || pair === void 0 ? void 0 : pair.token1;
        if (!currencyAmountA || !currencyAmountB) {
            throw new Error(t('error.missingCurrencyAmounts'));
        }
        const liquidityAmount = parsedAmounts[Field$2.LIQUIDITY];
        if (!liquidityAmount)
            throw new Error(t('error.missingLiquidityAmount'));
        if (!tokenA || !tokenB)
            throw new Error(t('error.missingTokens'));
        const poolId = yield nearFn.getPoolId(chainId, tokenA, tokenB);
        const tokens = [tokenA, tokenB];
        const amountsMin = [
            (_a = calculateSlippageAmount(currencyAmountA, allowedSlippage)[0]) === null || _a === void 0 ? void 0 : _a.toString(),
            (_b = calculateSlippageAmount(currencyAmountB, allowedSlippage)[0]) === null || _b === void 0 ? void 0 : _b.toString(),
        ];
        const exchangeContractId = NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId];
        for (const token of tokens) {
            const currencyId = token.address;
            const tokenRegistered = yield nearFn.getStorageBalance(currencyId, exchangeContractId);
            if (tokenRegistered === null) {
                withDrawTransactions.unshift({
                    receiverId: currencyId,
                    functionCalls: [
                        nearFn.storageDepositAction({
                            accountId: exchangeContractId,
                            registrationOnly: true,
                            amount: NEAR_STORAGE_TO_REGISTER_WITH_FT,
                        }),
                    ],
                });
            }
        }
        const neededStorage = yield nearFn.checkUserNeedsStorageDeposit(chainId);
        if (neededStorage) {
            withDrawTransactions.unshift({
                receiverId: exchangeContractId,
                functionCalls: [nearFn.storageDepositAction({ amount: neededStorage })],
            });
        }
        const withdrawActions = tokens.map((token) => nearFn.withdrawAction({ tokenId: token === null || token === void 0 ? void 0 : token.address, amount: '0' }));
        const actions = [
            {
                methodName: 'remove_liquidity',
                args: { pool_id: poolId, shares: liquidityAmount === null || liquidityAmount === void 0 ? void 0 : liquidityAmount.raw.toString(), min_amounts: amountsMin },
                amount: ONE_YOCTO_NEAR,
            },
        ];
        withdrawActions.forEach((item) => {
            actions.push(item);
        });
        transactions = [
            ...withDrawTransactions,
            {
                receiverId: exchangeContractId,
                functionCalls: [...actions],
            },
        ];
        return nearFn.executeMultipleTransactions(transactions);
    });
    const onAttemptToApprove = () => {
        // This is intentional
    };
    return { removeLiquidity, onAttemptToApprove, signatureData: undefined, setSignatureData: () => { } };
}
function useGetUserLP() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    // fetch the user's balances of all tracked V2 LP tokens
    const trackedTokenPairs = useTrackedTokenPairs();
    const tokenPairsWithLiquidityTokens = React.useMemo(() => trackedTokenPairs.map((tokens) => ({
        liquidityToken: toV2LiquidityToken(tokens, chainId),
        tokens,
    })), [trackedTokenPairs, chainId]);
    const liquidityTokens = React.useMemo(() => tokenPairsWithLiquidityTokens.map((tpwlt) => tpwlt.liquidityToken), [tokenPairsWithLiquidityTokens]);
    const [v2PairsBalances, fetchingV2PairBalances] = useTokenBalancesWithLoadingIndicator(account !== null && account !== void 0 ? account : undefined, liquidityTokens);
    //fetch the reserves for all V2 pools in which the user has a balance
    const liquidityTokensWithBalances = React.useMemo(() => tokenPairsWithLiquidityTokens.filter(({ liquidityToken }) => { var _a; return (_a = v2PairsBalances[liquidityToken.address]) === null || _a === void 0 ? void 0 : _a.greaterThan('0'); }), [tokenPairsWithLiquidityTokens, v2PairsBalances]);
    const lpTokensWithBalances = React.useMemo(() => liquidityTokensWithBalances.map(({ tokens }) => tokens), [liquidityTokensWithBalances]);
    const v2Pairs = usePairs(lpTokensWithBalances);
    const v2IsLoading = fetchingV2PairBalances ||
        (v2Pairs === null || v2Pairs === void 0 ? void 0 : v2Pairs.length) < liquidityTokensWithBalances.length ||
        (v2Pairs === null || v2Pairs === void 0 ? void 0 : v2Pairs.some((V2Pair) => !V2Pair));
    const allV2PairsWithLiquidity = React.useMemo(() => v2Pairs.map(([, pair]) => pair).filter((v2Pair) => Boolean(v2Pair)), [v2Pairs]);
    const pairWithLpTokens = React.useMemo(() => tokenPairsWithLiquidityTokens.map(({ tokens }) => tokens), [tokenPairsWithLiquidityTokens]);
    const v2AllPairs = usePairs(pairWithLpTokens);
    const allV2AllPairsWithLiquidity = React.useMemo(() => v2AllPairs.map(([, pair]) => pair).filter((_v2AllPairs) => Boolean(_v2AllPairs)), [v2AllPairs]);
    return React.useMemo(() => ({ v2IsLoading, allV2PairsWithLiquidity, allPairs: allV2AllPairsWithLiquidity }), [v2IsLoading, allV2PairsWithLiquidity, allV2AllPairsWithLiquidity]);
}
function useGetNearUserLP() {
    const { account } = usePangolinWeb3();
    const { isLoading: v2IsLoading, data: pools = [] } = useGetNearAllPool();
    const allTokenAddress = React.useMemo(() => {
        var _a;
        let tokenAddresses = [];
        for (let i = 0; i < (pools === null || pools === void 0 ? void 0 : pools.length); i++) {
            tokenAddresses = [...tokenAddresses, ...(_a = pools === null || pools === void 0 ? void 0 : pools[i]) === null || _a === void 0 ? void 0 : _a.token_account_ids];
        }
        return [...new Set(tokenAddresses)];
    }, [pools]);
    const allTokens = useNearTokens(allTokenAddress);
    const tokensMapping = React.useMemo(() => {
        var _a;
        if (allTokens && allTokens.length > 0 && allTokenAddress.length === allTokens.length) {
            const tokensObj = {};
            for (let i = 0; i < (allTokens === null || allTokens === void 0 ? void 0 : allTokens.length); i++) {
                tokensObj[(_a = allTokens === null || allTokens === void 0 ? void 0 : allTokens[i]) === null || _a === void 0 ? void 0 : _a.address] = allTokens[i];
            }
            return tokensObj;
        }
        return undefined;
    }, [allTokens, allTokenAddress]);
    const liquidityTokens = React.useMemo(() => {
        if (allTokens && allTokens.length > 0 && tokensMapping && Object.keys(tokensMapping).length === allTokens.length) {
            const allLPTokens = (pools || []).map((pool) => {
                const tokens = pool === null || pool === void 0 ? void 0 : pool.token_account_ids.map((address) => {
                    const token = tokensMapping[address];
                    return token;
                });
                return [tokens === null || tokens === void 0 ? void 0 : tokens[0], tokens === null || tokens === void 0 ? void 0 : tokens[1]];
            });
            return allLPTokens;
        }
        return undefined;
    }, [allTokens, pools, tokensMapping]);
    const memoArray = React.useMemo(() => [], []);
    const v2AllPairs = useNearPairs(liquidityTokens || memoArray);
    const allV2Pairs = React.useMemo(() => v2AllPairs.map(([, pair]) => pair).filter((_v2AllPairs) => Boolean(_v2AllPairs)), [v2AllPairs]);
    const v2PairsBalances = useNearTokenBalances(account !== null && account !== void 0 ? account : undefined, allV2Pairs);
    //fetch the reserves for all V2 pools in which the user has a balance
    const allV2PairsWithLiquidity = React.useMemo(() => allV2Pairs.filter(({ liquidityToken }) => { var _a; return (_a = v2PairsBalances[liquidityToken.address]) === null || _a === void 0 ? void 0 : _a.greaterThan('0'); }), [allV2Pairs, v2PairsBalances]);
    const pairs = (liquidityTokens || memoArray).length > 0 ? allV2PairsWithLiquidity : [];
    return React.useMemo(() => ({ v2IsLoading, allV2PairsWithLiquidity: pairs }), [v2IsLoading, pairs]);
}
function useNearCreatePool() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    return (data) => tslib.__awaiter(this, void 0, void 0, function* () {
        if (!chainId || !library || !account)
            return;
        let transactions = [];
        const { tokenA, tokenB } = data;
        if (!tokenA || !tokenB) {
            throw new Error(`Missing dependency`);
        }
        // const poolId = await nearFn.getPoolId(chainId, tokenA, tokenB);
        // if (poolId) {
        //   throw new Error(`Pool is already exits`);
        // }
        const tokens = [tokenA, tokenB];
        const exchangeContractId = NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId];
        const tokenIds = tokens.map((token) => token === null || token === void 0 ? void 0 : token.address);
        const storageBalances = yield Promise.all(tokenIds.map((id) => nearFn.getStorageBalance(id, exchangeContractId)));
        transactions = storageBalances
            .reduce((acc, sb, i) => {
            if (!sb || sb.total === '0')
                acc.push(tokenIds[i]);
            return acc;
        }, [])
            .map((id) => ({
            receiverId: id,
            functionCalls: [
                nearFn.storageDepositAction({
                    accountId: exchangeContractId,
                    registrationOnly: true,
                    amount: NEAR_STORAGE_TO_REGISTER_WITH_FT,
                }),
            ],
        }));
        transactions.push({
            receiverId: exchangeContractId,
            functionCalls: [
                {
                    methodName: 'add_simple_pool',
                    args: { tokens: tokenIds, fee: 0.5 },
                    amount: '0.05',
                },
            ],
        });
        const query = qs__default["default"].stringify({
            currency0: tokenA === null || tokenA === void 0 ? void 0 : tokenA.address,
            currency1: tokenB === null || tokenB === void 0 ? void 0 : tokenB.address,
        });
        return nearFn.executeMultipleTransactions(transactions, `${window.location.origin}/${window.location.hash}?${query}`);
    });
}
/* eslint-enable max-lines */

/* eslint-disable max-lines */
function useSwapState() {
    return useSelector((state) => state.pswap);
}
function useSwapActionHandlers(chainId) {
    const dispatch = useDispatch();
    const onCurrencySelection = React.useCallback((field, currency) => {
        var _a, _b;
        dispatch(selectCurrency({
            field,
            currencyId: currency instanceof sdk.Token
                ? currency.address
                : currency === sdk.CAVAX[chainId] && ((_a = sdk.CAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.symbol)
                    ? (_b = sdk.CAVAX[chainId]) === null || _b === void 0 ? void 0 : _b.symbol
                    : '',
        }));
    }, [dispatch]);
    const onSwitchTokens = React.useCallback(() => {
        dispatch(switchCurrencies());
    }, [dispatch]);
    const onUserInput = React.useCallback((field, typedValue) => {
        dispatch(typeInput({ field, typedValue }));
    }, [dispatch]);
    const onChangeRecipient = React.useCallback((recipient) => {
        dispatch(setRecipient({ recipient }));
    }, [dispatch]);
    return {
        onSwitchTokens,
        onCurrencySelection,
        onUserInput,
        onChangeRecipient,
    };
}
// try to parse a user entered amount for a given token
function tryParseAmount(value, currency, chainId = sdk.ChainId.AVALANCHE) {
    if (!value || !currency) {
        return undefined;
    }
    try {
        const typedValueParsed = units.parseUnits(value, currency.decimals).toString();
        if (typedValueParsed !== '0') {
            return currency instanceof sdk.Token
                ? new sdk.TokenAmount(currency, sdk.JSBI.BigInt(typedValueParsed))
                : sdk.CurrencyAmount.ether(sdk.JSBI.BigInt(typedValueParsed), chainId);
        }
    }
    catch (error) {
        // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)
        console.debug(`Failed to parse input amount: "${value}"`, error);
    }
    // necessary for all paths to return a value
    return undefined;
}
const BAD_RECIPIENT_ADDRESSES = [
    sdk.FACTORY_ADDRESS[sdk.ChainId.AVALANCHE],
    ROUTER_ADDRESS[sdk.ChainId.AVALANCHE],
    ROUTER_DAAS_ADDRESS[sdk.ChainId.AVALANCHE], // DaaS router
];
/**
 * Returns true if any of the pairs or tokens in a trade have the given checksummed address
 * @param trade to check for the given address
 * @param checksummedAddress address to check in the pairs and tokens
 */
function involvesAddress(trade, checksummedAddress) {
    return (trade.route.path.some((token) => token.address === checksummedAddress) ||
        trade.route.pools.some((pool) => pool.liquidityToken.address === checksummedAddress));
}
// from the current swap inputs, compute the best trade and return it.
function useDerivedSwapInfo() {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const toggledVersion = useToggledVersion();
    const { independentField, typedValue, [Field.INPUT]: { currencyId: inputCurrencyId }, [Field.OUTPUT]: { currencyId: outputCurrencyId }, recipient, } = useSwapState();
    const inputCurrency = useCurrency(inputCurrencyId);
    const outputCurrency = useCurrency(outputCurrencyId);
    const recipientAddress = isEvmChain(chainId) ? isAddress(recipient) : recipient;
    const to = (_a = (recipientAddress ? recipientAddress : account)) !== null && _a !== void 0 ? _a : null;
    const relevantTokenBalances = useCurrencyBalances(chainId, account !== null && account !== void 0 ? account : undefined, [
        inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined,
        outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined,
    ]);
    const isExactIn = independentField === Field.INPUT;
    const parsedAmount = tryParseAmount(typedValue, (_b = (isExactIn ? inputCurrency : outputCurrency)) !== null && _b !== void 0 ? _b : undefined, chainId);
    const { trade: bestTradeExactIn, isLoading: isLoadingIn } = useTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined);
    const { trade: bestTradeExactOut, isLoading: isLoadingOut } = useTradeExactOut(inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, !isExactIn ? parsedAmount : undefined);
    const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut;
    const currencyBalances = {
        [Field.INPUT]: relevantTokenBalances[0],
        [Field.OUTPUT]: relevantTokenBalances[1],
    };
    const currencies = {
        [Field.INPUT]: inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined,
        [Field.OUTPUT]: outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined,
    };
    // get link to trade on v1, if a better rate exists
    const v1Trade = undefined;
    let inputError;
    if (!account) {
        inputError = 'Connect Wallet';
    }
    if (!parsedAmount) {
        inputError = inputError !== null && inputError !== void 0 ? inputError : 'Enter an amount';
    }
    if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {
        inputError = inputError !== null && inputError !== void 0 ? inputError : 'Select a token';
    }
    const formattedTo = isEvmChain(chainId) ? isAddress(to) : to;
    if (!to || !formattedTo) {
        inputError = inputError !== null && inputError !== void 0 ? inputError : 'Enter a recipient';
    }
    else {
        if (BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 ||
            (bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo)) ||
            (bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo))) {
            inputError = inputError !== null && inputError !== void 0 ? inputError : 'Invalid recipient';
        }
    }
    const [allowedSlippage] = useUserSlippageTolerance();
    const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage);
    // compare input balance to max input based on version
    const [balanceIn, amountIn] = [
        currencyBalances[Field.INPUT],
        toggledVersion === Version.v1
            ? null
            : slippageAdjustedAmounts
                ? slippageAdjustedAmounts[Field.INPUT]
                : null,
    ];
    if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {
        inputError = 'Insufficient ' + amountIn.currency.symbol + ' balance';
    }
    const isLoading = isExactIn ? isLoadingIn : isLoadingOut;
    return {
        currencies,
        currencyBalances,
        parsedAmount,
        v2Trade: v2Trade !== null && v2Trade !== void 0 ? v2Trade : undefined,
        inputError,
        v1Trade,
        isLoading,
    };
}
function parseCurrencyFromURLParameter(urlParam, chainId) {
    var _a, _b, _c, _d;
    if (typeof urlParam === 'string') {
        const valid = isAddress(urlParam);
        if (valid)
            return valid;
        if (urlParam.toUpperCase() === ((_b = (_a = sdk.CAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.toUpperCase()))
            return (_c = sdk.CAVAX[chainId]) === null || _c === void 0 ? void 0 : _c.symbol;
        if (valid === false)
            return (_d = sdk.CAVAX[chainId]) === null || _d === void 0 ? void 0 : _d.symbol;
    }
    //return 'AVAX' ?? '';
    return '';
}
function parseTokenAmountURLParameter(urlParam) {
    return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';
}
function parseIndependentFieldURLParameter(urlParam) {
    return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;
}
const ENS_NAME_REGEX$1 = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;
const ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;
function validatedRecipient(recipient) {
    if (typeof recipient !== 'string')
        return null;
    const address = isAddress(recipient);
    if (address)
        return address;
    if (ENS_NAME_REGEX$1.test(recipient))
        return recipient;
    if (ADDRESS_REGEX.test(recipient))
        return recipient;
    return null;
}
function queryParametersToSwapState(parsedQs, chainId) {
    let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency, chainId);
    let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency, chainId);
    if (inputCurrency === outputCurrency) {
        if (typeof parsedQs.outputCurrency === 'string') {
            inputCurrency = '';
        }
        else {
            outputCurrency = '';
        }
    }
    const recipient = validatedRecipient(parsedQs.recipient);
    return {
        [Field.INPUT]: {
            currencyId: inputCurrency,
        },
        [Field.OUTPUT]: {
            currencyId: outputCurrency,
        },
        typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),
        independentField: parseIndependentFieldURLParameter(parsedQs.exactField),
        recipient,
    };
}
// updates the swap state to use the defaults for a given network
function useDefaultsFromURLSearch() {
    const { chainId } = usePangolinWeb3();
    const dispatch = useDispatch();
    const parsedQs = useParsedQueryString();
    const [result, setResult] = React.useState();
    const { [Field.INPUT]: { currencyId: inputCurrencyId }, [Field.OUTPUT]: { currencyId: outputCurrencyId }, } = useSwapState();
    React.useEffect(() => {
        var _a, _b;
        if (!chainId)
            return;
        const parsed = queryParametersToSwapState(parsedQs, chainId);
        dispatch(replaceSwapState({
            typedValue: parsed.typedValue,
            field: parsed.independentField,
            inputCurrencyId: parsed[Field.INPUT].currencyId
                ? parsed[Field.INPUT].currencyId
                : inputCurrencyId
                    ? inputCurrencyId
                    : (_a = SWAP_DEFAULT_CURRENCY[chainId]) === null || _a === void 0 ? void 0 : _a.inputCurrency,
            outputCurrencyId: parsed[Field.OUTPUT].currencyId
                ? parsed[Field.OUTPUT].currencyId
                : outputCurrencyId
                    ? outputCurrencyId
                    : (_b = SWAP_DEFAULT_CURRENCY[chainId]) === null || _b === void 0 ? void 0 : _b.outputCurrency,
            recipient: parsed.recipient,
        }));
        setResult({ inputCurrencyId: parsed[Field.INPUT].currencyId, outputCurrencyId: parsed[Field.OUTPUT].currencyId });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [dispatch, chainId]);
    return result;
}
function useGelatoLimitOrderDetail(order) {
    const { chainId } = usePangolinWeb3();
    const gelatoLibrary = limitOrdersReact.useGelatoLimitOrdersLib();
    const inputCurrency = order.inputToken === NATIVE && chainId ? 'AVAX' : order.inputToken;
    const outputCurrency = order.outputToken === NATIVE && chainId ? 'AVAX' : order.outputToken;
    const currency0 = useCurrency(inputCurrency);
    const currency1 = useCurrency(outputCurrency);
    const inputToken = currency0 ? wrappedCurrency(currency0, chainId) : undefined;
    const outputToken = currency1 ? wrappedCurrency(currency1, chainId) : undefined;
    const inputAmount = React.useMemo(() => (inputToken && order.inputAmount ? new sdk.TokenAmount(inputToken, order.inputAmount) : undefined), [inputToken, order.inputAmount]);
    const rawMinReturn = React.useMemo(() => order.adjustedMinReturn
        ? order.adjustedMinReturn
        : gelatoLibrary && chainId && order.minReturn
            ? gelatoLibrary.getAdjustedMinReturn(order.minReturn)
            : undefined, [chainId, gelatoLibrary, order.adjustedMinReturn, order.minReturn]);
    const outputAmount = React.useMemo(() => (outputToken && rawMinReturn ? new sdk.TokenAmount(outputToken, rawMinReturn) : undefined), [outputToken, rawMinReturn]);
    const executionPrice = React.useMemo(() => outputAmount && outputAmount.greaterThan('0') && inputAmount && currency0 && currency1
        ? new sdk.Price(currency0, currency1, inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.raw, outputAmount === null || outputAmount === void 0 ? void 0 : outputAmount.raw)
        : undefined, [currency0, currency1, inputAmount, outputAmount]);
    return React.useMemo(() => ({
        currency0,
        currency1,
        inputAmount,
        outputAmount,
        executionPrice,
    }), [currency0, currency1, inputAmount, outputAmount, executionPrice]);
}
function useGelatoLimitOrderList() {
    const { open, executed, cancelled } = limitOrdersReact.useGelatoLimitOrdersHistory();
    const openPending = React.useMemo(() => (open.pending || []).map((item) => {
        const container = Object.assign({}, item);
        container['pending'] = true;
        return container;
    }), [open.pending]);
    const cancelledPending = React.useMemo(() => (cancelled.pending || []).map((item) => {
        const container = Object.assign({}, item);
        container['pending'] = true;
        return container;
    }), [cancelled.pending]);
    const allOrders = React.useMemo(() => [...cancelledPending, ...openPending, ...open.confirmed, ...cancelled.confirmed, ...executed], [openPending, cancelledPending, open.confirmed, cancelled.confirmed, executed]);
    const allOpenOrders = React.useMemo(() => [...cancelledPending, ...openPending, ...open.confirmed], [openPending, cancelledPending, open.confirmed]);
    const allCancelledOrders = React.useMemo(() => cancelled.confirmed, [cancelled.confirmed]);
    return React.useMemo(() => ({
        allOrders,
        allOpenOrders,
        allCancelledOrders,
        executed,
    }), [allOrders, allOpenOrders, allCancelledOrders, executed]);
}
function useDaasFeeTo() {
    const dispatch = useDispatch();
    const feeTo = useSelector((state) => {
        return state.pswap.feeTo;
    });
    const setFeeTo = React.useCallback((newFeeTo) => {
        dispatch(updateFeeTo({ feeTo: newFeeTo }));
    }, [dispatch]);
    return [feeTo, setFeeTo];
}
function useDaasFeeInfo() {
    const dispatch = useDispatch();
    const feeInfo = useSelector((state) => {
        return state.pswap.feeInfo;
    });
    const setFeeInfo = React.useCallback((newFeeInfo) => {
        dispatch(updateFeeInfo({ feeInfo: newFeeInfo }));
    }, [dispatch]);
    return [feeInfo, setFeeInfo];
}
/* eslint-enable max-lines */

/**
 * Given a name or address, does a lookup to resolve to an address and name
 * @param nameOrAddress ENS name or address
 */
function useENS(nameOrAddress) {
    const validated = isAddress(nameOrAddress);
    return {
        loading: false,
        address: validated ? validated : null,
        name: null,
    };
}

// combines the current timestamp with the user setting to give the deadline that should be used for any submitted transaction
function useTransactionDeadline() {
    const ttl = useSelector((state) => state.puser.userDeadline);
    const currentTimestampSeconds = ethers.BigNumber.from(Math.ceil(Date.now() / 1000));
    return ttl ? currentTimestampSeconds.add(ttl) : undefined;
}

var SwapCallbackState;
(function (SwapCallbackState) {
    SwapCallbackState[SwapCallbackState["INVALID"] = 0] = "INVALID";
    SwapCallbackState[SwapCallbackState["LOADING"] = 1] = "LOADING";
    SwapCallbackState[SwapCallbackState["VALID"] = 2] = "VALID";
})(SwapCallbackState || (SwapCallbackState = {}));
/**
 * Returns the swap calls that can be used to make the trade
 * @param trade trade to execute
 * @param allowedSlippage user allowed slippage
 * @param recipientAddressOrName
 */
function useSwapCallArguments(trade, // trade to execute, required
allowedSlippage = INITIAL_ALLOWED_SLIPPAGE, // in bips
recipientAddressOrName) {
    const { account, chainId } = usePangolinWeb3();
    const { library } = useLibrary();
    const [partnerDaaS] = useDaasFeeTo();
    const { address: recipientAddress } = useENS(recipientAddressOrName);
    const recipient = recipientAddressOrName === null ? account : recipientAddress;
    let deadline = useTransactionDeadline();
    const currentTime = bignumber.BigNumber.from(new Date().getTime());
    if (deadline && deadline < currentTime.add(10)) {
        deadline = currentTime.add(10);
    }
    const contract = React.useMemo(() => {
        if (!chainId || !library || !account || !partnerDaaS)
            return null;
        return partnerDaaS === ZERO_ADDRESS
            ? getRouterContract(chainId, library, account)
            : getRouterContractDaaS(chainId, library, account);
    }, [chainId, library, account, partnerDaaS]);
    return React.useMemo(() => {
        if (!trade || !contract || !recipient || !deadline) {
            return [];
        }
        const swapMethods = [];
        swapMethods.push(sdk.Router.swapCallParameters(trade, {
            feeOnTransfer: false,
            allowedSlippage: new sdk.Percent(sdk.JSBI.BigInt(allowedSlippage), BIPS_BASE),
            recipient,
            deadline: deadline.toNumber(),
        }));
        if (trade.tradeType === sdk.TradeType.EXACT_INPUT) {
            swapMethods.push(sdk.Router.swapCallParameters(trade, {
                feeOnTransfer: true,
                allowedSlippage: new sdk.Percent(sdk.JSBI.BigInt(allowedSlippage), BIPS_BASE),
                recipient,
                deadline: deadline.toNumber(),
            }));
        }
        return swapMethods.map((parameters) => ({ parameters, contract }));
    }, [trade, contract, allowedSlippage, recipient, deadline]);
}
// returns a function that will execute a swap, if the parameters are all valid
// and the user has approved the slippage adjusted input amount for the trade
function useSwapCallback(trade, // trade to execute, required
allowedSlippage = INITIAL_ALLOWED_SLIPPAGE, // in bips
recipientAddressOrName) {
    const { account, chainId } = usePangolinWeb3();
    const { library } = useLibrary();
    const swapCalls = useSwapCallArguments(trade, allowedSlippage, recipientAddressOrName);
    const addTransaction = useTransactionAdder();
    const { address: recipientAddress } = useENS(recipientAddressOrName);
    const recipient = recipientAddressOrName === null ? account : recipientAddress;
    return React.useMemo(() => {
        if (!trade || !library || !account || !chainId) {
            return { state: SwapCallbackState.INVALID, callback: null, error: 'Missing dependencies' };
        }
        if (!recipient) {
            if (recipientAddressOrName !== null) {
                return { state: SwapCallbackState.INVALID, callback: null, error: 'Invalid recipient' };
            }
            else {
                return { state: SwapCallbackState.LOADING, callback: null, error: null };
            }
        }
        const tradeVersion = Version.v2;
        return {
            state: SwapCallbackState.VALID,
            callback: function onSwap() {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const estimatedCalls = yield Promise.all(swapCalls.map((call) => {
                        const { parameters: { methodName, args, value }, contract, } = call;
                        const options = !value || isZero(value) ? {} : { value };
                        return contract.estimateGas[methodName](...args, options)
                            .then((gasEstimate) => {
                            return {
                                call,
                                gasEstimate,
                            };
                        })
                            .catch((gasError) => {
                            console.debug('Gas estimate failed, trying eth_call to extract error', call);
                            return contract.callStatic[methodName](...args, options)
                                .then((result) => {
                                console.debug('Unexpected successful call after failed estimate gas', call, gasError, result);
                                return { call, error: new Error('Unexpected issue with estimating the gas. Please try again.') };
                            })
                                .catch((callError) => {
                                console.debug('Call threw error', call, callError);
                                let errorMessage;
                                switch (callError.reason) {
                                    case 'PangolinRouter: INSUFFICIENT_OUTPUT_AMOUNT':
                                    case 'PangolinRouter: EXCESSIVE_INPUT_AMOUNT':
                                        errorMessage =
                                            'This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.';
                                        break;
                                    default:
                                        errorMessage = `The transaction cannot succeed due to error: ${callError.reason}. This is probably an issue with one of the tokens you are swapping.`;
                                }
                                return { call, error: new Error(errorMessage) };
                            });
                        });
                    }));
                    // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate
                    const successfulEstimation = estimatedCalls.find((el, ix, list) => 'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1]));
                    if (!successfulEstimation) {
                        const errorCalls = estimatedCalls.filter((call) => 'error' in call);
                        if (errorCalls.length > 0)
                            throw errorCalls[errorCalls.length - 1].error;
                        throw new Error('Unexpected error. Please contact support: none of the calls threw an error');
                    }
                    const { call: { contract, parameters: { methodName, args, value }, }, gasEstimate, } = successfulEstimation;
                    return contract[methodName](...args, Object.assign({ gasLimit: calculateGasMargin(gasEstimate) }, (value && !isZero(value) ? { value, from: account } : { from: account })))
                        .then((response) => {
                        const inputSymbol = trade.inputAmount.currency.symbol;
                        const outputSymbol = trade.outputAmount.currency.symbol;
                        const inputAmount = trade.inputAmount.toSignificant(3);
                        const outputAmount = trade.outputAmount.toSignificant(3);
                        const base = `Swap ${inputAmount} ${inputSymbol} for ${outputAmount} ${outputSymbol}`;
                        const withRecipient = recipient === account
                            ? base
                            : `${base} to ${recipientAddressOrName && isAddress(recipientAddressOrName)
                                ? shortenAddress(recipientAddressOrName, chainId)
                                : recipientAddressOrName}`;
                        const withVersion = tradeVersion === Version.v2
                            ? withRecipient
                            : `${withRecipient} on ${tradeVersion.toUpperCase()}`;
                        addTransaction(response, {
                            summary: withVersion,
                        });
                        return response.hash;
                    })
                        .catch((error) => {
                        // if the user rejected the tx, pass this along
                        if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {
                            throw new Error('Transaction rejected.');
                        }
                        else {
                            // otherwise, the error was unexpected and we need to convey that
                            console.error(`Swap failed`, error, methodName, args, value);
                            throw new Error(`Swap failed: ${error.message}`);
                        }
                    });
                });
            },
            error: null,
        };
    }, [trade, library, account, chainId, recipient, recipientAddressOrName, swapCalls, addTransaction]);
}
function useNearSwapCallback(trade, // trade to execute, required
// eslint-disable-next-line @typescript-eslint/no-unused-vars
_allowedSlippage = INITIAL_ALLOWED_SLIPPAGE, // in bips
recipientAddressOrName) {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const addTransaction = useTransactionAdder();
    const poolId = useGetNearPoolId((_a = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _a === void 0 ? void 0 : _a.currency, (_b = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _b === void 0 ? void 0 : _b.currency);
    return React.useMemo(() => {
        if (!trade || !library || !account || !chainId) {
            return { state: SwapCallbackState.INVALID, callback: null, error: 'Missing dependencies' };
        }
        return {
            state: SwapCallbackState.VALID,
            callback: function onSwap() {
                var _a, _b;
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const transactions = [];
                    const tokenInActions = [];
                    const inputToken = (_a = trade.inputAmount) === null || _a === void 0 ? void 0 : _a.currency;
                    const outPutToken = (_b = trade.outputAmount) === null || _b === void 0 ? void 0 : _b.currency;
                    const inputCurrencyId = inputToken instanceof sdk.Token ? inputToken === null || inputToken === void 0 ? void 0 : inputToken.address : undefined;
                    const outputCurrencyId = outPutToken instanceof sdk.Token ? outPutToken === null || outPutToken === void 0 ? void 0 : outPutToken.address : undefined;
                    const inputAmount = trade.inputAmount.toExact();
                    if (!inputCurrencyId || !outputCurrencyId) {
                        throw new Error(`Missing Currency`);
                    }
                    const tokenRegistered = yield nearFn.getStorageBalance(outputCurrencyId).catch(() => {
                        throw new Error(`${outPutToken === null || outPutToken === void 0 ? void 0 : outPutToken.symbol} doesn't exist.`);
                    });
                    if (tokenRegistered === null) {
                        transactions.push({
                            receiverId: outputCurrencyId,
                            functionCalls: [
                                nearFn.storageDepositAction({
                                    accountId: account,
                                    registrationOnly: true,
                                    amount: '0.00125',
                                }),
                            ],
                        });
                    }
                    const swapActions = {
                        pool_id: poolId,
                        token_in: inputCurrencyId,
                        token_out: outputCurrencyId,
                        amount_in: units.parseUnits(inputAmount, inputToken === null || inputToken === void 0 ? void 0 : inputToken.decimals).toString(),
                        min_amount_out: '0',
                    };
                    tokenInActions.push({
                        methodName: 'ft_transfer_call',
                        args: {
                            receiver_id: NEAR_EXCHANGE_CONTRACT_ADDRESS[chainId],
                            amount: units.parseUnits(inputAmount, inputToken === null || inputToken === void 0 ? void 0 : inputToken.decimals).toString(),
                            msg: JSON.stringify({
                                force: 0,
                                actions: [swapActions],
                            }),
                        },
                        amount: ONE_YOCTO_NEAR,
                    });
                    transactions.push({
                        receiverId: inputCurrencyId,
                        functionCalls: tokenInActions,
                    });
                    return nearFn.executeMultipleTransactions(transactions);
                });
            },
            error: null,
        };
    }, [trade, poolId, library, account, chainId, recipientAddressOrName, addTransaction]);
}

/**
 * Returns the tokens price in relation to gas coin (avax, wagmi, flare, etc)
 *
 * @param tokens array of tokens to get the price in wrapped gas coin
 * @returns object where the key is the address of the token and the value is the Price
 */
function useTokensCurrencyPrice(tokens) {
    const chainId = useChainId();
    const currency = sdk.WAVAX[chainId];
    // remove currency if exist e remove undefined
    const filteredTokens = tokens.filter((token) => !!token && !token.equals(currency));
    const _pairs = filteredTokens.map((token) => [token, currency]);
    const pairs = usePairs(_pairs);
    const prices = {};
    // if exist currency, add to object with price 1
    const existCurrency = Boolean(tokens.find((token) => !!token && token.equals(currency)));
    if (existCurrency) {
        prices[currency.address] = new sdk.Price(currency, currency, '1', '1');
    }
    return React.useMemo(() => {
        pairs.forEach(([pairState, pair], index) => {
            const token = filteredTokens[index];
            // if not exist pair, return 0 for price of this token
            if (pairState !== PairState.EXISTS || !pair) {
                prices[token.address] = new sdk.Price(token, currency, '1', '0'); // 0
            }
            else {
                const tokenCurrencyPrice = pair.priceOf(token, currency);
                prices[token.address] = tokenCurrencyPrice;
            }
        });
        return prices;
    }, [pairs, prices, filteredTokens]);
}
/**
 * Returns the token price in relation to gas coin (avax, wagmi, flare, etc)
 *
 * @param token token to get the price
 * @returns the price of token in relation to gas coin
 */
function useTokenCurrencyPrice(token) {
    const chainId = useChainId();
    const currency = sdk.WAVAX[chainId];
    const [pairState, pair] = usePair(token, currency);
    return React.useMemo(() => {
        if (!token)
            return new sdk.Price(currency, currency, '1', '0');
        if (token.equals(currency)) {
            return new sdk.Price(currency, currency, '1', '1');
        }
        if (pairState !== PairState.EXISTS || !pair) {
            return new sdk.Price(token, currency, '1', '0'); // 0
        }
        else {
            return pair.priceOf(token, currency);
        }
    }, [pairState, pair, token]);
}
/**
 * Returns the price of pairs in relation to gas coin
 *
 * @param pairs array of pair and total supply of pair
 * @returns object where the key is the address of the pair and the value is the Price
 */
function usePairsCurrencyPrice(pairs) {
    const chainId = useChainId();
    const currency = sdk.WAVAX[chainId];
    // Have the same size
    const tokens0 = pairs.map(({ pair }) => pair.token0);
    const tokens1 = pairs.map(({ pair }) => pair.token1);
    const uniqueTokens = [];
    const map = new Map();
    for (let index = 0; index < tokens0.length; index++) {
        const token0 = tokens0[index];
        const token1 = tokens1[index];
        if (!map.has(token0.address)) {
            map.set(token0.address, true);
            uniqueTokens.push(token0);
        }
        if (!map.has(token1.address)) {
            map.set(token1.address, true);
            uniqueTokens.push(token1);
        }
    }
    const tokensPrices = useTokensCurrencyPrice(uniqueTokens);
    return React.useMemo(() => {
        const pairsPrices = {};
        pairs.forEach(({ pair, totalSupply }) => {
            var _a, _b;
            const token0 = pair.token0;
            const token1 = pair.token1;
            const token0Price = (_a = tokensPrices[token0.address]) !== null && _a !== void 0 ? _a : new sdk.Price(token0, currency, '1', '0');
            const token1Price = (_b = tokensPrices[token1.address]) !== null && _b !== void 0 ? _b : new sdk.Price(token1, currency, '1', '0');
            let token0Amount = new sdk.TokenAmount(token0, '0');
            let token1Amount = new sdk.TokenAmount(token1, '0');
            if (sdk.JSBI.greaterThan(totalSupply.raw, ONE_TOKEN) || sdk.JSBI.equal(totalSupply.raw, ONE_TOKEN)) {
                [token0Amount, token1Amount] = pair.getLiquidityValues(totalSupply, new sdk.TokenAmount(pair.liquidityToken, ONE_TOKEN));
            }
            const token0PairPrice = token0Amount.multiply(token0Price);
            const token1PairPrice = token1Amount.multiply(token1Price);
            const _pairPrice = token0PairPrice.add(token1PairPrice);
            const pairPrice = new sdk.Price(pair.liquidityToken, currency, _pairPrice.denominator, _pairPrice.numerator);
            pairsPrices[pair.liquidityToken.address] = pairPrice;
        });
        return pairsPrices;
    }, [pairs, tokensPrices]);
}

/**
 * Returns the price in USDC of the input currency
 * @param currency currency to compute the USDC price of
 */
function useUSDCPrice(currency) {
    const chainId = useChainId();
    const wrapped = wrappedCurrency(currency, chainId);
    const USDC = USDCe[chainId];
    const tokenPairs = React.useMemo(() => [
        [
            chainId && wrapped && sdk.currencyEquals(sdk.WAVAX[chainId], wrapped) ? undefined : currency,
            chainId ? sdk.WAVAX[chainId] : undefined,
        ],
        [(wrapped === null || wrapped === void 0 ? void 0 : wrapped.equals(USDC)) ? undefined : wrapped, chainId === sdk.ChainId.AVALANCHE ? USDC : undefined],
        [chainId ? sdk.WAVAX[chainId] : undefined, chainId === sdk.ChainId.AVALANCHE ? USDC : undefined],
    ], [chainId, currency, wrapped, USDC]);
    const [[avaxPairState, avaxPair], [usdcPairState, usdcPair], [usdcAvaxPairState, usdcAvaxPair]] = usePairs(tokenPairs);
    return React.useMemo(() => {
        if (!currency || !wrapped || !chainId) {
            return undefined;
        }
        // handle wavax/avax
        if (wrapped.equals(sdk.WAVAX[chainId])) {
            if (usdcPair) {
                const price = usdcPair.priceOf(sdk.WAVAX[chainId], USDC);
                return new sdk.Price(currency, USDC, price.denominator, price.numerator);
            }
            else {
                return undefined;
            }
        }
        // handle usdc
        if (wrapped.equals(USDC)) {
            return new sdk.Price(USDC, USDC, '1', '1');
        }
        const avaxPairAVAXAmount = avaxPair === null || avaxPair === void 0 ? void 0 : avaxPair.reserveOfToken(sdk.WAVAX[chainId]);
        const avaxPairAVAXUSDCValue = avaxPairAVAXAmount && usdcAvaxPair
            ? usdcAvaxPair.priceOf(sdk.WAVAX[chainId], USDC).quote(avaxPairAVAXAmount, chainId).raw
            : sdk.JSBI.BigInt(0);
        // all other tokens
        // first try the usdc pair
        if (usdcPairState === PairState.EXISTS &&
            usdcPair &&
            usdcPair.reserveOfToken(USDC).greaterThan(avaxPairAVAXUSDCValue)) {
            const price = usdcPair.priceOf(wrapped, USDC);
            return new sdk.Price(currency, USDC, price.denominator, price.numerator);
        }
        if (avaxPairState === PairState.EXISTS && avaxPair && usdcAvaxPairState === PairState.EXISTS && usdcAvaxPair) {
            if (usdcAvaxPair.reserveOfToken(USDC).greaterThan('0') &&
                avaxPair.reserveOfToken(sdk.WAVAX[chainId]).greaterThan('0')) {
                const avaxUsdcPrice = usdcAvaxPair.priceOf(USDC, sdk.WAVAX[chainId]);
                const currencyAvaxPrice = avaxPair.priceOf(sdk.WAVAX[chainId], wrapped);
                const usdcPrice = avaxUsdcPrice.multiply(currencyAvaxPrice).invert();
                return new sdk.Price(currency, USDC, usdcPrice.denominator, usdcPrice.numerator);
            }
        }
        return undefined;
    }, [
        chainId,
        currency,
        avaxPair,
        avaxPairState,
        usdcAvaxPair,
        usdcAvaxPairState,
        usdcPair,
        usdcPairState,
        wrapped,
        USDC,
    ]);
}
function useNearUSDCPrice(currency) {
    const [result, setResult] = React.useState('');
    const chainId = useChainId();
    const token = wrappedCurrency(currency, chainId);
    React.useEffect(() => {
        const fetchPrice = () => tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const url = `${NEAR_API_BASE_URL}/list-token-price`;
                const response = yield fetch(url);
                const data = yield response.json();
                if (token) {
                    setResult((_a = data === null || data === void 0 ? void 0 : data[token === null || token === void 0 ? void 0 : token.address]) === null || _a === void 0 ? void 0 : _a.price);
                }
            }
            catch (error) {
                console.error('near token api error', error);
            }
        });
        fetchPrice();
    }, [token]);
    const USDC = USDCe[chainId];
    return React.useMemo(() => {
        if (!currency || !token || !chainId || !result) {
            return undefined;
        }
        const tokenAmount1 = new sdk.TokenAmount(token, units.parseUnits(result || '1', token === null || token === void 0 ? void 0 : token.decimals).toString());
        const tokenAmount2 = new sdk.TokenAmount(USDC, units.parseUnits('1', USDC === null || USDC === void 0 ? void 0 : USDC.decimals).toString());
        return new sdk.Price(USDC, currency, tokenAmount2.raw, tokenAmount1.raw);
    }, [chainId, currency, token, USDC, result]);
}
function useSongBirdUSDPrice(currency) {
    const chainId = sdk.ChainId.SONGBIRD;
    const wrapped = wrappedCurrency(currency, chainId);
    const tokenPrice = useTokenCurrencyPrice(wrapped); // token price in sgb
    const usd = USDC[chainId];
    const { data: currencyPrice, isLoading } = useCoinGeckoCurrencyPrice(chainId); // sbg price in usd
    return React.useMemo(() => {
        if (!wrapped || !currencyPrice || !tokenPrice || isLoading || !currency)
            return undefined;
        const tokenUSDPrice = tokenPrice.raw.multiply(decimalToFraction(currencyPrice));
        return new sdk.Price(currency, usd, tokenUSDPrice.denominator, tokenUSDPrice.numerator);
    }, [wrapped, currencyPrice, tokenPrice]);
}

var WrapType;
(function (WrapType) {
    WrapType[WrapType["NOT_APPLICABLE"] = 0] = "NOT_APPLICABLE";
    WrapType[WrapType["WRAP"] = 1] = "WRAP";
    WrapType[WrapType["UNWRAP"] = 2] = "UNWRAP";
})(WrapType || (WrapType = {}));
const NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE };
/**
 * Given the selected input and output currency, return a wrap callback
 * @param inputCurrency the selected input currency
 * @param outputCurrency the selected output currency
 * @param typedValue the user input value
 */
function useWrapCallback(inputCurrency, outputCurrency, typedValue) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const wethContract = useWETHContract();
    const balance = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, inputCurrency);
    // we can always parse the amount typed as the input currency, since wrapping is 1:1
    const inputAmount = React.useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue]);
    const addTransaction = useTransactionAdder();
    return React.useMemo(() => {
        if (!wethContract || !chainId || !inputCurrency || !outputCurrency)
            return NOT_APPLICABLE;
        const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);
        if (inputCurrency === sdk.CAVAX[chainId] && sdk.currencyEquals(sdk.WAVAX[chainId], outputCurrency)) {
            return {
                wrapType: WrapType.WRAP,
                execute: sufficientBalance && inputAmount
                    ? () => tslib.__awaiter(this, void 0, void 0, function* () {
                        try {
                            const txReceipt = yield wethContract.deposit({ value: `0x${inputAmount.raw.toString(16)}` });
                            addTransaction(txReceipt, { summary: `Wrap ${inputAmount.toSignificant(6)} AVAX to WAVAX` });
                        }
                        catch (error) {
                            console.error('Could not deposit', error);
                        }
                    })
                    : undefined,
                inputError: sufficientBalance ? undefined : 'Insufficient AVAX balance',
            };
        }
        else if (sdk.currencyEquals(sdk.WAVAX[chainId], inputCurrency) && outputCurrency === sdk.CAVAX[chainId]) {
            return {
                wrapType: WrapType.UNWRAP,
                execute: sufficientBalance && inputAmount
                    ? () => tslib.__awaiter(this, void 0, void 0, function* () {
                        try {
                            const txReceipt = yield wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`);
                            addTransaction(txReceipt, { summary: `Unwrap ${inputAmount.toSignificant(6)} WAVAX to AVAX` });
                        }
                        catch (error) {
                            console.error('Could not withdraw', error);
                        }
                    })
                    : undefined,
                inputError: sufficientBalance ? undefined : 'Insufficient WAVAX balance',
            };
        }
        else {
            return NOT_APPLICABLE;
        }
    }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);
}
/**
 * Given the selected input and output currency, return a wrap callback
 * @param inputCurrency the selected input currency
 * @param outputCurrency the selected output currency
 * @param typedValue the user input value
 */
function useWrapNearCallback(inputCurrency, outputCurrency, typedValue) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const balance = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, inputCurrency);
    // we can always parse the amount typed as the input currency, since wrapping is 1:1
    const inputAmount = React.useMemo(() => tryParseAmount(typedValue, inputCurrency, chainId), [inputCurrency, typedValue, chainId]);
    const addTransaction = useTransactionAdder();
    return React.useMemo(() => {
        if (!chainId || !inputCurrency || !outputCurrency)
            return NOT_APPLICABLE;
        const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);
        const unWrapFunction = () => tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (sufficientBalance && inputAmount) {
                try {
                    //addTransaction({} as any, { summary: `Unwrap ${inputAmount.toSignificant(6)} WNear to Near` });
                    const transactions = [
                        {
                            receiverId: sdk.WAVAX[chainId].address,
                            functionCalls: [
                                nearFn.nearDepositAction(utils.parseUnits(inputAmount.toFixed(), (_a = sdk.WAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.decimals).toString()),
                            ],
                        },
                    ];
                    nearFn.executeMultipleTransactions(transactions);
                }
                catch (error) {
                    console.error('Could not withdraw', error);
                }
            }
        });
        const wrapFunction = () => tslib.__awaiter(this, void 0, void 0, function* () {
            if (sufficientBalance && inputAmount) {
                try {
                    //addTransaction({} as any, { summary: `Wrap ${inputAmount.toSignificant(6)} NEAR to wNear` });
                    const transaction = [
                        {
                            receiverId: sdk.WAVAX[chainId].address,
                            functionCalls: [nearFn.nearWithdrawAction(inputAmount.toSignificant(6))],
                        },
                    ];
                    nearFn.executeMultipleTransactions(transaction);
                }
                catch (error) {
                    console.error('Could not withdraw', error);
                }
            }
        });
        if (inputCurrency === sdk.CAVAX[chainId] && sdk.currencyEquals(sdk.WAVAX[chainId], outputCurrency)) {
            return {
                wrapType: WrapType.WRAP,
                execute: wrapFunction,
                inputError: sufficientBalance ? undefined : 'Insufficient NEAR balance',
            };
        }
        else if (sdk.currencyEquals(sdk.WAVAX[chainId], inputCurrency) && outputCurrency === sdk.CAVAX[chainId]) {
            return {
                wrapType: WrapType.UNWRAP,
                execute: unWrapFunction,
                inputError: sufficientBalance ? undefined : 'Insufficient wNear balance',
            };
        }
        else {
            return NOT_APPLICABLE;
        }
    }, [chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);
}

const useWrapCallbackHook = {
    [sdk.ChainId.FUJI]: useWrapCallback,
    [sdk.ChainId.AVALANCHE]: useWrapCallback,
    [sdk.ChainId.WAGMI]: useWrapCallback,
    [sdk.ChainId.COSTON]: useWrapCallback,
    [sdk.ChainId.SONGBIRD]: useWrapCallback,
    [sdk.ChainId.NEAR_MAINNET]: useWrapNearCallback,
    [sdk.ChainId.NEAR_TESTNET]: useWrapNearCallback,
};
const useTokenHook = {
    [sdk.ChainId.FUJI]: useToken,
    [sdk.ChainId.AVALANCHE]: useToken,
    [sdk.ChainId.WAGMI]: useToken,
    [sdk.ChainId.COSTON]: useToken,
    [sdk.ChainId.SONGBIRD]: useToken,
    [sdk.ChainId.NEAR_MAINNET]: useNearToken,
    [sdk.ChainId.NEAR_TESTNET]: useNearToken,
};
const useApproveCallbackFromTradeHook = {
    [sdk.ChainId.FUJI]: useApproveCallbackFromTrade,
    [sdk.ChainId.AVALANCHE]: useApproveCallbackFromTrade,
    [sdk.ChainId.WAGMI]: useApproveCallbackFromTrade,
    [sdk.ChainId.COSTON]: useApproveCallbackFromTrade,
    [sdk.ChainId.SONGBIRD]: useApproveCallbackFromTrade,
    [sdk.ChainId.NEAR_MAINNET]: useApproveCallbackFromNearTrade,
    [sdk.ChainId.NEAR_TESTNET]: useApproveCallbackFromNearTrade,
};
const useSwapCallbackHook = {
    [sdk.ChainId.FUJI]: useSwapCallback,
    [sdk.ChainId.AVALANCHE]: useSwapCallback,
    [sdk.ChainId.WAGMI]: useSwapCallback,
    [sdk.ChainId.COSTON]: useSwapCallback,
    [sdk.ChainId.SONGBIRD]: useSwapCallback,
    [sdk.ChainId.NEAR_MAINNET]: useNearSwapCallback,
    [sdk.ChainId.NEAR_TESTNET]: useNearSwapCallback,
};
const useApproveCallbackHook = {
    [sdk.ChainId.FUJI]: useApproveCallback,
    [sdk.ChainId.AVALANCHE]: useApproveCallback,
    [sdk.ChainId.WAGMI]: useApproveCallback,
    [sdk.ChainId.COSTON]: useApproveCallback,
    [sdk.ChainId.SONGBIRD]: useApproveCallback,
    [sdk.ChainId.NEAR_MAINNET]: useNearApproveCallback,
    [sdk.ChainId.NEAR_TESTNET]: useNearApproveCallback,
};
const useUSDCPriceHook = {
    [sdk.ChainId.FUJI]: useUSDCPrice,
    [sdk.ChainId.AVALANCHE]: useUSDCPrice,
    [sdk.ChainId.WAGMI]: useUSDCPrice,
    [sdk.ChainId.COSTON]: useUSDCPrice,
    [sdk.ChainId.SONGBIRD]: useSongBirdUSDPrice,
    [sdk.ChainId.NEAR_MAINNET]: useNearUSDCPrice,
    [sdk.ChainId.NEAR_TESTNET]: useNearUSDCPrice,
};
({
    [sdk.ChainId.FUJI]: useTokens,
    [sdk.ChainId.AVALANCHE]: useTokens,
    [sdk.ChainId.WAGMI]: useTokens,
    [sdk.ChainId.COSTON]: useTokens,
    [sdk.ChainId.SONGBIRD]: useTokens,
    [sdk.ChainId.NEAR_MAINNET]: useNearTokens,
    [sdk.ChainId.NEAR_TESTNET]: useNearTokens,
});

/**
 * Given some token amount, return the max that can be spent of it
 * @param currencyAmount to return max of
 */
function maxAmountSpend(chainId, currencyAmount) {
    if (!currencyAmount)
        return undefined;
    if (chainId && currencyAmount.currency === sdk.CAVAX[chainId]) {
        if (sdk.JSBI.greaterThan(currencyAmount.raw, MIN_ETH)) {
            return sdk.CurrencyAmount.ether(sdk.JSBI.subtract(currencyAmount.raw, MIN_ETH), chainId);
        }
        else {
            return sdk.CurrencyAmount.ether(sdk.JSBI.BigInt(0), chainId);
        }
    }
    return currencyAmount;
}
function galetoMaxAmountSpend(chainId, currencyAmount) {
    if (!currencyAmount)
        return undefined;
    if (chainId && currencyAmount.currency === sdk.CAVAX[chainId]) {
        if (sdk.JSBI.greaterThan(currencyAmount.numerator, MIN_ETH)) {
            return sdk.CurrencyAmount.ether(sdk.JSBI.subtract(currencyAmount.numerator, MIN_ETH), chainId);
        }
        else {
            return sdk.CurrencyAmount.ether(sdk.JSBI.BigInt(0), chainId);
        }
    }
    return currencyAmount;
}

class JSBI extends Array{constructor(i,_){if(super(i),this.sign=_,i>JSBI.__kMaxLength)throw new RangeError("Maximum BigInt size exceeded")}static BigInt(i){var _=Math.floor,t=Number.isFinite;if("number"==typeof i){if(0===i)return JSBI.__zero();if(JSBI.__isOneDigitInt(i))return 0>i?JSBI.__oneDigit(-i,!0):JSBI.__oneDigit(i,!1);if(!t(i)||_(i)!==i)throw new RangeError("The number "+i+" cannot be converted to BigInt because it is not an integer");return JSBI.__fromDouble(i)}if("string"==typeof i){const _=JSBI.__fromString(i);if(null===_)throw new SyntaxError("Cannot convert "+i+" to a BigInt");return _}if("boolean"==typeof i)return !0===i?JSBI.__oneDigit(1,!1):JSBI.__zero();if("object"==typeof i){if(i.constructor===JSBI)return i;const _=JSBI.__toPrimitive(i);return JSBI.BigInt(_)}throw new TypeError("Cannot convert "+i+" to a BigInt")}toDebugString(){const i=["BigInt["];for(const _ of this)i.push((_?(_>>>0).toString(16):_)+", ");return i.push("]"),i.join("")}toString(i=10){if(2>i||36<i)throw new RangeError("toString() radix argument must be between 2 and 36");return 0===this.length?"0":0==(i&i-1)?JSBI.__toStringBasePowerOfTwo(this,i):JSBI.__toStringGeneric(this,i,!1)}static toNumber(i){const _=i.length;if(0===_)return 0;if(1===_){const _=i.__unsignedDigit(0);return i.sign?-_:_}const t=i.__digit(_-1),e=JSBI.__clz30(t),n=30*_-e;if(1024<n)return i.sign?-Infinity:1/0;let g=n-1,o=t,s=_-1;const l=e+3;let r=32===l?0:o<<l;r>>>=12;const a=l-12;let u=12<=l?0:o<<20+l,d=20+l;for(0<a&&0<s&&(s--,o=i.__digit(s),r|=o>>>30-a,u=o<<a+2,d=a+2);0<d&&0<s;)s--,o=i.__digit(s),u|=30<=d?o<<d-30:o>>>30-d,d-=30;const h=JSBI.__decideRounding(i,d,s,o);if((1===h||0===h&&1==(1&u))&&(u=u+1>>>0,0===u&&(r++,0!=r>>>20&&(r=0,g++,1023<g))))return i.sign?-Infinity:1/0;const m=i.sign?-2147483648:0;return g=g+1023<<20,JSBI.__kBitConversionInts[1]=m|g|r,JSBI.__kBitConversionInts[0]=u,JSBI.__kBitConversionDouble[0]}static unaryMinus(i){if(0===i.length)return i;const _=i.__copy();return _.sign=!i.sign,_}static bitwiseNot(i){return i.sign?JSBI.__absoluteSubOne(i).__trim():JSBI.__absoluteAddOne(i,!0)}static exponentiate(i,_){if(_.sign)throw new RangeError("Exponent must be positive");if(0===_.length)return JSBI.__oneDigit(1,!1);if(0===i.length)return i;if(1===i.length&&1===i.__digit(0))return i.sign&&0==(1&_.__digit(0))?JSBI.unaryMinus(i):i;if(1<_.length)throw new RangeError("BigInt too big");let t=_.__unsignedDigit(0);if(1===t)return i;if(t>=JSBI.__kMaxLengthBits)throw new RangeError("BigInt too big");if(1===i.length&&2===i.__digit(0)){const _=1+(0|t/30),e=i.sign&&0!=(1&t),n=new JSBI(_,e);n.__initializeDigits();const g=1<<t%30;return n.__setDigit(_-1,g),n}let e=null,n=i;for(0!=(1&t)&&(e=i),t>>=1;0!==t;t>>=1)n=JSBI.multiply(n,n),0!=(1&t)&&(null===e?e=n:e=JSBI.multiply(e,n));return e}static multiply(_,t){if(0===_.length)return _;if(0===t.length)return t;let i=_.length+t.length;30<=_.__clzmsd()+t.__clzmsd()&&i--;const e=new JSBI(i,_.sign!==t.sign);e.__initializeDigits();for(let n=0;n<_.length;n++)JSBI.__multiplyAccumulate(t,_.__digit(n),e,n);return e.__trim()}static divide(i,_){if(0===_.length)throw new RangeError("Division by zero");if(0>JSBI.__absoluteCompare(i,_))return JSBI.__zero();const t=i.sign!==_.sign,e=_.__unsignedDigit(0);let n;if(1===_.length&&32767>=e){if(1===e)return t===i.sign?i:JSBI.unaryMinus(i);n=JSBI.__absoluteDivSmall(i,e,null);}else n=JSBI.__absoluteDivLarge(i,_,!0,!1);return n.sign=t,n.__trim()}static remainder(i,_){if(0===_.length)throw new RangeError("Division by zero");if(0>JSBI.__absoluteCompare(i,_))return i;const t=_.__unsignedDigit(0);if(1===_.length&&32767>=t){if(1===t)return JSBI.__zero();const _=JSBI.__absoluteModSmall(i,t);return 0===_?JSBI.__zero():JSBI.__oneDigit(_,i.sign)}const e=JSBI.__absoluteDivLarge(i,_,!1,!0);return e.sign=i.sign,e.__trim()}static add(i,_){const t=i.sign;return t===_.sign?JSBI.__absoluteAdd(i,_,t):0<=JSBI.__absoluteCompare(i,_)?JSBI.__absoluteSub(i,_,t):JSBI.__absoluteSub(_,i,!t)}static subtract(i,_){const t=i.sign;return t===_.sign?0<=JSBI.__absoluteCompare(i,_)?JSBI.__absoluteSub(i,_,t):JSBI.__absoluteSub(_,i,!t):JSBI.__absoluteAdd(i,_,t)}static leftShift(i,_){return 0===_.length||0===i.length?i:_.sign?JSBI.__rightShiftByAbsolute(i,_):JSBI.__leftShiftByAbsolute(i,_)}static signedRightShift(i,_){return 0===_.length||0===i.length?i:_.sign?JSBI.__leftShiftByAbsolute(i,_):JSBI.__rightShiftByAbsolute(i,_)}static unsignedRightShift(){throw new TypeError("BigInts have no unsigned right shift; use >> instead")}static lessThan(i,_){return 0>JSBI.__compareToBigInt(i,_)}static lessThanOrEqual(i,_){return 0>=JSBI.__compareToBigInt(i,_)}static greaterThan(i,_){return 0<JSBI.__compareToBigInt(i,_)}static greaterThanOrEqual(i,_){return 0<=JSBI.__compareToBigInt(i,_)}static equal(_,t){if(_.sign!==t.sign)return !1;if(_.length!==t.length)return !1;for(let e=0;e<_.length;e++)if(_.__digit(e)!==t.__digit(e))return !1;return !0}static notEqual(i,_){return !JSBI.equal(i,_)}static bitwiseAnd(i,_){var t=Math.max;if(!i.sign&&!_.sign)return JSBI.__absoluteAnd(i,_).__trim();if(i.sign&&_.sign){const e=t(i.length,_.length)+1;let n=JSBI.__absoluteSubOne(i,e);const g=JSBI.__absoluteSubOne(_);return n=JSBI.__absoluteOr(n,g,n),JSBI.__absoluteAddOne(n,!0,n).__trim()}return i.sign&&([i,_]=[_,i]),JSBI.__absoluteAndNot(i,JSBI.__absoluteSubOne(_)).__trim()}static bitwiseXor(i,_){var t=Math.max;if(!i.sign&&!_.sign)return JSBI.__absoluteXor(i,_).__trim();if(i.sign&&_.sign){const e=t(i.length,_.length),n=JSBI.__absoluteSubOne(i,e),g=JSBI.__absoluteSubOne(_);return JSBI.__absoluteXor(n,g,n).__trim()}const e=t(i.length,_.length)+1;i.sign&&([i,_]=[_,i]);let n=JSBI.__absoluteSubOne(_,e);return n=JSBI.__absoluteXor(n,i,n),JSBI.__absoluteAddOne(n,!0,n).__trim()}static bitwiseOr(i,_){var t=Math.max;const e=t(i.length,_.length);if(!i.sign&&!_.sign)return JSBI.__absoluteOr(i,_).__trim();if(i.sign&&_.sign){let t=JSBI.__absoluteSubOne(i,e);const n=JSBI.__absoluteSubOne(_);return t=JSBI.__absoluteAnd(t,n,t),JSBI.__absoluteAddOne(t,!0,t).__trim()}i.sign&&([i,_]=[_,i]);let n=JSBI.__absoluteSubOne(_,e);return n=JSBI.__absoluteAndNot(n,i,n),JSBI.__absoluteAddOne(n,!0,n).__trim()}static asIntN(_,t){var i=Math.floor;if(0===t.length)return t;if(_=i(_),0>_)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===_)return JSBI.__zero();if(_>=JSBI.__kMaxLengthBits)return t;const e=0|(_+29)/30;if(t.length<e)return t;const g=t.__unsignedDigit(e-1),o=1<<(_-1)%30;if(t.length===e&&g<o)return t;if(!((g&o)===o))return JSBI.__truncateToNBits(_,t);if(!t.sign)return JSBI.__truncateAndSubFromPowerOfTwo(_,t,!0);if(0==(g&o-1)){for(let n=e-2;0<=n;n--)if(0!==t.__digit(n))return JSBI.__truncateAndSubFromPowerOfTwo(_,t,!1);return t.length===e&&g===o?t:JSBI.__truncateToNBits(_,t)}return JSBI.__truncateAndSubFromPowerOfTwo(_,t,!1)}static asUintN(i,_){var t=Math.floor;if(0===_.length)return _;if(i=t(i),0>i)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===i)return JSBI.__zero();if(_.sign){if(i>JSBI.__kMaxLengthBits)throw new RangeError("BigInt too big");return JSBI.__truncateAndSubFromPowerOfTwo(i,_,!1)}if(i>=JSBI.__kMaxLengthBits)return _;const e=0|(i+29)/30;if(_.length<e)return _;const g=i%30;if(_.length==e){if(0===g)return _;const i=_.__digit(e-1);if(0==i>>>g)return _}return JSBI.__truncateToNBits(i,_)}static ADD(i,_){if(i=JSBI.__toPrimitive(i),_=JSBI.__toPrimitive(_),"string"==typeof i)return "string"!=typeof _&&(_=_.toString()),i+_;if("string"==typeof _)return i.toString()+_;if(i=JSBI.__toNumeric(i),_=JSBI.__toNumeric(_),JSBI.__isBigInt(i)&&JSBI.__isBigInt(_))return JSBI.add(i,_);if("number"==typeof i&&"number"==typeof _)return i+_;throw new TypeError("Cannot mix BigInt and other types, use explicit conversions")}static LT(i,_){return JSBI.__compare(i,_,0)}static LE(i,_){return JSBI.__compare(i,_,1)}static GT(i,_){return JSBI.__compare(i,_,2)}static GE(i,_){return JSBI.__compare(i,_,3)}static EQ(i,_){for(;;){if(JSBI.__isBigInt(i))return JSBI.__isBigInt(_)?JSBI.equal(i,_):JSBI.EQ(_,i);if("number"==typeof i){if(JSBI.__isBigInt(_))return JSBI.__equalToNumber(_,i);if("object"!=typeof _)return i==_;_=JSBI.__toPrimitive(_);}else if("string"==typeof i){if(JSBI.__isBigInt(_))return i=JSBI.__fromString(i),null!==i&&JSBI.equal(i,_);if("object"!=typeof _)return i==_;_=JSBI.__toPrimitive(_);}else if("boolean"==typeof i){if(JSBI.__isBigInt(_))return JSBI.__equalToNumber(_,+i);if("object"!=typeof _)return i==_;_=JSBI.__toPrimitive(_);}else if("symbol"==typeof i){if(JSBI.__isBigInt(_))return !1;if("object"!=typeof _)return i==_;_=JSBI.__toPrimitive(_);}else if("object"==typeof i){if("object"==typeof _&&_.constructor!==JSBI)return i==_;i=JSBI.__toPrimitive(i);}else return i==_}}static NE(i,_){return !JSBI.EQ(i,_)}static __zero(){return new JSBI(0,!1)}static __oneDigit(i,_){const t=new JSBI(1,_);return t.__setDigit(0,i),t}__copy(){const _=new JSBI(this.length,this.sign);for(let t=0;t<this.length;t++)_[t]=this[t];return _}__trim(){let i=this.length,_=this[i-1];for(;0===_;)i--,_=this[i-1],this.pop();return 0===i&&(this.sign=!1),this}__initializeDigits(){for(let _=0;_<this.length;_++)this[_]=0;}static __decideRounding(i,_,t,e){if(0<_)return -1;let n;if(0>_)n=-_-1;else {if(0===t)return -1;t--,e=i.__digit(t),n=29;}let g=1<<n;if(0==(e&g))return -1;if(g-=1,0!=(e&g))return 1;for(;0<t;)if(t--,0!==i.__digit(t))return 1;return 0}static __fromDouble(i){JSBI.__kBitConversionDouble[0]=i;const _=2047&JSBI.__kBitConversionInts[1]>>>20,t=_-1023,e=(0|t/30)+1,n=new JSBI(e,0>i);let g=1048575&JSBI.__kBitConversionInts[1]|1048576,o=JSBI.__kBitConversionInts[0];const s=20,l=t%30;let r,a=0;if(l<20){const i=s-l;a=i+32,r=g>>>i,g=g<<32-i|o>>>i,o<<=32-i;}else if(l===20)a=32,r=g,g=o,o=0;else {const i=l-s;a=32-i,r=g<<i|o>>>32-i,g=o<<i,o=0;}n.__setDigit(e-1,r);for(let _=e-2;0<=_;_--)0<a?(a-=30,r=g>>>2,g=g<<30|o>>>2,o<<=30):r=0,n.__setDigit(_,r);return n.__trim()}static __isWhitespace(i){return !!(13>=i&&9<=i)||(159>=i?32==i:131071>=i?160==i||5760==i:196607>=i?(i&=131071,10>=i||40==i||41==i||47==i||95==i||4096==i):65279==i)}static __fromString(i,_=0){let t=0;const e=i.length;let n=0;if(n===e)return JSBI.__zero();let g=i.charCodeAt(n);for(;JSBI.__isWhitespace(g);){if(++n===e)return JSBI.__zero();g=i.charCodeAt(n);}if(43===g){if(++n===e)return null;g=i.charCodeAt(n),t=1;}else if(45===g){if(++n===e)return null;g=i.charCodeAt(n),t=-1;}if(0===_){if(_=10,48===g){if(++n===e)return JSBI.__zero();if(g=i.charCodeAt(n),88===g||120===g){if(_=16,++n===e)return null;g=i.charCodeAt(n);}else if(79===g||111===g){if(_=8,++n===e)return null;g=i.charCodeAt(n);}else if(66===g||98===g){if(_=2,++n===e)return null;g=i.charCodeAt(n);}}}else if(16===_&&48===g){if(++n===e)return JSBI.__zero();if(g=i.charCodeAt(n),88===g||120===g){if(++n===e)return null;g=i.charCodeAt(n);}}if(0!=t&&10!==_)return null;for(;48===g;){if(++n===e)return JSBI.__zero();g=i.charCodeAt(n);}const o=e-n;let s=JSBI.__kMaxBitsPerChar[_],l=JSBI.__kBitsPerCharTableMultiplier-1;if(o>1073741824/s)return null;const r=s*o+l>>>JSBI.__kBitsPerCharTableShift,a=new JSBI(0|(r+29)/30,!1),u=10>_?_:10,h=10<_?_-10:0;if(0==(_&_-1)){s>>=JSBI.__kBitsPerCharTableShift;const _=[],t=[];let o=!1;do{let l=0,r=0;for(;;){let _;if(g-48>>>0<u)_=g-48;else if((32|g)-97>>>0<h)_=(32|g)-87;else {o=!0;break}if(r+=s,l=l<<s|_,++n===e){o=!0;break}if(g=i.charCodeAt(n),30<r+s)break}_.push(l),t.push(r);}while(!o);JSBI.__fillFromParts(a,_,t);}else {a.__initializeDigits();let t=!1,o=0;do{let r=0,b=1;for(;;){let s;if(g-48>>>0<u)s=g-48;else if((32|g)-97>>>0<h)s=(32|g)-87;else {t=!0;break}const l=b*_;if(1073741823<l)break;if(b=l,r=r*_+s,o++,++n===e){t=!0;break}g=i.charCodeAt(n);}l=30*JSBI.__kBitsPerCharTableMultiplier-1;const D=0|(s*o+l>>>JSBI.__kBitsPerCharTableShift)/30;a.__inplaceMultiplyAdd(b,r,D);}while(!t)}if(n!==e){if(!JSBI.__isWhitespace(g))return null;for(n++;n<e;n++)if(g=i.charCodeAt(n),!JSBI.__isWhitespace(g))return null}return a.sign=-1==t,a.__trim()}static __fillFromParts(_,t,e){let n=0,g=0,o=0;for(let s=t.length-1;0<=s;s--){const i=t[s],l=e[s];g|=i<<o,o+=l,30===o?(_.__setDigit(n++,g),o=0,g=0):30<o&&(_.__setDigit(n++,1073741823&g),o-=30,g=i>>>l-o);}if(0!==g){if(n>=_.length)throw new Error("implementation bug");_.__setDigit(n++,g);}for(;n<_.length;n++)_.__setDigit(n,0);}static __toStringBasePowerOfTwo(_,i){const t=_.length;let e=i-1;e=(85&e>>>1)+(85&e),e=(51&e>>>2)+(51&e),e=(15&e>>>4)+(15&e);const n=e,g=i-1,o=_.__digit(t-1),s=JSBI.__clz30(o);let l=0|(30*t-s+n-1)/n;if(_.sign&&l++,268435456<l)throw new Error("string too long");const r=Array(l);let a=l-1,u=0,d=0;for(let e=0;e<t-1;e++){const i=_.__digit(e),t=(u|i<<d)&g;r[a--]=JSBI.__kConversionChars[t];const o=n-d;for(u=i>>>o,d=30-o;d>=n;)r[a--]=JSBI.__kConversionChars[u&g],u>>>=n,d-=n;}const h=(u|o<<d)&g;for(r[a--]=JSBI.__kConversionChars[h],u=o>>>n-d;0!==u;)r[a--]=JSBI.__kConversionChars[u&g],u>>>=n;if(_.sign&&(r[a--]="-"),-1!=a)throw new Error("implementation bug");return r.join("")}static __toStringGeneric(_,i,t){const e=_.length;if(0===e)return "";if(1===e){let e=_.__unsignedDigit(0).toString(i);return !1===t&&_.sign&&(e="-"+e),e}const n=30*e-JSBI.__clz30(_.__digit(e-1)),g=JSBI.__kMaxBitsPerChar[i],o=g-1;let s=n*JSBI.__kBitsPerCharTableMultiplier;s+=o-1,s=0|s/o;const l=s+1>>1,r=JSBI.exponentiate(JSBI.__oneDigit(i,!1),JSBI.__oneDigit(l,!1));let a,u;const d=r.__unsignedDigit(0);if(1===r.length&&32767>=d){a=new JSBI(_.length,!1),a.__initializeDigits();let t=0;for(let e=2*_.length-1;0<=e;e--){const i=t<<15|_.__halfDigit(e);a.__setHalfDigit(e,0|i/d),t=0|i%d;}u=t.toString(i);}else {const t=JSBI.__absoluteDivLarge(_,r,!0,!0);a=t.quotient;const e=t.remainder.__trim();u=JSBI.__toStringGeneric(e,i,!0);}a.__trim();let h=JSBI.__toStringGeneric(a,i,!0);for(;u.length<l;)u="0"+u;return !1===t&&_.sign&&(h="-"+h),h+u}static __unequalSign(i){return i?-1:1}static __absoluteGreater(i){return i?-1:1}static __absoluteLess(i){return i?1:-1}static __compareToBigInt(i,_){const t=i.sign;if(t!==_.sign)return JSBI.__unequalSign(t);const e=JSBI.__absoluteCompare(i,_);return 0<e?JSBI.__absoluteGreater(t):0>e?JSBI.__absoluteLess(t):0}static __compareToNumber(i,_){if(JSBI.__isOneDigitInt(_)){const t=i.sign,e=0>_;if(t!==e)return JSBI.__unequalSign(t);if(0===i.length){if(e)throw new Error("implementation bug");return 0===_?0:-1}if(1<i.length)return JSBI.__absoluteGreater(t);const n=Math.abs(_),g=i.__unsignedDigit(0);return g>n?JSBI.__absoluteGreater(t):g<n?JSBI.__absoluteLess(t):0}return JSBI.__compareToDouble(i,_)}static __compareToDouble(i,_){if(_!==_)return _;if(_===1/0)return -1;if(_===-Infinity)return 1;const t=i.sign;if(t!==0>_)return JSBI.__unequalSign(t);if(0===_)throw new Error("implementation bug: should be handled elsewhere");if(0===i.length)return -1;JSBI.__kBitConversionDouble[0]=_;const e=2047&JSBI.__kBitConversionInts[1]>>>20;if(2047==e)throw new Error("implementation bug: handled elsewhere");const n=e-1023;if(0>n)return JSBI.__absoluteGreater(t);const g=i.length;let o=i.__digit(g-1);const s=JSBI.__clz30(o),l=30*g-s,r=n+1;if(l<r)return JSBI.__absoluteLess(t);if(l>r)return JSBI.__absoluteGreater(t);let a=1048576|1048575&JSBI.__kBitConversionInts[1],u=JSBI.__kBitConversionInts[0];const d=20,h=29-s;if(h!==(0|(l-1)%30))throw new Error("implementation bug");let m,b=0;if(20>h){const i=d-h;b=i+32,m=a>>>i,a=a<<32-i|u>>>i,u<<=32-i;}else if(20===h)b=32,m=a,a=u,u=0;else {const i=h-d;b=32-i,m=a<<i|u>>>32-i,a=u<<i,u=0;}if(o>>>=0,m>>>=0,o>m)return JSBI.__absoluteGreater(t);if(o<m)return JSBI.__absoluteLess(t);for(let e=g-2;0<=e;e--){0<b?(b-=30,m=a>>>2,a=a<<30|u>>>2,u<<=30):m=0;const _=i.__unsignedDigit(e);if(_>m)return JSBI.__absoluteGreater(t);if(_<m)return JSBI.__absoluteLess(t)}if(0!==a||0!==u){if(0===b)throw new Error("implementation bug");return JSBI.__absoluteLess(t)}return 0}static __equalToNumber(i,_){var t=Math.abs;return JSBI.__isOneDigitInt(_)?0===_?0===i.length:1===i.length&&i.sign===0>_&&i.__unsignedDigit(0)===t(_):0===JSBI.__compareToDouble(i,_)}static __comparisonResultToBool(i,_){return 0===_?0>i:1===_?0>=i:2===_?0<i:3===_?0<=i:void 0}static __compare(i,_,t){if(i=JSBI.__toPrimitive(i),_=JSBI.__toPrimitive(_),"string"==typeof i&&"string"==typeof _)switch(t){case 0:return i<_;case 1:return i<=_;case 2:return i>_;case 3:return i>=_;}if(JSBI.__isBigInt(i)&&"string"==typeof _)return _=JSBI.__fromString(_),null!==_&&JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i,_),t);if("string"==typeof i&&JSBI.__isBigInt(_))return i=JSBI.__fromString(i),null!==i&&JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i,_),t);if(i=JSBI.__toNumeric(i),_=JSBI.__toNumeric(_),JSBI.__isBigInt(i)){if(JSBI.__isBigInt(_))return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i,_),t);if("number"!=typeof _)throw new Error("implementation bug");return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i,_),t)}if("number"!=typeof i)throw new Error("implementation bug");if(JSBI.__isBigInt(_))return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_,i),2^t);if("number"!=typeof _)throw new Error("implementation bug");return 0===t?i<_:1===t?i<=_:2===t?i>_:3===t?i>=_:void 0}__clzmsd(){return JSBI.__clz30(this.__digit(this.length-1))}static __absoluteAdd(_,t,e){if(_.length<t.length)return JSBI.__absoluteAdd(t,_,e);if(0===_.length)return _;if(0===t.length)return _.sign===e?_:JSBI.unaryMinus(_);let n=_.length;(0===_.__clzmsd()||t.length===_.length&&0===t.__clzmsd())&&n++;const g=new JSBI(n,e);let o=0,s=0;for(;s<t.length;s++){const i=_.__digit(s)+t.__digit(s)+o;o=i>>>30,g.__setDigit(s,1073741823&i);}for(;s<_.length;s++){const i=_.__digit(s)+o;o=i>>>30,g.__setDigit(s,1073741823&i);}return s<g.length&&g.__setDigit(s,o),g.__trim()}static __absoluteSub(_,t,e){if(0===_.length)return _;if(0===t.length)return _.sign===e?_:JSBI.unaryMinus(_);const n=new JSBI(_.length,e);let g=0,o=0;for(;o<t.length;o++){const i=_.__digit(o)-t.__digit(o)-g;g=1&i>>>30,n.__setDigit(o,1073741823&i);}for(;o<_.length;o++){const i=_.__digit(o)-g;g=1&i>>>30,n.__setDigit(o,1073741823&i);}return n.__trim()}static __absoluteAddOne(_,i,t=null){const e=_.length;null===t?t=new JSBI(e,i):t.sign=i;let n=1;for(let g=0;g<e;g++){const i=_.__digit(g)+n;n=i>>>30,t.__setDigit(g,1073741823&i);}return 0!=n&&t.__setDigitGrow(e,1),t}static __absoluteSubOne(_,t){const e=_.length;t=t||e;const n=new JSBI(t,!1);let g=1;for(let o=0;o<e;o++){const i=_.__digit(o)-g;g=1&i>>>30,n.__setDigit(o,1073741823&i);}if(0!=g)throw new Error("implementation bug");for(let g=e;g<t;g++)n.__setDigit(g,0);return n}static __absoluteAnd(_,t,e=null){let n=_.length,g=t.length,o=g;if(n<g){o=n;const i=_,e=n;_=t,n=g,t=i,g=e;}let s=o;null===e?e=new JSBI(s,!1):s=e.length;let l=0;for(;l<o;l++)e.__setDigit(l,_.__digit(l)&t.__digit(l));for(;l<s;l++)e.__setDigit(l,0);return e}static __absoluteAndNot(_,t,e=null){const n=_.length,g=t.length;let o=g;n<g&&(o=n);let s=n;null===e?e=new JSBI(s,!1):s=e.length;let l=0;for(;l<o;l++)e.__setDigit(l,_.__digit(l)&~t.__digit(l));for(;l<n;l++)e.__setDigit(l,_.__digit(l));for(;l<s;l++)e.__setDigit(l,0);return e}static __absoluteOr(_,t,e=null){let n=_.length,g=t.length,o=g;if(n<g){o=n;const i=_,e=n;_=t,n=g,t=i,g=e;}let s=n;null===e?e=new JSBI(s,!1):s=e.length;let l=0;for(;l<o;l++)e.__setDigit(l,_.__digit(l)|t.__digit(l));for(;l<n;l++)e.__setDigit(l,_.__digit(l));for(;l<s;l++)e.__setDigit(l,0);return e}static __absoluteXor(_,t,e=null){let n=_.length,g=t.length,o=g;if(n<g){o=n;const i=_,e=n;_=t,n=g,t=i,g=e;}let s=n;null===e?e=new JSBI(s,!1):s=e.length;let l=0;for(;l<o;l++)e.__setDigit(l,_.__digit(l)^t.__digit(l));for(;l<n;l++)e.__setDigit(l,_.__digit(l));for(;l<s;l++)e.__setDigit(l,0);return e}static __absoluteCompare(_,t){const e=_.length-t.length;if(0!=e)return e;let n=_.length-1;for(;0<=n&&_.__digit(n)===t.__digit(n);)n--;return 0>n?0:_.__unsignedDigit(n)>t.__unsignedDigit(n)?1:-1}static __multiplyAccumulate(_,t,e,n){if(0===t)return;const g=32767&t,o=t>>>15;let s=0,l=0;for(let r,a=0;a<_.length;a++,n++){r=e.__digit(n);const i=_.__digit(a),t=32767&i,u=i>>>15,d=JSBI.__imul(t,g),h=JSBI.__imul(t,o),m=JSBI.__imul(u,g),b=JSBI.__imul(u,o);r+=l+d+s,s=r>>>30,r&=1073741823,r+=((32767&h)<<15)+((32767&m)<<15),s+=r>>>30,l=b+(h>>>15)+(m>>>15),e.__setDigit(n,1073741823&r);}for(;0!=s||0!==l;n++){let i=e.__digit(n);i+=s+l,l=0,s=i>>>30,e.__setDigit(n,1073741823&i);}}static __internalMultiplyAdd(_,t,e,g,o){let s=e,l=0;for(let n=0;n<g;n++){const i=_.__digit(n),e=JSBI.__imul(32767&i,t),g=JSBI.__imul(i>>>15,t),a=e+((32767&g)<<15)+l+s;s=a>>>30,l=g>>>15,o.__setDigit(n,1073741823&a);}if(o.length>g)for(o.__setDigit(g++,s+l);g<o.length;)o.__setDigit(g++,0);else if(0!==s+l)throw new Error("implementation bug")}__inplaceMultiplyAdd(i,_,t){t>this.length&&(t=this.length);const e=32767&i,n=i>>>15;let g=0,o=_;for(let s=0;s<t;s++){const i=this.__digit(s),_=32767&i,t=i>>>15,l=JSBI.__imul(_,e),r=JSBI.__imul(_,n),a=JSBI.__imul(t,e),u=JSBI.__imul(t,n);let d=o+l+g;g=d>>>30,d&=1073741823,d+=((32767&r)<<15)+((32767&a)<<15),g+=d>>>30,o=u+(r>>>15)+(a>>>15),this.__setDigit(s,1073741823&d);}if(0!=g||0!==o)throw new Error("implementation bug")}static __absoluteDivSmall(_,t,e=null){null===e&&(e=new JSBI(_.length,!1));let n=0;for(let g,o=2*_.length-1;0<=o;o-=2){g=(n<<15|_.__halfDigit(o))>>>0;const i=0|g/t;n=0|g%t,g=(n<<15|_.__halfDigit(o-1))>>>0;const s=0|g/t;n=0|g%t,e.__setDigit(o>>>1,i<<15|s);}return e}static __absoluteModSmall(_,t){let e=0;for(let n=2*_.length-1;0<=n;n--){const i=(e<<15|_.__halfDigit(n))>>>0;e=0|i%t;}return e}static __absoluteDivLarge(i,_,t,e){const g=_.__halfDigitLength(),n=_.length,o=i.__halfDigitLength()-g;let s=null;t&&(s=new JSBI(o+2>>>1,!1),s.__initializeDigits());const l=new JSBI(g+2>>>1,!1);l.__initializeDigits();const r=JSBI.__clz15(_.__halfDigit(g-1));0<r&&(_=JSBI.__specialLeftShift(_,r,0));const a=JSBI.__specialLeftShift(i,r,1),u=_.__halfDigit(g-1);let d=0;for(let r,h=o;0<=h;h--){r=32767;const i=a.__halfDigit(h+g);if(i!==u){const t=(i<<15|a.__halfDigit(h+g-1))>>>0;r=0|t/u;let e=0|t%u;const n=_.__halfDigit(g-2),o=a.__halfDigit(h+g-2);for(;JSBI.__imul(r,n)>>>0>(e<<16|o)>>>0&&(r--,e+=u,!(32767<e)););}JSBI.__internalMultiplyAdd(_,r,0,n,l);let e=a.__inplaceSub(l,h,g+1);0!==e&&(e=a.__inplaceAdd(_,h,g),a.__setHalfDigit(h+g,32767&a.__halfDigit(h+g)+e),r--),t&&(1&h?d=r<<15:s.__setDigit(h>>>1,d|r));}if(e)return a.__inplaceRightShift(r),t?{quotient:s,remainder:a}:a;if(t)return s;throw new Error("unreachable")}static __clz15(i){return JSBI.__clz30(i)-15}__inplaceAdd(_,t,e){let n=0;for(let g=0;g<e;g++){const i=this.__halfDigit(t+g)+_.__halfDigit(g)+n;n=i>>>15,this.__setHalfDigit(t+g,32767&i);}return n}__inplaceSub(_,t,e){let n=0;if(1&t){t>>=1;let g=this.__digit(t),o=32767&g,s=0;for(;s<e-1>>>1;s++){const i=_.__digit(s),e=(g>>>15)-(32767&i)-n;n=1&e>>>15,this.__setDigit(t+s,(32767&e)<<15|32767&o),g=this.__digit(t+s+1),o=(32767&g)-(i>>>15)-n,n=1&o>>>15;}const i=_.__digit(s),l=(g>>>15)-(32767&i)-n;n=1&l>>>15,this.__setDigit(t+s,(32767&l)<<15|32767&o);if(t+s+1>=this.length)throw new RangeError("out of bounds");0==(1&e)&&(g=this.__digit(t+s+1),o=(32767&g)-(i>>>15)-n,n=1&o>>>15,this.__setDigit(t+_.length,1073709056&g|32767&o));}else {t>>=1;let g=0;for(;g<_.length-1;g++){const i=this.__digit(t+g),e=_.__digit(g),o=(32767&i)-(32767&e)-n;n=1&o>>>15;const s=(i>>>15)-(e>>>15)-n;n=1&s>>>15,this.__setDigit(t+g,(32767&s)<<15|32767&o);}const i=this.__digit(t+g),o=_.__digit(g),s=(32767&i)-(32767&o)-n;n=1&s>>>15;let l=0;0==(1&e)&&(l=(i>>>15)-(o>>>15)-n,n=1&l>>>15),this.__setDigit(t+g,(32767&l)<<15|32767&s);}return n}__inplaceRightShift(_){if(0===_)return;let t=this.__digit(0)>>>_;const e=this.length-1;for(let n=0;n<e;n++){const i=this.__digit(n+1);this.__setDigit(n,1073741823&i<<30-_|t),t=i>>>_;}this.__setDigit(e,t);}static __specialLeftShift(_,t,e){const g=_.length,n=new JSBI(g+e,!1);if(0===t){for(let t=0;t<g;t++)n.__setDigit(t,_.__digit(t));return 0<e&&n.__setDigit(g,0),n}let o=0;for(let s=0;s<g;s++){const i=_.__digit(s);n.__setDigit(s,1073741823&i<<t|o),o=i>>>30-t;}return 0<e&&n.__setDigit(g,o),n}static __leftShiftByAbsolute(_,i){const t=JSBI.__toShiftAmount(i);if(0>t)throw new RangeError("BigInt too big");const e=0|t/30,n=t%30,g=_.length,o=0!==n&&0!=_.__digit(g-1)>>>30-n,s=g+e+(o?1:0),l=new JSBI(s,_.sign);if(0===n){let t=0;for(;t<e;t++)l.__setDigit(t,0);for(;t<s;t++)l.__setDigit(t,_.__digit(t-e));}else {let t=0;for(let _=0;_<e;_++)l.__setDigit(_,0);for(let o=0;o<g;o++){const i=_.__digit(o);l.__setDigit(o+e,1073741823&i<<n|t),t=i>>>30-n;}if(o)l.__setDigit(g+e,t);else if(0!==t)throw new Error("implementation bug")}return l.__trim()}static __rightShiftByAbsolute(_,i){const t=_.length,e=_.sign,n=JSBI.__toShiftAmount(i);if(0>n)return JSBI.__rightShiftByMaximum(e);const g=0|n/30,o=n%30;let s=t-g;if(0>=s)return JSBI.__rightShiftByMaximum(e);let l=!1;if(e){if(0!=(_.__digit(g)&(1<<o)-1))l=!0;else for(let t=0;t<g;t++)if(0!==_.__digit(t)){l=!0;break}}if(l&&0===o){const i=_.__digit(t-1);0==~i&&s++;}let r=new JSBI(s,e);if(0===o){r.__setDigit(s-1,0);for(let e=g;e<t;e++)r.__setDigit(e-g,_.__digit(e));}else {let e=_.__digit(g)>>>o;const n=t-g-1;for(let t=0;t<n;t++){const i=_.__digit(t+g+1);r.__setDigit(t,1073741823&i<<30-o|e),e=i>>>o;}r.__setDigit(n,e);}return l&&(r=JSBI.__absoluteAddOne(r,!0,r)),r.__trim()}static __rightShiftByMaximum(i){return i?JSBI.__oneDigit(1,!0):JSBI.__zero()}static __toShiftAmount(i){if(1<i.length)return -1;const _=i.__unsignedDigit(0);return _>JSBI.__kMaxLengthBits?-1:_}static __toPrimitive(i,_="default"){if("object"!=typeof i)return i;if(i.constructor===JSBI)return i;if("undefined"!=typeof Symbol&&"symbol"==typeof Symbol.toPrimitive){const t=i[Symbol.toPrimitive];if(t){const i=t(_);if("object"!=typeof i)return i;throw new TypeError("Cannot convert object to primitive value")}}const t=i.valueOf;if(t){const _=t.call(i);if("object"!=typeof _)return _}const e=i.toString;if(e){const _=e.call(i);if("object"!=typeof _)return _}throw new TypeError("Cannot convert object to primitive value")}static __toNumeric(i){return JSBI.__isBigInt(i)?i:+i}static __isBigInt(i){return "object"==typeof i&&null!==i&&i.constructor===JSBI}static __truncateToNBits(i,_){const t=0|(i+29)/30,e=new JSBI(t,_.sign),n=t-1;for(let t=0;t<n;t++)e.__setDigit(t,_.__digit(t));let g=_.__digit(n);if(0!=i%30){const _=32-i%30;g=g<<_>>>_;}return e.__setDigit(n,g),e.__trim()}static __truncateAndSubFromPowerOfTwo(_,t,e){var n=Math.min;const g=0|(_+29)/30,o=new JSBI(g,e);let s=0;const l=g-1;let a=0;for(const i=n(l,t.length);s<i;s++){const i=0-t.__digit(s)-a;a=1&i>>>30,o.__setDigit(s,1073741823&i);}for(;s<l;s++)o.__setDigit(s,0|1073741823&-a);let u=l<t.length?t.__digit(l):0;const d=_%30;let h;if(0==d)h=0-u-a,h&=1073741823;else {const i=32-d;u=u<<i>>>i;const _=1<<32-i;h=_-u-a,h&=_-1;}return o.__setDigit(l,h),o.__trim()}__digit(_){return this[_]}__unsignedDigit(_){return this[_]>>>0}__setDigit(_,i){this[_]=0|i;}__setDigitGrow(_,i){this[_]=0|i;}__halfDigitLength(){const i=this.length;return 32767>=this.__unsignedDigit(i-1)?2*i-1:2*i}__halfDigit(_){return 32767&this[_>>>1]>>>15*(1&_)}__setHalfDigit(_,i){const t=_>>>1,e=this.__digit(t),n=1&_?32767&e|i<<15:1073709056&e|32767&i;this.__setDigit(t,n);}static __digitPow(i,_){let t=1;for(;0<_;)1&_&&(t*=i),_>>>=1,i*=i;return t}static __isOneDigitInt(i){return (1073741823&i)===i}}JSBI.__kMaxLength=33554432,JSBI.__kMaxLengthBits=JSBI.__kMaxLength<<5,JSBI.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],JSBI.__kBitsPerCharTableShift=5,JSBI.__kBitsPerCharTableMultiplier=1<<JSBI.__kBitsPerCharTableShift,JSBI.__kConversionChars=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],JSBI.__kBitConversionBuffer=new ArrayBuffer(8),JSBI.__kBitConversionDouble=new Float64Array(JSBI.__kBitConversionBuffer),JSBI.__kBitConversionInts=new Int32Array(JSBI.__kBitConversionBuffer),JSBI.__clz30=Math.clz32?function(i){return Math.clz32(i)-2}:function(i){return 0===i?30:0|29-(0|Math.log(i>>>0)/Math.LN2)},JSBI.__imul=Math.imul||function(i,_){return 0|i*_};

/*
 *  decimal.js-light v2.5.1
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js-light
 *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Expat Licence
 */


// ------------------------------------  EDITABLE DEFAULTS  ------------------------------------- //


// The limit on the value of `precision`, and on the value of the first argument to
// `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
var MAX_DIGITS = 1e9,                        // 0 to 1e9


  // The initial configuration properties of the Decimal constructor.
  defaults = {

    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed during run-time using `Decimal.config`.

    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,                         // 1 to MAX_DIGITS

    // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
    // `toFixed`, `toPrecision` and `toSignificantDigits`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,                           // 0 to 8

    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,                          // 0 to -MAX_E

    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos:  21,                         // 0 to MAX_E

    // The natural logarithm of 10.
    // 115 digits
    LN10: '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286'
  },


// ------------------------------------ END OF EDITABLE DEFAULTS -------------------------------- //


  Decimal$1,
  external = true,

  decimalError = '[DecimalError] ',
  invalidArgument = decimalError + 'Invalid argument: ',
  exponentOutOfRange = decimalError + 'Exponent out of range: ',

  mathfloor = Math.floor,
  mathpow = Math.pow,

  isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

  ONE,
  BASE = 1e7,
  LOG_BASE = 7,
  MAX_SAFE_INTEGER = 9007199254740991,
  MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE),    // 1286742750677284

  // Decimal.prototype object
  P$1 = {};


// Decimal prototype methods


/*
 *  absoluteValue                       abs
 *  comparedTo                          cmp
 *  decimalPlaces                       dp
 *  dividedBy                           div
 *  dividedToIntegerBy                  idiv
 *  equals                              eq
 *  exponent
 *  greaterThan                         gt
 *  greaterThanOrEqualTo                gte
 *  isInteger                           isint
 *  isNegative                          isneg
 *  isPositive                          ispos
 *  isZero
 *  lessThan                            lt
 *  lessThanOrEqualTo                   lte
 *  logarithm                           log
 *  minus                               sub
 *  modulo                              mod
 *  naturalExponential                  exp
 *  naturalLogarithm                    ln
 *  negated                             neg
 *  plus                                add
 *  precision                           sd
 *  squareRoot                          sqrt
 *  times                               mul
 *  toDecimalPlaces                     todp
 *  toExponential
 *  toFixed
 *  toInteger                           toint
 *  toNumber
 *  toPower                             pow
 *  toPrecision
 *  toSignificantDigits                 tosd
 *  toString
 *  valueOf                             val
 */


/*
 * Return a new Decimal whose value is the absolute value of this Decimal.
 *
 */
P$1.absoluteValue = P$1.abs = function () {
  var x = new this.constructor(this);
  if (x.s) x.s = 1;
  return x;
};


/*
 * Return
 *   1    if the value of this Decimal is greater than the value of `y`,
 *  -1    if the value of this Decimal is less than the value of `y`,
 *   0    if they have the same value
 *
 */
P$1.comparedTo = P$1.cmp = function (y) {
  var i, j, xdL, ydL,
    x = this;

  y = new x.constructor(y);

  // Signs differ?
  if (x.s !== y.s) return x.s || -y.s;

  // Compare exponents.
  if (x.e !== y.e) return x.e > y.e ^ x.s < 0 ? 1 : -1;

  xdL = x.d.length;
  ydL = y.d.length;

  // Compare digit by digit.
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (x.d[i] !== y.d[i]) return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
  }

  // Compare lengths.
  return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
};


/*
 * Return the number of decimal places of the value of this Decimal.
 *
 */
P$1.decimalPlaces = P$1.dp = function () {
  var x = this,
    w = x.d.length - 1,
    dp = (w - x.e) * LOG_BASE;

  // Subtract the number of trailing zeros of the last word.
  w = x.d[w];
  if (w) for (; w % 10 == 0; w /= 10) dp--;

  return dp < 0 ? 0 : dp;
};


/*
 * Return a new Decimal whose value is the value of this Decimal divided by `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.dividedBy = P$1.div = function (y) {
  return divide(this, new this.constructor(y));
};


/*
 * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
 * by the value of `y`, truncated to `precision` significant digits.
 *
 */
P$1.dividedToIntegerBy = P$1.idiv = function (y) {
  var x = this,
    Ctor = x.constructor;
  return round$1(divide(x, new Ctor(y), 0, 1), Ctor.precision);
};


/*
 * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
 *
 */
P$1.equals = P$1.eq = function (y) {
  return !this.cmp(y);
};


/*
 * Return the (base 10) exponent value of this Decimal (this.e is the base 10000000 exponent).
 *
 */
P$1.exponent = function () {
  return getBase10Exponent(this);
};


/*
 * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
 * false.
 *
 */
P$1.greaterThan = P$1.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Decimal is greater than or equal to the value of `y`,
 * otherwise return false.
 *
 */
P$1.greaterThanOrEqualTo = P$1.gte = function (y) {
  return this.cmp(y) >= 0;
};


/*
 * Return true if the value of this Decimal is an integer, otherwise return false.
 *
 */
P$1.isInteger = P$1.isint = function () {
  return this.e > this.d.length - 2;
};


/*
 * Return true if the value of this Decimal is negative, otherwise return false.
 *
 */
P$1.isNegative = P$1.isneg = function () {
  return this.s < 0;
};


/*
 * Return true if the value of this Decimal is positive, otherwise return false.
 *
 */
P$1.isPositive = P$1.ispos = function () {
  return this.s > 0;
};


/*
 * Return true if the value of this Decimal is 0, otherwise return false.
 *
 */
P$1.isZero = function () {
  return this.s === 0;
};


/*
 * Return true if the value of this Decimal is less than `y`, otherwise return false.
 *
 */
P$1.lessThan = P$1.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
 *
 */
P$1.lessThanOrEqualTo = P$1.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return the logarithm of the value of this Decimal to the specified base, truncated to
 * `precision` significant digits.
 *
 * If no base is specified, return log[10](x).
 *
 * log[base](x) = ln(x) / ln(base)
 *
 * The maximum error of the result is 1 ulp (unit in the last place).
 *
 * [base] {number|string|Decimal} The base of the logarithm.
 *
 */
P$1.logarithm = P$1.log = function (base) {
  var r,
    x = this,
    Ctor = x.constructor,
    pr = Ctor.precision,
    wpr = pr + 5;

  // Default base is 10.
  if (base === void 0) {
    base = new Ctor(10);
  } else {
    base = new Ctor(base);

    // log[-b](x) = NaN
    // log[0](x)  = NaN
    // log[1](x)  = NaN
    if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + 'NaN');
  }

  // log[b](-x) = NaN
  // log[b](0) = -Infinity
  if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));

  // log[b](1) = 0
  if (x.eq(ONE)) return new Ctor(0);

  external = false;
  r = divide(ln(x, wpr), ln(base, wpr), wpr);
  external = true;

  return round$1(r, pr);
};


/*
 * Return a new Decimal whose value is the value of this Decimal minus `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.minus = P$1.sub = function (y) {
  var x = this;
  y = new x.constructor(y);
  return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
};


/*
 * Return a new Decimal whose value is the value of this Decimal modulo `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.modulo = P$1.mod = function (y) {
  var q,
    x = this,
    Ctor = x.constructor,
    pr = Ctor.precision;

  y = new Ctor(y);

  // x % 0 = NaN
  if (!y.s) throw Error(decimalError + 'NaN');

  // Return x if x is 0.
  if (!x.s) return round$1(new Ctor(x), pr);

  // Prevent rounding of intermediate calculations.
  external = false;
  q = divide(x, y, 0, 1).times(y);
  external = true;

  return x.minus(q);
};


/*
 * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
 * i.e. the base e raised to the power the value of this Decimal, truncated to `precision`
 * significant digits.
 *
 */
P$1.naturalExponential = P$1.exp = function () {
  return exp(this);
};


/*
 * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
 * truncated to `precision` significant digits.
 *
 */
P$1.naturalLogarithm = P$1.ln = function () {
  return ln(this);
};


/*
 * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
 * -1.
 *
 */
P$1.negated = P$1.neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s || 0;
  return x;
};


/*
 * Return a new Decimal whose value is the value of this Decimal plus `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.plus = P$1.add = function (y) {
  var x = this;
  y = new x.constructor(y);
  return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
};


/*
 * Return the number of significant digits of the value of this Decimal.
 *
 * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
 *
 */
P$1.precision = P$1.sd = function (z) {
  var e, sd, w,
    x = this;

  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

  e = getBase10Exponent(x) + 1;
  w = x.d.length - 1;
  sd = w * LOG_BASE + 1;
  w = x.d[w];

  // If non-zero...
  if (w) {

    // Subtract the number of trailing zeros of the last word.
    for (; w % 10 == 0; w /= 10) sd--;

    // Add the number of digits of the first word.
    for (w = x.d[0]; w >= 10; w /= 10) sd++;
  }

  return z && e > sd ? e : sd;
};


/*
 * Return a new Decimal whose value is the square root of this Decimal, truncated to `precision`
 * significant digits.
 *
 */
P$1.squareRoot = P$1.sqrt = function () {
  var e, n, pr, r, s, t, wpr,
    x = this,
    Ctor = x.constructor;

  // Negative or zero?
  if (x.s < 1) {
    if (!x.s) return new Ctor(0);

    // sqrt(-x) = NaN
    throw Error(decimalError + 'NaN');
  }

  e = getBase10Exponent(x);
  external = false;

  // Initial estimate.
  s = Math.sqrt(+x);

  // Math.sqrt underflow/overflow?
  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(x.d);
    if ((n.length + e) % 2 == 0) n += '0';
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

    if (s == 1 / 0) {
      n = '5e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }

  pr = Ctor.precision;
  s = wpr = pr + 3;

  // Newton-Raphson iteration.
  for (;;) {
    t = r;
    r = t.plus(divide(x, t, wpr + 2)).times(0.5);

    if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
      n = n.slice(wpr - 3, wpr + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
      // 4999, i.e. approaching a rounding boundary, continue the iteration.
      if (s == wpr && n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        round$1(t, pr + 1, 0);

        if (t.times(t).eq(x)) {
          r = t;
          break;
        }
      } else if (n != '9999') {
        break;
      }

      wpr += 4;
    }
  }

  external = true;

  return round$1(r, pr);
};


/*
 * Return a new Decimal whose value is the value of this Decimal times `y`, truncated to
 * `precision` significant digits.
 *
 */
P$1.times = P$1.mul = function (y) {
  var carry, e, i, k, r, rL, t, xdL, ydL,
    x = this,
    Ctor = x.constructor,
    xd = x.d,
    yd = (y = new Ctor(y)).d;

  // Return 0 if either is 0.
  if (!x.s || !y.s) return new Ctor(0);

  y.s *= x.s;
  e = x.e + y.e;
  xdL = xd.length;
  ydL = yd.length;

  // Ensure xd points to the longer array.
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }

  // Initialise the result array with zeros.
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--;) r.push(0);

  // Multiply!
  for (i = ydL; --i >= 0;) {
    carry = 0;
    for (k = xdL + i; k > i;) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }

    r[k] = (r[k] + carry) % BASE | 0;
  }

  // Remove trailing zeros.
  for (; !r[--rL];) r.pop();

  if (carry) ++e;
  else r.shift();

  y.d = r;
  y.e = e;

  return external ? round$1(y, Ctor.precision) : y;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
 * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
 *
 * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P$1.toDecimalPlaces = P$1.todp = function (dp, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);
  if (dp === void 0) return x;

  checkInt32(dp, 0, MAX_DIGITS);

  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);

  return round$1(x, dp + getBase10Exponent(x) + 1, rm);
};


/*
 * Return a string representing the value of this Decimal in exponential notation rounded to
 * `dp` fixed decimal places using rounding mode `rounding`.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P$1.toExponential = function (dp, rm) {
  var str,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) {
    str = toString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = round$1(new Ctor(x), dp + 1, rm);
    str = toString(x, true, dp + 1);
  }

  return str;
};


/*
 * Return a string representing the value of this Decimal in normal (fixed-point) notation to
 * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
 * omitted.
 *
 * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 * (-0).toFixed(3) is '0.000'.
 * (-0.5).toFixed(0) is '-0'.
 *
 */
P$1.toFixed = function (dp, rm) {
  var str, y,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) return toString(x);

  checkInt32(dp, 0, MAX_DIGITS);

  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);

  y = round$1(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);
  str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);

  // To determine whether to add the minus sign look at the value before it was rounded,
  // i.e. look at `x` rather than `y`.
  return x.isneg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
 * rounding mode `rounding`.
 *
 */
P$1.toInteger = P$1.toint = function () {
  var x = this,
    Ctor = x.constructor;
  return round$1(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
};


/*
 * Return the value of this Decimal converted to a number primitive.
 *
 */
P$1.toNumber = function () {
  return +this;
};


/*
 * Return a new Decimal whose value is the value of this Decimal raised to the power `y`,
 * truncated to `precision` significant digits.
 *
 * For non-integer or very large exponents pow(x, y) is calculated using
 *
 *   x^y = exp(y*ln(x))
 *
 * The maximum error is 1 ulp (unit in last place).
 *
 * y {number|string|Decimal} The power to which to raise this Decimal.
 *
 */
P$1.toPower = P$1.pow = function (y) {
  var e, k, pr, r, sign, yIsInt,
    x = this,
    Ctor = x.constructor,
    guard = 12,
    yn = +(y = new Ctor(y));

  // pow(x, 0) = 1
  if (!y.s) return new Ctor(ONE);

  x = new Ctor(x);

  // pow(0, y > 0) = 0
  // pow(0, y < 0) = Infinity
  if (!x.s) {
    if (y.s < 1) throw Error(decimalError + 'Infinity');
    return x;
  }

  // pow(1, y) = 1
  if (x.eq(ONE)) return x;

  pr = Ctor.precision;

  // pow(x, 1) = x
  if (y.eq(ONE)) return round$1(x, pr);

  e = y.e;
  k = y.d.length - 1;
  yIsInt = e >= k;
  sign = x.s;

  if (!yIsInt) {

    // pow(x < 0, y non-integer) = NaN
    if (sign < 0) throw Error(decimalError + 'NaN');

  // If y is a small integer use the 'exponentiation by squaring' algorithm.
  } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = new Ctor(ONE);

    // Max k of 9007199254740991 takes 53 loop iterations.
    // Maximum digits array length; leaves [28, 34] guard digits.
    e = Math.ceil(pr / LOG_BASE + 4);

    external = false;

    for (;;) {
      if (k % 2) {
        r = r.times(x);
        truncate(r.d, e);
      }

      k = mathfloor(k / 2);
      if (k === 0) break;

      x = x.times(x);
      truncate(x.d, e);
    }

    external = true;

    return y.s < 0 ? new Ctor(ONE).div(r) : round$1(r, pr);
  }

  // Result is negative if x is negative and the last digit of integer y is odd.
  sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;

  x.s = 1;
  external = false;
  r = y.times(ln(x, pr + guard));
  external = true;
  r = exp(r);
  r.s = sign;

  return r;
};


/*
 * Return a string representing the value of this Decimal rounded to `sd` significant digits
 * using rounding mode `rounding`.
 *
 * Return exponential notation if `sd` is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P$1.toPrecision = function (sd, rm) {
  var e, str,
    x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    e = getBase10Exponent(x);
    str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = round$1(new Ctor(x), sd, rm);
    e = getBase10Exponent(x);
    str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);
  }

  return str;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
 * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
 * omitted.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P$1.toSignificantDigits = P$1.tosd = function (sd, rm) {
  var x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }

  return round$1(new Ctor(x), sd, rm);
};


/*
 * Return a string representing the value of this Decimal.
 *
 * Return exponential notation if this Decimal has a positive exponent equal to or greater than
 * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
 *
 */
P$1.toString = P$1.valueOf = P$1.val = P$1.toJSON = P$1[Symbol.for('nodejs.util.inspect.custom')] = function () {
  var x = this,
    e = getBase10Exponent(x),
    Ctor = x.constructor;

  return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
};


// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


/*
 *  add                 P.minus, P.plus
 *  checkInt32          P.todp, P.toExponential, P.toFixed, P.toPrecision, P.tosd
 *  digitsToString      P.log, P.sqrt, P.pow, toString, exp, ln
 *  divide              P.div, P.idiv, P.log, P.mod, P.sqrt, exp, ln
 *  exp                 P.exp, P.pow
 *  getBase10Exponent   P.exponent, P.sd, P.toint, P.sqrt, P.todp, P.toFixed, P.toPrecision,
 *                      P.toString, divide, round, toString, exp, ln
 *  getLn10             P.log, ln
 *  getZeroString       digitsToString, toString
 *  ln                  P.log, P.ln, P.pow, exp
 *  parseDecimal        Decimal
 *  round               P.abs, P.idiv, P.log, P.minus, P.mod, P.neg, P.plus, P.toint, P.sqrt,
 *                      P.times, P.todp, P.toExponential, P.toFixed, P.pow, P.toPrecision, P.tosd,
 *                      divide, getLn10, exp, ln
 *  subtract            P.minus, P.plus
 *  toString            P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf
 *  truncate            P.pow
 *
 *  Throws:             P.log, P.mod, P.sd, P.sqrt, P.pow,  checkInt32, divide, round,
 *                      getLn10, exp, ln, parseDecimal, Decimal, config
 */


function add(x, y) {
  var carry, d, e, i, k, len, xd, yd,
    Ctor = x.constructor,
    pr = Ctor.precision;

  // If either is zero...
  if (!x.s || !y.s) {

    // Return x if y is zero.
    // Return y if y is non-zero.
    if (!y.s) y = new Ctor(x);
    return external ? round$1(y, pr) : y;
  }

  xd = x.d;
  yd = y.d;

  // x and y are finite, non-zero numbers with the same sign.

  k = x.e;
  e = y.e;
  xd = xd.slice();
  i = k - e;

  // If base 1e7 exponents differ...
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }

    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;

    if (i > len) {
      i = len;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
    d.reverse();
    for (; i--;) d.push(0);
    d.reverse();
  }

  len = xd.length;
  i = yd.length;

  // If yd is longer than xd, swap xd and yd so xd points to the longer array.
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }

  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
  for (carry = 0; i;) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }

  if (carry) {
    xd.unshift(carry);
    ++e;
  }

  // Remove trailing zeros.
  // No need to check for zero, as +x + +y != 0 && -x + -y != 0
  for (len = xd.length; xd[--len] == 0;) xd.pop();

  y.d = xd;
  y.e = e;

  return external ? round$1(y, pr) : y;
}


function checkInt32(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
}


function digitsToString(d) {
  var i, k, ws,
    indexOfLastWord = d.length - 1,
    str = '',
    w = d[0];

  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
      str += ws;
    }

    w = d[i];
    ws = w + '';
    k = LOG_BASE - ws.length;
    if (k) str += getZeroString(k);
  } else if (w === 0) {
    return '0';
  }

  // Remove trailing zeros of last w.
  for (; w % 10 === 0;) w /= 10;

  return str + w;
}


var divide = (function () {

  // Assumes non-zero x and k, and hence non-zero result.
  function multiplyInteger(x, k) {
    var temp,
      carry = 0,
      i = x.length;

    for (x = x.slice(); i--;) {
      temp = x[i] * k + carry;
      x[i] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }

    if (carry) x.unshift(carry);

    return x;
  }

  function compare(a, b, aL, bL) {
    var i, r;

    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }

    return r;
  }

  function subtract(a, b, aL) {
    var i = 0;

    // Subtract b from a.
    for (; aL--;) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * BASE + a[aL] - b[aL];
    }

    // Remove leading zeros.
    for (; !a[0] && a.length > 1;) a.shift();
  }

  return function (x, y, pr, dp) {
    var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz,
      Ctor = x.constructor,
      sign = x.s == y.s ? 1 : -1,
      xd = x.d,
      yd = y.d;

    // Either 0?
    if (!x.s) return new Ctor(x);
    if (!y.s) throw Error(decimalError + 'Division by zero');

    e = x.e - y.e;
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign);
    qd = q.d = [];

    // Result exponent may be one less than e.
    for (i = 0; yd[i] == (xd[i] || 0); ) ++i;
    if (yd[i] > (xd[i] || 0)) --e;

    if (pr == null) {
      sd = pr = Ctor.precision;
    } else if (dp) {
      sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
    } else {
      sd = pr;
    }

    if (sd < 0) return new Ctor(0);

    // Convert precision in number of base 10 digits to base 1e7 digits.
    sd = sd / LOG_BASE + 2 | 0;
    i = 0;

    // divisor < 1e7
    if (yL == 1) {
      k = 0;
      yd = yd[0];
      sd++;

      // k is the carry.
      for (; (i < xL || k) && sd--; i++) {
        t = k * BASE + (xd[i] || 0);
        qd[i] = t / yd | 0;
        k = t % yd | 0;
      }

    // divisor >= 1e7
    } else {

      // Normalise xd and yd so highest order digit of yd is >= BASE/2
      k = BASE / (yd[0] + 1) | 0;

      if (k > 1) {
        yd = multiplyInteger(yd, k);
        xd = multiplyInteger(xd, k);
        yL = yd.length;
        xL = xd.length;
      }

      xi = yL;
      rem = xd.slice(0, yL);
      remL = rem.length;

      // Add zeros to make remainder as long as divisor.
      for (; remL < yL;) rem[remL++] = 0;

      yz = yd.slice();
      yz.unshift(0);
      yd0 = yd[0];

      if (yd[1] >= BASE / 2) ++yd0;

      do {
        k = 0;

        // Compare divisor and remainder.
        cmp = compare(yd, rem, yL, remL);

        // If divisor < remainder.
        if (cmp < 0) {

          // Calculate trial digit, k.
          rem0 = rem[0];
          if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);

          // k will be how many times the divisor goes into the current remainder.
          k = rem0 / yd0 | 0;

          //  Algorithm:
          //  1. product = divisor * trial digit (k)
          //  2. if product > remainder: product -= divisor, k--
          //  3. remainder -= product
          //  4. if product was < remainder at 2:
          //    5. compare new remainder and divisor
          //    6. If remainder > divisor: remainder -= divisor, k++

          if (k > 1) {
            if (k >= BASE) k = BASE - 1;

            // product = divisor * trial digit.
            prod = multiplyInteger(yd, k);
            prodL = prod.length;
            remL = rem.length;

            // Compare product and remainder.
            cmp = compare(prod, rem, prodL, remL);

            // product > remainder.
            if (cmp == 1) {
              k--;

              // Subtract divisor from product.
              subtract(prod, yL < prodL ? yz : yd, prodL);
            }
          } else {

            // cmp is -1.
            // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
            // to avoid it. If k is 1 there is a need to compare yd and rem again below.
            if (k == 0) cmp = k = 1;
            prod = yd.slice();
          }

          prodL = prod.length;
          if (prodL < remL) prod.unshift(0);

          // Subtract product from remainder.
          subtract(rem, prod, remL);

          // If product was < previous remainder.
          if (cmp == -1) {
            remL = rem.length;

            // Compare divisor and new remainder.
            cmp = compare(yd, rem, yL, remL);

            // If divisor < new remainder, subtract divisor from remainder.
            if (cmp < 1) {
              k++;

              // Subtract divisor from remainder.
              subtract(rem, yL < remL ? yz : yd, remL);
            }
          }

          remL = rem.length;
        } else if (cmp === 0) {
          k++;
          rem = [0];
        }    // if cmp === 1, k will be 0

        // Add the next digit, k, to the result array.
        qd[i++] = k;

        // Update the remainder.
        if (cmp && rem[0]) {
          rem[remL++] = xd[xi] || 0;
        } else {
          rem = [xd[xi]];
          remL = 1;
        }

      } while ((xi++ < xL || rem[0] !== void 0) && sd--);
    }

    // Leading zero?
    if (!qd[0]) qd.shift();

    q.e = e;

    return round$1(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
  };
})();


/*
 * Return a new Decimal whose value is the natural exponential of `x` truncated to `sd`
 * significant digits.
 *
 * Taylor/Maclaurin series.
 *
 * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
 *
 * Argument reduction:
 *   Repeat x = x / 32, k += 5, until |x| < 0.1
 *   exp(x) = exp(x / 2^k)^(2^k)
 *
 * Previously, the argument was initially reduced by
 * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
 * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
 * found to be slower than just dividing repeatedly by 32 as above.
 *
 * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
 *
 *  exp(x) is non-terminating for any finite, non-zero x.
 *
 */
function exp(x, sd) {
  var denominator, guard, pow, sum, t, wpr,
    i = 0,
    k = 0,
    Ctor = x.constructor,
    pr = Ctor.precision;

  if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x));

  // exp(0) = 1
  if (!x.s) return new Ctor(ONE);

  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }

  t = new Ctor(0.03125);

  while (x.abs().gte(0.1)) {
    x = x.times(t);    // x = x / 2^5
    k += 5;
  }

  // Estimate the precision increase necessary to ensure the first 4 rounding digits are correct.
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(ONE);
  Ctor.precision = wpr;

  for (;;) {
    pow = round$1(pow.times(x), wpr);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow, denominator, wpr));

    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      while (k--) sum = round$1(sum.times(sum), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round$1(sum, pr)) : sum;
    }

    sum = t;
  }
}


// Calculate the base 10 exponent from the base 1e7 exponent.
function getBase10Exponent(x) {
  var e = x.e * LOG_BASE,
    w = x.d[0];

  // Add the number of digits of the first word of the digits array.
  for (; w >= 10; w /= 10) e++;
  return e;
}


function getLn10(Ctor, sd, pr) {

  if (sd > Ctor.LN10.sd()) {


    // Reset global state in case the exception is caught.
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(decimalError + 'LN10 precision limit exceeded');
  }

  return round$1(new Ctor(Ctor.LN10), sd);
}


function getZeroString(k) {
  var zs = '';
  for (; k--;) zs += '0';
  return zs;
}


/*
 * Return a new Decimal whose value is the natural logarithm of `x` truncated to `sd` significant
 * digits.
 *
 *  ln(n) is non-terminating (n != 1)
 *
 */
function ln(y, sd) {
  var c, c0, denominator, e, numerator, sum, t, wpr, x2,
    n = 1,
    guard = 10,
    x = y,
    xd = x.d,
    Ctor = x.constructor,
    pr = Ctor.precision;

  // ln(-x) = NaN
  // ln(0) = -Infinity
  if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));

  // ln(1) = 0
  if (x.eq(ONE)) return new Ctor(0);

  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }

  if (x.eq(10)) {
    if (sd == null) external = true;
    return getLn10(Ctor, wpr);
  }

  wpr += guard;
  Ctor.precision = wpr;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  e = getBase10Exponent(x);

  if (Math.abs(e) < 1.5e15) {

    // Argument reduction.
    // The series converges faster the closer the argument is to 1, so using
    // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
    // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
    // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
    // later be divided by this number, then separate out the power of 10 using
    // ln(a*10^b) = ln(a) + b*ln(10).

    // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
    //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
    // max n is 6 (gives 0.7 - 1.3)
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }

    e = getBase10Exponent(x);

    if (c0 > 1) {
      x = new Ctor('0.' + c);
      e++;
    } else {
      x = new Ctor(c0 + '.' + c.slice(1));
    }
  } else {

    // The argument reduction method above may result in overflow if the argument y is a massive
    // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
    // function using ln(x*10^e) = ln(x) + e*ln(10).
    t = getLn10(Ctor, wpr + 2, pr).times(e + '');
    x = ln(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);

    Ctor.precision = pr;
    return sd == null ? (external = true, round$1(x, pr)) : x;
  }

  // x is reduced to a value near 1.

  // Taylor series.
  // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
  // where x = (y - 1)/(y + 1)    (|x| < 1)
  sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
  x2 = round$1(x.times(x), wpr);
  denominator = 3;

  for (;;) {
    numerator = round$1(numerator.times(x2), wpr);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr));

    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);

      // Reverse the argument reduction.
      if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
      sum = divide(sum, new Ctor(n), wpr);

      Ctor.precision = pr;
      return sd == null ? (external = true, round$1(sum, pr)) : sum;
    }

    sum = t;
    denominator += 2;
  }
}


/*
 * Parse the value of a new Decimal `x` from string `str`.
 */
function parseDecimal(x, str) {
  var e, i, len;

  // Decimal point?
  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

  // Exponential form?
  if ((i = str.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = str.length;
  }

  // Determine leading zeros.
  for (i = 0; str.charCodeAt(i) === 48;) ++i;

  // Determine trailing zeros.
  for (len = str.length; str.charCodeAt(len - 1) === 48;) --len;
  str = str.slice(i, len);

  if (str) {
    len -= i;
    e = e - i - 1;
    x.e = mathfloor(e / LOG_BASE);
    x.d = [];

    // Transform base

    // e is the base 10 exponent.
    // i is where to slice str to get the first word of the digits array.
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;

    if (i < len) {
      if (i) x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }

    for (; i--;) str += '0';
    x.d.push(+str);

    if (external && (x.e > MAX_E || x.e < -MAX_E)) throw Error(exponentOutOfRange + e);
  } else {

    // Zero.
    x.s = 0;
    x.e = 0;
    x.d = [0];
  }

  return x;
}


/*
 * Round `x` to `sd` significant digits, using rounding mode `rm` if present (truncate otherwise).
 */
 function round$1(x, sd, rm) {
  var i, j, k, n, rd, doRound, w, xdi,
    xd = x.d;

  // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
  // w: the word of xd which contains the rounding digit, a base 1e7 number.
  // xdi: the index of w within xd.
  // n: the number of digits of w.
  // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
  // they had leading zeros)
  // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

  // Get the length of the first word of the digits array xd.
  for (n = 1, k = xd[0]; k >= 10; k /= 10) n++;
  i = sd - n;

  // Is the rounding digit in the first word of xd?
  if (i < 0) {
    i += LOG_BASE;
    j = sd;
    w = xd[xdi = 0];
  } else {
    xdi = Math.ceil((i + 1) / LOG_BASE);
    k = xd.length;
    if (xdi >= k) return x;
    w = k = xd[xdi];

    // Get the number of digits of w.
    for (n = 1; k >= 10; k /= 10) n++;

    // Get the index of rd within w.
    i %= LOG_BASE;

    // Get the index of rd within w, adjusted for leading zeros.
    // The number of leading zeros of w is given by LOG_BASE - n.
    j = i - LOG_BASE + n;
  }

  if (rm !== void 0) {
    k = mathpow(10, n - j - 1);

    // Get the rounding digit at index j of w.
    rd = w / k % 10 | 0;

    // Are there any non-zero digits after the rounding digit?
    doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;

    // The expression `w % mathpow(10, n - j - 1)` returns all the digits of w to the right of the
    // digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression will give
    // 714.

    doRound = rm < 4
      ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
      : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 &&

        // Check whether the digit to the left of the rounding digit is odd.
        ((i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
          rm == (x.s < 0 ? 8 : 7));
  }

  if (sd < 1 || !xd[0]) {
    if (doRound) {
      k = getBase10Exponent(x);
      xd.length = 1;

      // Convert sd to decimal places.
      sd = sd - k - 1;

      // 1, 0.1, 0.01, 0.001, 0.0001 etc.
      xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
      x.e = mathfloor(-sd / LOG_BASE) || 0;
    } else {
      xd.length = 1;

      // Zero.
      xd[0] = x.e = x.s = 0;
    }

    return x;
  }

  // Remove excess digits.
  if (i == 0) {
    xd.length = xdi;
    k = 1;
    xdi--;
  } else {
    xd.length = xdi + 1;
    k = mathpow(10, LOG_BASE - i);

    // E.g. 56700 becomes 56000 if 7 is the rounding digit.
    // j > 0 means i > number of leading zeros of w.
    xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
  }

  if (doRound) {
    for (;;) {

      // Is the digit to be rounded up in the first word of xd?
      if (xdi == 0) {
        if ((xd[0] += k) == BASE) {
          xd[0] = 1;
          ++x.e;
        }

        break;
      } else {
        xd[xdi] += k;
        if (xd[xdi] != BASE) break;
        xd[xdi--] = 0;
        k = 1;
      }
    }
  }

  // Remove trailing zeros.
  for (i = xd.length; xd[--i] === 0;) xd.pop();

  if (external && (x.e > MAX_E || x.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x));
  }

  return x;
}


function subtract(x, y) {
  var d, e, i, j, k, len, xd, xe, xLTy, yd,
    Ctor = x.constructor,
    pr = Ctor.precision;

  // Return y negated if x is zero.
  // Return x if y is zero and x is non-zero.
  if (!x.s || !y.s) {
    if (y.s) y.s = -y.s;
    else y = new Ctor(x);
    return external ? round$1(y, pr) : y;
  }

  xd = x.d;
  yd = y.d;

  // x and y are non-zero numbers with the same sign.

  e = y.e;
  xe = x.e;
  xd = xd.slice();
  k = xe - e;

  // If exponents differ...
  if (k) {
    xLTy = k < 0;

    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }

    // Numbers with massively different exponents would result in a very high number of zeros
    // needing to be prepended, but this can be avoided while still ensuring correct rounding by
    // limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

    if (k > i) {
      k = i;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents.
    d.reverse();
    for (i = k; i--;) d.push(0);
    d.reverse();

  // Base 1e7 exponents equal.
  } else {

    // Check digits to determine which is the bigger number.

    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;

    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }

    k = 0;
  }

  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }

  len = xd.length;

  // Append zeros to xd if shorter.
  // Don't add zeros to yd if shorter as subtraction only needs to start at yd length.
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

  // Subtract yd from xd.
  for (i = yd.length; i > k;) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }

    xd[i] -= yd[i];
  }

  // Remove trailing zeros.
  for (; xd[--len] === 0;) xd.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xd[0] === 0; xd.shift()) --e;

  // Zero?
  if (!xd[0]) return new Ctor(0);

  y.d = xd;
  y.e = e;

  //return external && xd.length >= pr / LOG_BASE ? round(y, pr) : y;
  return external ? round$1(y, pr) : y;
}


function toString(x, isExp, sd) {
  var k,
    e = getBase10Exponent(x),
    str = digitsToString(x.d),
    len = str.length;

  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + '.' + str.slice(1);
    }

    str = str + (e < 0 ? 'e' : 'e+') + e;
  } else if (e < 0) {
    str = '0.' + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0) str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
  } else {
    if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len) str += '.';
      str += getZeroString(k);
    }
  }

  return x.s < 0 ? '-' + str : str;
}


// Does not strip trailing zeros.
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}


// Decimal methods


/*
 *  clone
 *  config/set
 */


/*
 * Create and return a Decimal constructor with the same configuration properties as this Decimal
 * constructor.
 *
 */
function clone(obj) {
  var i, p, ps;

  /*
   * The Decimal constructor and exported function.
   * Return a new Decimal instance.
   *
   * value {number|string|Decimal} A numeric value.
   *
   */
  function Decimal(value) {
    var x = this;

    // Decimal called without new.
    if (!(x instanceof Decimal)) return new Decimal(value);

    // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
    // which points to Object.
    x.constructor = Decimal;

    // Duplicate.
    if (value instanceof Decimal) {
      x.s = value.s;
      x.e = value.e;
      x.d = (value = value.d) ? value.slice() : value;
      return;
    }

    if (typeof value === 'number') {

      // Reject Infinity/NaN.
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }

      if (value > 0) {
        x.s = 1;
      } else if (value < 0) {
        value = -value;
        x.s = -1;
      } else {
        x.s = 0;
        x.e = 0;
        x.d = [0];
        return;
      }

      // Fast path for small integers.
      if (value === ~~value && value < 1e7) {
        x.e = 0;
        x.d = [value];
        return;
      }

      return parseDecimal(x, value.toString());
    } else if (typeof value !== 'string') {
      throw Error(invalidArgument + value);
    }

    // Minus sign?
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x.s = -1;
    } else {
      x.s = 1;
    }

    if (isDecimal.test(value)) parseDecimal(x, value);
    else throw Error(invalidArgument + value);
  }

  Decimal.prototype = P$1;

  Decimal.ROUND_UP = 0;
  Decimal.ROUND_DOWN = 1;
  Decimal.ROUND_CEIL = 2;
  Decimal.ROUND_FLOOR = 3;
  Decimal.ROUND_HALF_UP = 4;
  Decimal.ROUND_HALF_DOWN = 5;
  Decimal.ROUND_HALF_EVEN = 6;
  Decimal.ROUND_HALF_CEIL = 7;
  Decimal.ROUND_HALF_FLOOR = 8;

  Decimal.clone = clone;
  Decimal.config = Decimal.set = config;

  if (obj === void 0) obj = {};
  if (obj) {
    ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'LN10'];
    for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
  }

  Decimal.config(obj);

  return Decimal;
}


/*
 * Configure global settings for a Decimal constructor.
 *
 * `obj` is an object with one or more of the following properties,
 *
 *   precision  {number}
 *   rounding   {number}
 *   toExpNeg   {number}
 *   toExpPos   {number}
 *
 * E.g. Decimal.config({ precision: 20, rounding: 4 })
 *
 */
function config(obj) {
  if (!obj || typeof obj !== 'object') {
    throw Error(decimalError + 'Object expected');
  }
  var i, p, v,
    ps = [
      'precision', 1, MAX_DIGITS,
      'rounding', 0, 8,
      'toExpNeg', -1 / 0, 0,
      'toExpPos', 0, 1 / 0
    ];

  for (i = 0; i < ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ': ' + v);
    }
  }

  if ((v = obj[p = 'LN10']) !== void 0) {
      if (v == Math.LN10) this[p] = new this(v);
      else throw Error(invalidArgument + p + ': ' + v);
  }

  return this;
}


// Create and configure initial Decimal constructor.
var Decimal$1 = clone(defaults);

// Internal constant.
ONE = new Decimal$1(1);

var _Decimal = Decimal$1;

/*
 *  big.js v5.2.2
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>
 *  https://github.com/MikeMcl/big.js/LICENCE
 */


/************************************** EDITABLE DEFAULTS *****************************************/


  // The default values below must be integers within the stated ranges.

  /*
   * The maximum number of decimal places (DP) of the results of operations involving division:
   * div and sqrt, and pow with negative exponents.
   */
var DP = 20,          // 0 to MAX_DP

  /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */
  RM = 1,             // 0, 1, 2 or 3

  // The maximum value of DP and Big.DP.
  MAX_DP = 1E6,       // 0 to 1000000

  // The maximum magnitude of the exponent argument to the pow method.
  MAX_POWER = 1E6,    // 1 to 1000000

  /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */
  NE = -7,            // 0 to -1000000

  /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big.
   * (This limit is not enforced or checked.)
   */
  PE = 21,            // 0 to 1000000


/**************************************************************************************************/


  // Error messages.
  NAME = '[big.js] ',
  INVALID = NAME + 'Invalid ',
  INVALID_DP = INVALID + 'decimal places',
  INVALID_RM = INVALID + 'rounding mode',
  DIV_BY_ZERO = NAME + 'Division by zero',

  // The shared prototype object.
  P = {},
  UNDEFINED = void 0,
  NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;


/*
 * Create and return a Big constructor.
 *
 */
function _Big_() {

  /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
  function Big(n) {
    var x = this;

    // Enable constructor usage without new.
    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

    // Duplicate.
    if (n instanceof Big) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      parse(x, n);
    }

    /*
     * Retain a reference to this Big constructor, and shadow Big.prototype.constructor which
     * points to Object.
     */
    x.constructor = Big;
  }

  Big.prototype = P;
  Big.DP = DP;
  Big.RM = RM;
  Big.NE = NE;
  Big.PE = PE;
  Big.version = '5.2.2';

  return Big;
}


/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse(x, n) {
  var e, i, nl;

  // Minus zero?
  if (n === 0 && 1 / n < 0) n = '-0';
  else if (!NUMERIC.test(n += '')) throw Error(INVALID + 'number');

  // Determine sign.
  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

  // Decimal point?
  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

  // Exponential form?
  if ((i = n.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = n.length;
  }

  nl = n.length;

  // Determine leading zeros.
  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;

  if (i == nl) {

    // Zero.
    x.c = [x.e = 0];
  } else {

    // Determine trailing zeros.
    for (; nl > 0 && n.charAt(--nl) == '0';);
    x.e = e - i - 1;
    x.c = [];

    // Convert string to array of digits without leading/trailing zeros.
    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
  }

  return x;
}


/*
 * Round Big x to a maximum of dp decimal places using rounding mode rm.
 * Called by stringify, P.div, P.round and P.sqrt.
 *
 * x {Big} The Big to round.
 * dp {number} Integer, 0 to MAX_DP inclusive.
 * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)
 * [more] {boolean} Whether the result of division was truncated.
 */
function round(x, dp, rm, more) {
  var xc = x.c,
    i = x.e + dp + 1;

  if (i < xc.length) {
    if (rm === 1) {

      // xc[i] is the digit after the digit that may be rounded up.
      more = xc[i] >= 5;
    } else if (rm === 2) {
      more = xc[i] > 5 || xc[i] == 5 &&
        (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);
    } else if (rm === 3) {
      more = more || !!xc[0];
    } else {
      more = false;
      if (rm !== 0) throw Error(INVALID_RM);
    }

    if (i < 1) {
      xc.length = 1;

      if (more) {

        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
        x.e = -dp;
        xc[0] = 1;
      } else {

        // Zero.
        xc[0] = x.e = 0;
      }
    } else {

      // Remove any digits after the required decimal places.
      xc.length = i--;

      // Round up?
      if (more) {

        // Rounding up may mean the previous digit has to be rounded up.
        for (; ++xc[i] > 9;) {
          xc[i] = 0;
          if (!i--) {
            ++x.e;
            xc.unshift(1);
          }
        }
      }

      // Remove trailing zeros.
      for (i = xc.length; !xc[--i];) xc.pop();
    }
  } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
    throw Error(INVALID_RM);
  }

  return x;
}


/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 *
 * x {Big}
 * id? {number} Caller id.
 *         1 toExponential
 *         2 toFixed
 *         3 toPrecision
 *         4 valueOf
 * n? {number|undefined} Caller's argument.
 * k? {number|undefined}
 */
function stringify(x, id, n, k) {
  var e, s,
    Big = x.constructor,
    z = !x.c[0];

  if (n !== UNDEFINED) {
    if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
      throw Error(id == 3 ? INVALID + 'precision' : INVALID_DP);
    }

    x = new Big(x);

    // The index of the digit that may be rounded up.
    n = k - x.e;

    // Round?
    if (x.c.length > ++k) round(x, n, Big.RM);

    // toFixed: recalculate k as x.e may have changed if value rounded up.
    if (id == 2) k = x.e + n + 1;

    // Append zeros?
    for (; x.c.length < k;) x.c.push(0);
  }

  e = x.e;
  s = x.c.join('');
  n = s.length;

  // Exponential notation?
  if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big.NE || e >= Big.PE)) {
    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

  // Normal notation.
  } else if (e < 0) {
    for (; ++e;) s = '0' + s;
    s = '0.' + s;
  } else if (e > 0) {
    if (++e > n) for (e -= n; e--;) s += '0';
    else if (e < n) s = s.slice(0, e) + '.' + s.slice(e);
  } else if (n > 1) {
    s = s.charAt(0) + '.' + s.slice(1);
  }

  return x.s < 0 && (!z || id == 4) ? '-' + s : s;
}


// Prototype/instance methods


/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};


/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
*/
P.cmp = function (y) {
  var isneg,
    x = this,
    xc = x.c,
    yc = (y = new x.constructor(y)).c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  isneg = i < 0;

  // Compare exponents.
  if (k != l) return k > l ^ isneg ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = -1; ++i < j;) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }

  // Compare lengths.
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};


/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
  var x = this,
    Big = x.constructor,
    a = x.c,                  // dividend
    b = (y = new Big(y)).c,   // divisor
    k = x.s == y.s ? 1 : -1,
    dp = Big.DP;

  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) throw Error(INVALID_DP);

  // Divisor is zero?
  if (!b[0]) throw Error(DIV_BY_ZERO);

  // Dividend is 0? Return +-0.
  if (!a[0]) return new Big(k * 0);

  var bl, bt, n, cmp, ri,
    bz = b.slice(),
    ai = bl = b.length,
    al = a.length,
    r = a.slice(0, bl),   // remainder
    rl = r.length,
    q = y,                // quotient
    qc = q.c = [],
    qi = 0,
    d = dp + (q.e = x.e - y.e) + 1;    // number of digits of the result

  q.s = k;
  k = d < 0 ? 0 : d;

  // Create version of divisor with leading zero.
  bz.unshift(0);

  // Add zeros to make remainder as long as divisor.
  for (; rl++ < bl;) r.push(0);

  do {

    // n is how many times the divisor goes into current remainder.
    for (n = 0; n < 10; n++) {

      // Compare divisor and remainder.
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl;) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }

      // If divisor < remainder, subtract divisor from remainder.
      if (cmp < 0) {

        // Remainder can't be more than 1 digit longer than divisor.
        // Equalise lengths using divisor with extra leading zero?
        for (bt = rl == bl ? b : bz; rl;) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri];) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }

        for (; !r[0];) r.shift();
      } else {
        break;
      }
    }

    // Add the digit n to the result array.
    qc[qi++] = cmp ? n : ++n;

    // Update the remainder.
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];

  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

  // Leading zero? Do not remove if result is simply zero (qi == 1).
  if (!qc[0] && qi != 1) {

    // There can't be more than one zero.
    qc.shift();
    q.e--;
  }

  // Round?
  if (qi > d) round(q, dp, Big.RM, r[0] !== UNDEFINED);

  return q;
};


/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
  return !this.cmp(y);
};


/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
  return this.cmp(y) > -1;
};


/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
  var i, j, t, xlty,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }

  var xc = x.c.slice(),
    xe = x.e,
    yc = y.c,
    ye = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) {

    // y is non-zero? x is non-zero? Or both are zero.
    return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);
  }

  // Determine which is the bigger number. Prepend zeros to equalise exponents.
  if (a = xe - ye) {

    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }

    t.reverse();
    for (b = a; b--;) t.push(0);
    t.reverse();
  } else {

    // Exponents equal. Check digit by digit.
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;

    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }

  // x < y? Point xc to the array of the bigger number.
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }

  /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

  // Subtract yc from xc.
  for (b = i; j > a;) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i];) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }

    xc[j] -= yc[j];
  }

  // Remove trailing zeros.
  for (; xc[--b] === 0;) xc.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xc[0] === 0;) {
    xc.shift();
    --ye;
  }

  if (!xc[0]) {

    // n - n = +0
    y.s = 1;

    // Result must be zero.
    xc = [ye = 0];
  }

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
  var ygtx,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  if (!y.c[0]) throw Error(DIV_BY_ZERO);

  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;

  if (ygtx) return new Big(x);

  a = Big.DP;
  b = Big.RM;
  Big.DP = Big.RM = 0;
  x = x.div(y);
  Big.DP = a;
  Big.RM = b;

  return this.minus(x.times(y));
};


/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
  var t,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.minus(y);
  }

  var xe = x.e,
    xc = x.c,
    ye = y.e,
    yc = y.c;

  // Either zero? y is non-zero? x is non-zero? Or both are zero.
  if (!xc[0] || !yc[0]) return yc[0] ? y : new Big(xc[0] ? x : a * 0);

  xc = xc.slice();

  // Prepend zeros to equalise exponents.
  // Note: reverse faster than unshifts.
  if (a = xe - ye) {
    if (a > 0) {
      ye = xe;
      t = yc;
    } else {
      a = -a;
      t = xc;
    }

    t.reverse();
    for (; a--;) t.push(0);
    t.reverse();
  }

  // Point xc to the longer array.
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }

  a = yc.length;

  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
  for (b = 0; a; xc[a] %= 10) b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;

  // No need to check for zero, as +x + +y != 0 && -x + -y != 0

  if (b) {
    xc.unshift(b);
    ++ye;
  }

  // Remove trailing zeros.
  for (a = xc.length; xc[--a] === 0;) xc.pop();

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
  var x = this,
    one = new x.constructor(1),
    y = one,
    isneg = n < 0;

  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) throw Error(INVALID + 'exponent');
  if (isneg) n = -n;

  for (;;) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }

  return isneg ? one.div(y) : y;
};


/*
 * Return a new Big whose value is the value of this Big rounded using rounding mode rm
 * to a maximum of dp decimal places, or, if dp is negative, to an integer which is a
 * multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 * If rm is not specified, use Big.RM.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)
 */
P.round = function (dp, rm) {
  var Big = this.constructor;
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) throw Error(INVALID_DP);
  return round(new Big(this), dp, rm === UNDEFINED ? Big.RM : rm);
};


/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
  var r, c, t,
    x = this,
    Big = x.constructor,
    s = x.s,
    e = x.e,
    half = new Big(0.5);

  // Zero?
  if (!x.c[0]) return new Big(x);

  // Negative?
  if (s < 0) throw Error(NAME + 'No square root');

  // Estimate.
  s = Math.sqrt(x + '');

  // Math.sqrt underflow/overflow?
  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
  if (s === 0 || s === 1 / 0) {
    c = x.c.join('');
    if (!(c.length + e & 1)) c += '0';
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big((s == 1 / 0 ? '1e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
  } else {
    r = new Big(s);
  }

  e = r.e + (Big.DP += 4);

  // Newton-Raphson iteration.
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));

  return round(r, Big.DP -= 4, Big.RM);
};


/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
  var c,
    x = this,
    Big = x.constructor,
    xc = x.c,
    yc = (y = new Big(y)).c,
    a = xc.length,
    b = yc.length,
    i = x.e,
    j = y.e;

  // Determine sign of result.
  y.s = x.s == y.s ? 1 : -1;

  // Return signed 0 if either 0.
  if (!xc[0] || !yc[0]) return new Big(y.s * 0);

  // Initialise exponent of result as x.e + y.e.
  y.e = i + j;

  // If array xc has fewer digits than yc, swap xc and yc, and lengths.
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }

  // Initialise coefficient array of result with zeros.
  for (c = new Array(j = a + b); j--;) c[j] = 0;

  // Multiply.

  // i is initially xc.length.
  for (i = b; i--;) {
    b = 0;

    // a is yc.length.
    for (j = a + i; j > i;) {

      // Current sum of products at this digit position, plus carry.
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;

      // carry
      b = b / 10 | 0;
    }

    c[j] = (c[j] + b) % 10;
  }

  // Increment result exponent if there is a final carry, otherwise remove leading zero.
  if (b) ++y.e;
  else c.shift();

  // Remove trailing zeros.
  for (i = c.length; !c[--i];) c.pop();
  y.c = c;

  return y;
};


/*
 * Return a string representing the value of this Big in exponential notation to dp fixed decimal
 * places and rounded using Big.RM.
 *
 * dp? {number} Integer, 0 to MAX_DP inclusive.
 */
P.toExponential = function (dp) {
  return stringify(this, 1, dp, dp);
};


/*
 * Return a string representing the value of this Big in normal notation to dp fixed decimal
 * places and rounded using Big.RM.
 *
 * dp? {number} Integer, 0 to MAX_DP inclusive.
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp) {
  return stringify(this, 2, dp, this.e + dp);
};


/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * Big.RM. Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Integer, 1 to MAX_DP inclusive.
 */
P.toPrecision = function (sd) {
  return stringify(this, 3, sd, sd - 1);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P.toString = function () {
  return stringify(this);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = P.toJSON = function () {
  return stringify(this, 4);
};


// Export


var Big$1 = _Big_();

var toFormat$1 = {exports: {}};

/*
 *  toFormat v2.0.0
 *  Adds a toFormat instance method to big.js or decimal.js
 *  Copyright (c) 2017 Michael Mclaughlin
 *  MIT Licence
 */

(function (module) {
/*
 * Adds a `toFormat` method to `Ctor.prototype` and a `format` object to `Ctor`, where `Ctor` is
 * a big number constructor such as `Decimal` (decimal.js) or `Big` (big.js).
 */
function toFormat(Ctor) {

  /*
   *  Returns a string representing the value of this big number in fixed-point notation to `dp`
   *  decimal places using rounding mode `rm`, and formatted according to the properties of the
   * `fmt`, `this.format` and `this.constructor.format` objects, in that order of precedence.
   *
   *  Example:
   *
   *  x = new Decimal('123456789.987654321')
   *
   *  // Add a format object to the constructor...
   *  Decimal.format = {
   *    decimalSeparator: '.',
   *    groupSeparator: ',',
   *    groupSize: 3,
   *    secondaryGroupSize: 0,
   *    fractionGroupSeparator: '',     // '\xA0' non-breaking space
   *    fractionGroupSize : 0
   *  }
   *
   *  x.toFormat();                // 123,456,789.987654321
   *  x.toFormat(2, 1);            // 123,456,789.98
   *
   *  // And/or add a format object to the big number itself...
   *  x.format = {
   *    decimalSeparator: ',',
   *    groupSeparator: '',
   *  }
   *
   *  x.toFormat();                // 123456789,987654321
   *
   *  format = {
   *    decimalSeparator: '.',
   *    groupSeparator: ' ',
   *    groupSize: 3,
   *    fractionGroupSeparator: ' ',     // '\xA0' non-breaking space
   *    fractionGroupSize : 5
   *  }

   *  // And/or pass a format object to the method call.
   *  x.toFormat(format);          // 123 456 789.98765 4321
   *  x.toFormat(4, format);       // 123 456 789.9877
   *  x.toFormat(2, 1, format);    // 123 456 789.98
   *
   *  [dp] {number} Decimal places. Integer.
   *  [rm] {number} Rounding mode. Integer, 0 to 8. (Ignored if using big.js.)
   *  [fmt] {Object} A format object.
   *
   */
  Ctor.prototype.toFormat = function toFormat(dp, rm, fmt) {

    if (!this.e && this.e !== 0) return this.toString();   // Infinity/NaN

    var arr, g1, g2, i,
      u,                             // undefined
      nd,                            // number of integer digits
      intd,                          // integer digits
      intp,                          // integer part
      fracp,                         // fraction part
      dsep,                          // decimalSeparator
      gsep,                          // groupSeparator
      gsize,                         // groupSize
      sgsize,                        // secondaryGroupSize
      fgsep,                         // fractionGroupSeparator
      fgsize,                        // fractionGroupSize
      tfmt = this.format || {},
      cfmt = this.constructor.format || {};

    if (dp != u) {
      if (typeof dp == 'object') {
        fmt = dp;
        dp = u;
      } else if (rm != u) {
        if (typeof rm == 'object') {
          fmt = rm;
          rm = u;
        } else if (typeof fmt != 'object') {
          fmt = {};
        }
      } else {
        fmt = {};
      }
    } else {
      fmt = {};
    }

    arr = this.toFixed(dp, rm).split('.');
    intp = arr[0];
    fracp = arr[1];
    intd = this.s < 0 ? intp.slice(1) : intp;
    nd = intd.length;

    dsep = fmt.decimalSeparator;
    if (dsep == u) {
      dsep = tfmt.decimalSeparator;
      if (dsep == u) {
        dsep = cfmt.decimalSeparator;
        if (dsep == u) dsep = '.';
      }
    }

    gsep = fmt.groupSeparator;
    if (gsep == u) {
      gsep = tfmt.groupSeparator;
      if (gsep == u) gsep = cfmt.groupSeparator;
    }

    if (gsep) {
      gsize = fmt.groupSize;
      if (gsize == u) {
        gsize = tfmt.groupSize;
        if (gsize == u) {
          gsize = cfmt.groupSize;
          if (gsize == u) gsize = 0;
        }
      }

      sgsize = fmt.secondaryGroupSize;
      if (sgsize == u) {
        sgsize = tfmt.secondaryGroupSize;
        if (sgsize == u) {
          sgsize = cfmt.secondaryGroupSize;
          if (sgsize == u) sgsize = 0;
        }
      }

      if (sgsize) {
        g1 = +sgsize;
        g2 = +gsize;
        nd -= g2;
      } else {
        g1 = +gsize;
        g2 = +sgsize;
      }

      if (g1 > 0 && nd > 0) {
        i = nd % g1 || g1;
        intp = intd.substr(0, i);
        for (; i < nd; i += g1) intp += gsep + intd.substr(i, g1);
        if (g2 > 0) intp += gsep + intd.slice(i);
        if (this.s < 0) intp = '-' + intp;
      }
    }

    if (fracp) {
      fgsep = fmt.fractionGroupSeparator;
      if (fgsep == u) {
        fgsep = tfmt.fractionGroupSeparator;
        if (fgsep == u) fgsep = cfmt.fractionGroupSeparator;
      }

      if (fgsep) {
        fgsize = fmt.fractionGroupSize;
        if (fgsize == u) {
          fgsize = tfmt.fractionGroupSize;
          if (fgsize == u) {
            fgsize = cfmt.fractionGroupSize;
            if (fgsize == u) fgsize = 0;
          }
        }

        fgsize = +fgsize;

        if (fgsize) {
          fracp = fracp.replace(new RegExp('\\d{' + fgsize + '}\\B', 'g'), '$&' + fgsep);
        }
      }

      return intp + dsep + fracp;
    } else {

      return intp;
    }
  };

  Ctor.format = {
    decimalSeparator: '.',
    groupSeparator: ',',
    groupSize: 3,
    secondaryGroupSize: 0,
    fractionGroupSeparator: '',
    fractionGroupSize: 0
  };

  return Ctor;
}

if (module.exports) module.exports = toFormat;
}(toFormat$1));

var toFormat = toFormat$1.exports;

var SupportedChainId;

(function (SupportedChainId) {
  SupportedChainId[SupportedChainId["MAINNET"] = 1] = "MAINNET";
  SupportedChainId[SupportedChainId["ROPSTEN"] = 3] = "ROPSTEN";
  SupportedChainId[SupportedChainId["RINKEBY"] = 4] = "RINKEBY";
  SupportedChainId[SupportedChainId["GOERLI"] = 5] = "GOERLI";
  SupportedChainId[SupportedChainId["KOVAN"] = 42] = "KOVAN";
  SupportedChainId[SupportedChainId["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  SupportedChainId[SupportedChainId["ARBITRUM_RINKEBY"] = 421611] = "ARBITRUM_RINKEBY";
  SupportedChainId[SupportedChainId["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  SupportedChainId[SupportedChainId["OPTIMISM"] = 10] = "OPTIMISM";
  SupportedChainId[SupportedChainId["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
  SupportedChainId[SupportedChainId["POLYGON"] = 137] = "POLYGON";
  SupportedChainId[SupportedChainId["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  SupportedChainId[SupportedChainId["CELO"] = 42220] = "CELO";
  SupportedChainId[SupportedChainId["CELO_ALFAJORES"] = 44787] = "CELO_ALFAJORES";
})(SupportedChainId || (SupportedChainId = {}));

var TradeType$1;

(function (TradeType) {
  TradeType[TradeType["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType[TradeType["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType$1 || (TradeType$1 = {}));

var Rounding;

(function (Rounding) {
  Rounding[Rounding["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding[Rounding["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding[Rounding["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding || (Rounding = {}));

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var _toSignificantRoundin, _toFixedRounding;
var Decimal = /*#__PURE__*/toFormat(_Decimal);
var Big = /*#__PURE__*/toFormat(Big$1);
var toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);
var toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);
var Fraction = /*#__PURE__*/function () {
  function Fraction(numerator, denominator) {
    if (denominator === void 0) {
      denominator = JSBI.BigInt(1);
    }

    this.numerator = JSBI.BigInt(numerator);
    this.denominator = JSBI.BigInt(denominator);
  }

  Fraction.tryParseFraction = function tryParseFraction(fractionish) {
    if (fractionish instanceof JSBI || typeof fractionish === 'number' || typeof fractionish === 'string') return new Fraction(fractionish);
    if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish;
    throw new Error('Could not parse fraction');
  } // performs floor division
  ;

  var _proto = Fraction.prototype;

  _proto.invert = function invert() {
    return new Fraction(this.denominator, this.numerator);
  };

  _proto.add = function add(other) {
    var otherParsed = Fraction.tryParseFraction(other);

    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);
    }

    return new Fraction(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };

  _proto.subtract = function subtract(other) {
    var otherParsed = Fraction.tryParseFraction(other);

    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);
    }

    return new Fraction(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };

  _proto.lessThan = function lessThan(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };

  _proto.equalTo = function equalTo(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };

  _proto.greaterThan = function greaterThan(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };

  _proto.multiply = function multiply(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return new Fraction(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));
  };

  _proto.divide = function divide(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return new Fraction(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));
  };

  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ''
      };
    }

    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }

    !Number.isInteger(significantDigits) ? process.env.NODE_ENV !== "production" ? invariant(false, significantDigits + " is not an integer.") : invariant(false) : void 0;
    !(significantDigits > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, significantDigits + " is not positive.") : invariant(false) : void 0;
    Decimal.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding[rounding]
    });
    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  };

  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ''
      };
    }

    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }

    !Number.isInteger(decimalPlaces) ? process.env.NODE_ENV !== "production" ? invariant(false, decimalPlaces + " is not an integer.") : invariant(false) : void 0;
    !(decimalPlaces >= 0) ? process.env.NODE_ENV !== "production" ? invariant(false, decimalPlaces + " is negative.") : invariant(false) : void 0;
    Big.DP = decimalPlaces;
    Big.RM = toFixedRounding[rounding];
    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  }
  /**
   * Helper method for converting any super class back to a fraction
   */
  ;

  _createClass(Fraction, [{
    key: "quotient",
    get: function get() {
      return JSBI.divide(this.numerator, this.denominator);
    } // remainder after floor division

  }, {
    key: "remainder",
    get: function get() {
      return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator);
    }
  }, {
    key: "asFraction",
    get: function get() {
      return new Fraction(this.numerator, this.denominator);
    }
  }]);

  return Fraction;
}();

var ONE_HUNDRED = /*#__PURE__*/new Fraction( /*#__PURE__*/JSBI.BigInt(100));
/**
 * Converts a fraction to a percent
 * @param fraction the fraction to convert
 */

function toPercent(fraction) {
  return new Percent(fraction.numerator, fraction.denominator);
}

var Percent = /*#__PURE__*/function (_Fraction) {
  _inheritsLoose(Percent, _Fraction);

  function Percent() {
    var _this;

    _this = _Fraction.apply(this, arguments) || this;
    /**
     * This boolean prevents a fraction from being interpreted as a Percent
     */

    _this.isPercent = true;
    return _this;
  }

  var _proto = Percent.prototype;

  _proto.add = function add(other) {
    return toPercent(_Fraction.prototype.add.call(this, other));
  };

  _proto.subtract = function subtract(other) {
    return toPercent(_Fraction.prototype.subtract.call(this, other));
  };

  _proto.multiply = function multiply(other) {
    return toPercent(_Fraction.prototype.multiply.call(this, other));
  };

  _proto.divide = function divide(other) {
    return toPercent(_Fraction.prototype.divide.call(this, other));
  };

  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 5;
    }

    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);
  };

  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 2;
    }

    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);
  };

  return Percent;
}(Fraction);

/**
 * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies
 */

var BaseCurrency =
/**
 * Constructs an instance of the base class `BaseCurrency`.
 * @param chainId the chain ID on which this currency resides
 * @param decimals decimals of the currency
 * @param symbol symbol of the currency
 * @param name of the currency
 */
function BaseCurrency(chainId, decimals, symbol, name) {
  !Number.isSafeInteger(chainId) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;
  !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;
  this.chainId = chainId;
  this.decimals = decimals;
  this.symbol = symbol;
  this.name = name;
};

/**
 * Validates an address and returns the parsed (checksummed) version of that address
 * @param address the unchecksummed hex address
 */

function validateAndParseAddress(address$1) {
  try {
    return address.getAddress(address$1);
  } catch (error) {
    throw new Error(address$1 + " is not a valid address.");
  }
} // Checks a string starts with 0x, is 42 characters long and contains only hex characters after 0x

var startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/;
/**
 * Checks if an address is valid by checking 0x prefix, length === 42 and hex encoding.
 * @param address the unchecksummed hex address
 */

function checkValidAddress(address) {
  if (startsWith0xLen42HexRegex.test(address)) {
    return address;
  }

  throw new Error(address + " is not a valid address.");
}

/**
 * Represents an ERC20 token with a unique address and some metadata.
 */

var Token = /*#__PURE__*/function (_BaseCurrency) {
  _inheritsLoose(Token, _BaseCurrency);

  /**
   *
   * @param chainId {@link BaseCurrency#chainId}
   * @param address The contract address on the chain on which this token lives
   * @param decimals {@link BaseCurrency#decimals}
   * @param symbol {@link BaseCurrency#symbol}
   * @param name {@link BaseCurrency#name}
   * @param bypassChecksum If true it only checks for length === 42, startsWith 0x and contains only hex characters
   */
  function Token(chainId, address, decimals, symbol, name, bypassChecksum) {
    var _this;

    _this = _BaseCurrency.call(this, chainId, decimals, symbol, name) || this;
    _this.isNative = false;
    _this.isToken = true;

    if (bypassChecksum) {
      _this.address = checkValidAddress(address);
    } else {
      _this.address = validateAndParseAddress(address);
    }

    return _this;
  }
  /**
   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.
   * @param other other token to compare
   */


  var _proto = Token.prototype;

  _proto.equals = function equals(other) {
    return other.isToken && this.chainId === other.chainId && this.address === other.address;
  }
  /**
   * Returns true if the address of this token sorts before the address of the other token
   * @param other other token to compare
   * @throws if the tokens have the same address
   * @throws if the tokens are on different chains
   */
  ;

  _proto.sortsBefore = function sortsBefore(other) {
    !(this.chainId === other.chainId) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CHAIN_IDS') : invariant(false) : void 0;
    !(this.address !== other.address) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ADDRESSES') : invariant(false) : void 0;
    return this.address.toLowerCase() < other.address.toLowerCase();
  }
  /**
   * Return this token, which does not need to be wrapped
   */
  ;

  _createClass(Token, [{
    key: "wrapped",
    get: function get() {
      return this;
    }
  }]);

  return Token;
}(BaseCurrency);

var _WETH;
/**
 * Known WETH9 implementation addresses, used in our implementation of Ether#wrapped
 */

(_WETH = {}, _WETH[1] = /*#__PURE__*/new Token(1, '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', 18, 'WETH', 'Wrapped Ether'), _WETH[3] = /*#__PURE__*/new Token(3, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[4] = /*#__PURE__*/new Token(4, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[5] = /*#__PURE__*/new Token(5, '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6', 18, 'WETH', 'Wrapped Ether'), _WETH[42] = /*#__PURE__*/new Token(42, '0xd0A1E359811322d97991E03f863a0C30C2cF029C', 18, 'WETH', 'Wrapped Ether'), _WETH[10] = /*#__PURE__*/new Token(10, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[69] = /*#__PURE__*/new Token(69, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[42161] = /*#__PURE__*/new Token(42161, '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1', 18, 'WETH', 'Wrapped Ether'), _WETH[421611] = /*#__PURE__*/new Token(421611, '0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681', 18, 'WETH', 'Wrapped Ether'), _WETH);

function computeFiatValuePriceImpact(fiatValueInput, fiatValueOutput) {
    if (!fiatValueOutput || !fiatValueInput)
        return undefined;
    //if (!fiatValueInput.currency.equals(fiatValueOutput.currency)) return undefined
    if (JSBI.equal(fiatValueInput.quotient, JSBI.BigInt(0)))
        return undefined;
    const pct = new Percent('1').subtract(fiatValueOutput.divide(fiatValueInput));
    return new Percent(pct.numerator, pct.denominator);
}

const ContentBox$3 = styled__default["default"](Box) `
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  padding: 15px;
  border-radius: 8px;
  margin-top: 10px;
`;
const DataBox$3 = styled__default["default"](Box) `
  align-items: center;
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const ValueText$1 = styled__default["default"](Text) `
  color: ${({ theme, severity }) => {
    var _a, _b;
    return severity === 3 || severity === 4
        ? theme.error
        : severity === 2
            ? theme.warning
            : severity === 1
                ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary
                : severity === 0
                    ? theme.success
                    : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.secondary;
}};
`;

const LimitOrderDetailInfo = ({ trade }) => {
    var _a, _b, _c, _d;
    const { chainId } = usePangolinWeb3();
    const { derivedOrderInfo: { parsedAmounts, rawAmounts }, } = limitOrdersReact.useGelatoLimitOrders();
    const { gasPrice, realExecutionPriceAsString } = limitOrdersReact.useGasOverhead(parsedAmounts.input, parsedAmounts.output);
    const priceText = realExecutionPriceAsString === 'never executes'
        ? realExecutionPriceAsString
        : `${(_b = '1 ' + ((_a = parsedAmounts === null || parsedAmounts === void 0 ? void 0 : parsedAmounts.input) === null || _a === void 0 ? void 0 : _a.currency.symbol) + ' = ' + realExecutionPriceAsString) !== null && _b !== void 0 ? _b : '-'} ${(_c = parsedAmounts === null || parsedAmounts === void 0 ? void 0 : parsedAmounts.output) === null || _c === void 0 ? void 0 : _c.currency.symbol}`;
    const formattedGasPrice = gasPrice ? `${parseFloat(units.formatUnits(gasPrice, 'gwei')).toFixed(0)} GWEI` : '-';
    const library = limitOrdersReact.useGelatoLimitOrdersLib();
    const outputAmount = parsedAmounts.output;
    const rawOutputAmount = (_d = rawAmounts.output) !== null && _d !== void 0 ? _d : '0';
    const { minReturn, slippagePercentage, gelatoFeePercentage } = React.useMemo(() => {
        var _a;
        if (!outputAmount || !library || !chainId)
            return {
                minReturn: undefined,
                slippagePercentage: undefined,
                gelatoFeePercentage: undefined,
            };
        const { minReturn } = library.getFeeAndSlippageAdjustedMinReturn(rawOutputAmount);
        const slippagePercentage = library.slippageBPS / 100;
        const gelatoFeePercentage = library.gelatoFeeBPS / 100;
        //const minReturnParsed = CurrencyAmount.fromRawAmount(trade?.outputAmount?.currency, minReturn)
        const minReturnParsed = new sdk.TokenAmount((_a = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _a === void 0 ? void 0 : _a.currency, minReturn);
        return {
            minReturn: minReturnParsed,
            slippagePercentage,
            gelatoFeePercentage,
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [outputAmount, chainId, library, rawOutputAmount]);
    const renderRow = (label, value) => {
        return (jsxRuntime.jsxs(DataBox$3, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 14 }, { children: label })), jsxRuntime.jsx(ValueText$1, Object.assign({ fontSize: 14 }, { children: value }))] }, label));
    };
    return (jsxRuntime.jsxs(ContentBox$3, { children: [renderRow('Gas Price', `${formattedGasPrice}`), renderRow('Real Execution Price', `${realExecutionPriceAsString ? `${priceText}` : '-'}`), renderRow('Gelato Fee', `${gelatoFeePercentage ? `${gelatoFeePercentage}` : '-'}%`), slippagePercentage !== INITIAL_ALLOWED_SLIPPAGE &&
                renderRow('Slippage Tolerance', `${slippagePercentage ? `${slippagePercentage}` : '-'}%`), renderRow(minReturn ? 'Minimum Received' : 'Maximum Sold', minReturn ? `${minReturn.toSignificant(4)} ${outputAmount ? outputAmount.currency.symbol : '-'}` : '-')] }));
};

function FiatValue({ fiatValue, priceImpact, }) {
    var _a;
    const theme = React.useContext(styled.ThemeContext);
    const priceImpactColor = React.useMemo(() => {
        var _a;
        if (!priceImpact)
            return undefined;
        if (priceImpact.lessThan('0'))
            return theme.success;
        const severity = warningSeverity(priceImpact);
        if (severity < 1)
            return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary;
        if (severity < 3)
            return theme.warning;
        return theme.error;
    }, [priceImpact, theme.success, theme.error, (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary, theme.warning]);
    return (jsxRuntime.jsxs(Text, Object.assign({ fontSize: 14, color: fiatValue ? 'swapWidget.primary' : 'swapWidget.secondary', ml: 10 }, { children: [fiatValue ? '~' : '', "$", fiatValue ? fiatValue === null || fiatValue === void 0 ? void 0 : fiatValue.toSignificant(6, { groupSeparator: ',' }) : '-', priceImpact ? (jsxRuntime.jsxs("span", Object.assign({ style: { color: priceImpactColor } }, { children: [" (", priceImpact.multiply('-1').toSignificant(3), "%)"] }))) : null] })));
}

const Root$j = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const Header$5 = styled__default["default"](Box) `
  padding: 0px 10px;
`;
const TokenRow$2 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: max-content auto max-content;
  align-items: center;
`;
styled__default["default"](Box) `
  padding: 10px;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 8px;
  margin-top: 15px;
`;
styled__default["default"](Text) `
  width: 100%;
  font-style: italic;
  font-size: 12px;
  text-align: left;
`;
const Footer$3 = styled__default["default"](Box) `
  padding: 0px 10px;
`;
const ErrorWrapper$6 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: minmax(300px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const ErrorBox$6 = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const SubmittedWrapper$3 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: minmax(300px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const Link$3 = styled__default["default"](Text) `
  text-decoration: none;
`;

const ConfirmLimitOrderDrawer = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { isOpen, onClose, trade, onAcceptChanges, recipient, onConfirm, attemptingTxn, swapErrorMessage, txHash } = props;
    const [showInverted, setShowInverted] = React.useState(false);
    const chainId = useChainId();
    const theme = React.useContext(styled.ThemeContext);
    const { derivedOrderInfo: { price, parsedAmounts }, } = limitOrdersReact.useGelatoLimitOrders();
    let formattedPrice;
    try {
        formattedPrice = showInverted ? price === null || price === void 0 ? void 0 : price.toSignificant(4) : (_a = price === null || price === void 0 ? void 0 : price.invert()) === null || _a === void 0 ? void 0 : _a.toSignificant(4);
    }
    catch (error) {
        formattedPrice = '0';
    }
    const label = showInverted ? `${(_b = price === null || price === void 0 ? void 0 : price.quoteCurrency) === null || _b === void 0 ? void 0 : _b.symbol}` : `${(_c = price === null || price === void 0 ? void 0 : price.baseCurrency) === null || _c === void 0 ? void 0 : _c.symbol} `;
    const labelInverted = showInverted ? `${(_d = price === null || price === void 0 ? void 0 : price.baseCurrency) === null || _d === void 0 ? void 0 : _d.symbol} ` : `${(_e = price === null || price === void 0 ? void 0 : price.quoteCurrency) === null || _e === void 0 ? void 0 : _e.symbol}`;
    const text = `${(_f = '1 ' + labelInverted + ' = ' + formattedPrice) !== null && _f !== void 0 ? _f : '-'} ${label}`;
    const flipPrice = React.useCallback(() => setShowInverted(!showInverted), [setShowInverted, showInverted]);
    const showAcceptChanges = false;
    const inputAmount = parsedAmounts.input;
    const outputAmount = parsedAmounts.output;
    const inputCurrency1 = inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.currency;
    const outputCurrency1 = outputAmount === null || outputAmount === void 0 ? void 0 : outputAmount.currency;
    const inputTokenInfo = inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.tokenInfo;
    const outputTokenInfo = outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.tokenInfo;
    const getInputCurrency = () => {
        if (inputCurrency1 && (inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.symbol) === sdk.CAVAX[chainId].symbol) {
            return sdk.CAVAX[chainId];
        }
        else if (inputTokenInfo && inputTokenInfo.symbol === sdk.CAVAX[chainId].symbol) {
            return sdk.CAVAX[chainId];
        }
        else if (inputTokenInfo) {
            return new sdk.Token(inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.chainId, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.address, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.decimals, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.symbol, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.name);
        }
        else if (inputCurrency1) {
            return new sdk.Token(inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.chainId, inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.address, inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.decimals, inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.symbol, inputCurrency1 === null || inputCurrency1 === void 0 ? void 0 : inputCurrency1.name);
        }
        else {
            return undefined;
        }
    };
    const getOutputCurrency = () => {
        if (outputCurrency1 && (outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.symbol) === sdk.CAVAX[chainId].symbol) {
            return sdk.CAVAX[chainId];
        }
        else if (outputTokenInfo && (outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.symbol) === sdk.CAVAX[chainId].symbol) {
            return sdk.CAVAX[chainId];
        }
        else if (outputTokenInfo) {
            return new sdk.Token(outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.chainId, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.address, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.decimals, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.symbol, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.name);
        }
        else if (outputCurrency1) {
            return new sdk.Token(outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.chainId, outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.address, outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.decimals, outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.symbol, outputCurrency1 === null || outputCurrency1 === void 0 ? void 0 : outputCurrency1.name);
        }
        else {
            return undefined;
        }
    };
    const inputCurrency = getInputCurrency();
    const outputCurrency = getOutputCurrency();
    const fiatValueInput = useUSDCPrice(inputCurrency);
    const fiatValueOutput = useUSDCPrice(outputCurrency);
    if (!inputAmount || !outputAmount)
        return null;
    // text to show while loading
    const pendingText = `Submitting order to swap ${(_g = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _g === void 0 ? void 0 : _g.toSignificant(6)} ${inputCurrency === null || inputCurrency === void 0 ? void 0 : inputCurrency.symbol} for ${(_h = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _h === void 0 ? void 0 : _h.toSignificant(6)} ${outputCurrency === null || outputCurrency === void 0 ? void 0 : outputCurrency.symbol}`;
    const ConfirmContent = (jsxRuntime.jsxs(Root$j, { children: [jsxRuntime.jsxs(Header$5, { children: [jsxRuntime.jsxs(TokenRow$2, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: inputCurrency, size: 24, imageSize: 48 }), jsxRuntime.jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: 'swapWidget.primary', style: { marginLeft: '12px' } }, { children: inputAmount.toSignificant(6) })), jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 24, fontWeight: 500, style: { marginLeft: '10px' } }, { children: inputCurrency === null || inputCurrency === void 0 ? void 0 : inputCurrency.symbol }))] }), jsxRuntime.jsx(reactFeather.ArrowDown, { size: "16", color: (_j = theme.swapWidget) === null || _j === void 0 ? void 0 : _j.interactiveColor, style: { marginLeft: '4px', minWidth: '16px' } }), jsxRuntime.jsxs(TokenRow$2, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: outputCurrency, size: 24, imageSize: 48 }), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, style: { marginLeft: '12px' }, color: 'swapWidget.primary' }, { children: outputAmount.toSignificant(6) })), jsxRuntime.jsx(FiatValue, { fiatValue: fiatValueOutput, priceImpact: computeFiatValuePriceImpact(fiatValueInput, fiatValueOutput) })] })), jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 24, fontWeight: 500, style: { marginLeft: '10px' } }, { children: outputCurrency === null || outputCurrency === void 0 ? void 0 : outputCurrency.symbol }))] }), showAcceptChanges , jsxRuntime.jsxs(Box, Object.assign({ mt: '30px', display: "flex", alignItems: "center", justifyContent: "space-between", onClick: flipPrice, style: { cursor: 'pointer' } }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 16 }, { children: "Limit Price" })), jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 16 }, { children: text }))] })), jsxRuntime.jsx(Box, Object.assign({ mt: '15px' }, { children: jsxRuntime.jsxs(Text, Object.assign({ color: "swapWidget.primary", fontSize: 16 }, { children: ["Output will be sent to", ' ', jsxRuntime.jsx("b", Object.assign({ title: recipient || '' }, { children: isAddress(recipient || '') ? shortenAddress(recipient || '', chainId) : recipient || '' }))] })) }))] }), jsxRuntime.jsxs(Footer$3, { children: [jsxRuntime.jsx(LimitOrderDetailInfo, { trade: trade }), jsxRuntime.jsx(Box, Object.assign({ my: '10px' }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onConfirm, isDisabled: showAcceptChanges }, { children: "Confirm Order" })) }))] })] }));
    const PendingContent = jsxRuntime.jsx(Loader, { size: 100, label: pendingText });
    const ErroContent = (jsxRuntime.jsxs(ErrorWrapper$6, { children: [jsxRuntime.jsxs(ErrorBox$6, { children: [jsxRuntime.jsx(reactFeather.AlertTriangle, { color: theme.error, style: { strokeWidth: 1.5 }, size: 64 }), jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'error', style: { textAlign: 'center', width: '85%' } }, { children: swapErrorMessage }))] }), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: "Dismiss" }))] }));
    const SubmittedContent = (jsxRuntime.jsxs(SubmittedWrapper$3, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", paddingY: '20px' }, { children: [jsxRuntime.jsx(Box, Object.assign({ flex: "1", display: "flex", alignItems: "center" }, { children: jsxRuntime.jsx(reactFeather.ArrowUpCircle, { strokeWidth: 0.5, size: 90, color: theme.primary }) })), jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontWeight: 500, fontSize: 20 }, { children: "Transaction Submitted" })), chainId && txHash && (jsxRuntime.jsx(Link$3, Object.assign({ as: "a", fontWeight: 500, fontSize: 14, color: 'primary', href: getEtherscanLink(chainId, txHash, 'transaction'), target: "_blank" }, { children: "View on explorer" })))] })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: "Close" }))] }));
    const getSwapError = () => {
        if (swapErrorMessage) {
            return ErroContent;
        }
        else if (txHash) {
            return SubmittedContent;
        }
        else if (attemptingTxn) {
            return PendingContent;
        }
        else {
            return ConfirmContent;
        }
    };
    return (jsxRuntime.jsx(Drawer, Object.assign({ title: swapErrorMessage || txHash || attemptingTxn ? '' : 'Confirm Order', isOpen: isOpen, onClose: onClose }, { children: getSwapError() })));
};

const Frame$4 = styled__default["default"](Box) `
  display: flex;
  flex-direction: column;
  gap: 15px;
  height: 100%;
  padding: 10px;
`;
const InputOptions$1 = styled__default["default"](Box) `
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 5px;
`;
const WarningButton = styled__default["default"](Button) `
  background-color: ${({ theme }) => theme.error};
  color: white;
`;
const Close = styled__default["default"](Button) `
  position: absolute;
  top: 15px;
  right: 15px;
  color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary; }};
  width: 30px;
  height: 30px;
`;
const ModalFrame = styled__default["default"](Box) `
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: justify;
  position: relative;

  width: 25vw;

  ${({ theme }) => theme.mediaWidth.upToSmall `
    width: 100% !important;
  `};

  ${({ theme }) => theme.mediaWidth.upToMedium `
    width: 50vw;
  `};
`;
const SettingsButton = styled__default["default"](Box) `
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveBgColor; }};
  color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveColor; }};
  border-radius: 4px;
  padding: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;

  &:hover,
  &:focus {
    opacity: 0.8;
  }
`;

const SwapWrapper$2 = styled__default["default"](Box) `
  width: 100%;
  /* min-width: 400px; */
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  position: relative;
  overflow: hidden;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
`;

const TradeOption$1 = ({ swapType, setSwapType, isLimitOrderVisible, showSettings = false, openSwapSettings = () => { }, }) => {
    return (jsxRuntime.jsx(SwapWrapper$2, { children: jsxRuntime.jsx(Box, Object.assign({ p: 10 }, { children: jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", style: { gap: '6px' } }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 24, fontWeight: 500, style: { flexGrow: 1 } }, { children: "Trade" })), showSettings && swapType === 'MARKET' && (jsxRuntime.jsx(SettingsButton, Object.assign({ onClick: openSwapSettings }, { children: jsxRuntime.jsx(reactFeather.Settings, { size: 20 }) }))), isLimitOrderVisible && (jsxRuntime.jsx(Box, Object.assign({ width: "130px" }, { children: jsxRuntime.jsx(ToggleButtons, { options: Object.values(exports.SwapTypes), value: swapType, onChange: (value) => {
                                setSwapType(value);
                            } }) })))] })) })) }));
};

const WarningWrapper = styled__default["default"].div `
  border-radius: 20px;
  border: ${({ theme }) => `1px solid ${theme.error}`};
  background: rgba(248, 45, 58, 0.05);
  padding: 1rem;
  color: ${({ theme }) => theme.error};
  position: relative;
  @media screen and (max-width: 800px) {
    width: 80% !important;
    margin-left: 5%;
  }
`;
const StyledWarningIcon$1 = styled__default["default"](reactFeather.AlertTriangle) `
  min-height: 20px;
  min-width: 20px;
  stroke: ${({ theme }) => theme.error};
`;
const ConvertLink = styled__default["default"].a `
  color: ${({ theme }) => theme.error};
  text-decoration: none;
`;
const AutoColumn$1 = styled__default["default"].div `
  display: grid;
  grid-auto-rows: auto;
  grid-row-gap: '4px';
`;

function DeprecatedWarning() {
    return (jsxRuntime.jsx(WarningWrapper, { children: jsxRuntime.jsxs(AutoColumn$1, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "fit-content" }, { children: [jsxRuntime.jsx(StyledWarningIcon$1, {}), jsxRuntime.jsx(Text, Object.assign({ fontWeight: 600, ml: '10px', color: "swapWidget.primary" }, { children: "Old AEB tokens Alert" }))] })), jsxRuntime.jsxs(Text, Object.assign({ fontWeight: 500, mt: '10px', color: "swapWidget.primary" }, { children: ["Please note these tokens were used by the old AEB bridge and have been deprecated. If you still hold old AEB tokens, please convert them here", ' ', jsxRuntime.jsx(ConvertLink, Object.assign({ href: 'https://bridge.avax.network/convert', target: "_blank" }, { children: "https://bridge.avax.network/convert" }))] }))] }) }));
}

const Root$i = styled__default["default"](Box) `
  width: 100%;
  /* min-width: 360px; */
  position: relative;
  overflow: hidden;
`;
const SwapWrapper$1 = styled__default["default"](Box) `
  border-bottom-left-radius: 10px;
  border-bottom-right-radius: 10px;
  width: 100%;
  /* min-width: 360px; */
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  position: relative;
  overflow: hidden;
`;
const CurrencyInputTextBox$1 = styled__default["default"](CurrencyInput) `
  align-items: center;
  border-radius: 4px;
`;
const InputText = styled__default["default"](TextInput) `
  align-items: center;
  border-radius: 4px;
`;
const ArrowWrapper$5 = styled__default["default"].div `
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveBgColor; }};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;
const PValue$2 = styled__default["default"](Box) `
  margin-left: 7px;
  margin-right: 7px;
  align-items: center;
  display: flex;
  width: 100%;
  font-size: 16px;
  color: ${({ theme, isActive }) => { var _a, _b; return (isActive ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.secondary); }};
  border-bottom: ${({ theme, isActive }) => { var _a; return (isActive ? `1px solid ${(_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary}` : 0); }};
  cursor: pointer;
  &:hover {
    color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary; }};
  }
`;

var Rate;
(function (Rate) {
    Rate["DIV"] = "DIV";
    Rate["MUL"] = "MUL";
})(Rate || (Rate = {}));
const LimitOrder = ({ swapType, setSwapType, isLimitOrderVisible, defaultInputAddress, defaultOutputAddress, }) => {
    var _a, _b, _c, _d;
    const [isTokenDrawerOpen, setIsTokenDrawerOpen] = React.useState(false);
    const [selectedPercentage, setSelectedPercentage] = React.useState(0);
    const [tokenDrawerType, setTokenDrawerType] = React.useState(LimitNewField.INPUT);
    const [activeTab, setActiveTab] = React.useState('SELL');
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useToken = useTokenHook[chainId];
    const theme = React.useContext(styled.ThemeContext);
    const percentageValue = [25, 50, 75, 100];
    const { handlers: { handleInput: onUserInput, handleRateType, handleCurrencySelection: onCurrencySelection, handleSwitchTokens: onSwitchTokens, handleLimitOrderSubmission, }, derivedOrderInfo: { parsedAmounts, currencies, currencyBalances, trade, formattedAmounts, inputError: swapInputError, rawAmounts, price, }, orderState: { independentField, rateType }, } = limitOrdersReact.useGelatoLimitOrders();
    const { onCurrencySelection: onSwapCurrencySelection } = useSwapActionHandlers(chainId);
    // get custom setting values for user
    const [allowedSlippage] = useUserSlippageTolerance();
    const recipient = account !== null && account !== void 0 ? account : null;
    const isValid = !swapInputError;
    const gelatoInputCurrency = currencies[LimitField.INPUT];
    const gelatoOutputCurrency = currencies[LimitField.OUTPUT];
    const inputTokenInfo = gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.tokenInfo;
    const outputTokenInfo = gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.tokenInfo;
    const getInputCurrency = () => {
        if (gelatoInputCurrency && (gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.symbol) === sdk.CAVAX[chainId].symbol) {
            return sdk.CAVAX[chainId];
        }
        else if (inputTokenInfo && (inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.symbol) === sdk.CAVAX[chainId].symbol) {
            return sdk.CAVAX[chainId];
        }
        else if (inputTokenInfo) {
            return new sdk.Token(inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.chainId, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.address, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.decimals, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.symbol, inputTokenInfo === null || inputTokenInfo === void 0 ? void 0 : inputTokenInfo.name);
        }
        else if (gelatoInputCurrency && (gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.isToken)) {
            return new sdk.Token(gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.chainId, gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.address, gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.decimals, gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.symbol, gelatoInputCurrency === null || gelatoInputCurrency === void 0 ? void 0 : gelatoInputCurrency.name);
        }
        else {
            return undefined;
        }
    };
    const getOutputCurrency = () => {
        if (gelatoOutputCurrency && (gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.symbol) === sdk.CAVAX[chainId].symbol) {
            return sdk.CAVAX[chainId];
        }
        else if (outputTokenInfo && (outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.symbol) === sdk.CAVAX[chainId].symbol) {
            return sdk.CAVAX[chainId];
        }
        else if (outputTokenInfo) {
            return new sdk.Token(outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.chainId, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.address, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.decimals, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.symbol, outputTokenInfo === null || outputTokenInfo === void 0 ? void 0 : outputTokenInfo.name);
        }
        else if (gelatoOutputCurrency && (gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.isToken)) {
            return new sdk.Token(gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.chainId, gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.address, gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.decimals, gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.symbol, gelatoOutputCurrency === null || gelatoOutputCurrency === void 0 ? void 0 : gelatoOutputCurrency.name);
        }
        else {
            return undefined;
        }
    };
    const handleActiveTab = (tab) => {
        if (activeTab === tab)
            return;
        handleRateType(rateType, price);
        setActiveTab(tab);
    };
    // toggle wallet when disconnected
    const toggleWalletModal = useWalletModalToggle();
    const handleTypeInput = React.useCallback((value) => {
        onUserInput(LimitNewField.INPUT, value);
    }, [onUserInput]);
    const handleTypeOutput = React.useCallback((value) => {
        onUserInput(LimitNewField.OUTPUT, value);
    }, [onUserInput]);
    // price
    const handleTypeDesiredRate = React.useCallback((value) => {
        onUserInput(LimitNewField.PRICE, value);
    }, [onUserInput]);
    // setting default tokens
    const defaultInputToken = useToken(defaultInputAddress);
    const defaultInputCurrency = defaultInputToken ? unwrappedToken(defaultInputToken, chainId) : undefined;
    const defaultOutputToken = useToken(defaultOutputAddress);
    const defaultOutputCurrency = defaultOutputToken ? unwrappedToken(defaultOutputToken, chainId) : undefined;
    React.useEffect(() => {
        if (defaultInputCurrency) {
            onCurrencySelect(defaultInputCurrency, LimitNewField.INPUT);
        }
        if (defaultOutputCurrency) {
            onCurrencySelect(defaultOutputCurrency, LimitNewField.OUTPUT);
        }
    }, [chainId, defaultInputAddress, defaultOutputAddress, defaultInputCurrency, defaultOutputCurrency]);
    // modal and loading
    const [{ showConfirm, tradeToConfirm, swapErrorMessage, attemptingTxn, txHash }, setSwapState] = React.useState({
        showConfirm: false,
        tradeToConfirm: undefined,
        attemptingTxn: false,
        swapErrorMessage: undefined,
        txHash: undefined,
    });
    const tradePrice = trade === null || trade === void 0 ? void 0 : trade.executionPrice;
    // check whether the user has approved the router on the input token
    const [approval, approveCallback] = useApproveCallbackFromInputCurrencyAmount(parsedAmounts.input);
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = React.useState(false);
    // mark when a user has submitted an approval, reset onTokenSelection for input field
    React.useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const maxAmountInput = galetoMaxAmountSpend(chainId, currencyBalances[LimitField.INPUT]);
    // for limit swap
    const handleSwap = React.useCallback(() => {
        var _a, _b, _c, _d, _e, _f;
        if (!handleLimitOrderSubmission) {
            return;
        }
        setSwapState({
            attemptingTxn: true,
            tradeToConfirm,
            showConfirm,
            swapErrorMessage: undefined,
            txHash: undefined,
        });
        try {
            if (!((_a = currencies.input) === null || _a === void 0 ? void 0 : _a.wrapped.address)) {
                throw new Error('Invalid input currency');
            }
            if (!((_b = currencies.output) === null || _b === void 0 ? void 0 : _b.wrapped.address)) {
                throw new Error('Invalid output currency');
            }
            if (!rawAmounts.input) {
                throw new Error('Invalid input amount');
            }
            if (!rawAmounts.output) {
                throw new Error('Invalid output amount');
            }
            if (!account) {
                throw new Error('No account');
            }
            handleLimitOrderSubmission({
                inputToken: ((_c = currencies.input) === null || _c === void 0 ? void 0 : _c.isNative) ? NATIVE : (_d = currencies.input) === null || _d === void 0 ? void 0 : _d.wrapped.address,
                outputToken: ((_e = currencies.output) === null || _e === void 0 ? void 0 : _e.isNative) ? NATIVE : (_f = currencies.output) === null || _f === void 0 ? void 0 : _f.wrapped.address,
                inputAmount: rawAmounts.input,
                outputAmount: rawAmounts.output,
                owner: account,
            })
                .then(({ hash }) => {
                setSwapState({
                    attemptingTxn: false,
                    tradeToConfirm,
                    showConfirm,
                    swapErrorMessage: undefined,
                    txHash: hash,
                });
            })
                .catch((error) => {
                setSwapState({
                    attemptingTxn: false,
                    tradeToConfirm,
                    showConfirm,
                    swapErrorMessage: error.message,
                    txHash: undefined,
                });
                // we only care if the error is something _other_ than the user rejected the tx
                if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {
                    console.error(error);
                }
            });
        }
        catch (error) {
            setSwapState({
                attemptingTxn: false,
                tradeToConfirm,
                showConfirm,
                swapErrorMessage: error.message,
                txHash: undefined,
            });
            // we only care if the error is something _other_ than the user rejected the tx
            if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {
                console.error(error);
            }
        }
    }, [
        handleLimitOrderSubmission,
        tradeToConfirm,
        showConfirm,
        currencies.input,
        currencies.output,
        rawAmounts.input,
        rawAmounts.output,
        account,
    ]);
    const handleSelectTokenDrawerClose = React.useCallback(() => {
        setIsTokenDrawerOpen(false);
    }, [setIsTokenDrawerOpen]);
    // show approve flow when: no error on inputs, not approved or pending, or approved in current session
    // never show if price impact is above threshold in non expert mode
    const showApproveFlow = !swapInputError &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED));
    const handleConfirmDismiss = React.useCallback(() => {
        setSwapState({ showConfirm: false, tradeToConfirm, attemptingTxn, swapErrorMessage, txHash });
        // if there was a tx hash, we want to clear the input
        if (txHash) {
            onUserInput(LimitNewField.INPUT, '');
        }
    }, [attemptingTxn, onUserInput, swapErrorMessage, tradeToConfirm, txHash]);
    const handleAcceptChanges = React.useCallback(() => {
        setSwapState({ tradeToConfirm: trade, swapErrorMessage, txHash, attemptingTxn, showConfirm });
    }, [attemptingTxn, showConfirm, swapErrorMessage, trade, txHash]);
    const onCurrencySelect = React.useCallback((currency, tokenDrawerTypeArg) => {
        const type = tokenDrawerTypeArg !== null && tokenDrawerTypeArg !== void 0 ? tokenDrawerTypeArg : tokenDrawerType;
        if (type === LimitNewField.INPUT) {
            setApprovalSubmitted(false); // reset 2 step UI for approvals
        }
        // here need to add isToken because in Galato hook require this variable to select currency
        const newCurrency = Object.assign({}, currency);
        if ((currency === null || currency === void 0 ? void 0 : currency.symbol) === sdk.CAVAX[chainId].symbol) {
            newCurrency.isNative = true;
        }
        else {
            newCurrency.isToken = true;
        }
        onCurrencySelection(type, newCurrency);
        // this is to update tokens on chart on token selection
        onSwapCurrencySelection(type, currency);
    }, [tokenDrawerType, onCurrencySelection, onSwapCurrencySelection]);
    const handleApprove = React.useCallback(() => tslib.__awaiter(void 0, void 0, void 0, function* () {
        yield approveCallback();
    }), [approveCallback]);
    const isAEBToken = useIsSelectedAEBToken();
    const handlePlaceOrder = () => {
        setSwapState({
            tradeToConfirm: trade,
            attemptingTxn: false,
            swapErrorMessage: undefined,
            showConfirm: true,
            txHash: undefined,
        });
    };
    const renderButton = () => {
        var _a;
        if (!account) {
            return (jsxRuntime.jsx(Button, Object.assign({ isDisabled: !account, variant: "primary", onClick: toggleWalletModal }, { children: "Connect Wallet" })));
        }
        if (showApproveFlow) {
            return (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, { children: [jsxRuntime.jsx(Box, Object.assign({ mr: "10px", width: "100%" }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', onClick: handleApprove, isDisabled: approval !== ApprovalState.NOT_APPROVED || approvalSubmitted, loading: approval === ApprovalState.PENDING, loadingText: "Approving" }, { children: approvalSubmitted && approval === ApprovalState.APPROVED
                                ? 'Approved'
                                : 'Approve' + ((_a = currencies[LimitField.INPUT]) === null || _a === void 0 ? void 0 : _a.symbol) })) })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: () => handlePlaceOrder(), id: "swap-button", isDisabled: !isValid || approval !== ApprovalState.APPROVED }, { children: "Place Order" }))] })));
        }
        return (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: () => handlePlaceOrder(), id: "swap-button", isDisabled: !isValid || !!swapInputError, backgroundColor: isValid ? 'primary' : undefined }, { children: swapInputError ? swapInputError : 'Place Order' })));
    };
    const renderPercentage = () => {
        return (jsxRuntime.jsx(Box, Object.assign({ display: "flex", pb: "5px" }, { children: percentageValue.map((value, index) => (jsxRuntime.jsxs(PValue$2, Object.assign({ isActive: selectedPercentage === value, onClick: () => {
                    var _a;
                    setSelectedPercentage(value);
                    if (maxAmountInput) {
                        const multipyAmount = sdk.JSBI.multiply(maxAmountInput === null || maxAmountInput === void 0 ? void 0 : maxAmountInput.numerator, sdk.JSBI.BigInt(value)); //Currency from uniswap sdk-core not contain raw function
                        const divideAmount = sdk.JSBI.divide(multipyAmount, sdk.JSBI.BigInt(100));
                        const token = wrappedGelatoCurrency((_a = maxAmountInput === null || maxAmountInput === void 0 ? void 0 : maxAmountInput.currency) !== null && _a !== void 0 ? _a : undefined, chainId);
                        const newFinalAmount = new sdk.TokenAmount(token, divideAmount);
                        onUserInput(LimitNewField.INPUT, newFinalAmount.toExact());
                    }
                } }, { children: [value, "%"] }), index))) })));
    };
    const inputCurrency = getInputCurrency();
    const outputCurrency = getOutputCurrency();
    return (jsxRuntime.jsxs(Root$i, { children: [jsxRuntime.jsx(TradeOption$1, { swapType: swapType, setSwapType: setSwapType, isLimitOrderVisible: isLimitOrderVisible }), jsxRuntime.jsxs(SwapWrapper$1, { children: [jsxRuntime.jsx(Box, Object.assign({ width: "100%", display: "flex", justifyContent: "center" }, { children: jsxRuntime.jsx(Box, Object.assign({ textAlign: "center", width: "120px" }, { children: jsxRuntime.jsx(ToggleButtons, { options: ['SELL', 'BUY'], value: activeTab, onChange: (value) => {
                                    handleActiveTab(value);
                                } }) })) })), jsxRuntime.jsxs(Box, Object.assign({ p: 10 }, { children: [isAEBToken && jsxRuntime.jsx(DeprecatedWarning, {}), jsxRuntime.jsx(CurrencyInputTextBox$1, { label: independentField === LimitNewField.OUTPUT && trade ? 'From (estimated)' : 'From', value: formattedAmounts[LimitField.INPUT], onChange: (value) => {
                                    setSelectedPercentage(0);
                                    handleTypeInput(value);
                                }, onTokenClick: () => {
                                    setTokenDrawerType(LimitNewField.INPUT);
                                    setIsTokenDrawerOpen(true);
                                }, currency: inputCurrency, fontSize: 24, isNumeric: true, placeholder: "0.00", id: "swap-currency-input", addonLabel: renderPercentage() }), jsxRuntime.jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: "flex", justifyContent: 'center', mt: 10 }, { children: jsxRuntime.jsx(ArrowWrapper$5, { children: rateType === Rate.MUL ? (jsxRuntime.jsx(reactFeather.X, { size: "16", color: (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveColor })) : (jsxRuntime.jsx(reactFeather.Divide, { size: "16", color: (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.interactiveColor })) }) })), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(InputText, { value: formattedAmounts[LimitField.PRICE], onChange: (value) => handleTypeDesiredRate(value), fontSize: 24, isNumeric: true, placeholder: "0.00", label: "Price" }) }), jsxRuntime.jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: "flex", justifyContent: 'center', mt: 10 }, { children: jsxRuntime.jsx(ArrowWrapper$5, Object.assign({ onClick: () => {
                                        setApprovalSubmitted(false); // reset 2 step UI for approvals
                                        onSwitchTokens();
                                    } }, { children: jsxRuntime.jsx(reactFeather.RefreshCcw, { size: "16", color: (_c = theme.swapWidget) === null || _c === void 0 ? void 0 : _c.interactiveColor }) })) })), jsxRuntime.jsx(CurrencyInputTextBox$1, { label: independentField === LimitNewField.INPUT && trade ? 'To (estimated)' : 'To', value: formattedAmounts[LimitField.OUTPUT], onChange: (value) => {
                                    setSelectedPercentage(0);
                                    handleTypeOutput(value);
                                }, onTokenClick: () => {
                                    setTokenDrawerType(LimitNewField.OUTPUT);
                                    setIsTokenDrawerOpen(true);
                                }, currency: outputCurrency, fontSize: 24, isNumeric: true, placeholder: "0.00", id: "swap-currency-output", addonLabel: tradePrice && (jsxRuntime.jsxs(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 16 }, { children: ["Price: ", tradePrice === null || tradePrice === void 0 ? void 0 : tradePrice.toSignificant(6), " ", (_d = tradePrice === null || tradePrice === void 0 ? void 0 : tradePrice.quoteCurrency) === null || _d === void 0 ? void 0 : _d.symbol] }))) }), trade && jsxRuntime.jsx(LimitOrderDetailInfo, { trade: trade }), jsxRuntime.jsx(Box, Object.assign({ width: "100%", mt: 10 }, { children: renderButton() }))] }))] }), isTokenDrawerOpen && (jsxRuntime.jsx(SelectTokenDrawer$1, { isOpen: isTokenDrawerOpen, onClose: handleSelectTokenDrawerClose, onCurrencySelect: onCurrencySelect, selectedCurrency: tokenDrawerType === LimitNewField.INPUT ? inputCurrency : outputCurrency, otherSelectedCurrency: tokenDrawerType === LimitNewField.INPUT ? outputCurrency : inputCurrency })), trade && (jsxRuntime.jsx(ConfirmLimitOrderDrawer, { isOpen: showConfirm, trade: trade, originalTrade: tradeToConfirm, onAcceptChanges: handleAcceptChanges, attemptingTxn: attemptingTxn, txHash: txHash, recipient: recipient, allowedSlippage: allowedSlippage, onConfirm: handleSwap, swapErrorMessage: swapErrorMessage, onClose: handleConfirmDismiss }))] }));
};

const ContentBox$2 = styled__default["default"](Box) `
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  padding: 15px;
  border-radius: 8px;
  margin-top: 10px;
`;
const DataBox$2 = styled__default["default"](Box) `
  align-items: center;
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const ValueText = styled__default["default"](Text) `
  color: ${({ theme, severity }) => {
    var _a, _b;
    return severity === 3 || severity === 4
        ? theme.error
        : severity === 2
            ? theme.warning
            : severity === 1
                ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary
                : severity === 0
                    ? theme.success
                    : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.secondary;
}};
`;

const SwapDetailInfo = ({ trade }) => {
    var _a, _b, _c, _d;
    const [allowedSlippage] = useUserSlippageTolerance();
    const [feeInfo] = useDaasFeeInfo();
    const { priceImpactWithoutFee, realizedLPFee, realizedLPFeeAmount } = computeTradePriceBreakdown(trade);
    const isExactIn = trade.tradeType === sdk.TradeType.EXACT_INPUT;
    const slippageAdjustedAmounts = computeSlippageAdjustedAmounts(trade, allowedSlippage);
    const amount = isExactIn
        ? (_b = `${(_a = slippageAdjustedAmounts[Field.OUTPUT]) === null || _a === void 0 ? void 0 : _a.toSignificant(4)} ${trade.outputAmount.currency.symbol}`) !== null && _b !== void 0 ? _b : '-'
        : (_d = `${(_c = slippageAdjustedAmounts[Field.INPUT]) === null || _c === void 0 ? void 0 : _c.toSignificant(4)} ${trade.inputAmount.currency.symbol}`) !== null && _d !== void 0 ? _d : '-';
    const priceImpact = priceImpactWithoutFee
        ? priceImpactWithoutFee.lessThan(ONE_BIPS)
            ? '<0.01%'
            : `${priceImpactWithoutFee.toFixed(2)}%`
        : '-';
    const lpFeeAmount = realizedLPFeeAmount
        ? `${realizedLPFeeAmount.toSignificant(4)} ${trade.inputAmount.currency.symbol}`
        : '-';
    const totalFee = realizedLPFee
        ? `${realizedLPFee.add(new sdk.Percent(feeInfo.feeTotal.toString(), BIPS_BASE)).multiply('100').toSignificant(4)}%`
        : '-';
    const renderRow = (label, value, showSeverity) => {
        return (jsxRuntime.jsxs(DataBox$2, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 14 }, { children: label })), jsxRuntime.jsx(ValueText, Object.assign({ fontSize: 14, severity: showSeverity ? warningSeverity(priceImpactWithoutFee) : -1 }, { children: value }))] }, label));
    };
    return (jsxRuntime.jsxs(ContentBox$2, { children: [allowedSlippage !== INITIAL_ALLOWED_SLIPPAGE && renderRow('Slippage tolerance', `${allowedSlippage / 100}%`), renderRow(isExactIn ? 'Minimum Received' : 'Maximum Sold', amount), renderRow('Price Impact', priceImpact, true), (feeInfo === null || feeInfo === void 0 ? void 0 : feeInfo.feeTotal) > 0 ? renderRow('Total Fee', totalFee) : renderRow('Liquidity Provider Fee', lpFeeAmount)] }));
};

const Root$h = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const Header$4 = styled__default["default"](Box) `
  padding: 0px 10px;
`;
const TokenRow$1 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: max-content auto max-content;
  align-items: center;
`;
const PriceUpdateBlock = styled__default["default"](Box) `
  padding: 10px;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 8px;
  margin-top: 15px;
`;
const OutputText$1 = styled__default["default"](Text) `
  width: 100%;
  font-style: italic;
  font-size: 12px;
  text-align: left;
`;
const Footer$2 = styled__default["default"](Box) `
  padding: 0px 10px;
`;
const ErrorWrapper$5 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: minmax(300px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const ErrorBox$5 = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const SubmittedWrapper$2 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: minmax(300px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const Link$2 = styled__default["default"](Text) `
  text-decoration: none;
`;

const ConfirmSwapDrawer$1 = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { isOpen, onClose, trade, originalTrade, allowedSlippage, onAcceptChanges, onConfirm, attemptingTxn, swapErrorMessage, txHash, recipient, } = props;
    const { chainId } = usePangolinWeb3();
    const theme = React.useContext(styled.ThemeContext);
    const slippageAdjustedAmounts = React.useMemo(() => computeSlippageAdjustedAmounts(trade, allowedSlippage), [trade, allowedSlippage]);
    const { priceImpactWithoutFee } = React.useMemo(() => computeTradePriceBreakdown(trade), [trade]);
    const priceImpactSeverity = warningSeverity(priceImpactWithoutFee);
    const showAcceptChanges = React.useMemo(() => Boolean(trade && originalTrade && tradeMeaningfullyDiffers(trade, originalTrade)), [originalTrade, trade]);
    // text to show while loading
    const pendingText = `Swapping ${(_a = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _a === void 0 ? void 0 : _a.toSignificant(6)} ${(_c = (_b = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _b === void 0 ? void 0 : _b.currency) === null || _c === void 0 ? void 0 : _c.symbol} for ${(_d = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _d === void 0 ? void 0 : _d.toSignificant(6)} ${(_f = (_e = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _e === void 0 ? void 0 : _e.currency) === null || _f === void 0 ? void 0 : _f.symbol}`;
    const ConfirmContent = (jsxRuntime.jsxs(Root$h, { children: [jsxRuntime.jsxs(Header$4, { children: [jsxRuntime.jsxs(TokenRow$1, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: trade.inputAmount.currency, size: 24, imageSize: 48 }), jsxRuntime.jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: showAcceptChanges && trade.tradeType === sdk.TradeType.EXACT_OUTPUT ? 'primary' : 'swapWidget.primary', style: { marginLeft: '12px' } }, { children: trade.inputAmount.toSignificant(6) })), jsxRuntime.jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: "swapWidget.primary", style: { marginLeft: '10px' } }, { children: trade.inputAmount.currency.symbol }))] }), jsxRuntime.jsx(reactFeather.ArrowDown, { size: "16", color: (_g = theme.swapWidget) === null || _g === void 0 ? void 0 : _g.interactiveColor, style: { marginLeft: '4px', minWidth: '16px' } }), jsxRuntime.jsxs(TokenRow$1, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: trade.outputAmount.currency, size: 24, imageSize: 48 }), jsxRuntime.jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, style: { marginLeft: '12px' }, color: priceImpactSeverity > 2
                                    ? 'error'
                                    : showAcceptChanges && trade.tradeType === sdk.TradeType.EXACT_INPUT
                                        ? 'primary'
                                        : 'swapWidget.primary' }, { children: trade.outputAmount.toSignificant(6) })), jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 24, fontWeight: 500, style: { marginLeft: '10px' } }, { children: trade.outputAmount.currency.symbol }))] }), showAcceptChanges && (jsxRuntime.jsxs(PriceUpdateBlock, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 14 }, { children: "Price Updated" })), jsxRuntime.jsx(Button, Object.assign({ onClick: onAcceptChanges, variant: "primary", width: 150, padding: "5px 10px" }, { children: "Accept" }))] })), jsxRuntime.jsx(Box, Object.assign({ mt: '15px' }, { children: trade.tradeType === sdk.TradeType.EXACT_INPUT ? (jsxRuntime.jsx(OutputText$1, Object.assign({ color: "swapWidget.secondary" }, { children: jsxRuntime.jsx(reactI18next.Trans, { i18nKey: "swap.outputEstimated", values: {
                                    amount: (_h = slippageAdjustedAmounts[Field.OUTPUT]) === null || _h === void 0 ? void 0 : _h.toSignificant(6),
                                    currencySymbol: trade.outputAmount.currency.symbol,
                                } }) }))) : (jsxRuntime.jsx(OutputText$1, Object.assign({ color: "swapWidget.secondary" }, { children: jsxRuntime.jsx(reactI18next.Trans, { i18nKey: "swap.inputEstimated", values: {
                                    amount: (_j = slippageAdjustedAmounts[Field.INPUT]) === null || _j === void 0 ? void 0 : _j.toSignificant(6),
                                    currencySymbol: trade.inputAmount.currency.symbol,
                                } }) }))) })), recipient && jsxRuntime.jsxs(OutputText$1, Object.assign({ color: "swapWidget.primary" }, { children: ["Sending to: ", recipient] }))] }), jsxRuntime.jsxs(Footer$2, { children: [jsxRuntime.jsx(SwapDetailInfo, { trade: trade }), jsxRuntime.jsx(Box, Object.assign({ my: '10px' }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onConfirm, isDisabled: showAcceptChanges }, { children: priceImpactSeverity > 2 ? 'Swap Anyway' : 'Confirm Swap' })) }))] })] }));
    const PendingContent = jsxRuntime.jsx(Loader, { size: 100, label: pendingText });
    const ErroContent = (jsxRuntime.jsxs(ErrorWrapper$5, { children: [jsxRuntime.jsxs(ErrorBox$5, { children: [jsxRuntime.jsx(reactFeather.AlertTriangle, { color: theme.error, style: { strokeWidth: 1.5 }, size: 64 }), jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'error', style: { textAlign: 'center', width: '85%' } }, { children: swapErrorMessage }))] }), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: "Dismiss" }))] }));
    const SubmittedContent = (jsxRuntime.jsxs(SubmittedWrapper$2, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", paddingY: '20px' }, { children: [jsxRuntime.jsx(Box, Object.assign({ flex: "1", display: "flex", alignItems: "center" }, { children: jsxRuntime.jsx(reactFeather.ArrowUpCircle, { strokeWidth: 0.5, size: 90, color: theme.primary }) })), jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontWeight: 500, fontSize: 20 }, { children: "Transaction Submitted" })), chainId && txHash && (jsxRuntime.jsx(Link$2, Object.assign({ as: "a", fontWeight: 500, fontSize: 14, color: 'primary', href: getEtherscanLink(chainId, txHash, 'transaction') }, { children: "View on explorer" })))] })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: "Close" }))] }));
    return (jsxRuntime.jsx(Drawer, Object.assign({ title: swapErrorMessage || txHash || attemptingTxn ? '' : 'Confirm Swap', isOpen: isOpen, onClose: onClose }, { children: swapErrorMessage ? ErroContent : txHash ? SubmittedContent : attemptingTxn ? PendingContent : ConfirmContent })));
};

const PValue$1 = styled__default["default"](Box) `
  margin-left: 3px;
  margin-right: 3px;
  align-items: center;
  display: flex;
  width: 100%;
  font-size: 12px;
  padding: 5px;
  color: ${({ theme, isActive }) => { var _a, _b; return (isActive ? (_a = theme.numberOptions) === null || _a === void 0 ? void 0 : _a.activeTextColor : (_b = theme.numberOptions) === null || _b === void 0 ? void 0 : _b.text); }};
  background-color: ${({ theme, isActive }) => { var _a, _b; return isActive ? (_a = theme.numberOptions) === null || _a === void 0 ? void 0 : _a.activeBackgroundColor : (_b = theme.numberOptions) === null || _b === void 0 ? void 0 : _b.inactiveBackgroundColor; }};
  border: ${({ theme, isActive }) => { var _a; return (isActive ? 0 : `1px solid ${(_a = theme.numberOptions) === null || _a === void 0 ? void 0 : _a.borderColor}`); }};
  border-radius: 5px;
  cursor: pointer;
  text-align: center;
  justify-content: center;
`;

const NumberOptions = (props) => {
    const { options = [25, 50, 75, 100], isPercentage = false, onChange, currentValue, isDisabled, variant } = props;
    return (jsxRuntime.jsxs(Box, { children: [variant === 'step' && (jsxRuntime.jsxs(Steps, Object.assign({ onChange: (value) => {
                    onChange && onChange(value);
                }, current: currentValue, progressDot: true }, { children: [jsxRuntime.jsx(Step, { disabled: isDisabled }), jsxRuntime.jsx(Step, { disabled: isDisabled }), jsxRuntime.jsx(Step, { disabled: isDisabled }), jsxRuntime.jsx(Step, { disabled: isDisabled }), jsxRuntime.jsx(Step, { disabled: isDisabled })] }))), variant === 'box' && (jsxRuntime.jsx(Box, Object.assign({ display: "flex", pb: "5px" }, { children: options.map((value, index) => (jsxRuntime.jsx(PValue$1, Object.assign({ isActive: currentValue === value, onClick: () => {
                        onChange && onChange(value);
                    } }, { children: isPercentage ? `${value}%` : value }), index))) })))] }));
};

const InputOptions = styled__default["default"](Box) `
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 5px;
`;

const SlippageInput = ({ expertMode = false, slippageTolerance, showTitle = true, setSlippageTolerance, }) => {
    const { t } = reactI18next.useTranslation();
    return (jsxRuntime.jsxs(Box, Object.assign({ height: "90px" }, { children: [showTitle && jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: t('settings.slippage') })), jsxRuntime.jsxs(InputOptions, { children: [jsxRuntime.jsx(TextInput, { value: slippageTolerance, addonAfter: jsxRuntime.jsx(Box, Object.assign({ bgColor: "swapWidget.detailsBackground", paddingX: "10px", paddingY: "4px", borderRadius: 4 }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: t('settings.percent') })) })), isNumeric: true, placeholder: "1", onChange: (value) => {
                            setSlippageTolerance(value);
                        } }), jsxRuntime.jsx(NumberOptions, { options: [0.1, 0.5, 1], isPercentage: true, currentValue: parseFloat(slippageTolerance), variant: "box", onChange: (number) => setSlippageTolerance(number.toString()), isDisabled: false })] }), Number(slippageTolerance) <= 0.1 && (jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 12, marginBottom: 10 }, { children: t('transactionSettings.transactionMayFail') }))), Number(slippageTolerance) > 50 && !expertMode ? (jsxRuntime.jsx(Text, Object.assign({ color: "error", fontSize: "10px", marginBottom: 10 }, { children: t('transactionSettings.transactionActiveExpertMode') }))) : (Number(slippageTolerance) > 5 && (jsxRuntime.jsx(Text, Object.assign({ color: "primary", fontSize: 12, marginBottom: 10 }, { children: t('transactionSettings.transactionMayFrontrun') }))))] })));
};

function useOnClickOutside(node, handler) {
    const handlerRef = React.useRef(handler);
    React.useEffect(() => {
        handlerRef.current = handler;
    }, [handler]);
    React.useEffect(() => {
        const handleClickOutside = (e) => {
            var _a, _b;
            if ((_b = (_a = node.current) === null || _a === void 0 ? void 0 : _a.contains(e.target)) !== null && _b !== void 0 ? _b : false) {
                return;
            }
            if (handlerRef.current)
                handlerRef.current();
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [node]);
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const StyledDialogOverlay = styled__default["default"].div `
  z-index: 999;
  background-color: transparent;
  overflow: hidden;
  display: ${({ isOpen }) => (!isOpen ? 'none' : 'flex')};
  align-items: center;
  justify-content: center;
  position: fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  background-color: ${({ theme, background }) => (background ? background : theme.modalBG)};
`;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const Container$1 = styled__default["default"].div `
  background: ${({ theme }) => theme.bg8};
  border-radius: 10px;
  ${({ theme }) => theme.mediaWidth.upToSmall `
    border-radius: 0px;
    width: 100%;
    height: 100%;
  `};
`;
function Modal({ isOpen, onDismiss, children, overlayBG, closeOnClickOutside = true }) {
    const node = React.useRef();
    const handleClose = React.useCallback(() => {
        onDismiss();
    }, [onDismiss]);
    useOnClickOutside(node, isOpen && closeOnClickOutside ? handleClose : undefined);
    return (jsxRuntime.jsx(reactPortal.Portal, { children: jsxRuntime.jsx(StyledDialogOverlay, Object.assign({ isOpen: isOpen, background: overlayBG }, { children: isOpen && jsxRuntime.jsx(Container$1, Object.assign({ ref: node }, { children: children })) })) }));
}

const WarningModal = ({ isOpen, close, setExpertMode }) => {
    const confirmAction = () => {
        const text = prompt('Please type the word "confirm" to enable expert mode.');
        if (text === 'confirm') {
            setExpertMode(true);
            close();
        }
    };
    return (jsxRuntime.jsx(Modal, Object.assign({ isOpen: isOpen, onDismiss: close }, { children: jsxRuntime.jsxs(ModalFrame, { children: [jsxRuntime.jsx(Close, Object.assign({ variant: "plain", onClick: close }, { children: jsxRuntime.jsx(reactFeather.X, { size: 28 }) })), jsxRuntime.jsx(Text, Object.assign({ fontSize: 28, fontWeight: 800, color: "swapWidget.primary" }, { children: "Are you sure?" })), jsxRuntime.jsxs(Box, Object.assign({ marginTop: 20 }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary" }, { children: "Expert mode turns off the confirm transaction prompt and allows high slippage trades that often result in bad rates and lost funds." })), jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontWeight: 800, fontSize: 20, marginTop: 20, marginBottom: 40 }, { children: "ONLY USE THIS MODE IF YOU KNOW WHAT YOU ARE DOING." })), jsxRuntime.jsx(WarningButton, Object.assign({ variant: "primary", onClick: confirmAction }, { children: "Turn on expert mode" }))] }))] }) })));
};

const SwapSettingsDrawer = ({ isOpen, close }) => {
    const [userExpertMode, setUserExpertMode] = useExpertModeManager();
    const [userslippage, setUserSlippageTolerance] = useUserSlippageTolerance();
    const [userDeadline, setUserDeadline] = useUserDeadline();
    const [deadline, setDeadline] = React.useState(userDeadline);
    const [expertMode, setExpertMode] = React.useState(userExpertMode);
    const [slippageTolerance, setSlippageTolerance] = React.useState((userslippage / 100).toString());
    const [isValidValues, setValidValues] = React.useState(true);
    const [modalOpen, setModalOpen] = React.useState(false);
    const save = React.useCallback(() => {
        if (deadline.length == 0) {
            setUserDeadline(DEFAULT_DEADLINE_FROM_NOW);
        }
        else {
            setUserDeadline(deadline);
        }
        setUserExpertMode(expertMode);
        if (slippageTolerance.length == 0) {
            setUserSlippageTolerance(0);
        }
        else {
            let slippageToleranceNumber = parseFloat(slippageTolerance);
            if (!expertMode && slippageToleranceNumber > 50) {
                setUserSlippageTolerance(5000);
            }
            else {
                if (slippageToleranceNumber > 100) {
                    slippageToleranceNumber = 100;
                }
                setUserSlippageTolerance(Math.ceil(slippageToleranceNumber * 100));
            }
        }
        close();
    }, [deadline, expertMode, slippageTolerance]);
    React.useEffect(() => {
        const slippageToleranceNumber = parseFloat(slippageTolerance);
        if (slippageTolerance.length == 0) {
            setValidValues(false);
        }
        else if (!expertMode && slippageToleranceNumber > 50) {
            setValidValues(false);
        }
        else if (slippageToleranceNumber > 100 || slippageToleranceNumber <= 0) {
            setValidValues(false);
        }
        else {
            setValidValues(true);
        }
    }, [expertMode, slippageTolerance]);
    return (jsxRuntime.jsxs(Drawer, Object.assign({ title: "Settings", isOpen: isOpen, onClose: close }, { children: [jsxRuntime.jsx(WarningModal, { isOpen: modalOpen, close: () => setModalOpen(false), setExpertMode: setExpertMode }), jsxRuntime.jsxs(Frame$4, { children: [jsxRuntime.jsx(SlippageInput, { expertMode: expertMode, slippageTolerance: slippageTolerance, setSlippageTolerance: setSlippageTolerance }), jsxRuntime.jsxs(Box, Object.assign({ height: "90px" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: "Time Limit" })), jsxRuntime.jsxs(InputOptions$1, { children: [jsxRuntime.jsx(TextInput, { value: deadline, addonAfter: jsxRuntime.jsx(Box, Object.assign({ bgColor: "swapWidget.detailsBackground", paddingX: "8px", paddingY: "4px", borderRadius: 4 }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: "Seconds" })) })), isNumeric: true, placeholder: "10", onChange: (number) => setDeadline(number.toString()) }), jsxRuntime.jsx(NumberOptions, { options: [60, 300, 600], currentValue: parseInt(deadline), variant: "box", onChange: (number) => setDeadline(number.toString()), isDisabled: false })] }), Number(deadline) <= 1 && (jsxRuntime.jsxs(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 12, marginBottom: 10 }, { children: [' ', "Your transaction may fail"] })))] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "row", alignItems: "center", justifyContent: "center", style: { gap: '15px' } }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.secondary" }, { children: "Toggle Expert Mode" })), jsxRuntime.jsx(Box, Object.assign({ width: "120px" }, { children: jsxRuntime.jsx(ToggleButtons, { options: ['ON', 'OFF'], value: expertMode ? 'ON' : 'OFF', onChange: (value) => {
                                        if (value === 'ON' && !expertMode) {
                                            setModalOpen(true);
                                        }
                                        else if (value === 'OFF' && expertMode) {
                                            setExpertMode(false);
                                        }
                                    } }) }))] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", alignContent: "center", style: { gap: '10px' } }, { children: [jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: save, isDisabled: !isValidValues }, { children: "Save & Close" })), jsxRuntime.jsx(Button, Object.assign({ variant: "plain", onClick: close, color: "swapWidget.secondary" }, { children: "Close" }))] }))] })] })));
};

const SwapRouteWrapper = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  width: 100%;
  margin: 0px auto;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  padding: 10px;
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  justify-content: center;
`;

const SwapRoute = ({ trade }) => {
    const theme = React.useContext(styled.ThemeContext);
    return (jsxRuntime.jsx(SwapRouteWrapper, { children: trade.route.path.map((token, i, path) => {
            var _a;
            const isLastItem = i === path.length - 1;
            return (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", my: '5px' }, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: token, size: 24 }), jsxRuntime.jsx(Box, Object.assign({ ml: '10px' }, { children: jsxRuntime.jsx(Text, Object.assign({ fontSize: 14, color: 'swapWidget.primary' }, { children: token.symbol })) }))] })), isLastItem ? null : jsxRuntime.jsx(reactFeather.ChevronRight, { color: (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveColor })] }), i));
        }) }));
};

const Wrapper$c = styled__default["default"].div `
  background: ${({ theme }) => { var _a; return polished.transparentize(0.6, (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor); }};
  padding: 0.75rem;
  border-radius: 20px;
`;
const WarningContainer = styled__default["default"].div `
  max-width: 420px;
  width: 100%;
  padding: 1rem;
  background: ${({ theme }) => polished.transparentize(0.9, theme.error)};
  border: 1px solid ${({ theme }) => theme.error};
  border-radius: 20px;
  overflow: auto;
`;
const StyledWarningIcon = styled__default["default"](reactFeather.AlertTriangle) `
  stroke: ${({ theme }) => theme.error};
`;
const AutoColumn = styled__default["default"].div `
  display: grid;
  grid-auto-rows: auto;
  grid-row-gap: ${({ gap }) => (gap === 'sm' && '8px') || (gap === 'md' && '12px') || (gap === 'lg' && '24px') || gap};
  justify-items: ${({ justify }) => justify && justify};
`;

function TokenWarningCard({ token }) {
    var _a, _b, _c, _d;
    const { chainId } = usePangolinWeb3();
    const tokenSymbol = (_b = (_a = token === null || token === void 0 ? void 0 : token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : '';
    const tokenName = (_d = (_c = token === null || token === void 0 ? void 0 : token.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) !== null && _d !== void 0 ? _d : '';
    const allTokens = useAllTokens();
    const duplicateNameOrSymbol = React.useMemo(() => {
        if (!token || !chainId)
            return false;
        return Object.keys(allTokens).some((tokenAddress) => {
            var _a, _b;
            const userToken = allTokens[tokenAddress];
            if (userToken.equals(token)) {
                return false;
            }
            return ((_a = userToken.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === tokenSymbol || ((_b = userToken.name) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === tokenName;
        });
    }, [token, chainId, allTokens, tokenSymbol, tokenName]);
    if (!token)
        return null;
    return (jsxRuntime.jsx(Wrapper$c, Object.assign({ error: duplicateNameOrSymbol }, { children: jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "100%", flexWrap: "wrap", margin: "-6px" }, { children: [jsxRuntime.jsxs(AutoColumn, Object.assign({ gap: "24px" }, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: token, size: 24, imageSize: 48 }), jsxRuntime.jsx("div", { children: " " })] })), jsxRuntime.jsxs(AutoColumn, Object.assign({ gap: "10px", justify: "flex-start" }, { children: [jsxRuntime.jsxs(Text, Object.assign({ fontWeight: 500, fontSize: 20, color: 'swapWidget.secondary' }, { children: [token && token.name && token.symbol && token.name !== token.symbol
                                    ? `${token.name} (${token.symbol})`
                                    : token.name || token.symbol, ' '] })), chainId && (jsxRuntime.jsx(ExternalLink, Object.assign({ style: { fontWeight: 400 }, href: getEtherscanLink(chainId, token.address, 'token') }, { children: jsxRuntime.jsxs(Text, Object.assign({ fontWeight: 500, color: 'primary', fontSize: 16 }, { children: [shortenAddress(token.address, chainId), " (View on explorer)"] })) })))] }))] })) })));
}
function TokenWarningModal({ isOpen, tokens, onConfirm, }) {
    const [understandChecked, setUnderstandChecked] = React.useState(false);
    const toggleUnderstand = React.useCallback(() => setUnderstandChecked((uc) => !uc), []);
    const handleDismiss = React.useCallback(() => null, []);
    return (jsxRuntime.jsx(Modal, Object.assign({ isOpen: isOpen, onDismiss: handleDismiss }, { children: jsxRuntime.jsx(WarningContainer, Object.assign({ className: "token-warning-container" }, { children: jsxRuntime.jsxs(AutoColumn, Object.assign({ gap: "lg" }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "100%", flexWrap: "wrap", margin: "-6px" }, { children: [jsxRuntime.jsx(StyledWarningIcon, {}), jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, fontSize: 20, color: 'error' }, { children: "Token imported" }))] })), jsxRuntime.jsxs(Text, Object.assign({ color: 'error', fontSize: 16 }, { children: ["Anyone can create an ERC-20 token on Avalanche with ", jsxRuntime.jsx("em", { children: "any" }), " name, including creating fake versions of existing tokens and tokens that claim to represent projects that do not have a token."] })), jsxRuntime.jsx(Text, Object.assign({ color: 'error', fontSize: 16 }, { children: "This interface can load arbitrary tokens by token addresses. Please take extra caution and do your research when interacting with arbitrary ERC-20 tokens." })), jsxRuntime.jsxs(Text, Object.assign({ color: 'error', fontSize: 16 }, { children: ["If you purchase an arbitrary token, ", jsxRuntime.jsx("strong", { children: "you may be unable to sell it back." })] })), tokens.map((token) => {
                        return jsxRuntime.jsx(TokenWarningCard, { token: token }, token.address);
                    }), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "100%", justifyContent: "space-between" }, { children: [jsxRuntime.jsx("div", { children: jsxRuntime.jsxs("label", Object.assign({ style: { cursor: 'pointer', userSelect: 'none' } }, { children: [jsxRuntime.jsx("input", { type: "checkbox", className: "understand-checkbox", checked: understandChecked, onChange: toggleUnderstand }), ' ', "I understand"] })) }), jsxRuntime.jsx(Button, Object.assign({ isDisabled: !understandChecked, variant: "primary", width: '140px', padding: "0.5rem 1rem", onClick: () => {
                                    onConfirm();
                                } }, { children: "Continue" }))] }))] })) })) })));
}

/**
 * Given the price impact, get user confirmation.
 *
 * @param priceImpactWithoutFee price impact of the trade without the fee.
 */
function confirmPriceImpactWithoutFee(priceImpactWithoutFee) {
    if (!priceImpactWithoutFee.lessThan(PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN)) {
        return (window.prompt(`This swap has a price impact of at least ${PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN.toFixed(0)}%. Please type the word "confirm" to continue with this swap`) === 'confirm');
    }
    else if (!priceImpactWithoutFee.lessThan(ALLOWED_PRICE_IMPACT_HIGH)) {
        return window.confirm(`This swap has a price impact of at least ${ALLOWED_PRICE_IMPACT_HIGH.toFixed(0)} %. Please confirm that you would like to continue with this swap.`);
    }
    return true;
}

const Root$g = styled__default["default"](Box) `
  width: 100%;
  /* min-width: 360px; */
  position: relative;
  overflow: hidden;
`;
const SwapWrapper = styled__default["default"](Box) `
  border-bottom-left-radius: ${({ showRoute }) => (showRoute ? `0px` : `10px`)};
  border-bottom-right-radius: ${({ showRoute }) => (showRoute ? `0px` : `10px`)};
  width: 100%;
  /* min-width: 360px; */
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  position: relative;
  overflow: hidden;
`;
const CurrencyInputTextBox = styled__default["default"](CurrencyInput) `
  align-items: center;
  border-radius: 4px;
`;
const ArrowWrapper$4 = styled__default["default"].div `
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveBgColor; }};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;
const PValue = styled__default["default"](Box) `
  margin-left: 7px;
  margin-right: 7px;
  align-items: center;
  display: flex;
  width: 100%;
  font-size: 16px;
  color: ${({ theme, isActive }) => { var _a, _b; return (isActive ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.secondary); }};
  border-bottom: ${({ theme, isActive }) => { var _a; return (isActive ? `1px solid ${(_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary}` : 0); }};
  cursor: pointer;
  &:hover {
    color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary; }};
  }
`;
const LinkStyledButton = styled__default["default"].button `
  border: none;
  text-decoration: none;
  background: none;

  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  color: ${({ theme, disabled }) => { var _a, _b; return (disabled ? (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary : (_b = theme.swapWidget) === null || _b === void 0 ? void 0 : _b.primary); }};
  font-weight: 500;

  :hover {
    text-decoration: ${({ disabled }) => (disabled ? null : 'underline')};
  }

  :focus {
    outline: none;
    text-decoration: ${({ disabled }) => (disabled ? null : 'underline')};
  }

  :active {
    text-decoration: none;
  }
`;

const MarketOrder = ({ swapType, setSwapType, isLimitOrderVisible, showSettings, partnerDaaS = ZERO_ADDRESS, defaultInputAddress, defaultOutputAddress, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    // const [isRetryDrawerOpen, setIsRetryDrawerOpen] = useState(false);
    const [isTokenDrawerOpen, setIsTokenDrawerOpen] = React.useState(false);
    const [openSettings, setOpenSettings] = React.useState(false);
    const [selectedPercentage, setSelectedPercentage] = React.useState(0);
    const [tokenDrawerType, setTokenDrawerType] = React.useState(Field.INPUT);
    const percentageValue = [25, 50, 75, 100];
    const loadedUrlParams = useDefaultsFromURLSearch();
    // token warning stuff
    const [loadedInputCurrency, loadedOutputCurrency] = [
        useCurrency(loadedUrlParams === null || loadedUrlParams === void 0 ? void 0 : loadedUrlParams.inputCurrencyId),
        useCurrency(loadedUrlParams === null || loadedUrlParams === void 0 ? void 0 : loadedUrlParams.outputCurrencyId),
    ];
    const [dismissTokenWarning, setDismissTokenWarning] = React.useState(false);
    const urlLoadedTokens = React.useMemo(() => { var _a, _b; return (_b = (_a = [loadedInputCurrency, loadedOutputCurrency]) === null || _a === void 0 ? void 0 : _a.filter((c) => c instanceof sdk.Token)) !== null && _b !== void 0 ? _b : []; }, [loadedInputCurrency, loadedOutputCurrency]);
    const handleConfirmTokenWarning = React.useCallback(() => {
        setDismissTokenWarning(true);
    }, []);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useToken = useTokenHook[chainId];
    const theme = React.useContext(styled.ThemeContext);
    const useWrapCallback = useWrapCallbackHook[chainId];
    const useApproveCallbackFromTrade = useApproveCallbackFromTradeHook[chainId];
    const useSwapCallback = useSwapCallbackHook[chainId];
    // toggle wallet when disconnected
    const toggleWalletModal = useWalletModalToggle();
    // for expert mode
    // const toggleSettings = useToggleSettingsMenu()
    const [isExpertMode] = useExpertModeManager();
    // get custom setting values for user
    const [allowedSlippage] = useUserSlippageTolerance();
    const [feeTo, setFeeTo] = useDaasFeeTo();
    React.useEffect(() => {
        if (feeTo === partnerDaaS)
            return;
        setFeeTo(partnerDaaS);
    }, [feeTo, partnerDaaS]);
    // swap state
    const { independentField, typedValue, recipient } = useSwapState();
    const { v1Trade, v2Trade, currencyBalances, parsedAmount, currencies, inputError: swapInputError, isLoading: isLoadingSwap, } = useDerivedSwapInfo();
    const { wrapType, execute: onWrap, inputError: wrapInputError, } = useWrapCallback(currencies[Field.INPUT], currencies[Field.OUTPUT], typedValue);
    const showWrap = wrapType !== WrapType.NOT_APPLICABLE;
    const { address: recipientAddress } = useENS(recipient);
    const toggledVersion = useToggledVersion();
    const tradesByVersion = {
        [Version.v1]: v1Trade,
        [Version.v2]: v2Trade,
    };
    const trade = showWrap ? undefined : tradesByVersion[toggledVersion];
    // const defaultTrade = showWrap ? undefined : tradesByVersion[DEFAULT_VERSION]
    // const betterTradeLinkVersion: Version | undefined = undefined
    const parsedAmounts = showWrap
        ? {
            [Field.INPUT]: parsedAmount,
            [Field.OUTPUT]: parsedAmount,
        }
        : {
            [Field.INPUT]: independentField === Field.INPUT ? parsedAmount : trade === null || trade === void 0 ? void 0 : trade.inputAmount,
            [Field.OUTPUT]: independentField === Field.OUTPUT ? parsedAmount : trade === null || trade === void 0 ? void 0 : trade.outputAmount,
        };
    const { onSwitchTokens, onCurrencySelection, onUserInput, onChangeRecipient } = useSwapActionHandlers(chainId);
    const isValid = !swapInputError;
    const dependentField = independentField === Field.INPUT ? Field.OUTPUT : Field.INPUT;
    const inputCurrency = currencies[Field.INPUT];
    const outputCurrency = currencies[Field.OUTPUT];
    const handleTypeInput = React.useCallback((value) => {
        onUserInput(Field.INPUT, value);
    }, [onUserInput]);
    const handleTypeOutput = React.useCallback((value) => {
        onUserInput(Field.OUTPUT, value);
    }, [onUserInput]);
    // setting default tokens
    const defaultInputToken = useToken(defaultInputAddress);
    const defaultInputCurrency = defaultInputToken ? unwrappedToken(defaultInputToken, chainId) : undefined;
    const defaultOututToken = useToken(defaultOutputAddress);
    const defaultOutputCurrency = defaultOututToken ? unwrappedToken(defaultOututToken, chainId) : undefined;
    React.useEffect(() => {
        if (defaultInputCurrency) {
            onCurrencySelection(Field.INPUT, defaultInputCurrency);
        }
        if (defaultOutputCurrency) {
            onCurrencySelection(Field.OUTPUT, defaultOutputCurrency);
        }
    }, [chainId, defaultInputAddress, defaultOutputAddress, defaultInputCurrency, defaultOutputCurrency]);
    // modal and loading
    const [{ showConfirm, tradeToConfirm, swapErrorMessage, attemptingTxn, txHash }, setSwapState] = React.useState({
        showConfirm: false,
        tradeToConfirm: undefined,
        attemptingTxn: false,
        swapErrorMessage: undefined,
        txHash: undefined,
    });
    const formattedAmounts = {
        [independentField]: typedValue,
        [dependentField]: showWrap
            ? (_b = (_a = parsedAmounts[independentField]) === null || _a === void 0 ? void 0 : _a.toExact()) !== null && _b !== void 0 ? _b : ''
            : (_d = (_c = parsedAmounts[dependentField]) === null || _c === void 0 ? void 0 : _c.toSignificant(6)) !== null && _d !== void 0 ? _d : '',
    };
    const route = trade === null || trade === void 0 ? void 0 : trade.route;
    const tradePrice = trade === null || trade === void 0 ? void 0 : trade.executionPrice;
    const userHasSpecifiedInputOutput = Boolean(currencies[Field.INPUT] && currencies[Field.OUTPUT] && ((_e = parsedAmounts[independentField]) === null || _e === void 0 ? void 0 : _e.greaterThan(sdk.JSBI.BigInt(0))));
    const noRoute = !route;
    // check whether the user has approved the router on the input token
    const [approval, approveCallback] = useApproveCallbackFromTrade(chainId, trade, allowedSlippage);
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = React.useState(false);
    // mark when a user has submitted an approval, reset onTokenSelection for input field
    React.useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const maxAmountInput = maxAmountSpend(chainId, currencyBalances[Field.INPUT]);
    // the callback to execute the swap
    const { callback: swapCallback, error: swapCallbackError } = useSwapCallback(trade, allowedSlippage, recipient);
    const { priceImpactWithoutFee } = computeTradePriceBreakdown(trade);
    const handleSwap = React.useCallback(() => {
        if (priceImpactWithoutFee && !confirmPriceImpactWithoutFee(priceImpactWithoutFee)) {
            return;
        }
        if (!swapCallback) {
            return;
        }
        setSwapState({ attemptingTxn: true, tradeToConfirm, showConfirm, swapErrorMessage: undefined, txHash: undefined });
        swapCallback()
            .then((hash) => {
            var _a, _b, _c, _d;
            setSwapState({ attemptingTxn: false, tradeToConfirm, showConfirm, swapErrorMessage: undefined, txHash: hash });
            // eslint-disable-next-line import/no-named-as-default-member
            ReactGA__default["default"].event({
                category: 'Swap',
                action: recipient === null
                    ? 'Swap w/o Send'
                    : (recipientAddress !== null && recipientAddress !== void 0 ? recipientAddress : recipient) === account
                        ? 'Swap w/o Send + recipient'
                        : 'Swap w/ Send',
                label: [(_b = (_a = trade === null || trade === void 0 ? void 0 : trade.inputAmount) === null || _a === void 0 ? void 0 : _a.currency) === null || _b === void 0 ? void 0 : _b.symbol, (_d = (_c = trade === null || trade === void 0 ? void 0 : trade.outputAmount) === null || _c === void 0 ? void 0 : _c.currency) === null || _d === void 0 ? void 0 : _d.symbol, Version.v2].join('/'),
            });
        })
            .catch((error) => {
            setSwapState({
                attemptingTxn: false,
                tradeToConfirm,
                showConfirm,
                swapErrorMessage: error.message,
                txHash: undefined,
            });
            // we only care if the error is something _other_ than the user rejected the tx
            if ((error === null || error === void 0 ? void 0 : error.code) !== 4001) {
                console.error(error);
            }
        });
    }, [tradeToConfirm, account, priceImpactWithoutFee, recipient, recipientAddress, showConfirm, swapCallback, trade]);
    const handleSelectTokenDrawerClose = React.useCallback(() => {
        setIsTokenDrawerOpen(false);
    }, [setIsTokenDrawerOpen]);
    // errors
    // const [showInverted, setShowInverted] = useState<boolean>(false)
    // warnings on slippage
    const priceImpactSeverity = warningSeverity(priceImpactWithoutFee);
    // show approve flow when: no error on inputs, not approved or pending, or approved in current session
    // never show if price impact is above threshold in non expert mode
    const showApproveFlow = !swapInputError &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED)) &&
        !(priceImpactSeverity > 3 && !isExpertMode);
    const handleConfirmDismiss = React.useCallback(() => {
        setSwapState({ showConfirm: false, tradeToConfirm, attemptingTxn, swapErrorMessage, txHash });
        // if there was a tx hash, we want to clear the input
        if (txHash) {
            onUserInput(Field.INPUT, '');
        }
    }, [attemptingTxn, onUserInput, swapErrorMessage, tradeToConfirm, txHash]);
    const handleAcceptChanges = React.useCallback(() => {
        setSwapState({ tradeToConfirm: trade, swapErrorMessage, txHash, attemptingTxn, showConfirm });
    }, [attemptingTxn, showConfirm, swapErrorMessage, trade, txHash]);
    // const handleMaxInput = useCallback(() => {
    //   maxAmountInput && onUserInput(Field.INPUT, maxAmountInput.toExact())
    // }, [maxAmountInput, onUserInput])
    const onCurrencySelect = React.useCallback((currency) => {
        if (tokenDrawerType === Field.INPUT) {
            setApprovalSubmitted(false); // reset 2 step UI for approvals
        }
        onCurrencySelection(tokenDrawerType, currency);
    }, [tokenDrawerType, onCurrencySelection]);
    const isAEBToken = useIsSelectedAEBToken();
    const selectedTokens = useSelectedTokenList();
    const whitelistedTokens = useTokenList(DEFAULT_TOKEN_LISTS_SELECTED);
    const isTrustedToken = React.useCallback((token) => {
        if (!chainId || !selectedTokens)
            return true; // Assume trusted at first to avoid flashing a warning
        return (TRUSTED_TOKEN_ADDRESSES[chainId].includes(token.address) || // trust token from manually whitelisted token
            isTokenOnList(selectedTokens, chainId, token) || // trust all tokens from selected token list by user
            isTokenOnList(whitelistedTokens, chainId, token) // trust all defi + AB tokens
        );
    }, [chainId, selectedTokens, whitelistedTokens]);
    const closeSwapSettings = React.useCallback(() => {
        setOpenSettings(false);
    }, [setOpenSettings]);
    const openSwapSettings = React.useCallback(() => {
        setOpenSettings(true);
    }, [setOpenSettings]);
    const showRoute = Boolean(trade && ((_g = (_f = trade === null || trade === void 0 ? void 0 : trade.route) === null || _f === void 0 ? void 0 : _f.path) === null || _g === void 0 ? void 0 : _g.length) > 2);
    if (openSettings && showSettings) {
        return (jsxRuntime.jsx(Box, Object.assign({ minHeight: 450 }, { children: jsxRuntime.jsx(SwapSettingsDrawer, { isOpen: openSettings, close: closeSwapSettings }) })));
    }
    const renderButton = () => {
        var _a;
        if (!account) {
            return (jsxRuntime.jsx(Button, Object.assign({ isDisabled: !account, variant: "primary", onClick: toggleWalletModal }, { children: "Connect Wallet" })));
        }
        if (showWrap) {
            return (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", isDisabled: Boolean(wrapInputError), onClick: onWrap }, { children: wrapInputError !== null && wrapInputError !== void 0 ? wrapInputError : (wrapType === WrapType.WRAP ? 'Wrap' : wrapType === WrapType.UNWRAP ? 'unwrap' : null) })));
        }
        if (isLoadingSwap && !swapInputError) {
            return (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", isDisabled: true }, { children: "Loading" })));
        }
        if (noRoute && userHasSpecifiedInputOutput) {
            return (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", isDisabled: true }, { children: "Insufficient liquidity for this trade." })));
        }
        if (showApproveFlow) {
            return (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, { children: [jsxRuntime.jsx(Box, Object.assign({ mr: "10px", width: "100%" }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', onClick: () => approveCallback(), isDisabled: approval !== ApprovalState.NOT_APPROVED || approvalSubmitted, loading: approval === ApprovalState.PENDING, loadingText: "Approving" }, { children: approvalSubmitted && approval === ApprovalState.APPROVED
                                ? 'Approved'
                                : 'Approve' + ((_a = currencies[Field.INPUT]) === null || _a === void 0 ? void 0 : _a.symbol) })) })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: () => {
                            setSwapState({
                                tradeToConfirm: trade,
                                attemptingTxn: false,
                                swapErrorMessage: undefined,
                                showConfirm: true,
                                txHash: undefined,
                            });
                        }, id: "swap-button", isDisabled: !isValid || approval !== ApprovalState.APPROVED || (priceImpactSeverity > 3 && !isExpertMode) }, { children: priceImpactSeverity > 3 && !isExpertMode
                            ? 'Price Impact High'
                            : 'Swap' + `${priceImpactSeverity > 2 ? 'Anyway' : ''}` }))] })));
        }
        return (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: () => {
                setSwapState({
                    tradeToConfirm: trade,
                    attemptingTxn: false,
                    swapErrorMessage: undefined,
                    showConfirm: true,
                    txHash: undefined,
                });
            }, id: "swap-button", isDisabled: !isValid || (priceImpactSeverity > 3 && !isExpertMode) || !!swapCallbackError || !!swapInputError, backgroundColor: isValid && priceImpactSeverity > 2 ? 'primary' : undefined, color: isValid && priceImpactSeverity <= 2 ? 'black' : undefined }, { children: swapInputError
                ? swapInputError
                : priceImpactSeverity > 3 && !isExpertMode
                    ? 'Price Impact High'
                    : 'Swap' + `${priceImpactSeverity > 2 ? 'Anyway' : ''}` })));
    };
    const renderPercentage = () => {
        return (jsxRuntime.jsx(Box, Object.assign({ display: "flex", pb: "5px" }, { children: percentageValue.map((value, index) => (jsxRuntime.jsxs(PValue, Object.assign({ isActive: selectedPercentage === value, onClick: () => {
                    var _a;
                    setSelectedPercentage(value);
                    if (maxAmountInput) {
                        const multipyAmount = sdk.JSBI.multiply(maxAmountInput === null || maxAmountInput === void 0 ? void 0 : maxAmountInput.raw, sdk.JSBI.BigInt(value));
                        const divideAmount = sdk.JSBI.divide(multipyAmount, sdk.JSBI.BigInt(100));
                        const token = wrappedCurrency((_a = maxAmountInput === null || maxAmountInput === void 0 ? void 0 : maxAmountInput.currency) !== null && _a !== void 0 ? _a : undefined, chainId);
                        const newFinalAmount = new sdk.TokenAmount(token, divideAmount);
                        onUserInput(Field.INPUT, newFinalAmount.toExact());
                    }
                } }, { children: [value, "%"] }), index))) })));
    };
    return (jsxRuntime.jsxs(Root$g, { children: [jsxRuntime.jsx(TradeOption$1, { swapType: swapType, setSwapType: setSwapType, isLimitOrderVisible: isLimitOrderVisible, showSettings: showSettings, openSwapSettings: openSwapSettings }), jsxRuntime.jsx(TokenWarningModal, { isOpen: urlLoadedTokens.length > 0 && !dismissTokenWarning && !urlLoadedTokens.every(isTrustedToken), tokens: urlLoadedTokens, onConfirm: handleConfirmTokenWarning }), jsxRuntime.jsx(SwapWrapper, Object.assign({ showRoute: showRoute }, { children: jsxRuntime.jsxs(Box, Object.assign({ p: 10 }, { children: [isAEBToken && jsxRuntime.jsx(DeprecatedWarning, {}), jsxRuntime.jsx(CurrencyInputTextBox, { label: independentField === Field.OUTPUT && !showWrap && trade ? 'From (estimated)' : 'From', value: formattedAmounts[Field.INPUT], onChange: (value) => {
                                setSelectedPercentage(0);
                                handleTypeInput(value);
                            }, onTokenClick: () => {
                                setTokenDrawerType(Field.INPUT);
                                setIsTokenDrawerOpen(true);
                            }, currency: inputCurrency, fontSize: 24, isNumeric: true, placeholder: "0.00", id: "swap-currency-input", addonLabel: renderPercentage() }), jsxRuntime.jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: "flex", justifyContent: 'center', mt: 10 }, { children: jsxRuntime.jsx(ArrowWrapper$4, Object.assign({ onClick: () => {
                                    setApprovalSubmitted(false); // reset 2 step UI for approvals
                                    onSwitchTokens();
                                } }, { children: jsxRuntime.jsx(reactFeather.RefreshCcw, { size: "16", color: (_h = theme.swapWidget) === null || _h === void 0 ? void 0 : _h.interactiveColor }) })) })), jsxRuntime.jsx(CurrencyInputTextBox, { label: independentField === Field.INPUT && !showWrap && trade ? 'To (estimated)' : 'To', value: formattedAmounts[Field.OUTPUT], onChange: (value) => {
                                setSelectedPercentage(0);
                                handleTypeOutput(value);
                            }, onTokenClick: () => {
                                setTokenDrawerType(Field.OUTPUT);
                                setIsTokenDrawerOpen(true);
                            }, currency: outputCurrency, fontSize: 24, isNumeric: true, placeholder: "0.00", id: "swap-currency-output", addonLabel: tradePrice && (jsxRuntime.jsxs(Text, Object.assign({ color: "swapWidget.secondary", fontSize: 16 }, { children: ["Price: ", tradePrice === null || tradePrice === void 0 ? void 0 : tradePrice.toSignificant(6), " ", (_j = tradePrice === null || tradePrice === void 0 ? void 0 : tradePrice.quoteCurrency) === null || _j === void 0 ? void 0 : _j.symbol] }))) }), recipient === null && !showWrap && isExpertMode ? (jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexDirection: "column", marginTop: 10 }, { children: jsxRuntime.jsx(LinkStyledButton, Object.assign({ id: "add-recipient-button", onClick: () => onChangeRecipient(''), style: { alignSelf: 'end' } }, { children: "+ Add Recipient" })) }))) : null, recipient !== null && !showWrap ? (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", marginTop: 10, marginBottom: 10 }, { children: [jsxRuntime.jsx(LinkStyledButton, Object.assign({ id: "add-recipient-button", onClick: () => onChangeRecipient(null), style: { alignSelf: 'end' } }, { children: "- Remove Recipient" })), jsxRuntime.jsx(TextInput, { label: "Recipient", placeholder: "Wallet Address", value: recipient, onChange: (value) => {
                                        const withoutSpaces = value.replace(/\s+/g, '');
                                        onChangeRecipient(withoutSpaces);
                                    }, addonLabel: recipient && !isAddress(recipient) && jsxRuntime.jsx(Text, Object.assign({ color: "warning" }, { children: "Invalid Address" })) })] }))) : null, trade && jsxRuntime.jsx(SwapDetailInfo, { trade: trade }), jsxRuntime.jsx(Box, Object.assign({ width: "100%", mt: 10 }, { children: renderButton() }))] })) })), trade && showRoute && jsxRuntime.jsx(SwapRoute, { trade: trade }), isTokenDrawerOpen && (jsxRuntime.jsx(SelectTokenDrawer$1, { isOpen: isTokenDrawerOpen, onClose: handleSelectTokenDrawerClose, onCurrencySelect: onCurrencySelect, selectedCurrency: tokenDrawerType === Field.INPUT ? inputCurrency : outputCurrency, otherSelectedCurrency: tokenDrawerType === Field.INPUT ? outputCurrency : inputCurrency })), trade && showConfirm && (jsxRuntime.jsx(ConfirmSwapDrawer$1, { isOpen: showConfirm, trade: trade, originalTrade: tradeToConfirm, onAcceptChanges: handleAcceptChanges, attemptingTxn: attemptingTxn, txHash: txHash, recipient: recipient, allowedSlippage: allowedSlippage, onConfirm: handleSwap, swapErrorMessage: swapErrorMessage, onClose: handleConfirmDismiss }))] }));
};

const Root$f = styled__default["default"](Box) `
  width: 100%;
  min-width: 320px;
  position: relative;
  overflow: hidden;

  * {
    box-sizing: border-box;
  }
`;

const SwapWidget = ({ isLimitOrderVisible = false, onSwapTypeChange, showSettings = true, partnerDaaS = ZERO_ADDRESS, defaultInputToken, defaultOutputToken, }) => {
    const [swapType, setSwapType] = React.useState(exports.SwapTypes.MARKET);
    return (jsxRuntime.jsx(Root$f, { children: swapType === exports.SwapTypes.LIMIT ? (jsxRuntime.jsx(LimitOrder, { swapType: swapType, setSwapType: (type) => {
                setSwapType(type);
                onSwapTypeChange && onSwapTypeChange(type);
            }, isLimitOrderVisible: isLimitOrderVisible, defaultInputAddress: defaultInputToken, defaultOutputAddress: defaultOutputToken })) : (jsxRuntime.jsx(MarketOrder, { swapType: swapType, setSwapType: (type) => {
                setSwapType(type);
                onSwapTypeChange && onSwapTypeChange(type);
            }, isLimitOrderVisible: isLimitOrderVisible, showSettings: showSettings, partnerDaaS: partnerDaaS, defaultInputAddress: defaultInputToken, defaultOutputAddress: defaultOutputToken })) }));
};

const Wrapper$b = styled__default["default"](Box) `
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 5px;
`;

const ShowMore = (props) => {
    const { onToggle, showMore } = props;
    const theme = React.useContext(styled.ThemeContext);
    return (jsxRuntime.jsxs(Wrapper$b, Object.assign({ onClick: () => onToggle() }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, marginLeft: '6px', textAlign: "center" }, { children: showMore ? 'See Less' : 'See More' })), showMore ? (jsxRuntime.jsx(reactFeather.ChevronUp, { size: "16", color: theme.text2, style: { marginLeft: '4px' } })) : (jsxRuntime.jsx(reactFeather.ChevronDown, { size: "16", color: theme.text2, style: { marginLeft: '4px' } }))] })));
};

function useToggle(initialState = false) {
    const [state, setState] = React.useState(initialState);
    const toggle = React.useCallback(() => setState((state) => !state), []);
    return [state, toggle];
}

function useSelectedCurrencyLists() {
    var _a;
    const { chainId = sdk.ChainId.AVALANCHE } = usePangolinWeb3();
    const allTokens = useAllTokens();
    const coins = Object.values(allTokens || {});
    let addresses = useSelector((state) => { var _a; return [].concat(((_a = state === null || state === void 0 ? void 0 : state.pwatchlists) === null || _a === void 0 ? void 0 : _a.currencies) || []); });
    addresses = [(_a = PNG[chainId]) === null || _a === void 0 ? void 0 : _a.address, ...addresses];
    let allSelectedToken = [];
    addresses.forEach((address) => {
        const filterTokens = coins.filter((coin) => address.toLowerCase() === coin.address.toLowerCase());
        allSelectedToken = [...allSelectedToken, ...filterTokens];
    });
    return allSelectedToken;
}
function useIsSelectedCurrency(address) {
    var _a;
    const { chainId = sdk.ChainId.AVALANCHE } = usePangolinWeb3();
    let addresses = useSelector((state) => { var _a; return [].concat(((_a = state === null || state === void 0 ? void 0 : state.pwatchlists) === null || _a === void 0 ? void 0 : _a.currencies) || []); });
    addresses = [(_a = PNG[chainId]) === null || _a === void 0 ? void 0 : _a.address, ...addresses];
    return (addresses || []).includes(address);
}

const Hidden = styled__default["default"](Box) `
  ${({ theme, upToExtraSmall }) => upToExtraSmall &&
    theme.mediaWidth.upToExtraSmall `
      display: none;
    `};

  ${({ theme, upToSmall }) => upToSmall &&
    theme.mediaWidth.upToSmall `
      display: none;
    `};

  ${({ theme, upToMedium }) => upToMedium &&
    theme.mediaWidth.upToMedium `
      display: none;
    `};

  ${({ theme, upToLarge }) => upToLarge &&
    theme.mediaWidth.upToLarge `
      display: none;
    `};
`;
const Visible = styled__default["default"](Box) `
  display: none;
  ${({ theme, upToExtraSmall }) => upToExtraSmall &&
    theme.mediaWidth.upToExtraSmall `
    display: block;
  `};

  ${({ theme, upToSmall }) => upToSmall &&
    theme.mediaWidth.upToSmall `
    display: block;
  `};

  ${({ theme, upToMedium }) => upToMedium &&
    theme.mediaWidth.upToMedium `
    display: block;
  `};

  ${({ theme, upToLarge }) => upToLarge &&
    theme.mediaWidth.upToLarge `
    display: block;
  `};
`;
const CloseIcon = styled__default["default"](reactFeather.X) `
  cursor: pointer;
`;

const GET_BLOCKS = (timestamps) => {
  let queryString = 'query blocks {';
  queryString += timestamps.map((timestamp) => {
    return `t${timestamp}:blocks(first: 1, orderBy: timestamp, orderDirection: asc, where: { timestamp_gt: ${timestamp}, timestamp_lt: ${
      timestamp + 60 * 60 * 24 * 7
    } }) {
      number
    }`;
  });
  queryString += '}';
  return gql__default["default"](queryString);
};

const PRICES_BY_BLOCK = (tokenAddress, blocks) => {
  let queryString = 'query blocks {';
  queryString += blocks.map(
    (block) => `
      t${block.timestamp}:token(id:"${tokenAddress}", block: { number: ${block.number} }) { 
        derivedETH
      }
    `,
  );
  queryString += ',';
  queryString += blocks.map(
    (block) => `
      b${block.timestamp}: bundle(id:"1", block: { number: ${block.number} }) { 
        ethPrice
      }
    `,
  );

  queryString += '}';
  return gql__default["default"](queryString);
};

const client = new apolloClient.ApolloClient({
  link: new apolloLinkHttp.HttpLink({
    uri: `${SUBGRAPH_BASE_URL}/exchange`,
  }),
  cache: new apolloCacheInmemory.InMemoryCache(),
  shouldBatch: true,
});

const blockClient = new apolloClient.ApolloClient({
  link: new apolloLinkHttp.HttpLink({
    uri: 'https://api.thegraph.com/subgraphs/name/dasconnor/avalanche-blocks',
  }),
  cache: new apolloCacheInmemory.InMemoryCache(),
});

const avalancheMininchefV2Client = new graphqlRequest.GraphQLClient(
  'https://api.thegraph.com/subgraphs/name/sarjuhansaliya/minichefv2-dummy',
  { headers: {} },
);

const mininchefV2Clients = {
  [sdk.ChainId.AVALANCHE]: avalancheMininchefV2Client,
  [sdk.ChainId.FUJI]: undefined,
  [sdk.ChainId.WAGMI]: undefined,
  [sdk.ChainId.COSTON]: undefined,
  [sdk.ChainId.SONGBIRD]: undefined,
  [sdk.ChainId.NEAR_MAINNET]: undefined,
  [sdk.ChainId.NEAR_TESTNET]: undefined,
};

const GET_TOKEN_DAY_DATAS = gql__default["default"]`
  query tokenDayDatas($token: String!) {
    tokenDayDatas(first: 7, orderBy: date, orderDirection: desc, where: { token: $token }) {
      id
      date
      priceUSD
      token {
        symbol
      }
    }
  }
`;

function splitQuery(query, localClient, vars, list, skipCount = 100) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        let fetchedData = {};
        let allFound = false;
        let skip = 0;
        while (!allFound) {
            let end = list.length;
            if (skip + skipCount < list.length) {
                end = skip + skipCount;
            }
            const sliced = list.slice(skip, end);
            const result = yield localClient.query({
                query: query(...vars, sliced),
                fetchPolicy: 'cache-first',
            });
            fetchedData = Object.assign(Object.assign({}, fetchedData), result.data);
            if (Object.keys(result.data).length < skipCount || skip + skipCount > list.length) {
                allFound = true;
            }
            else {
                skip += skipCount;
            }
        }
        return fetchedData;
    });
}

dayjs__default["default"].extend(utc__default["default"]);
function useAllTokenWeeklyPriceChartData() {
    return useSelector((state) => { var _a; return ((_a = state === null || state === void 0 ? void 0 : state.ptoken) === null || _a === void 0 ? void 0 : _a.weekly) || {}; });
}
function useAllTokenPricesChartData() {
    return useSelector((state) => { var _a; return ((_a = state === null || state === void 0 ? void 0 : state.ptoken) === null || _a === void 0 ? void 0 : _a.tokenPrices) || {}; });
}
function useTokenWeeklyChartData(tokenAddress) {
    const data1 = useAllTokenWeeklyPriceChartData();
    const chartData = data1 === null || data1 === void 0 ? void 0 : data1[tokenAddress];
    const dispatch = useDispatch();
    React.useEffect(() => {
        function checkForChartData() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (!chartData) {
                    const data = yield getTokenWeeklyChartData(tokenAddress);
                    dispatch(updateTokenWeeklyPriceChartData({ address: tokenAddress, chartData: data }));
                }
            });
        }
        checkForChartData();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [chartData, tokenAddress]);
    return chartData;
}
const getTokenWeeklyChartData = (tokenAddress) => tslib.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    let data = [];
    try {
        const result = yield client.query({
            query: GET_TOKEN_DAY_DATAS,
            variables: {
                token: tokenAddress,
            },
            fetchPolicy: 'cache-first',
        });
        data = (_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.tokenDayDatas;
    }
    catch (e) {
        console.log(e);
    }
    data = data.sort((a, b) => (parseInt(a.date) > parseInt(b.date) ? 1 : -1));
    return data;
});
function useTokenPriceData(tokenAddress, timeWindow, interval = 3600, type = 'ALL') {
    const data1 = useAllTokenPricesChartData();
    const chartData = data1 === null || data1 === void 0 ? void 0 : data1[tokenAddress];
    const dispatch = useDispatch();
    React.useEffect(() => {
        const currentTime = dayjs__default["default"] === null || dayjs__default["default"] === void 0 ? void 0 : dayjs__default["default"].utc();
        // February 8th 2021 - Arcanum Factory is created
        const startTime = type === 'ALL'
            ? dayjs__default["default"]('2021-02-11').startOf('hour').unix()
            : currentTime
                .subtract(1, timeWindow)
                .startOf('hour')
                .unix();
        function fetch() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const data = yield getIntervalTokenData(tokenAddress, startTime, undefined, interval);
                dispatch(updateTokenPriceChartData({ address: tokenAddress, chartData: data }));
            });
        }
        fetch();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [interval, timeWindow, tokenAddress]);
    return chartData;
}
const getIntervalTokenData = (tokenAddress, startTime, to = dayjs__default["default"].utc().unix(), interval = 3600 * 24) => tslib.__awaiter(void 0, void 0, void 0, function* () {
    var _b, _c;
    const utcEndTime = to;
    let time = startTime;
    // create an array of hour start times until we reach current hour
    // buffer by half hour to catch case where graph isnt synced to latest block
    const timestamps = [];
    while (time < utcEndTime) {
        timestamps.push(time);
        time += interval;
    }
    // backout if invalid timestamp format
    if (timestamps.length === 0) {
        return [];
    }
    // once you have all the timestamps, get the blocks for each timestamp in a bulk query
    let blocks;
    try {
        blocks = yield getBlocksFromTimestamps(timestamps, 100);
        // catch failing case
        if (!blocks || blocks.length === 0) {
            return [];
        }
        const result = yield splitQuery(PRICES_BY_BLOCK, client, [tokenAddress], blocks, 50);
        // format token ETH price results
        const values = [];
        for (const row in result) {
            const timestamp = row.split('t')[1];
            if (!timestamp)
                continue;
            const derivedETH = parseFloat((_b = result[`t${timestamp}`]) === null || _b === void 0 ? void 0 : _b.derivedETH);
            const ethPrice = parseFloat((_c = result[`b${timestamp}`]) === null || _c === void 0 ? void 0 : _c.ethPrice);
            const priceUSD = ethPrice * derivedETH;
            values.push({
                timestamp,
                derivedETH,
                ethPrice,
                priceUSD,
            });
        }
        const formattedHistory = [];
        // for each hour, construct the open and close price
        for (let i = 0; i < values.length - 1; i++) {
            formattedHistory.push({
                timestamp: values[i].timestamp,
                priceUSD: parseFloat(values === null || values === void 0 ? void 0 : values[i].priceUSD),
            });
        }
        return formattedHistory;
    }
    catch (e) {
        console.log(e);
        console.log('error fetching blocks');
        return [];
    }
});
function getBlocksFromTimestamps(timestamps, skipCount = 500) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        if ((timestamps === null || timestamps === void 0 ? void 0 : timestamps.length) === 0) {
            return [];
        }
        const fetchedData = yield splitQuery(GET_BLOCKS, blockClient, [], timestamps, skipCount);
        const blocks = [];
        if (fetchedData) {
            for (const t in fetchedData) {
                if (fetchedData[t].length > 0) {
                    blocks.push({
                        timestamp: t.split('t')[1],
                        number: fetchedData[t][0]['number'],
                    });
                }
            }
        }
        return blocks;
    });
}

dayjs__default["default"].extend(utc__default["default"]);
const toK = (num) => {
    return numeral__default["default"](num).format('0.[00]a');
};
// using a currency library here in case we want to add more in future
const priceFormatter = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
});
const toNiceDateYear = (date) => {
    return dayjs__default["default"].utc(dayjs__default["default"].unix(date)).format('MMMM DD, YYYY');
};
const formattedNum = (number, usd = false) => {
    if (isNaN(number) || number === '' || number === undefined) {
        return usd ? '$0' : 0;
    }
    const num = parseFloat(number);
    if (num > 500000000) {
        return (usd ? '$' : '') + toK(num.toFixed(0));
    }
    if (num === 0) {
        if (usd) {
            return '$0';
        }
        return 0;
    }
    if (num < 0.0001 && num > 0) {
        return usd ? '< $0.0001' : '< 0.0001';
    }
    if (num > 1000) {
        return usd
            ? '$' + Number(parseFloat(num).toFixed(0)).toLocaleString()
            : '' + Number(parseFloat(num).toFixed(0)).toLocaleString();
    }
    if (usd) {
        if (num < 0.1) {
            return '$' + Number(parseFloat(num).toFixed(4));
        }
        else {
            const usdString = priceFormatter.format(num);
            return '$' + usdString.slice(1, usdString.length);
        }
    }
    return Number(parseFloat(num).toFixed(5));
};

const WatchListRoot = styled__default["default"](Box) `
  width: 100%;
  height: 100%;
  border-radius: 10px;
  padding: 20px;
  background-color: ${({ theme }) => theme.color2};
  display: flex;
  flex-direction: column;
`;
const DesktopWatchList = styled__default["default"](Box) `
  display: flex;
  flex-direction: column;
  ${({ theme }) => theme.mediaWidth.upToSmall `
    display: none;
  `};
`;
const MobileWatchList = styled__default["default"].div `
  display: none;
  ${({ theme }) => theme.mediaWidth.upToSmall `
  display: block;
`};
`;
const GridContainer$1 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: ${({ coinChartVisible }) => (!coinChartVisible ? `100%` : `minmax(auto, 50%) 50%`)};
  grid-gap: 8px;
  flex: 1;
  min-height: 263px;
  ${({ theme }) => theme.mediaWidth.upToSmall `
    grid-template-columns: none;
    grid-template-rows: max-content;
  `};
`;
styled__default["default"](Box) `
  height: 1px;
  background-color: ${({ theme }) => theme.bg7};
  margin: 10px 0px 10px 0px;
  width: 100%;
`;
styled__default["default"](Box) `
  max-height: 200px;
  overflow-y: auto;
`;
// WatchList Row Styles
const RowWrapper$2 = styled__default["default"](Box) `
  padding: 0px 10px;
  display: grid;
  grid-template-columns: 100px minmax(auto, 1fr) max-content;
  align-items: center;
  border-bottom: 1px solid ${({ theme }) => theme.text9};
  cursor: ${({ isSelected }) => (isSelected ? 'default' : 'pointer')} !important;
  background-color: ${({ theme, isSelected }) => (isSelected ? theme.color10 : theme.color2)};

  height: 48px;

  &:hover {
    background-color: ${({ theme }) => theme.color10};
  }
`;
const DeleteButton = styled__default["default"].button `
  background-image: linear-gradient(to right, rgba(255, 0, 0, 0), ${({ theme }) => theme.bg6});
  background-color: transparent;
  border: 0px;
  color: ${({ theme }) => theme.text1};
  cursor: pointer;
  display: block;
  height: 64px;
  width: 100%;
  position: absolute;
`;
// Coin Chart Styles
const SelectedCoinInfo = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: max-content auto max-content;
  grid-gap: 8px;
  align-items: center;
`;
const TrackIcons = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: max-content max-content;
  grid-gap: 15px;
  align-items: center;
`;
const DurationBtns = styled__default["default"](Box) `
  display: flex;
  justify-content: space-between;
  align-items: center;
`;
const Title$1 = styled__default["default"](Text) `
  font-size: 24px;
  font-weight: 500;
  color: ${({ theme }) => theme.text1};

  ${({ theme }) => theme.mediaWidth.upToSmall `
    font-size: 24px
  `};
`;

const CoinChart = ({ coin, visibleTradeButton, tradeLinkUrl, redirect }) => {
    const chainId = useChainId();
    const weekFrame = TIMEFRAME.find((value) => value.label === '1W');
    const { tokenUsdPrice } = useCoinGeckoTokenPrice(coin);
    const [timeWindow, setTimeWindow] = React.useState(weekFrame ||
        {});
    const tokenPrice = useUSDCPrice(coin);
    const usdcPrice = tokenUsdPrice || (tokenPrice === null || tokenPrice === void 0 ? void 0 : tokenPrice.toSignificant(4));
    const { onCurrencySelection } = useSwapActionHandlers(chainId);
    const onCurrencySelect = React.useCallback((currency) => {
        onCurrencySelection(Field.INPUT, currency);
    }, [onCurrencySelection]);
    const pangolinData = useTokenPriceData(((coin === null || coin === void 0 ? void 0 : coin.address) || '').toLowerCase(), timeWindow === null || timeWindow === void 0 ? void 0 : timeWindow.momentIdentifier, timeWindow === null || timeWindow === void 0 ? void 0 : timeWindow.interval, timeWindow === null || timeWindow === void 0 ? void 0 : timeWindow.label) || [];
    const coinGekoData = useCoinGeckoTokenPriceChart(coin, timeWindow === null || timeWindow === void 0 ? void 0 : timeWindow.days) || [];
    const token = unwrappedToken(coin, chainId);
    const priceChart = coinGekoData.length > 0 ? [...coinGekoData] : [...pangolinData];
    // add current price in chart
    if (priceChart.length > 0 && usdcPrice) {
        const timestampnow = Math.floor(Date.now() / 1000);
        priceChart.push({
            priceUSD: parseFloat(usdcPrice),
            timestamp: `${timestampnow}`,
        });
    }
    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(SelectedCoinInfo, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: token, size: 48 }), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "24px", fontWeight: 500 }, { children: token.symbol })), jsxRuntime.jsxs(Text, Object.assign({ color: "green1", fontSize: "16px" }, { children: ["$", usdcPrice ? usdcPrice : '-'] }))] }), jsxRuntime.jsxs(TrackIcons, { children: [jsxRuntime.jsx(Button, Object.assign({ variant: "primary", backgroundColor: "primary", color: "black", width: '32px', height: '32px', padding: "0px", href: `${ANALYTICS_PAGE}/#/token/${coin === null || coin === void 0 ? void 0 : coin.address}`, target: "_blank", as: "a" }, { children: jsxRuntime.jsx(reactFeather.Link, { size: 12 }) })), visibleTradeButton &&
                                (redirect ? (jsxRuntime.jsx(Button, Object.assign({ variant: "plain", backgroundColor: "oceanBlue", color: "white", padding: "0px 10px", height: "32px", href: `/#${tradeLinkUrl}?inputCurrency=${coin === null || coin === void 0 ? void 0 : coin.address}`, target: "", as: "a" }, { children: "Trade" }))) : (jsxRuntime.jsx(Button, Object.assign({ variant: "plain", backgroundColor: "oceanBlue", color: "white", padding: "0px 10px", height: "32px", onClick: () => {
                                        onCurrencySelect(coin);
                                    } }, { children: "Trade" }))))] })] }), jsxRuntime.jsx(recharts.ResponsiveContainer, Object.assign({ height: 150, width: '100%' }, { children: jsxRuntime.jsxs(recharts.LineChart, Object.assign({ data: priceChart }, { children: [jsxRuntime.jsx(recharts.Line, { type: "monotone", dataKey: "priceUSD", stroke: '#18C145', dot: false }), jsxRuntime.jsx(recharts.Tooltip, { cursor: true, formatter: (priceUSD) => {
                                return [`${formattedNum(priceUSD, true)}`, 'USD'];
                            }, labelFormatter: (_label, data) => {
                                var _a, _b;
                                return toNiceDateYear((_b = (_a = data === null || data === void 0 ? void 0 : data[0]) === null || _a === void 0 ? void 0 : _a.payload) === null || _b === void 0 ? void 0 : _b.timestamp);
                            }, labelStyle: { paddingTop: 4 }, wrapperStyle: { top: -70, left: -10, zIndex: 9999 } })] })) })), jsxRuntime.jsx(DurationBtns, { children: TIMEFRAME.map((btn) => (jsxRuntime.jsx(Button, Object.assign({ variant: "plain", padding: "0px", width: "auto", color: timeWindow.label === btn.label ? 'mustardYellow' : 'text1', onClick: () => setTimeWindow(btn) }, { children: btn === null || btn === void 0 ? void 0 : btn.label }), btn === null || btn === void 0 ? void 0 : btn.label))) })] }));
};

function filterTokens$1(tokens, search) {
    if (search.length === 0)
        return tokens;
    const searchingAddress = isAddress(search);
    if (searchingAddress) {
        return tokens.filter((token) => token.address === searchingAddress);
    }
    const lowerSearchParts = search
        .toLowerCase()
        .split(/\s+/)
        .filter((s) => s.length > 0);
    if (lowerSearchParts.length === 0) {
        return tokens;
    }
    const matchesSearch = (s) => {
        const sParts = s
            .toLowerCase()
            .split(/\s+/)
            .filter((value) => value.length > 0);
        return lowerSearchParts.every((p) => p.length === 0 || sParts.some((sp) => sp.startsWith(p) || sp.endsWith(p)));
    };
    return tokens.filter((token) => {
        const { symbol, name } = token;
        return (symbol && matchesSearch(symbol)) || (name && matchesSearch(name));
    });
}

// compare two token amounts with highest one coming first
function balanceComparator$1(balanceA, balanceB) {
    if (balanceA && balanceB) {
        return balanceA.greaterThan(balanceB) ? -1 : balanceA.equalTo(balanceB) ? 0 : 1;
    }
    else if (balanceA && balanceA.greaterThan('0')) {
        return -1;
    }
    else if (balanceB && balanceB.greaterThan('0')) {
        return 1;
    }
    return 0;
}
function getTokenComparator$1(balances) {
    return function sortTokens(tokenA, tokenB) {
        // -1 = a is first
        // 1 = b is first
        // sort by balances
        const balanceA = balances[tokenA.address];
        const balanceB = balances[tokenB.address];
        const balanceComp = balanceComparator$1(balanceA, balanceB);
        if (balanceComp !== 0)
            return balanceComp;
        if (tokenA.symbol && tokenB.symbol) {
            // sort by symbol
            return tokenA.symbol.toLowerCase() < tokenB.symbol.toLowerCase() ? -1 : 1;
        }
        else {
            return tokenA.symbol ? -1 : tokenB.symbol ? -1 : 0;
        }
    };
}
function useTokenComparator$1(inverted, firstTokens) {
    const balances = useAllTokenBalances();
    const comparator = React.useMemo(() => getTokenComparator$1(balances !== null && balances !== void 0 ? balances : {}), [balances]);
    return React.useMemo(() => {
        // if firstToken add firstToken in top of array
        if (firstTokens) {
            return (tokenA, tokenB) => {
                const firstTokenIndex = firstTokens.findIndex((t) => t.address === tokenA.address);
                const secondTokenIndex = firstTokens.findIndex((t) => t.address === tokenB.address);
                if (firstTokenIndex !== -1 || secondTokenIndex !== -1) {
                    return secondTokenIndex - firstTokenIndex;
                }
                return comparator(tokenA, tokenB) * (inverted ? -1 : 1);
            };
        }
        if (inverted) {
            return (tokenA, tokenB) => comparator(tokenA, tokenB) * -1;
        }
        else {
            return comparator;
        }
    }, [inverted, firstTokens, comparator]);
}

// modified from https://usehooks.com/usePrevious/
function usePrevious(value) {
    // The ref object is a generic container whose current property is mutable ...
    // ... and can hold any value, similar to an instance property on a class
    const ref = React.useRef();
    // Store current value in ref
    React.useEffect(() => {
        ref.current = value;
    }, [value]); // Only re-run if value changes
    // Return previous value (happens before update in useEffect above)
    return ref.current;
}

styled__default["default"](Box) `
  padding: 10px;
`;
const AddInputWrapper$1 = styled__default["default"](Box) `
  display: grid;
  grid-gap: 10px;
`;
const PopoverContainer$1 = styled__default["default"](Box) `
  z-index: 100;
  background: ${({ theme }) => theme.bg6};
  box-shadow: 0px 0px 1px rgba(0, 0, 0, 0.01), 0px 4px 8px rgba(0, 0, 0, 0.04), 0px 16px 24px rgba(0, 0, 0, 0.04),
    0px 24px 32px rgba(0, 0, 0, 0.01);
  color: ${({ theme }) => theme.text2};
  border-radius: 0.5rem;
  padding: 5px;
  display: flex;
  flex-direction: column;
  font-size: 1rem;
  text-align: left;
  height: 200px;
  position: absolute;
  min-width: 20.125rem;
  right: -6px;
  margin-top: 20px;
  &:after {
    content: '';
    position: absolute;
    top: -14px;
    left: 280px;
    border-style: solid;
    border-width: 0px 15px 15px;
    border-color: ${({ theme }) => theme.bg6} transparent;
    display: block;
    width: 0;
    z-index: 1;
  }
`;
const RowWrapper$1 = styled__default["default"].div `
  padding: 5px 5px;
  display: grid;
  grid-template-columns: 100px minmax(auto, calc(100% - 150px)) 50px;
  align-items: center;
  border-bottom: 1px solid ${({ theme }) => theme.text9};
  border-radius: 4px 4px 0px 0px;
  height: 45px;

  cursor: ${({ disabled }) => !disabled && 'pointer'};
  pointer-events: ${({ disabled }) => disabled && 'none'};

  &:hover {
    background-color: ${({ theme, disabled }) => !disabled && theme.bg3};
  }

  opacity: ${({ disabled }) => (disabled ? 0.5 : 1)};
`;
const CurrencyList$2 = styled__default["default"].div `
  display: flex;
  flex: 1;
  flex-direction: column;
  position: relative;
  overflow-y: auto;
`;

const WatchlistCurrencyRow = ({ currency, onSelect, style }) => {
    const usdcPrice = useUSDCPrice(currency);
    const isSelected = useIsSelectedCurrency(currency === null || currency === void 0 ? void 0 : currency.address);
    const chainId = useChainId();
    const handleSelect = React.useCallback(() => {
        onSelect(currency === null || currency === void 0 ? void 0 : currency.address);
    }, [onSelect, currency]);
    const token = unwrappedToken(currency, chainId);
    return (jsxRuntime.jsxs(RowWrapper$1, Object.assign({ disabled: isSelected, style: style }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsx(CurrencyLogo, { size: 24, currency: token }), jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 400, marginLeft: '6px' }, { children: token === null || token === void 0 ? void 0 : token.symbol }))] })), jsxRuntime.jsx(Box, Object.assign({ ml: '10px', textAlign: "right" }, { children: jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 400 }, { children: ["$", usdcPrice ? usdcPrice === null || usdcPrice === void 0 ? void 0 : usdcPrice.toSignificant(4, { groupSeparator: ',' }) : '-'] })) })), jsxRuntime.jsx(Box, Object.assign({ ml: '10px', textAlign: "right" }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "secondary", backgroundColor: "bg9", color: "text6", padding: '0px', onClick: handleSelect, height: "24px" }, { children: "Add" })) }))] })));
};

const currencyKey$1 = (currency, chainId) => {
    var _a, _b;
    return currency instanceof sdk.Token
        ? currency.address
        : currency === sdk.CAVAX[chainId] && ((_a = sdk.CAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.symbol)
            ? (_b = sdk.CAVAX[chainId]) === null || _b === void 0 ? void 0 : _b.symbol
            : '';
};
const CurrencyPopover = ({ getRef = () => {
    /* */
}, coins, isOpen, onSelectCurrency, }) => {
    const [searchQuery, setSearchQuery] = React.useState('');
    const [invertSearchOrder] = React.useState(false);
    const chainId = useChainId();
    const inputRef = React.useRef(null);
    const lastOpen = usePrevious(isOpen);
    React.useEffect(() => {
        if (isOpen && !lastOpen) {
            setSearchQuery('');
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen]);
    React.useEffect(() => {
        if (isOpen && inputRef.current) {
            setTimeout(() => {
                var _a;
                (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }, 500);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen]);
    const isAddressSearch = isAddress(searchQuery);
    const searchToken = useToken(searchQuery);
    const tokenComparator = useTokenComparator$1(invertSearchOrder, [sdk.WAVAX[chainId]]);
    const filteredTokens = React.useMemo(() => {
        if (isAddressSearch)
            return searchToken ? [searchToken] : [];
        return filterTokens$1(Object.values(coins), searchQuery);
    }, [isAddressSearch, searchToken, coins, searchQuery]);
    const filteredSortedTokens = React.useMemo(() => {
        if (searchToken)
            return [searchToken];
        const sorted = filteredTokens.sort(tokenComparator);
        const symbolMatch = searchQuery
            .toLowerCase()
            .split(/\s+/)
            .filter((s) => s.length > 0);
        if (symbolMatch.length > 1)
            return sorted;
        return [
            ...(searchToken ? [searchToken] : []),
            // sort any exact symbol matches first
            ...sorted.filter((token) => { var _a; return ((_a = token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === symbolMatch[0]; }),
            ...sorted.filter((token) => { var _a; return ((_a = token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== symbolMatch[0]; }),
        ];
    }, [filteredTokens, searchQuery, searchToken, tokenComparator]);
    const currencies = filteredSortedTokens;
    const dispatch = useDispatch();
    const onCurrencySelection = React.useCallback((address) => {
        dispatch(addCurrency(address));
    }, [dispatch]);
    const Row = React.useCallback(({ data, index, style }) => {
        const currency = data === null || data === void 0 ? void 0 : data[index];
        return currency ? (jsxRuntime.jsx(WatchlistCurrencyRow, { style: style, currency: currency, onSelect: (address) => {
                onSelectCurrency(currency);
                onCurrencySelection(address);
            } }, index)) : null;
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    return (jsxRuntime.jsxs(PopoverContainer$1, Object.assign({ ref: (ref) => getRef(ref) }, { children: [jsxRuntime.jsx(Box, Object.assign({ padding: "0px 10px" }, { children: jsxRuntime.jsx(AddInputWrapper$1, { children: jsxRuntime.jsx(TextInput, { placeholder: "Search", onChange: (value) => {
                            setSearchQuery(value);
                        }, value: searchQuery, getRef: (ref) => (inputRef.current = ref) }) }) })), jsxRuntime.jsx(CurrencyList$2, { children: jsxRuntime.jsx(AutoSizer__default["default"], Object.assign({ disableWidth: true }, { children: ({ height }) => (jsxRuntime.jsx(reactWindow.FixedSizeList, Object.assign({ height: height, width: "100%", itemCount: currencies.length, itemSize: 45, itemData: currencies, itemKey: (index, data) => currencyKey$1(data[index], chainId) }, { children: Row }))) })) })] })));
};

const WatchlistRow = ({ coin, onClick, onRemove, isSelected }) => {
    var _a, _b, _c;
    const chainId = useChainId();
    const [showChart, setShowChart] = React.useState(false);
    const [showDeleteButton, setShowDeleteButton] = React.useState(false);
    const theme = React.useContext(styled.ThemeContext);
    const { tokenUsdPrice } = useCoinGeckoTokenPrice(coin);
    const tokenPrice = useUSDCPrice(coin);
    const usdcPrice = tokenUsdPrice || (tokenPrice === null || tokenPrice === void 0 ? void 0 : tokenPrice.toSignificant(4));
    const coinGekoData = useCoinGeckoTokenPriceChart(coin) || [];
    const pangolinData = useTokenWeeklyChartData((_a = coin === null || coin === void 0 ? void 0 : coin.address) === null || _a === void 0 ? void 0 : _a.toLowerCase());
    const chartData = coinGekoData.length > 0 ? coinGekoData : pangolinData;
    const currentUSDPrice = ((_b = chartData === null || chartData === void 0 ? void 0 : chartData[(chartData || []).length - 1]) === null || _b === void 0 ? void 0 : _b.priceUSD) || 0;
    const previousUSDPrice = ((_c = chartData === null || chartData === void 0 ? void 0 : chartData[0]) === null || _c === void 0 ? void 0 : _c.priceUSD) || 0;
    const diffPercent = currentUSDPrice - previousUSDPrice < 0 ? -1 : 1;
    const decreaseValue = currentUSDPrice - previousUSDPrice;
    const perc = (decreaseValue / previousUSDPrice) * 100;
    const token = unwrappedToken(coin, chainId);
    const dispatch = useDispatch();
    const removeToken = () => {
        onRemove();
        dispatch(removeCurrency(coin === null || coin === void 0 ? void 0 : coin.address));
    };
    React.useEffect(() => {
        if (usdcPrice) {
            setTimeout(() => {
                // show chart only after price of token comes to display chart in visible space
                setShowChart(true);
            });
        }
    }, [usdcPrice, setShowChart]);
    return (jsxRuntime.jsxs(RowWrapper$2, Object.assign({ isSelected: isSelected, onMouseEnter: () => setShowDeleteButton(true), onMouseLeave: () => setShowDeleteButton(false) }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", height: '100%', onClick: onClick }, { children: [jsxRuntime.jsx(CurrencyLogo, { size: 24, currency: token, imageSize: 48 }), jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: 20, fontWeight: 500, marginLeft: '6px' }, { children: token.symbol }))] })), jsxRuntime.jsx(Box, Object.assign({ px: "7px", display: "flex", alignItems: "center", height: '100%', onClick: onClick }, { children: showChart && (jsxRuntime.jsx(recharts.ResponsiveContainer, Object.assign({ width: '99%' }, { children: jsxRuntime.jsx(recharts.LineChart, Object.assign({ data: chartData, margin: { top: 23 } }, { children: jsxRuntime.jsx(recharts.Line, { type: "monotone", dataKey: "priceUSD", stroke: diffPercent >= 0 ? theme.green1 : theme.red1, dot: false }) })) }))) })), jsxRuntime.jsxs(Box, Object.assign({ textAlign: "right", minWidth: 30, height: '100%' }, { children: [showDeleteButton && coin.address !== PNG[chainId].address && (jsxRuntime.jsx(Box, Object.assign({ zIndex: 2, position: "relative" }, { children: jsxRuntime.jsx(DeleteButton, Object.assign({ onClick: removeToken }, { children: jsxRuntime.jsx(reactFeather.X, { fontSize: 16, fontWeight: 600, style: { float: 'right' } }) })) }))), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", height: "100%", onClick: onClick }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 500 }, { children: usdcPrice ? `$${usdcPrice}` : '-' })), !isNaN(perc) && (jsxRuntime.jsxs(Text, Object.assign({ color: diffPercent > 0 ? 'green1' : 'red1', fontSize: '8px', fontWeight: 500 }, { children: [perc.toFixed(3), "%"] })))] }))] }))] })));
};

const WatchList = ({ coinChartVisible = true, visibleTradeButton = true, tradeLinkUrl, redirect = false, }) => {
    var _a;
    const { chainId = sdk.ChainId.AVALANCHE } = usePangolinWeb3();
    const [showMore, setShowMore] = React.useState(false);
    const allTokens = useAllTokens();
    const coins = Object.values(allTokens || {});
    const watchListCurrencies = useSelectedCurrencyLists();
    const theme = React.useContext(styled.ThemeContext);
    const [selectedToken, setSelectedToken] = React.useState((watchListCurrencies === null || watchListCurrencies === void 0 ? void 0 : watchListCurrencies[0]) || {});
    const [open, toggle] = useToggle(false);
    const node = React.useRef();
    const popoverRef = React.useRef(null);
    const referenceElement = React.useRef(null);
    const currencies = React.useMemo(() => ((watchListCurrencies || []).length === 0 ? [PNG[chainId]] : watchListCurrencies), [chainId, watchListCurrencies]);
    useOnClickOutside(node, open ? toggle : undefined);
    const renderWatchlistRow = (coin) => {
        return (jsxRuntime.jsx(WatchlistRow, { coin: coin, onClick: () => setSelectedToken(coin), onRemove: () => setSelectedToken(PNG[chainId]), isSelected: (coin === null || coin === void 0 ? void 0 : coin.address) === (selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.address) }, coin.address));
    };
    const renderCoinChart = () => {
        return (jsxRuntime.jsx(Hidden, Object.assign({ upToSmall: true }, { children: jsxRuntime.jsx(CoinChart, { coin: selectedToken, visibleTradeButton: visibleTradeButton, tradeLinkUrl: tradeLinkUrl, redirect: redirect }) })));
    };
    return (jsxRuntime.jsxs(WatchListRoot, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, { children: [jsxRuntime.jsx(Title$1, { children: "Watchlist" }), jsxRuntime.jsxs(Box, Object.assign({ bgColor: theme.bg5, position: "relative", p: '5px', ref: node }, { children: [jsxRuntime.jsx(Box, Object.assign({ ref: referenceElement, onClick: toggle }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", backgroundColor: "primary", color: "white", width: '32px', height: '32px', padding: "0px" }, { children: jsxRuntime.jsx(reactFeather.Plus, { size: 12, color: 'black' }) })) })), open && (jsxRuntime.jsx(CurrencyPopover, { getRef: (ref) => (popoverRef.current = ref), coins: coins, isOpen: open, onSelectCurrency: (currency) => {
                                    setSelectedToken(currency);
                                    toggle();
                                } }))] }))] })), jsxRuntime.jsxs(GridContainer$1, Object.assign({ coinChartVisible: coinChartVisible }, { children: [((_a = sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet) && coinChartVisible && renderCoinChart(), jsxRuntime.jsx(DesktopWatchList, { children: jsxRuntime.jsx(Scrollbars__default["default"], { children: (currencies || []).map(renderWatchlistRow) }) }), jsxRuntime.jsxs(MobileWatchList, { children: [(currencies || []).slice(0, 3).map(renderWatchlistRow), showMore && (currencies || []).slice(3).map(renderWatchlistRow), currencies.length > 3 && jsxRuntime.jsx(ShowMore, { showMore: showMore, onToggle: () => setShowMore(!showMore) })] })] }))] }));
};

var Earth = "data:image/png;base64,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";

// Get News in Arcanum Strapi api
function useGetNews() {
    var _a;
    const chainId = useChainId();
    const chain = (_a = getChainByNumber(chainId)) !== null && _a !== void 0 ? _a : sdk.AVALANCHE_MAINNET;
    const query = qs__default["default"].stringify({
        sort: ['-date_created'],
        filter: {
            status: {
                _eq: 'published',
            },
        },
    }, {
        encodeValuesOnly: true,
    });
    return reactQuery.useQuery(['getNews', chain.id], () => tslib.__awaiter(this, void 0, void 0, function* () {
        var _b;
        const response = yield axios__default["default"].get(`${DIRECTUS_URL_NEWS}/items/news?${query}`, {
            timeout: 60000,
        });
        const data = response.data;
        const news = (_b = data === null || data === void 0 ? void 0 : data.data) === null || _b === void 0 ? void 0 : _b.map((element) => {
            return {
                id: element === null || element === void 0 ? void 0 : element.id,
                title: element === null || element === void 0 ? void 0 : element.title,
                content: element === null || element === void 0 ? void 0 : element.content,
                createdAt: new Date(element === null || element === void 0 ? void 0 : element.date_created),
                updatedAt: !(element === null || element === void 0 ? void 0 : element.date_updated) ? null : new Date(element === null || element === void 0 ? void 0 : element.date_updated),
                chains: element === null || element === void 0 ? void 0 : element.chain,
            };
        });
        return news.filter((element) => element.chains.includes(chain.symbol.toLocaleUpperCase()) || element.chains.includes('all'));
    }), {
        cacheTime: 60 * 60 * 1000,
        refetchInterval: 60 * 10 * 1000, // 10 minutes
    });
}

// news section
const NewsSection = styled__default["default"](Box) `
  background-color: ${({ theme }) => theme.bg2};
  background-image: url(${(props) => props.img});
  background-repeat: no-repeat;
  background-position: bottom right;
  height: 100%;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  overflow: hidden;
  & .slick-slider {
    height: 100%;
    padding: 0px;

    .slick-dots {
      bottom: 0px;
      li button:before {
        color: ${({ theme }) => theme.text1};
      }
      li.slick-active button:before {
        color: ${({ theme }) => theme.text1};
      }
    }
  }

  & .slick-slide {
    height: auto;

    & div {
      height: 100%;
    }
  }

  & .slick-list {
    height: 100%;
    overflow: hidden;
  }

  & .slick-track {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: stretch;
    height: 100%;
  }

  ${({ theme }) => theme.mediaWidth.upToSmall `
    height: 600px;
  `};
`;
const NewsTitle = styled__default["default"](Box) `
  align-self: start;
  font-weight: bold;
  font-size: 24px;
  line-height: 48px;
  padding: 20px;
  background: linear-gradient(0deg, #ffc800, #ffc800);
  border-radius: 5px 0px 5px 0px;
`;
const NewsContent = styled__default["default"](Box) `
  color: ${({ theme }) => theme.text7};
  font-weight: 400;
  font-size: 16px;
  line-height: 27px;
  height: 90% !important;
  padding: 0px 20px;
  & a {
    color: ${({ theme }) => theme.text7};
  }
`;
const NewsDate = styled__default["default"](Box) `
  font-size: 10px;
  line-height: 15px;
  display: flex;
  align-items: center;
  color: #929292;
  margin-bottom: 15px;
  height: 10% !important;
  padding: 0px 10px;
`;
const SlickNext = styled__default["default"](Box) `
  background: ${({ theme }) => theme.primary};
  width: 32px;
  height: 32px;
  border-radius: 16px;
  display: flex;
  justify-content: center;
  align-items: center;

  &:hover {
    cursor: pointer;
  }
  z-index: 9999;
`;
const TitleWrapper = styled__default["default"](Box) `
  display: flex;
  justify-content: space-between;
`;
const ArrowWrapper$3 = styled__default["default"](Box) `
  display: flex;
  gap: 10px;
  padding: 20px;
`;

// import 'slick-carousel/slick/slick.css';
// import 'slick-carousel/slick/slick-theme.css';
const NewsFeedSettings = {
    dots: false,
    infinite: true,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1,
    arrows: false,
    autoplay: false,
    autoplaySpeed: 10000,
};
const NewsWidget = ({ boxHeight = '400px' }) => {
    const theme = React.useContext(styled.ThemeContext);
    const sliderRef = React.useRef(null);
    const handleNewsNext = () => {
        var _a;
        (_a = sliderRef === null || sliderRef === void 0 ? void 0 : sliderRef.current) === null || _a === void 0 ? void 0 : _a.slickNext();
    };
    const handleNewsBack = () => {
        var _a;
        (_a = sliderRef === null || sliderRef === void 0 ? void 0 : sliderRef.current) === null || _a === void 0 ? void 0 : _a.slickPrev();
    };
    const { data: news, isLoading } = useGetNews();
    return (jsxRuntime.jsxs(NewsSection, Object.assign({ img: Earth }, { children: [jsxRuntime.jsxs(TitleWrapper, { children: [jsxRuntime.jsx(NewsTitle, { children: "News" }), jsxRuntime.jsxs(ArrowWrapper$3, { children: [jsxRuntime.jsx(SlickNext, Object.assign({ onClick: handleNewsBack, style: { right: 60 } }, { children: jsxRuntime.jsx(reactFeather.ArrowLeft, { size: 20, style: { minWidth: 24 } }) })), jsxRuntime.jsx(SlickNext, Object.assign({ onClick: handleNewsNext }, { children: jsxRuntime.jsx(reactFeather.ArrowRight, { size: 20, style: { minWidth: 24 } }) }))] })] }), jsxRuntime.jsx("div", Object.assign({ style: { height: '100%' } }, { children: !isLoading ? (jsxRuntime.jsx(Slider__default["default"], Object.assign({ ref: sliderRef }, NewsFeedSettings, { children: news &&
                        news.map((element) => {
                            var _a, _b;
                            return (jsxRuntime.jsxs("div", { children: [jsxRuntime.jsx(NewsContent, { children: jsxRuntime.jsx(Scrollbars__default["default"], Object.assign({ style: { minHeight: boxHeight, padding: '0px 10px' }, 
                                            // eslint-disable-next-line react/prop-types
                                            renderView: (props) => jsxRuntime.jsx("div", Object.assign({}, props, { style: Object.assign(Object.assign({}, props.style), { overflowX: 'hidden' }) })), renderThumbVertical: (props) => (jsxRuntime.jsx("div", Object.assign({}, props, { style: Object.assign(Object.assign({}, props.style), { backgroundColor: theme.text1, opacity: 0.2, cursor: 'pointer', borderRadius: '3px' }) }))) }, { children: jsxRuntime.jsx(ReactMarkdown__default["default"], Object.assign({ remarkPlugins: [remarkGfm__default["default"]], linkTarget: '_blank', components: {
                                                    /* eslint-disable react/prop-types */
                                                    a: (_a) => {
                                                        var { children } = _a, props = tslib.__rest(_a, ["children"]);
                                                        const linkProps = props;
                                                        if (props.target === '_blank') {
                                                            linkProps['rel'] = 'noopener noreferrer';
                                                        }
                                                        return jsxRuntime.jsx("a", Object.assign({}, linkProps, { children: children }));
                                                    },
                                                } }, { children: element.content })) })) }), jsxRuntime.jsxs(NewsDate, { children: [(element === null || element === void 0 ? void 0 : element.updatedAt)
                                                ? (_a = element === null || element === void 0 ? void 0 : element.updatedAt) === null || _a === void 0 ? void 0 : _a.toLocaleTimeString()
                                                : element === null || element === void 0 ? void 0 : element.createdAt.toLocaleTimeString(), ", ", element.updatedAt ? (_b = element === null || element === void 0 ? void 0 : element.updatedAt) === null || _b === void 0 ? void 0 : _b.toDateString() : element === null || element === void 0 ? void 0 : element.createdAt.toDateString()] })] }, element.id));
                        }) }))) : (jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "center", height: "100%" }, { children: jsxRuntime.jsx(Loader, { size: 100 }) }))) }))] })));
};

const Frame$3 = styled__default["default"](Box) `
  width: 40vw;
  background-color: ${({ theme }) => theme.bg2};
  padding: 30px;
  display: grid;
  position: relative;
  grid-template-areas:"text buttons"
                      "chains chains";
  grid-template-columns: grid-template-columns: repeat(2, 50%);

  ${({ theme }) => theme.mediaWidth.upToMedium `
    width: 60vw;
  `};

  ${({ theme }) => theme.mediaWidth.upToSmall `
    width: 100vw;
  `};

`;
const ButtonFrame = styled__default["default"](Box) `
  grid-area: buttons;
  display: flex;
  justify-content: flex-end;
  align-items: flex-start;
`;
const CloseButton$1 = styled__default["default"](CloseIcon) `
  color: ${({ theme }) => theme.text1};
  position: absolute;
  right: 3px;
  top: 3px;
`;
const ChainsList = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: repeat(2, auto);
  gap: 20px;
`;
const ChainButton = styled__default["default"].button `
  background-color: ${({ theme }) => theme.bg8};
  display: flex;
  align-items: center;
  border: 0px;
  border-radius: 5px;
  cursor: pointer;
  padding: 10px;
  height: 48px;
  font-weight: 500;

  :hover {
    opacity: 0.5;
  }
`;
const Logo = styled__default["default"].img `
  border-radius: 20px;
  height: 28px;
  width: 28px;
  margin-right: 10px;
`;

var NETWORK_TYPE;
(function (NETWORK_TYPE) {
    NETWORK_TYPE["MAINNET"] = "Mainnet";
    NETWORK_TYPE["TESTNET"] = "Testnet";
})(NETWORK_TYPE || (NETWORK_TYPE = {}));
const NetworkSelection = (props) => {
    const { open, closeModal } = props;
    const [mainnet, setMainnet] = React.useState(true);
    const [chainListHeight, setChainListHeight] = React.useState(48);
    const { ethereum } = window;
    const chains = sdk.ALL_CHAINS.filter((chain) => chain.pangolin_is_live && chain.mainnet === mainnet);
    const provider = React.useMemo(() => {
        if (window.xfi && window.xfi.ethereum) {
            return window.xfi.ethereum;
        }
        else if (window.bitkeep && window.isBitKeep) {
            return window.bitkeep.ethereum;
        }
        return window.ethereum;
    }, undefined);
    React.useEffect(() => {
        if (chains.length / 2 <= 1)
            setChainListHeight(48);
        else if (chains.length / 2 <= 2)
            setChainListHeight(116);
        else
            setChainListHeight(184);
    }, [mainnet]);
    const changeChain = (chain) => tslib.__awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        if (ethereum) {
            try {
                yield provider.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: `0x${(_a = chain === null || chain === void 0 ? void 0 : chain.chain_id) === null || _a === void 0 ? void 0 : _a.toString(16)}` }],
                });
                window.location.reload();
                closeModal();
            }
            catch (error) {
                // This error code indicates that the chain has not been added to MetaMask.
                const metamask = error;
                if (metamask.code === 4902) {
                    try {
                        yield provider.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainName: chain.name,
                                    chainId: `0x${(_b = chain === null || chain === void 0 ? void 0 : chain.chain_id) === null || _b === void 0 ? void 0 : _b.toString(16)}`,
                                    //nativeCurrency: chain.nativeCurrency,
                                    rpcUrls: [chain.rpc_uri],
                                    blockExplorerUrls: chain.blockExplorerUrls,
                                    iconUrls: chain.logo,
                                    nativeCurrency: chain.nativeCurrency,
                                },
                            ],
                        });
                        closeModal();
                    }
                    catch (_error) {
                        return;
                    }
                }
            }
        }
    });
    return (jsxRuntime.jsx(Modal, Object.assign({ isOpen: open, onDismiss: closeModal }, { children: jsxRuntime.jsxs(Frame$3, { children: [jsxRuntime.jsx(CloseButton$1, { onClick: closeModal }), jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "24px", marginBottom: 20, style: { gridArea: 'text' } }, { children: "Select Chain" })), jsxRuntime.jsx(ButtonFrame, { children: jsxRuntime.jsx(ToggleButtons, { options: [NETWORK_TYPE.MAINNET, NETWORK_TYPE.TESTNET], value: mainnet === true ? NETWORK_TYPE.MAINNET : NETWORK_TYPE.TESTNET, onChange: (value) => {
                            setMainnet(value === NETWORK_TYPE.MAINNET);
                        } }) }), jsxRuntime.jsx(Box, Object.assign({ height: chainListHeight, style: { gridArea: 'chains' } }, { children: jsxRuntime.jsx(Scrollbars.Scrollbars, { children: jsxRuntime.jsx(ChainsList, { children: chains.map((chain, index) => (jsxRuntime.jsxs(ChainButton, Object.assign({ onClick: () => changeChain(chain) }, { children: [jsxRuntime.jsx(Logo, { src: chain.logo }), jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: chain.name }))] }), index))) }) }) }))] }) })));
};

const InfoCard = styled__default["default"].button `
  background-color: ${({ theme, active }) => (active ? theme.bg3 : theme.bg2)};
  padding: 1rem;
  outline: none;
  border: 1px solid;
  border-radius: 12px;
  width: 100% !important;
  &:focus {
    box-shadow: 0 0 0 1px ${({ theme }) => theme.primary1};
  }
  border-color: ${({ theme, active }) => (active ? 'transparent' : theme.bg3)};
`;
const OptionCard = styled__default["default"](InfoCard) `
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  margin-top: 2rem;
  padding: 1rem;
`;
const OptionCardLeft = styled__default["default"].div `
  ${({ theme }) => theme.flexColumnNoWrap};
  justify-content: center;
  height: 100%;
`;
const OptionCardClickable = styled__default["default"](OptionCard) `
  margin-top: 0;
  &:hover {
    cursor: ${({ clickable }) => (clickable ? 'pointer' : '')};
    border: ${({ clickable, theme }) => (clickable ? `1px solid ${theme.primary}` : ``)};
  }
  opacity: ${({ disabled }) => (disabled ? '0.5' : '1')};
`;
const GreenCircle = styled__default["default"].div `
  ${({ theme }) => theme.flexRowNoWrap}
  justify-content: center;
  align-items: center;

  &:first-child {
    height: 8px;
    width: 8px;
    margin-right: 8px;
    background-color: ${({ theme }) => theme.green1};
    border-radius: 50%;
  }
`;
const CircleWrapper = styled__default["default"].div `
  color: ${({ theme }) => theme.green1};
  display: flex;
  justify-content: center;
  align-items: center;
`;
const HeaderText = styled__default["default"].div `
  ${({ theme }) => theme.flexRowNoWrap};
  color: ${(props) => (props.color === 'blue' ? ({ theme }) => theme.primary1 : ({ theme }) => theme.text1)};
  font-size: 1rem;
  font-weight: 500;
`;
const SubHeader = styled__default["default"].div `
  color: ${({ theme }) => theme.text1};
  margin-top: 10px;
  font-size: 12px;
`;
const IconWrapper = styled__default["default"].div `
  ${({ theme }) => theme.flexColumnNoWrap};
  align-items: center;
  justify-content: center;
  & > img,
  span {
    height: ${({ size }) => (size ? size + 'px' : '24px')};
    width: ${({ size }) => (size ? size + 'px' : '24px')};
  }
  ${({ theme }) => theme.mediaWidth.upToMedium `
    align-items: flex-end;
  `};
`;

function Option({ link = null, clickable = true, size, onClick = null, color, header, subheader = null, icon, active = false, id, }) {
    const content = (jsxRuntime.jsxs(OptionCardClickable, Object.assign({ id: id, onClick: onClick, clickable: clickable && !active, active: active }, { children: [jsxRuntime.jsxs(OptionCardLeft, { children: [jsxRuntime.jsxs(HeaderText, Object.assign({ color: color }, { children: [active ? (jsxRuntime.jsx(CircleWrapper, { children: jsxRuntime.jsx(GreenCircle, { children: jsxRuntime.jsx("div", {}) }) })) : (''), header] })), subheader && jsxRuntime.jsx(SubHeader, { children: subheader })] }), jsxRuntime.jsx(IconWrapper, Object.assign({ size: size }, { children: jsxRuntime.jsx("img", { src: icon, alt: 'Icon' }) }))] })));
    if (link) {
        return jsxRuntime.jsx(ExternalLink, Object.assign({ href: link }, { children: content }));
    }
    return content;
}

const rotate = styled.keyframes `
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`;
const StyledSVG$1 = styled__default["default"].svg `
  animation: 2s ${rotate} linear infinite;
  height: ${({ size }) => size};
  width: ${({ size }) => size};
  path {
    stroke: ${({ stroke, theme }) => stroke !== null && stroke !== void 0 ? stroke : theme.primary1};
  }
`;

/**
 * Takes in custom size and stroke for circle color, default to primary color as fill,
 * need ...rest for layered styles on top
 */
function CircleLoader(_a) {
    var { size = '16px', stroke } = _a, rest = tslib.__rest(_a, ["size", "stroke"]);
    return (jsxRuntime.jsx(StyledSVG$1, Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", size: size, stroke: stroke }, rest, { children: jsxRuntime.jsx("path", { d: "M12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 9.27455 20.9097 6.80375 19.1414 5", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round" }) })));
}

const PendingSection = styled__default["default"].div `
  ${({ theme }) => theme.flexColumnNoWrap};
  align-items: center;
  justify-content: center;
  width: 100%;
  & > * {
    width: 100%;
  }
`;
const StyledLoader = styled__default["default"](CircleLoader) `
  margin-right: 1rem;
`;
const LoadingMessage = styled__default["default"].div `
  ${({ theme }) => theme.flexRowNoWrap};
  align-items: center;
  justify-content: flex-start;
  border-radius: 12px;
  margin-bottom: 20px;
  color: ${({ theme, error }) => (error ? theme.red1 : 'inherit')};
  border: 1px solid ${({ theme, error }) => (error ? theme.red1 : theme.text4)};

  & > * {
    padding: 1rem;
  }
`;
const ErrorGroup = styled__default["default"].div `
  ${({ theme }) => theme.flexRowNoWrap};
  align-items: center;
  justify-content: flex-start;
`;
const ErrorButton = styled__default["default"].div `
  border-radius: 8px;
  font-size: 12px;
  color: ${({ theme }) => theme.text1};
  background-color: ${({ theme }) => theme.bg4};
  margin-left: 1rem;
  padding: 0.5rem;
  font-weight: 600;
  user-select: none;

  &:hover {
    cursor: pointer;
    background-color: ${({ theme }) => polished.darken(0.1, theme.text4)};
  }
`;
const LoadingWrapper$1 = styled__default["default"].div `
  ${({ theme }) => theme.flexRowNoWrap};
  align-items: center;
  justify-content: center;
`;

function PendingView({ option, connector, error = false, setPendingError, tryActivation, }) {
    return (jsxRuntime.jsxs(PendingSection, { children: [jsxRuntime.jsx(LoadingMessage, Object.assign({ error: error }, { children: jsxRuntime.jsx(LoadingWrapper$1, { children: error ? (jsxRuntime.jsxs(ErrorGroup, { children: [jsxRuntime.jsx("div", { children: "Error connecting." }), jsxRuntime.jsx(ErrorButton, Object.assign({ onClick: () => {
                                    setPendingError(false);
                                    connector && option && tryActivation(connector, option);
                                } }, { children: "Try Again" }))] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(StyledLoader, {}), "Initializing..."] })) }) })), option && (jsxRuntime.jsx(Option, { id: `connect-${option.name}`, clickable: false, color: option.color, header: option.name, subheader: option.description, icon: option.iconName }, option.name))] }));
}

const CloseButton = styled__default["default"](CloseIcon) `
  color: ${({ theme }) => theme.text1};
  position: relative;
  right: -3px;
  top: 3px;
`;
const Wrapper$a = styled__default["default"].div `
  ${({ theme }) => theme.flexColumnNoWrap}
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  max-width: 422px;
  border-radius: 10px;
  background-color: ${({ theme, background }) => (background ? background : theme.bg2)};
  ${({ theme }) => theme.mediaWidth.upToMedium `max-width: 100%`};
`;
const ModalWrapper = styled__default["default"](Box) `
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0rem 2rem;
  ${({ theme }) => theme.mediaWidth.upToMedium `padding: 0rem 1rem`};
`;
const HeaderRow = styled__default["default"].div `
  ${({ theme }) => theme.flexRowNoWrap};
  padding: 1rem 0rem;
  font-weight: 500;
  color: ${({ theme }) => theme.color4};
`;
const ContentWrapper$1 = styled__default["default"].div `
  padding: 0 2rem 2rem 2rem;
  ${({ theme }) => theme.mediaWidth.upToMedium `padding: 0 1rem 1rem 1rem`};
`;
const UpperSection = styled__default["default"].div `
  position: relative;

  h5 {
    margin: 0;
    margin-bottom: 0.5rem;
    font-size: 1rem;
    font-weight: 400;
  }

  h5:last-child {
    margin-bottom: 0px;
  }

  h4 {
    margin-top: 0;
    font-weight: 500;
  }
`;
const Blurb = styled__default["default"].div `
  ${({ theme }) => theme.flexRowNoWrap}
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 2rem;
  ${({ theme }) => theme.mediaWidth.upToMedium `
    margin: 1rem;
    font-size: 12px;
  `};
`;
const OptionGrid = styled__default["default"].div `
  display: grid;
  grid-gap: 10px;
  ${({ theme }) => theme.mediaWidth.upToMedium `
    grid-template-columns: 1fr;
    grid-gap: 10px;
  `};
`;
const HoverText = styled__default["default"].div `
  :hover {
    cursor: pointer;
  }
`;

const WALLET_TUTORIAL = `${LANDING_PAGE}/tutorials/getting-started/#set-up-metamask`;
var CHAIN_TYPE;
(function (CHAIN_TYPE) {
    CHAIN_TYPE["EVM_CHAINS"] = "EVM CHAINS";
    CHAIN_TYPE["NON_EVM_CHAINS"] = "NON-EVM CHAINS";
})(CHAIN_TYPE || (CHAIN_TYPE = {}));
const WALLET_VIEWS = {
    OPTIONS: 'options',
    OPTIONS_SECONDARY: 'options_secondary',
    ACCOUNT: 'account',
    PENDING: 'pending',
};
const getConnectorKey = (connector) => { var _a; return (_a = Object.keys(SUPPORTED_WALLETS).find((key) => SUPPORTED_WALLETS[key].connector === connector)) !== null && _a !== void 0 ? _a : null; };
const WalletModal = ({ open, closeModal, background, shouldShowBackButton, onWalletConnect, onClickBack, }) => {
    var _a;
    // important that these are destructed from the account-specific web3-react context
    const { connector, activate, error: web3Error } = core.useWeb3React();
    const [walletType, setWalletType] = React.useState(CHAIN_TYPE.EVM_CHAINS);
    const [walletView, setWalletView] = React.useState('');
    const [pendingWallet, setPendingWallet] = React.useState();
    const [selectedOption, setSelectedOption] = React.useState();
    const [pendingError, setPendingError] = React.useState();
    const [triedSafe, setTriedSafe] = React.useState(!IS_IN_IFRAME);
    const walletModalOpen = open;
    const walletOptions = React.useMemo(() => {
        if (walletType === CHAIN_TYPE.EVM_CHAINS) {
            return Object.keys(SUPPORTED_WALLETS)
                .filter((key) => SUPPORTED_WALLETS[key].isEVM)
                .reduce((obj, key) => {
                obj[key] = SUPPORTED_WALLETS[key];
                return obj;
            }, {});
        }
        else {
            return Object.keys(SUPPORTED_WALLETS)
                .filter((key) => !SUPPORTED_WALLETS[key].isEVM)
                .reduce((obj, key) => {
                obj[key] = SUPPORTED_WALLETS[key];
                return obj;
            }, {});
        }
    }, [walletType]);
    const addAvalancheNetwork = React.useCallback(() => {
        connector === null || connector === void 0 ? void 0 : connector.getProvider().then((provider) => {
            provider === null || provider === void 0 ? void 0 : provider.request({
                method: 'wallet_addEthereumChain',
                params: [AVALANCHE_CHAIN_PARAMS],
            }).then(() => {
                onWalletConnect(getConnectorKey(connector));
            }).catch((error) => {
                console.log(error);
            });
        });
    }, [connector]);
    // always reset to account view
    React.useEffect(() => {
        const name = Object.keys(SUPPORTED_WALLETS).find((key) => SUPPORTED_WALLETS[key].connector === connector);
        if (name) {
            const activeOption = SUPPORTED_WALLETS[name];
            if (activeOption && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.isEVM)) {
                setWalletType(CHAIN_TYPE.NON_EVM_CHAINS);
            }
            else {
                setWalletType(CHAIN_TYPE.EVM_CHAINS);
            }
        }
        if (walletModalOpen) {
            setPendingError(false);
            setWalletView('');
        }
    }, [walletModalOpen]);
    const isMetamask = window.ethereum && window.ethereum.isMetaMask;
    const isTalisman = window.ethereum && window.ethereum.isTalisman;
    const isRabby = window.ethereum && window.ethereum.isRabby;
    const isCbWalletDappBrowser = (_a = window === null || window === void 0 ? void 0 : window.ethereum) === null || _a === void 0 ? void 0 : _a.isCoinbaseWallet;
    const isWalletlink = !!(window === null || window === void 0 ? void 0 : window.WalletLinkProvider) || !!(window === null || window === void 0 ? void 0 : window.walletLinkExtension);
    const isCbWallet = isCbWalletDappBrowser || isWalletlink;
    const isBitKeep = window.isBitKeep && !!window.bitkeep.ethereum;
    const tryActivation = (activationConnector, option) => tslib.__awaiter(void 0, void 0, void 0, function* () {
        var _b, _c;
        const name = Object.keys(walletOptions).find((key) => walletOptions[key].connector === activationConnector);
        // log selected wallet
        // eslint-disable-next-line import/no-named-as-default-member
        ReactGA__default["default"].event({
            category: 'Wallet',
            action: 'Change Wallet',
            label: name,
        });
        setPendingWallet(connector); // set wallet for pending view
        setSelectedOption(option);
        setWalletView(WALLET_VIEWS.PENDING);
        // if the connector is walletconnect and the user has already tried to connect, manually reset the connector
        if (activationConnector instanceof walletconnectConnector.WalletConnectConnector && ((_c = (_b = activationConnector.walletConnectProvider) === null || _b === void 0 ? void 0 : _b.wc) === null || _c === void 0 ? void 0 : _c.uri)) {
            activationConnector.walletConnectProvider = undefined;
        }
        if (!triedSafe && activationConnector instanceof safeAppsWeb3React.SafeAppConnector) {
            activationConnector.isSafeApp().then((loadedInSafe) => {
                if (loadedInSafe) {
                    activate(activationConnector, undefined, true)
                        .then(() => {
                        onWalletConnect(getConnectorKey(activationConnector));
                    })
                        .catch(() => {
                        setTriedSafe(true);
                    });
                }
                setTriedSafe(true);
            });
        }
        else if (activationConnector) {
            activate(activationConnector, undefined, true)
                .then(() => {
                if (isCbWallet) {
                    addAvalancheNetwork();
                }
                else {
                    onWalletConnect(getConnectorKey(activationConnector));
                }
            })
                .catch((error) => {
                if (error instanceof core.UnsupportedChainIdError) {
                    activate(activationConnector); // a little janky...can't use setError because the connector isn't set
                }
                else {
                    setPendingError(true);
                }
            });
        }
    });
    function getActiveOption() {
        if (connector === injected) {
            if (isRabby) {
                return SUPPORTED_WALLETS.RABBY;
            }
            else if (isTalisman) {
                return SUPPORTED_WALLETS.TALISMAN;
            }
            else if (isBitKeep) {
                return SUPPORTED_WALLETS.BITKEEP;
            }
            else if (isMetamask) {
                return SUPPORTED_WALLETS.METAMASK;
            }
            return SUPPORTED_WALLETS.INJECTED;
        }
        const name = Object.keys(walletOptions).find((key) => walletOptions[key].connector === connector);
        if (name) {
            return walletOptions[name];
        }
        return undefined;
    }
    //get wallets user can switch too, depending on device/browser
    function getOptions() {
        const isXDEFI = window.ethereum && window.ethereum.isXDEFI;
        const activeOption = getActiveOption();
        return Object.keys(walletOptions).map((key) => {
            const option = walletOptions[key];
            // check for mobile options
            if (reactDeviceDetect.isMobile) {
                if (!window.web3 && !window.ethereum && option.mobile) {
                    return (jsxRuntime.jsx(Option, { onClick: () => {
                            option.connector !== connector && !option.href && tryActivation(option.connector, option);
                        }, id: `connect-${key}`, active: activeOption && option.name === activeOption.name, color: option.color, link: option.href, header: option.name, subheader: null, icon: option.iconName }, key));
                }
                return null;
            }
            // overwrite injected when needed
            if (option.connector === injected) {
                if (option.name === 'Rabby Wallet') {
                    if (!isRabby) {
                        return (jsxRuntime.jsx(Option, { id: `connect-${key}`, color: '#7a7cff', header: 'Install Rabby Wallet', subheader: null, link: 'https://rabby.io/', icon: option.iconName }, key));
                    }
                }
                // don't show injected if there's no injected provider
                if (!(window.web3 || window.ethereum)) {
                    if (option.name === 'MetaMask') {
                        return (jsxRuntime.jsx(Option, { id: `connect-${key}`, color: '#E8831D', header: 'Install Metamask', subheader: null, link: 'https://metamask.io/', icon: option.iconName }, key));
                    }
                    else {
                        return null; //dont want to return install twice
                    }
                }
                // don't return metamask if injected provider isn't metamask
                else if (option.name === 'MetaMask' && !isMetamask) {
                    return null;
                }
                // likewise for generic
                else if (option.name === 'Injected' && isMetamask) {
                    return null;
                }
            }
            // overwrite injected when needed
            else if (option.connector === bitKeep) {
                if (!isBitKeep) {
                    return (jsxRuntime.jsx(Option, { id: `connect-${key}`, color: '#7a7cff', header: 'Install BitKeep', subheader: null, link: 'https://bitkeep.com/', icon: option.iconName }, key));
                }
            }
            else if (option.connector === xDefi) {
                // don't show injected if there's no injected provider
                if (!window.xfi) {
                    if (option.name === 'XDEFI Wallet') {
                        return (jsxRuntime.jsx(Option, { id: `connect-${key}`, color: '#315CF5', header: 'Install XDEFI Wallet', subheader: null, link: 'https://www.xdefi.io/', icon: option.iconName }, key));
                    }
                    else {
                        return null; //dont want to return install twice
                    }
                }
                // likewise for generic
                else if (option.name === 'Injected' && (isMetamask || isXDEFI)) {
                    return null;
                }
            }
            else if (option.connector === talisman) {
                // provide talisman install link if not installed
                if (!window.talismanEth) {
                    return (jsxRuntime.jsx(Option, { id: `connect-${key}`, color: option.color, header: 'Install Talisman', subheader: null, link: 'https://talisman.xyz', icon: option.iconName }, key));
                }
            }
            // Not show Gnosis Safe option without Gnosis Interface
            if (option.connector === gnosisSafe && !IS_IN_IFRAME) {
                return null;
            }
            // return rest of options
            return (!reactDeviceDetect.isMobile &&
                !option.mobileOnly && (jsxRuntime.jsx(Option, { id: `connect-${key}`, onClick: () => {
                    option.connector !== connector && !option.href && tryActivation(option.connector, option);
                }, active: activeOption && option.name === activeOption.name, color: option.color, link: option.href, header: option.name, subheader: null, icon: option.iconName }, key)));
        });
    }
    const renderHeader = () => {
        if (web3Error) {
            return (jsxRuntime.jsx(HeaderRow, { children: web3Error instanceof core.UnsupportedChainIdError ? 'Wrong Network' : 'Error connecting' }));
        }
        else if (walletView === WALLET_VIEWS.PENDING || shouldShowBackButton) {
            return (jsxRuntime.jsx(HeaderRow, { children: jsxRuntime.jsx(HoverText, Object.assign({ onClick: () => {
                        if (onClickBack && shouldShowBackButton) {
                            onClickBack();
                        }
                        else {
                            setPendingError(false);
                            setWalletView('');
                        }
                    } }, { children: "Back" })) }));
        }
        else {
            return (jsxRuntime.jsx(HeaderRow, { children: jsxRuntime.jsx(HoverText, { children: "Connect to a wallet" }) }));
        }
    };
    const renderContent = () => {
        const isXDEFI = window.xfi && window.xfi.ethereum && window.xfi.ethereum.isXDEFI;
        const supportsAddNetwork = isMetamask || isCbWallet || isXDEFI || isTalisman || isBitKeep;
        if (web3Error) {
            return (jsxRuntime.jsx(ContentWrapper$1, { children: web3Error instanceof core.UnsupportedChainIdError ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("h5", { children: "Please connect to the appropriate Avalanche network." }), supportsAddNetwork && (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: addAvalancheNetwork }, { children: "Switch to Avalanche Chain" })))] })) : ('Error connecting. Try refreshing the page.') }));
        }
        else {
            return (jsxRuntime.jsxs(ContentWrapper$1, { children: [walletView === WALLET_VIEWS.PENDING ? (jsxRuntime.jsx(PendingView, { option: selectedOption, connector: pendingWallet, error: pendingError, setPendingError: setPendingError, tryActivation: tryActivation })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Box, Object.assign({ mt: "5px", width: "100%", mb: "5px" }, { children: jsxRuntime.jsx(ToggleButtons, { options: [CHAIN_TYPE.EVM_CHAINS, CHAIN_TYPE.NON_EVM_CHAINS], value: walletType, onChange: (value) => {
                                        setWalletType(value);
                                    } }) })), jsxRuntime.jsx(OptionGrid, { children: getOptions() })] })), walletView !== WALLET_VIEWS.PENDING && (jsxRuntime.jsxs(Blurb, { children: [jsxRuntime.jsx("span", { children: "New to Avalanche? \u00A0" }), ' ', jsxRuntime.jsx(ExternalLink, Object.assign({ href: WALLET_TUTORIAL }, { children: "Learn more about setting up a wallet" }))] }))] }));
        }
    };
    function getModalContent() {
        return (jsxRuntime.jsxs(UpperSection, { children: [jsxRuntime.jsxs(ModalWrapper, { children: [renderHeader(), jsxRuntime.jsx(CloseButton, { onClick: closeModal })] }), renderContent()] }));
    }
    return (jsxRuntime.jsx(Modal, Object.assign({ isOpen: walletModalOpen, onDismiss: () => {
            closeModal();
        } }, { children: jsxRuntime.jsx(Wrapper$a, Object.assign({ background: background }, { children: getModalContent() })) })));
};

const openApi = axios__default["default"].create({
    baseURL: OPEN_API_DEBANK,
    timeout: 2000,
});
class TokenDataUser {
    constructor(token, price, amount, protocol, logo) {
        this.token = token;
        this.price = price;
        this.amount = amount;
        this.usdValue = price * amount;
        this.protocol = protocol;
        this.logo = logo;
    }
}
class PairDataUser {
    constructor(pair, usdValue, protocol, logos) {
        this.pair = pair;
        this.usdValue = usdValue;
        this.protocol = protocol;
        this.logos = logos;
    }
}
// Get the USD balance of address of all chains (supported by Debank)
function useGetChainsBalances() {
    const { account } = usePangolinWeb3();
    const query = qs__default["default"].stringify({
        id: account,
    }, {
        encodeValuesOnly: true,
    });
    return reactQuery.useQuery(['getChainsBalances', account], () => tslib.__awaiter(this, void 0, void 0, function* () {
        var _a;
        if (account) {
            const response = yield openApi.get(`/total_balance?${query}`);
            const data = response.data;
            const chainbalances = {
                total: data === null || data === void 0 ? void 0 : data.total_usd_value,
                chains: [],
            };
            (_a = data === null || data === void 0 ? void 0 : data.chain_list) === null || _a === void 0 ? void 0 : _a.forEach((chain) => {
                const _chain = sdk.ALL_CHAINS.filter((value) => value.chain_id === (chain === null || chain === void 0 ? void 0 : chain.community_id))[0];
                if (_chain && (chain === null || chain === void 0 ? void 0 : chain.usd_value) >= 0.01) {
                    chainbalances.chains.push({
                        chainID: chain === null || chain === void 0 ? void 0 : chain.community_id,
                        balance: chain === null || chain === void 0 ? void 0 : chain.usd_value,
                    });
                }
            });
            chainbalances.chains.sort((a, b) => b.balance - a.balance);
            return chainbalances;
        }
        return null;
    }), { refetchOnWindowFocus: false });
}
// Get the Tokens of wallet
function useGetWalletChainTokens(chainId) {
    const { account } = usePangolinWeb3();
    let chain = getChainByNumber(chainId);
    const getPangolinPairs = () => tslib.__awaiter(this, void 0, void 0, function* () {
        const query = qs__default["default"].stringify({
            id: account,
            protocol_id: 'avax_pangolin',
        }, {
            encodeValuesOnly: true,
        });
        if (account) {
            const response = yield openApi.get(`/protocol?${query}`);
            const data = response.data;
            const requestPairs = data === null || data === void 0 ? void 0 : data.portfolio_item_list.map((pair) => {
                var _a, _b, _c;
                const token1 = (_a = pair === null || pair === void 0 ? void 0 : pair.detail) === null || _a === void 0 ? void 0 : _a.supply_token_list[0];
                const token2 = (_b = pair === null || pair === void 0 ? void 0 : pair.detail) === null || _b === void 0 ? void 0 : _b.supply_token_list[1];
                // If token2 does not exist its because this pair is not a pair but a single staking
                if (!token2) {
                    return new TokenDataUser(new sdk.Token(chainId, token1 === null || token1 === void 0 ? void 0 : token1.id, token1 === null || token1 === void 0 ? void 0 : token1.decimals, `${token1 === null || token1 === void 0 ? void 0 : token1.symbol} - Staked`, token1 === null || token1 === void 0 ? void 0 : token1.name), token1 === null || token1 === void 0 ? void 0 : token1.price, token1 === null || token1 === void 0 ? void 0 : token1.amount);
                }
                const tokenA = new sdk.TokenAmount(new sdk.Token(chainId, token1 === null || token1 === void 0 ? void 0 : token1.id, token1 === null || token1 === void 0 ? void 0 : token1.decimals, token1 === null || token1 === void 0 ? void 0 : token1.symbol, token1 === null || token1 === void 0 ? void 0 : token1.name), token1 === null || token1 === void 0 ? void 0 : token1.amount.toString().replace('.', ''));
                const tokenB = new sdk.TokenAmount(new sdk.Token(chainId, token2 === null || token2 === void 0 ? void 0 : token2.id, token2 === null || token2 === void 0 ? void 0 : token2.decimals, token2 === null || token2 === void 0 ? void 0 : token2.symbol, token2 === null || token2 === void 0 ? void 0 : token2.name), token2 === null || token2 === void 0 ? void 0 : token2.amount.toString().replace('.', ''));
                return new PairDataUser(new sdk.Pair(tokenA, tokenB, chainId), (_c = pair === null || pair === void 0 ? void 0 : pair.stats) === null || _c === void 0 ? void 0 : _c.net_usd_value, undefined, [
                    token1 === null || token1 === void 0 ? void 0 : token1.logo_url,
                    token2 === null || token2 === void 0 ? void 0 : token2.logo_url,
                ]);
            });
            return requestPairs;
        }
        return [];
    });
    const getTokens = () => tslib.__awaiter(this, void 0, void 0, function* () {
        if (account) {
            if (!chain || !chain.mainnet) {
                chain = sdk.AVALANCHE_MAINNET;
            }
            const query = qs__default["default"].stringify({
                id: account,
                chain_id: chain.symbol.toLowerCase(),
            }, {
                encodeValuesOnly: true,
            });
            const response = yield openApi.get(`/token_list?${query}`);
            const data = response.data;
            let requestTokens = data
                .filter((token) => (token === null || token === void 0 ? void 0 : token.is_wallet) && (token === null || token === void 0 ? void 0 : token.is_verified))
                .map((token) => {
                var _a, _b;
                if (((_a = token === null || token === void 0 ? void 0 : token.id) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ((_b = sdk.CAVAX[chainId]) === null || _b === void 0 ? void 0 : _b.symbol).toLowerCase()) {
                    return new TokenDataUser(sdk.CAVAX[chainId], token === null || token === void 0 ? void 0 : token.price, token === null || token === void 0 ? void 0 : token.amount);
                }
                if (!isAddress(token === null || token === void 0 ? void 0 : token.id)) {
                    return new TokenDataUser(new sdk.Token(chainId, ZERO_ADDRESS, token === null || token === void 0 ? void 0 : token.decimals, token === null || token === void 0 ? void 0 : token.symbol, token === null || token === void 0 ? void 0 : token.name), token === null || token === void 0 ? void 0 : token.price, token === null || token === void 0 ? void 0 : token.amount, undefined, token === null || token === void 0 ? void 0 : token.logo_url);
                }
                return new TokenDataUser(new sdk.Token(chainId, token === null || token === void 0 ? void 0 : token.id, token === null || token === void 0 ? void 0 : token.decimals, token === null || token === void 0 ? void 0 : token.symbol, token === null || token === void 0 ? void 0 : token.name), token === null || token === void 0 ? void 0 : token.price, token === null || token === void 0 ? void 0 : token.amount, undefined, token === null || token === void 0 ? void 0 : token.logo_url);
            });
            if (chainId === sdk.ChainId.AVALANCHE) {
                const pairs = yield getPangolinPairs();
                requestTokens = [...requestTokens, ...pairs];
            }
            return requestTokens.sort((a, b) => b.usdValue - a.usdValue).filter((token) => token.usdValue >= 0.01);
        }
        return null;
    });
    return reactQuery.useQuery(['getWalletChainTokens', chainId.toString(), account], () => tslib.__awaiter(this, void 0, void 0, function* () {
        const tokens = yield getTokens();
        return tokens;
    }), {
        refetchInterval: 600000,
        refetchOnWindowFocus: false,
    });
}

const PortfolioRoot = styled__default["default"](Box) `
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 15px;

  padding: 20px;

  border-radius: 10px;
  background-color: ${({ theme }) => theme.color2};
`;
const PortfolioHeader = styled__default["default"](Box) `
  width: 100%;
  display: flex;
  flex-direction: row;
  gap: 5px;
`;
const HideButton = styled__default["default"].button `
  background-color: ${({ theme }) => theme.bg6};
  color: ${({ theme }) => theme.text15};

  min-width: 20px;
  min-height: 20px;

  font-size: 12px;
  border-radius: 5px;
  border: 0px;
  padding: 5px;

  display: flex;
  align-items: center;

  cursor: pointer;

  :hover,
  :focus {
    opacity: 0.8;
  }

  align-self: flex-start;

  ${({ theme }) => theme.mediaWidth.upToMedium `
    #portfolio-text {
      display: none;
    }
  `}
`;
const ChainCard = styled__default["default"](Box) `
  height: 80px;
  padding: 10px;
  background-color: ${({ theme }) => theme.bg6};
  border-radius: 4px;
  display: flex;
  flex-direction: row;

  justify-content: center;
  align-items: center;

  gap: 10px;

  font-weight: 500;
`;
const Frame$2 = styled__default["default"](Box) `
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 20px;
`;

const ToggleBalanceButton = ({ showBalances, handleShowBalances }) => {
    return (jsxRuntime.jsx(HideButton, Object.assign({ onClick: handleShowBalances }, { children: showBalances ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(reactFeather.EyeOff, { size: 12, id: "portfolio-icon" }), jsxRuntime.jsx(Text, Object.assign({ fontSize: ['8px', '10px', '12px'], id: "portfolio-text", style: { marginLeft: '5px' } }, { children: "Hide Your Balance" }))] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(reactFeather.Eye, { size: 12, id: "portfolio-icon" }), jsxRuntime.jsx(Text, Object.assign({ fontSize: 12, id: "portfolio-text", style: { marginLeft: '5px' } }, { children: "Show Your Balance" }))] })) })));
};

const Portfolio$1 = () => {
    const theme = React.useContext(styled.ThemeContext);
    const { account } = usePangolinWeb3();
    const { data: balances, isRefetching, isLoading } = useGetChainsBalances();
    const [showBalances, setShowBalances] = React.useState(true);
    const handleShowBalances = React.useCallback(() => {
        setShowBalances(!showBalances);
    }, [showBalances]);
    const renderChain = (_chain, key) => {
        const chain = sdk.ALL_CHAINS.filter((value) => value.chain_id === _chain.chainID)[0];
        const balance = _chain.balance.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 });
        return (jsxRuntime.jsxs(ChainCard, { children: [jsxRuntime.jsx("img", { width: "48px", height: "48px", src: chain === null || chain === void 0 ? void 0 : chain.logo, alt: 'Chain logo' }), jsxRuntime.jsxs(Box, Object.assign({ height: "100%", display: "flex", justifyContent: "center", flexDirection: "column" }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 14, color: "text1" }, { children: chain.name })), showBalances ? (jsxRuntime.jsxs(Text, Object.assign({ fontSize: 14, color: "text13" }, { children: ["$", balance] }))) : (jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexDirection: "row" }, { children: [...Array(4)].map((_value, _key) => (jsxRuntime.jsx(reactFeather.Lock, { color: theme.text13, size: 14 }, _key))) })))] }))] }, key));
    };
    const renderTotalBalance = () => {
        if (showBalances) {
            return (jsxRuntime.jsxs(Text, Object.assign({ fontSize: 18, color: "text1", fontWeight: 600 }, { children: ["$", balances
                        ? balances.total.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 })
                        : 0] })));
        }
        return jsxRuntime.jsx(reactFeather.Lock, { color: theme.text1, size: 18 });
    };
    return (jsxRuntime.jsxs(PortfolioRoot, { children: [jsxRuntime.jsxs(PortfolioHeader, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: ['16px', '16px', '24px'], color: "text1", fontWeight: 600, style: { flexGrow: 1 } }, { children: "Portfolio Value in All Chains" })), jsxRuntime.jsx(ToggleBalanceButton, { showBalances: showBalances, handleShowBalances: handleShowBalances })] }), jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexGrow: 1, width: "100%", alignItems: "center", justifyContent: "center", flexDirection: "column" }, { children: !account ? (jsxRuntime.jsx(Text, Object.assign({ fontSize: 20, color: "text1", textAlign: "center" }, { children: "Connect a wallet to see your Portfolio" }))) : isRefetching || isLoading || !balances ? (jsxRuntime.jsx(Loader, { size: 100 })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(Box, Object.assign({ padding: 10, borderRadius: 4, display: "flex", marginBottom: 15, alignItems: "center", bgColor: "bg6", flexWrap: "wrap", width: "100%", style: { boxSizing: 'border-box' } }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 18, color: "text1", style: { flexGrow: 1, minWidth: '200px' } }, { children: "Total Amount Invested" })), renderTotalBalance()] })), jsxRuntime.jsx(Box, Object.assign({ width: "100%", minHeight: "140px" }, { children: balances.chains.length > 0 ? (jsxRuntime.jsx(Scrollbars__default["default"], Object.assign({ style: { width: '100%', height: '100%', minHeight: '140px' } }, { children: jsxRuntime.jsx(Frame$2, { children: balances.chains.map((chain, key) => renderChain(chain, key)) }) }))) : (jsxRuntime.jsx(Text, Object.assign({ fontSize: 18, color: "text1", textAlign: "center" }, { children: "Not found balances" }))) }))] })) }))] }));
};

const Root$e = styled__default["default"](Box) `
  width: 100%;
  height: 100%;

  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;

  padding: 20px;

  border-radius: 10px;
  background-color: ${({ theme }) => theme.color2};
`;
const Header$3 = styled__default["default"](Box) `
  width: 100%;
  display: flex;
  flex-direction: row;
  gap: 5px;
`;
const SelectedCard = styled__default["default"](Box) `
  height: 60px;

  background-color: ${({ theme, selected }) => (selected ? theme.bg3 : theme.bg6)};
  padding: 2px;
  border-radius: 4px;
  display: flex;
  flex-direction: row;

  justify-content: center;
  align-items: center;

  gap: 10px;
  cursor: pointer;

  font-weight: 500;

  &:hover,
  &:focus {
    opacity: 0.8;
  }
`;
const Frame$1 = styled__default["default"](Box) `
  width: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 10px;
`;
const RowWrapper = styled__default["default"](Box) `
  padding: 0px 10px;
  display: grid;
  grid-template-columns: auto auto;
  align-items: center;
  border-bottom: 1px solid ${({ theme }) => theme.text9};
  border-radius: 4px 4px 0px 0px;
  background-color: ${({ theme }) => theme.color2};

  height: 64px;

  &:hover {
    background-color: ${({ theme }) => theme.color3};
  }
`;
const Body = styled__default["default"](Box) `
  width: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));

  grid-gap: 20px;
`;

const PortfolioRow = ({ coin, pair, showBalances }) => {
    var _a, _b, _c, _d, _e;
    const theme = React.useContext(styled.ThemeContext);
    const renderLogo = (size) => {
        var _a, _b, _c;
        if (coin) {
            if ((coin.token instanceof sdk.Token && coin.token.chainId == sdk.ChainId.AVALANCHE) || !(coin.token instanceof sdk.Token)) {
                return jsxRuntime.jsx(CurrencyLogo, { size: size, currency: coin.token });
            }
            else if (coin === null || coin === void 0 ? void 0 : coin.logo) {
                return jsxRuntime.jsx(StyledLogo, { srcs: [coin.logo], size: `${size}px` });
            }
        }
        if (pair) {
            if (((_a = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _a === void 0 ? void 0 : _a.chainId) == sdk.ChainId.AVALANCHE) {
                return jsxRuntime.jsx(DoubleCurrencyLogo, { currency0: (_b = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _b === void 0 ? void 0 : _b.token0, currency1: (_c = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _c === void 0 ? void 0 : _c.token1, size: 24 });
            }
            else if (pair.logos) {
                return (jsxRuntime.jsxs(Wrapper$d, Object.assign({ margin: false, sizeraw: size }, { children: [jsxRuntime.jsx(StyledLogo, { srcs: [pair.logos[0]], size: `${size}px`, style: { zIndex: 2 } }), jsxRuntime.jsx(StyledLogo, { srcs: [pair.logos[1]], size: `${size}px`, style: { position: 'absolute', left: '-' + (size / 2).toString() + 'px' } })] })));
            }
        }
        return jsxRuntime.jsx(reactFeather.HelpCircle, { size: size });
    };
    const amount = coin && !pair ? coin.price * coin.amount : pair && !coin ? pair.usdValue : 0;
    return (jsxRuntime.jsxs(RowWrapper, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [renderLogo(24), coin && (jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 500, marginLeft: '6px' }, { children: (_a = coin === null || coin === void 0 ? void 0 : coin.token) === null || _a === void 0 ? void 0 : _a.symbol }))), pair && (jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 500, marginLeft: '6px' }, { children: [(_c = (_b = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _b === void 0 ? void 0 : _b.token0) === null || _c === void 0 ? void 0 : _c.symbol, " - ", (_e = (_d = pair === null || pair === void 0 ? void 0 : pair.pair) === null || _d === void 0 ? void 0 : _d.token1) === null || _e === void 0 ? void 0 : _e.symbol] })))] })), jsxRuntime.jsx(Box, Object.assign({ textAlign: "right" }, { children: !showBalances ? (jsxRuntime.jsx(reactFeather.Lock, { color: theme.text13, size: 16 })) : (jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: 14, fontWeight: 500 }, { children: ["$", amount.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 })] }))) }))] }));
};

const MyPortfolio = () => {
    const theme = React.useContext(styled.ThemeContext);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const [showBalances, setShowBalances] = React.useState(true);
    const [selectChain, setSelectChain] = React.useState(43114);
    const { data: balances, isLoading } = useGetChainsBalances();
    const { data: chainTokens, isLoading: isLoadingTokens } = useGetWalletChainTokens(selectChain);
    React.useEffect(() => {
        if (balances) {
            if (balances.chains.length > 0) {
                // if chainId in balances.chains then selectChain = chainId
                const _chain = balances.chains.find((chain) => chain.chainID === chainId);
                setSelectChain(_chain ? chainId : balances.chains[0].chainID);
            }
        }
    }, [balances]);
    const handleShowBalances = React.useCallback(() => {
        setShowBalances(!showBalances);
    }, [showBalances]);
    const renderChain = (_chain, key) => {
        const chain = sdk.ALL_CHAINS.filter((value) => value.chain_id === _chain.chainID)[0];
        const balance = _chain.balance.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 });
        const isSelected = selectChain === _chain.chainID;
        return (jsxRuntime.jsxs(SelectedCard, Object.assign({ onClick: () => setSelectChain(_chain.chainID), selected: isSelected }, { children: [jsxRuntime.jsx("img", { width: "26px", height: "26px", src: chain === null || chain === void 0 ? void 0 : chain.logo, alt: 'Chain logo' }), jsxRuntime.jsxs(Box, Object.assign({ height: "100%", display: "flex", justifyContent: "center", flexDirection: "column" }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 12, color: "text1" }, { children: chain.name })), showBalances ? (jsxRuntime.jsxs(Text, Object.assign({ fontSize: 12, color: "text13" }, { children: ["$", balance] }))) : (jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexDirection: "row" }, { children: [...Array(4)].map((_value, _key) => (jsxRuntime.jsx(reactFeather.Lock, { color: theme.text13, size: 14 }, _key))) })))] }))] }), key));
    };
    const renderTotalBalance = () => {
        if (showBalances) {
            return (jsxRuntime.jsxs(Text, Object.assign({ fontSize: 16, color: "text1", fontWeight: 600 }, { children: ["$", balances
                        ? balances.total.toLocaleString(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 2 })
                        : 0] })));
        }
        return jsxRuntime.jsx(reactFeather.Lock, { color: theme.text1, size: 18 });
    };
    const renderRow = (item, index) => {
        return (jsxRuntime.jsx(PortfolioRow, { coin: item instanceof TokenDataUser ? item : undefined, pair: item instanceof PairDataUser ? item : undefined, showBalances: showBalances }, index));
    };
    return (jsxRuntime.jsxs(Root$e, { children: [jsxRuntime.jsxs(Header$3, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: ['16px', '16px', '24px'], color: "text1", fontWeight: 600, style: { flexGrow: 1 } }, { children: "Your Portfolio" })), jsxRuntime.jsx(ToggleBalanceButton, { showBalances: showBalances, handleShowBalances: handleShowBalances })] }), jsxRuntime.jsx(Box, Object.assign({ width: "100%", display: "flex", flexGrow: 1, justifyContent: "center" }, { children: !account ? (jsxRuntime.jsx(Box, Object.assign({ height: "100%", display: "flex", alignItems: "center" }, { children: jsxRuntime.jsx(Text, Object.assign({ fontSize: 20, color: "text1", textAlign: "center" }, { children: "Connect a wallet to see your portfolio" })) }))) : isLoading || !balances ? (jsxRuntime.jsx(Loader, { size: 100 })) : balances && balances.chains.length == 0 ? (jsxRuntime.jsx(Box, Object.assign({ height: "100%", display: "flex", alignItems: "center", flexWrap: "wrap" }, { children: jsxRuntime.jsx(Text, Object.assign({ fontSize: 18, color: "text1", textAlign: "center" }, { children: "Not found balances" })) }))) : (jsxRuntime.jsxs(Body, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", width: "100%" }, { children: [jsxRuntime.jsxs(Box, Object.assign({ padding: 10, borderRadius: 4, display: "flex", marginBottom: 15, alignItems: "center", bgColor: "bg6", flexWrap: "wrap" }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 18, color: "text1", style: { flexGrow: 1, minWidth: '200px' } }, { children: "Total:" })), renderTotalBalance()] })), jsxRuntime.jsx(Box, Object.assign({ width: "100%", height: "100%", minHeight: "128px" }, { children: jsxRuntime.jsx(Scrollbars__default["default"], Object.assign({ style: { width: '100%', height: '100%' } }, { children: jsxRuntime.jsx(Frame$1, { children: balances.chains.map((chain, key) => renderChain(chain, key)) }) })) }))] })), jsxRuntime.jsx(Box, Object.assign({ width: "100%" }, { children: isLoadingTokens || !chainTokens ? (jsxRuntime.jsx(Loader, { size: 100 })) : chainTokens.length == 0 ? (jsxRuntime.jsx(Text, Object.assign({ fontSize: 18, color: "text1", textAlign: "center" }, { children: "Not found tokens on this chain" }))) : (jsxRuntime.jsx(Box, Object.assign({ height: "100%", minHeight: "128px" }, { children: jsxRuntime.jsx(Scrollbars__default["default"], Object.assign({ style: { width: '100%', height: '100%' } }, { children: chainTokens.map((item, index) => renderRow(item, index)) })) }))) }))] })) }))] }));
};

var AnalyticsIcon = "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2221%22%20height%3D%2219.421%22%20viewBox%3D%220%200%2021%2019.421%22%3E%20%20%3Cg%20id%3D%22Analytics%22%20transform%3D%22translate%28-34.934%201014.056%29%22%3E%20%20%20%20%3Cpath%20id%3D%22Path_209%22%20data-name%3D%22Path%20209%22%20d%3D%22M55.931-1001.787H34.943v-.237q0-5.541%2C0-11.081a.843.843%2C0%2C0%2C1%2C.942-.951H55.013a.836.836%2C0%2C0%2C1%2C.928.923q0%2C5.573%2C0%2C11.145C55.941-1001.925%2C55.935-1001.863%2C55.931-1001.787Zm-9.2-9.231-3.434%2C3.436-2.1-2.12-3.323%2C3.329.436.426%2C2.969-2.974%2C2.162%2C2.17%2C3.347-3.447%2C1.9%2C1.907%2C3.275-3.277.694.8.406-2.255-2.233.349-.034.073.657.6-2.85%2C2.851Zm5.6%2C8.2v-6.428H51.151v6.428Zm-4.235-.008h1.2v-4.126h-1.2Zm-3.033-3.926v3.924h1.173v-3.924Zm-1.914%2C1.421h-1.2v2.506h1.2Zm-4.235.5v2h1.182v-2Z%22%20transform%3D%22translate%28-0.008%29%22%20fill%3D%22%23707070%22%2F%3E%20%20%20%20%3Cpath%20id%3D%22Path_210%22%20data-name%3D%22Path%20210%22%20d%3D%22M34.935-783.157H55.92c0%2C.068.012.13.012.191%2C0%2C.633%2C0%2C1.267%2C0%2C1.9a.84.84%2C0%2C0%2C1-.916.917q-9.585%2C0-19.169%2C0a.838.838%2C0%2C0%2C1-.912-.921C34.933-781.758%2C34.935-782.447%2C34.935-783.157Zm11.194%2C1.484a.689.689%2C0%2C0%2C0-.693-.708.688.688%2C0%2C0%2C0-.7.684.681.681%2C0%2C0%2C0%2C.682.714A.681.681%2C0%2C0%2C0%2C46.129-781.673Z%22%20transform%3D%22translate%280%20-217.728%29%22%20fill%3D%22%23707070%22%2F%3E%20%20%20%20%3Cpath%20id%3D%22Path_211%22%20data-name%3D%22Path%20211%22%20d%3D%22M164.39-712.733h-2.815a.45.45%2C0%2C0%2C1-.19-.007.712.712%2C0%2C0%2C1-.288-.209.27.27%2C0%2C0%2C1%2C.091-.36%2C4.188%2C4.188%2C0%2C0%2C0%2C1.3-1.684.208.208%2C0%2C0%2C1%2C.159-.1q1.717-.008%2C3.433%2C0a.23.23%2C0%2C0%2C1%2C.167.115%2C4.144%2C4.144%2C0%2C0%2C0%2C1.3%2C1.633.32.32%2C0%2C0%2C1%2C.135.391.329.329%2C0%2C0%2C1-.353.217Q165.861-712.736%2C164.39-712.733Z%22%20transform%3D%22translate%28-118.932%20-281.909%29%22%20fill%3D%22%23707070%22%2F%3E%20%20%3C%2Fg%3E%3C%2Fsvg%3E";

const AnalyticsLink = styled__default["default"].a `
  display: flex;
  align-items: center;
  padding: 0px 0px 0px 4px;
  border-radius: 4px;

  svg {
    height: 16px;
  }

  path {
    fill: ${({ theme }) => theme.text1};
  }

  &:hover,
  &focus {
    path {
      fill: ${({ theme }) => theme.yellow1};
    }
  }
`;

const Stat = ({ title, titlePosition, stat, titleColor, titleFontSize, statColor, statFontSize, currency, statAlign, showAnalytics = false, }) => {
    const chainId = useChainId();
    const token = currency instanceof sdk.Currency && currency instanceof sdk.Token ? currency : sdk.WAVAX[chainId];
    function getAlignment() {
        if (statAlign === 'center') {
            return 'center';
        }
        else if (statAlign === 'right') {
            return 'flex-end';
        }
        else {
            return 'flex-start';
        }
    }
    return (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", alignItems: getAlignment() }, { children: [titlePosition === 'top' && title && (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "row", style: { gap: '5px' }, alignItems: "center" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: titleColor || 'text1', fontSize: titleFontSize || 20 }, { children: title })), showAnalytics && (jsxRuntime.jsx(AnalyticsLink, Object.assign({ href: `${ANALYTICS_PAGE}/#/token/${token.address}`, target: "_blank" }, { children: jsxRuntime.jsx("img", { src: AnalyticsIcon, alt: "analytics-icon" }) })))] }))), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", mt: titlePosition === 'top' ? '8px' : '0px', mb: titlePosition === 'bottom' ? '8px' : '0px' }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: statColor || 'text1', fontSize: statFontSize || 16 }, { children: stat })), currency && (jsxRuntime.jsx(Box, Object.assign({ ml: 10, height: 24 }, { children: jsxRuntime.jsx(CurrencyLogo, { currency: currency, size: 24, imageSize: 48 }) })))] })), titlePosition === 'bottom' && title && (jsxRuntime.jsx(Text, Object.assign({ color: titleColor || 'text1', fontSize: titleFontSize || 16 }, { children: title })))] })));
};

var SpaceType;
(function (SpaceType) {
    SpaceType["card"] = "card";
    SpaceType["detail"] = "detail";
})(SpaceType || (SpaceType = {}));
exports.PoolType = void 0;
(function (PoolType) {
    PoolType["own"] = "own";
    PoolType["all"] = "all";
    PoolType["superFarms"] = "superFarms";
})(exports.PoolType || (exports.PoolType = {}));

// modified from https://usehooks.com/useDebounce/
function useDebounce(value, delay) {
    const [debouncedValue, setDebouncedValue] = React.useState(value);
    React.useEffect(() => {
        // Update debounced value after delay
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);
        // Cancel the timeout if value changes (also on delay change or unmount)
        // This is how we prevent debounced value from updating if value is changed ...
        // .. within the delay period. Timeout gets cleared and restarted.
        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);
    return debouncedValue;
}

const GET_MINICHEF = gql__default["default"]`
  query minichefs($where: Minichef_filter, $userAddress: String) {
    minichefs(where: $where) {
      id
      totalAllocPoint
      rewardPerSecond
      rewardsExpiration
      farms(first: 1000) {
        id
        pid
        tvl
        allocPoint
        rewarderAddress
        chefAddress
        pairAddress
        rewarder {
          id
          rewards {
            id
            token {
              id
              symbol
              derivedUSD
              name
              decimals
            }
            multiplier
          }
        }
        pair {
          id
          reserve0
          reserve1
          totalSupply
          token0 {
            id
            symbol
            derivedUSD
            name
            decimals
          }
          token1 {
            id
            symbol
            derivedUSD
            name
            decimals
          }
        }
        farmingPositions(where: { userAddress: $userAddress }) {
          id
          stakedTokenBalance
        }
      }
    }
  }
`;

const PANGOLIN_PAIR_INTERFACE = new abi$1.Interface(IArcanumPair_json.abi);

// returns undefined if input token is undefined, or fails to get token contract,
// or contract total supply cannot be fetched
function useTotalSupply(token) {
    var _a, _b;
    const contract = useTokenContract(token === null || token === void 0 ? void 0 : token.address, false);
    const totalSupply = (_b = (_a = useSingleCallResult(contract, 'totalSupply')) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b[0];
    // Special case to handle PNG's proxy burnt total supply
    if (token === null || token === void 0 ? void 0 : token.equals(PNG[sdk.ChainId.AVALANCHE])) {
        return new sdk.TokenAmount(token, '230000000000000000000000000');
    }
    return token && totalSupply ? new sdk.TokenAmount(token, totalSupply.toString()) : undefined;
}
function useNearTotalSupply(tokenOrPair) {
    const chainId = useChainId();
    const [totalSupply, setTotalSupply] = React.useState();
    React.useEffect(() => {
        function getTotalSupply() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (tokenOrPair && tokenOrPair instanceof sdk.Pair) {
                    const pool = yield nearFn.getPool(chainId, tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.token0, tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.token1);
                    const totalSupplyAmt = new sdk.TokenAmount(tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.liquidityToken, pool === null || pool === void 0 ? void 0 : pool.shares_total_supply);
                    setTotalSupply(totalSupplyAmt);
                }
                else if (tokenOrPair instanceof sdk.Token) {
                    const totalSupply = yield nearFn.getTotalSupply(tokenOrPair === null || tokenOrPair === void 0 ? void 0 : tokenOrPair.address);
                    const totalSupplyAmt = new sdk.TokenAmount(tokenOrPair, totalSupply);
                    setTotalSupply(totalSupplyAmt);
                }
            });
        }
        getTotalSupply();
    }, [tokenOrPair, chainId]);
    return React.useMemo(() => totalSupply, [totalSupply]);
}
const useTotalSupplyHook = {
    [sdk.ChainId.FUJI]: useTotalSupply,
    [sdk.ChainId.AVALANCHE]: useTotalSupply,
    [sdk.ChainId.WAGMI]: useTotalSupply,
    [sdk.ChainId.COSTON]: useTotalSupply,
    [sdk.ChainId.SONGBIRD]: useTotalSupply,
    [sdk.ChainId.NEAR_MAINNET]: useNearTotalSupply,
    [sdk.ChainId.NEAR_TESTNET]: useNearTotalSupply,
};

const useGetFarmApr = (pid) => {
    const chainId = useChainId();
    const swapFeeApr = useSelector((state) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.aprs) === null || _b === void 0 ? void 0 : _b[chainId]) === null || _c === void 0 ? void 0 : _c[pid]) === null || _d === void 0 ? void 0 : _d.swapFeeApr; });
    const combinedApr = useSelector((state) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.aprs) === null || _b === void 0 ? void 0 : _b[chainId]) === null || _c === void 0 ? void 0 : _c[pid]) === null || _d === void 0 ? void 0 : _d.combinedApr; });
    const stakingApr = useSelector((state) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.aprs) === null || _b === void 0 ? void 0 : _b[chainId]) === null || _c === void 0 ? void 0 : _c[pid]) === null || _d === void 0 ? void 0 : _d.stakingApr; });
    return React.useMemo(() => ({
        swapFeeApr,
        combinedApr,
        stakingApr,
    }), [swapFeeApr, combinedApr, stakingApr]);
};
const useGetEarnedAmount = (pid) => {
    const chainId = useChainId();
    const png = PNG[chainId];
    const amount = useSelector((state) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.earnedAmounts) === null || _b === void 0 ? void 0 : _b[chainId]) === null || _c === void 0 ? void 0 : _c[pid]) === null || _d === void 0 ? void 0 : _d.earnedAmount; });
    return React.useMemo(() => ({
        earnedAmount: new sdk.TokenAmount(png, sdk.JSBI.BigInt(amount !== null && amount !== void 0 ? amount : 0)),
    }), [png, amount]);
};
const useSortFarmAprs = () => {
    const chainId = useChainId();
    const allAprs = useSelector((state) => { var _a, _b; return (_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.aprs) === null || _b === void 0 ? void 0 : _b[chainId]; });
    return React.useMemo(() => (allAprs ? Object.values(allAprs).sort((a, b) => b.combinedApr - a.combinedApr) : []), [allAprs]);
};
const fetchChunkedAprs = (pids, chainId, chunkSize = 4) => tslib.__awaiter(void 0, void 0, void 0, function* () {
    const pidChunks = [];
    for (let i = 0; i < pids.length; i += chunkSize) {
        const pidChunk = pids.slice(i, i + chunkSize);
        pidChunks.push(pidChunk);
    }
    const chunkedResults = yield Promise.all(pidChunks.map((chunk) => fetch(`${PANGOLIN_API_BASE_URL}/v2/${chainId}/pangolin/aprs/${chunk.join(',')}`).then((res) => res.json())));
    return chunkedResults.flat();
});
const useGetMinichefPids = () => {
    const chainId = useChainId();
    const farms = useSelector((state) => { var _a, _b; return ((_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.minichefStakingData[chainId]) === null || _b === void 0 ? void 0 : _b.farms) || []; });
    const pIds1 = farms === null || farms === void 0 ? void 0 : farms.map((farm) => farm === null || farm === void 0 ? void 0 : farm.pid);
    const pIds1String = (pIds1 || []).sort().join();
    const poolMap = useMinichefPools();
    const pIds2 = Object.values(poolMap || {}).map(String);
    const pIds2String = (pIds2 || []).sort().join();
    return React.useMemo(() => {
        return pIds1.length > 0 ? pIds1 : pIds2;
    }, [pIds1String, pIds2String]);
};
function useFetchFarmAprs() {
    const chainId = useChainId();
    const pids = useGetMinichefPids();
    const dispatch = useDispatch();
    React.useEffect(() => {
        if (!chainId || !pids || pids.length === 0)
            return;
        fetchChunkedAprs(pids, chainId).then((res) => {
            const newResult = res.reduce((acc, value, i) => (Object.assign(Object.assign({}, acc), { [pids[i]]: Object.assign(Object.assign({}, value), { pid: pids[i] }) })), {});
            if (res.length > 0) {
                dispatch(updateMinichefStakingAllAprs({
                    data: { chainId: chainId, data: newResult },
                }));
            }
        });
    }, [pids, chainId, dispatch]);
}
function useUpdateAllFarmsEarnAmount() {
    const poolIdArray = useGetMinichefPids();
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const minichefContract = useStakingContract(MINICHEF_ADDRESS[chainId]);
    const dispatch = useDispatch();
    const userInfoInput = React.useMemo(() => {
        if (!poolIdArray || !account)
            return [];
        return poolIdArray.map((pid) => [pid, account]);
    }, [poolIdArray, account]);
    const pendingRewards = useSingleContractMultipleData(minichefContract, 'pendingReward', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const prevPendingRewards = usePrevious(pendingRewards);
    React.useEffect(() => {
        var _a;
        const isAllFetched = pendingRewards.every((item) => !item.loading);
        const areValuesSame = isEqual__default["default"](pendingRewards, prevPendingRewards);
        if (isAllFetched && !areValuesSame) {
            const pendingRewardsObj = {};
            for (let index = 0; index < pendingRewards.length; index++) {
                const pid = poolIdArray[index];
                const pendingRewardInfo = pendingRewards[index];
                pendingRewardsObj[pid] = {
                    pid: pid,
                    earnedAmount: (_a = pendingRewardInfo === null || pendingRewardInfo === void 0 ? void 0 : pendingRewardInfo.result) === null || _a === void 0 ? void 0 : _a['pending'].toString(),
                };
            }
            dispatch(updateMinichefStakingAllFarmsEarnedAmount({ data: { chainId: chainId, data: pendingRewardsObj } }));
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [pendingRewards, prevPendingRewards]);
}
const sortingOnAvaxStake = (info_a, info_b) => {
    var _a, _b;
    // only first has ended
    if (info_a.isPeriodFinished && !info_b.isPeriodFinished)
        return 1;
    // only second has ended
    if (!info_a.isPeriodFinished && info_b.isPeriodFinished)
        return -1;
    // greater stake in avax comes first
    return ((_a = info_a.totalStakedInUsd) === null || _a === void 0 ? void 0 : _a.greaterThan((_b = info_b.totalStakedInUsd) !== null && _b !== void 0 ? _b : BIG_INT_ZERO)) ? -1 : 1;
};
const sortingOnStakedAmount = (info_a, info_b) => {
    // only the first is being staked, so we should bring the first up
    if (info_a.stakedAmount.greaterThan(BIG_INT_ZERO) && !info_b.stakedAmount.greaterThan(BIG_INT_ZERO))
        return -1;
    // only the second is being staked, so we should bring the first down
    if (!info_a.stakedAmount.greaterThan(BIG_INT_ZERO) && info_b.stakedAmount.greaterThan(BIG_INT_ZERO))
        return 1;
    return 0;
};
const useMinichefPools = () => {
    const minichefContract = useMiniChefContract();
    const lpTokens = useSingleCallResult(minichefContract, 'lpTokens', []).result;
    const lpTokensArr = lpTokens === null || lpTokens === void 0 ? void 0 : lpTokens[0];
    return React.useMemo(() => {
        const poolMap = {};
        if (lpTokensArr) {
            lpTokensArr.forEach((address, index) => {
                poolMap[address] = index;
            });
        }
        return poolMap;
    }, [lpTokensArr]);
};
function useMinichefPendingRewards(miniChefStaking) {
    var _a, _b, _c, _d, _e;
    const { account } = usePangolinWeb3();
    const rewardData = React.useRef({});
    const rewardAddress = miniChefStaking === null || miniChefStaking === void 0 ? void 0 : miniChefStaking.rewardsAddress;
    const rewardContract = useRewardViaMultiplierContract(rewardAddress !== ZERO_ADDRESS ? rewardAddress : undefined);
    const getRewardTokensRes = useSingleCallResult(rewardContract, 'getRewardTokens');
    const getRewardMultipliersRes = useSingleCallResult(rewardContract, 'getRewardMultipliers');
    const { earnedAmount: _earnedAmount } = useGetEarnedAmount(miniChefStaking === null || miniChefStaking === void 0 ? void 0 : miniChefStaking.pid);
    const earnedAmount = (miniChefStaking === null || miniChefStaking === void 0 ? void 0 : miniChefStaking.earnedAmount) || _earnedAmount;
    const rewardTokensAddress = (_a = getRewardTokensRes === null || getRewardTokensRes === void 0 ? void 0 : getRewardTokensRes.result) === null || _a === void 0 ? void 0 : _a[0];
    const rewardTokensMultiplier = (_b = getRewardMultipliersRes === null || getRewardMultipliersRes === void 0 ? void 0 : getRewardMultipliersRes.result) === null || _b === void 0 ? void 0 : _b[0];
    const earnedAmountStr = earnedAmount ? sdk.JSBI.BigInt(earnedAmount === null || earnedAmount === void 0 ? void 0 : earnedAmount.raw).toString() : sdk.JSBI.BigInt(0).toString();
    const pendingTokensRes = useSingleContractMultipleData(rewardContract, 'pendingTokens', account ? [[0, account, earnedAmountStr]] : []);
    const isLoading = (_c = pendingTokensRes === null || pendingTokensRes === void 0 ? void 0 : pendingTokensRes[0]) === null || _c === void 0 ? void 0 : _c.loading;
    const rewardTokens = useTokens(rewardTokensAddress);
    const rewardAmounts = ((_e = (_d = pendingTokensRes === null || pendingTokensRes === void 0 ? void 0 : pendingTokensRes[0]) === null || _d === void 0 ? void 0 : _d.result) === null || _e === void 0 ? void 0 : _e.amounts) || []; // eslint-disable-line react-hooks/exhaustive-deps
    const rewardTokensAmount = React.useMemo(() => {
        if (!rewardTokens)
            return [];
        return rewardTokens.map((rewardToken, index) => new sdk.TokenAmount(rewardToken, rewardAmounts[index] || 0));
    }, [rewardAmounts, rewardTokens]);
    React.useEffect(() => {
        if (!isLoading) {
            rewardData.current = {
                rewardTokensAmount,
                rewardTokensMultiplier,
            };
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [rewardTokensAmount, rewardTokensMultiplier, isLoading]);
    return rewardData.current;
}
function useGetPoolDollerWorth(pair) {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useTokenBalance = useTokenBalanceHook[chainId];
    const useTotalSupply = useTotalSupplyHook[chainId];
    const _useUSDCPrice = useUSDCPriceHook[chainId];
    const token0 = pair === null || pair === void 0 ? void 0 : pair.token0;
    const currency0 = unwrappedToken(token0, chainId);
    const currency0PriceTmp = _useUSDCPrice(currency0);
    const currency0Price = ((_a = sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet) ? currency0PriceTmp : undefined;
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    const userArl = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pairOrToken);
    const totalPoolTokens = useTotalSupply(pairOrToken);
    const [token0Deposited] = !!pair &&
        !!totalPoolTokens &&
        !!userArl &&
        sdk.JSBI.greaterThan(totalPoolTokens.raw, BIG_INT_ZERO) &&
        sdk.JSBI.greaterThan(userArl.raw, BIG_INT_ZERO) &&
        // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply
        sdk.JSBI.greaterThanOrEqual(totalPoolTokens.raw, userArl.raw)
        ? pair.getLiquidityValues(totalPoolTokens, userArl, { feeOn: false })
        : [undefined, undefined];
    let liquidityInUSD = 0;
    if (((_b = sdk.CHAINS[chainId]) === null || _b === void 0 ? void 0 : _b.mainnet) && currency0Price && token0Deposited) {
        liquidityInUSD = Number(currency0Price.toFixed()) * 2 * Number(token0Deposited === null || token0Deposited === void 0 ? void 0 : token0Deposited.toSignificant(6));
    }
    return React.useMemo(() => ({
        userArl,
        liquidityInUSD,
    }), [userArl, liquidityInUSD]);
}
// based on typed value
function useDerivedStakeInfo(typedValue, stakingToken, userLiquidityUnstaked) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const parsedInput = tryParseAmount(typedValue, stakingToken, chainId);
    const parsedAmount = parsedInput && userLiquidityUnstaked && sdk.JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw)
        ? parsedInput
        : undefined;
    let error;
    if (!account) {
        error = t('stakeHooks.connectWallet');
    }
    if (parsedInput && !parsedAmount) {
        error = error !== null && error !== void 0 ? error : t('stakeHooks.insufficientBalance', { symbol: stakingToken.symbol });
    }
    if (!parsedAmount) {
        error = error !== null && error !== void 0 ? error : t('stakeHooks.enterAmount');
    }
    return {
        parsedAmount,
        error,
    };
}
function useGetRewardTokens(rewardTokens, rewardTokensAddress) {
    const _rewardTokens = useTokens(rewardTokensAddress);
    return React.useMemo(() => {
        if (!rewardTokens && _rewardTokens) {
            // filter only tokens
            const tokens = _rewardTokens.filter((token) => token && token instanceof sdk.Token);
            return tokens;
        }
        return rewardTokens;
    }, [_rewardTokens, rewardTokens]);
}
const calculateTotalStakedAmountInAvax = function (amountStaked, amountAvailable, reserveInWavax, chainId) {
    if (sdk.JSBI.GT(amountAvailable, 0)) {
        // take the total amount of LP tokens staked, multiply by AVAX value of all LP tokens, divide by all LP tokens
        return new sdk.TokenAmount(sdk.WAVAX[chainId], sdk.JSBI.divide(sdk.JSBI.multiply(sdk.JSBI.multiply(amountStaked, reserveInWavax), sdk.JSBI.BigInt(2)), amountAvailable));
    }
    else {
        return new sdk.TokenAmount(sdk.WAVAX[chainId], sdk.JSBI.BigInt(0));
    }
};
const calculateTotalStakedAmountInAvaxFromPng = function (amountStaked, amountAvailable, avaxPngPairReserveOfPng, avaxPngPairReserveOfWavax, reserveInPng, chainId) {
    if (sdk.JSBI.EQ(amountAvailable, sdk.JSBI.BigInt(0))) {
        return new sdk.TokenAmount(sdk.WAVAX[chainId], sdk.JSBI.BigInt(0));
    }
    const oneToken = sdk.JSBI.BigInt(1000000000000000000);
    const avaxPngRatio = sdk.JSBI.divide(sdk.JSBI.multiply(oneToken, avaxPngPairReserveOfWavax), avaxPngPairReserveOfPng);
    const valueOfPngInAvax = sdk.JSBI.divide(sdk.JSBI.multiply(reserveInPng, avaxPngRatio), oneToken);
    return new sdk.TokenAmount(sdk.WAVAX[chainId], sdk.JSBI.divide(sdk.JSBI.multiply(sdk.JSBI.multiply(amountStaked, valueOfPngInAvax), sdk.JSBI.BigInt(2)), amountAvailable));
};
const getExtraTokensWeeklyRewardRate = (rewardRatePerWeek, token, tokenMultiplier) => {
    const TEN_EIGHTEEN = sdk.JSBI.exponentiate(sdk.JSBI.BigInt(10), sdk.JSBI.BigInt(18));
    const rewardMultiplier = sdk.JSBI.BigInt(tokenMultiplier || 1);
    const unadjustedRewardPerWeek = sdk.JSBI.multiply(rewardMultiplier, rewardRatePerWeek === null || rewardRatePerWeek === void 0 ? void 0 : rewardRatePerWeek.raw);
    const finalReward = sdk.JSBI.divide(unadjustedRewardPerWeek, TEN_EIGHTEEN);
    return new sdk.TokenAmount(token, finalReward);
};
const tokenComparator = ({ address: addressA }, { address: addressB }) => {
    // Sort AVAX last
    if (addressA === sdk.WAVAX[sdk.ChainId.AVALANCHE].address)
        return 1;
    else if (addressB === sdk.WAVAX[sdk.ChainId.AVALANCHE].address)
        return -1;
    // Sort PNG first
    else if (addressA === PNG[sdk.ChainId.AVALANCHE].address)
        return -1;
    else if (addressB === PNG[sdk.ChainId.AVALANCHE].address)
        return 1;
    // Sort axlUST first
    else if (addressA === axlUST[sdk.ChainId.AVALANCHE].address)
        return -1;
    else if (addressB === axlUST[sdk.ChainId.AVALANCHE].address)
        return 1;
    // Sort USDC first
    else if (addressA === USDC[sdk.ChainId.AVALANCHE].address)
        return -1;
    else if (addressB === USDC[sdk.ChainId.AVALANCHE].address)
        return 1;
    // Sort USDCe first
    else if (addressA === USDCe[sdk.ChainId.AVALANCHE].address)
        return -1;
    else if (addressB === USDCe[sdk.ChainId.AVALANCHE].address)
        return 1;
    else
        return 0;
};
/* eslint-disable @typescript-eslint/no-unused-vars */
const useDummyMinichefHook = (_version, _pairToFilterBy) => {
    return [];
};
const useMinichefStakingInfos = (version = 2, pairToFilterBy) => {
    var _a;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const minichefContract = useMiniChefContract();
    const poolMap = useMinichefPools();
    const lpTokens = Object.keys(poolMap);
    // if chain is not avalanche skip the first pool because it's dummyERC20
    if (chainId !== sdk.ChainId.AVALANCHE) {
        lpTokens.shift();
    }
    const _tokens0Call = useMultipleContractSingleData(lpTokens, PANGOLIN_PAIR_INTERFACE, 'token0', []);
    const _tokens1Call = useMultipleContractSingleData(lpTokens, PANGOLIN_PAIR_INTERFACE, 'token1', []);
    const tokens0Adrr = React.useMemo(() => {
        return _tokens0Call.map((result) => {
            return result.result && result.result.length > 0 ? result.result[0] : null;
        });
    }, [_tokens0Call]);
    const tokens1Adrr = React.useMemo(() => {
        return _tokens1Call.map((result) => (result.result && result.result.length > 0 ? result.result[0] : null));
    }, [_tokens1Call]);
    const tokens0 = useTokens(tokens0Adrr);
    const tokens1 = useTokens(tokens1Adrr);
    const info = React.useMemo(() => {
        const filterPair = (item) => {
            if (pairToFilterBy === undefined) {
                return true;
            }
            if (pairToFilterBy === null) {
                return false;
            }
            return pairToFilterBy.involvesToken(item.tokens[0]) && pairToFilterBy.involvesToken(item.tokens[1]);
        };
        const _infoTokens = [];
        if (tokens0 && tokens1 && (tokens0 === null || tokens0 === void 0 ? void 0 : tokens0.length) === (tokens1 === null || tokens1 === void 0 ? void 0 : tokens1.length)) {
            tokens0.forEach((token0, index) => {
                var _a;
                const token1 = tokens1[index];
                if (token0 && token1) {
                    _infoTokens.push({
                        tokens: [token0, token1],
                        stakingRewardAddress: (_a = minichefContract === null || minichefContract === void 0 ? void 0 : minichefContract.address) !== null && _a !== void 0 ? _a : '',
                        version: version,
                    });
                }
            });
            return _infoTokens.filter(filterPair);
        }
        return _infoTokens;
    }, [chainId, minichefContract, tokens0, tokens1, pairToFilterBy, version]);
    const _tokens = React.useMemo(() => (info ? info.map(({ tokens }) => tokens) : []), [info]);
    const pairs = usePairs(_tokens);
    // @dev: If no farms load, you likely loaded an incorrect config from doubleSideConfig.js
    // Enable this and look for an invalid pair
    const pairAddresses = React.useMemo(() => {
        return pairs.map(([, pair]) => pair === null || pair === void 0 ? void 0 : pair.liquidityToken.address);
    }, [pairs]);
    const pairTotalSupplies = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'totalSupply');
    const balances = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'balanceOf', [
        MINICHEF_ADDRESS[chainId],
    ]);
    const [avaxPngPairState, avaxPngPair] = usePair(sdk.WAVAX[chainId], PNG[chainId]);
    const poolIdArray = React.useMemo(() => {
        if (!pairAddresses || !poolMap)
            return [];
        const NOT_FOUND = -1;
        const results = pairAddresses.map((address) => { var _a; return (_a = poolMap[address !== null && address !== void 0 ? address : '']) !== null && _a !== void 0 ? _a : NOT_FOUND; });
        if (results.some((result) => result === NOT_FOUND))
            return [];
        return results;
    }, [poolMap, pairAddresses]);
    const poolsIdInput = React.useMemo(() => {
        if (!poolIdArray)
            return [];
        return poolIdArray.map((pid) => [pid]);
    }, [poolIdArray]);
    const poolInfos = useSingleContractMultipleData(minichefContract, 'poolInfo', poolsIdInput !== null && poolsIdInput !== void 0 ? poolsIdInput : []);
    const rewarders = useSingleContractMultipleData(minichefContract, 'rewarder', poolsIdInput !== null && poolsIdInput !== void 0 ? poolsIdInput : []);
    const userInfoInput = React.useMemo(() => {
        if (!poolIdArray || !account)
            return [];
        return poolIdArray.map((pid) => [pid, account]);
    }, [poolIdArray, account]);
    const userInfos = useSingleContractMultipleData(minichefContract, 'userInfo', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const pendingRewards = useSingleContractMultipleData(minichefContract, 'pendingReward', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const rewardsAddresses = React.useMemo(() => {
        if ((rewarders || []).length === 0)
            return [];
        if (rewarders.some((item) => item.loading))
            return [];
        return rewarders.map((reward) => { var _a; return (_a = reward === null || reward === void 0 ? void 0 : reward.result) === null || _a === void 0 ? void 0 : _a[0]; });
    }, [rewarders]);
    const rewardTokensAddresses = useMultipleContractSingleData(rewardsAddresses, REWARDER_VIA_MULTIPLIER_INTERFACE, 'getRewardTokens', []);
    const rewardTokensMultipliers = useMultipleContractSingleData(rewardsAddresses, REWARDER_VIA_MULTIPLIER_INTERFACE, 'getRewardMultipliers', []);
    const rewardPerSecond = useSingleCallResult(minichefContract, 'rewardPerSecond', []).result;
    const totalAllocPoint = useSingleCallResult(minichefContract, 'totalAllocPoint', []).result;
    const rewardsExpiration = useSingleCallResult(minichefContract, 'rewardsExpiration', []).result;
    const usdPriceTmp = useUSDCPrice(sdk.WAVAX[chainId]);
    const usdPrice = ((_a = sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet) ? usdPriceTmp : undefined;
    return React.useMemo(() => {
        if (!chainId || !PNG[chainId])
            return [];
        return pairAddresses.reduce((memo, _pairAddress, index) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
            const pairTotalSupplyState = pairTotalSupplies[index];
            const balanceState = balances[index];
            const poolInfo = poolInfos[index];
            const userPoolInfo = userInfos[index];
            const [pairState, pair] = pairs[index];
            const pendingRewardInfo = pendingRewards[index];
            const rewardTokensAddress = rewardTokensAddresses[index];
            const rewardTokensMultiplier = rewardTokensMultipliers[index];
            const rewardsAddress = rewardsAddresses[index];
            if ((pairTotalSupplyState === null || pairTotalSupplyState === void 0 ? void 0 : pairTotalSupplyState.loading) === false &&
                (poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.loading) === false &&
                (balanceState === null || balanceState === void 0 ? void 0 : balanceState.loading) === false &&
                pair &&
                avaxPngPair &&
                pairState !== PairState.LOADING &&
                avaxPngPairState !== PairState.LOADING &&
                rewardPerSecond &&
                totalAllocPoint &&
                (rewardsExpiration === null || rewardsExpiration === void 0 ? void 0 : rewardsExpiration[0]) &&
                (rewardTokensAddress === null || rewardTokensAddress === void 0 ? void 0 : rewardTokensAddress.loading) === false) {
                if ((balanceState === null || balanceState === void 0 ? void 0 : balanceState.error) ||
                    pairTotalSupplyState.error ||
                    pairState === PairState.INVALID ||
                    pairState === PairState.NOT_EXISTS ||
                    avaxPngPairState === PairState.INVALID ||
                    avaxPngPairState === PairState.NOT_EXISTS) {
                    console.error('Failed to load staking rewards info');
                    return memo;
                }
                const pid = poolMap[pair.liquidityToken.address].toString();
                // get the LP token
                const token0 = pair === null || pair === void 0 ? void 0 : pair.token0;
                const token1 = pair === null || pair === void 0 ? void 0 : pair.token1;
                const tokens = [token0, token1].sort(tokenComparator);
                const dummyPair = new sdk.Pair(new sdk.TokenAmount(tokens[0], '0'), new sdk.TokenAmount(tokens[1], '0'), chainId);
                const lpToken = dummyPair.liquidityToken;
                const poolAllocPointAmount = new sdk.TokenAmount(lpToken, sdk.JSBI.BigInt((_a = poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.result) === null || _a === void 0 ? void 0 : _a['allocPoint']));
                const totalAllocPointAmount = new sdk.TokenAmount(lpToken, sdk.JSBI.BigInt(totalAllocPoint === null || totalAllocPoint === void 0 ? void 0 : totalAllocPoint[0]));
                const rewardRatePerSecAmount = new sdk.TokenAmount(PNG[chainId], sdk.JSBI.BigInt(rewardPerSecond === null || rewardPerSecond === void 0 ? void 0 : rewardPerSecond[0]));
                const poolRewardRate = new sdk.TokenAmount(PNG[chainId], sdk.JSBI.divide(sdk.JSBI.multiply(poolAllocPointAmount.raw, rewardRatePerSecAmount.raw), totalAllocPointAmount.raw));
                const totalRewardRatePerWeek = new sdk.TokenAmount(PNG[chainId], sdk.JSBI.multiply(poolRewardRate.raw, BIG_INT_SECONDS_IN_WEEK));
                const periodFinishMs = (_c = (_b = rewardsExpiration === null || rewardsExpiration === void 0 ? void 0 : rewardsExpiration[0]) === null || _b === void 0 ? void 0 : _b.mul(1000)) === null || _c === void 0 ? void 0 : _c.toNumber();
                // periodFinish will be 0 immediately after a reward contract is initialized
                const isPeriodFinished = periodFinishMs === 0 ? false : periodFinishMs < Date.now() || poolAllocPointAmount.equalTo('0');
                const totalSupplyStaked = sdk.JSBI.BigInt((_d = balanceState === null || balanceState === void 0 ? void 0 : balanceState.result) === null || _d === void 0 ? void 0 : _d[0]);
                const totalSupplyAvailable = sdk.JSBI.BigInt((_e = pairTotalSupplyState === null || pairTotalSupplyState === void 0 ? void 0 : pairTotalSupplyState.result) === null || _e === void 0 ? void 0 : _e[0]);
                const totalStakedAmount = new sdk.TokenAmount(lpToken, sdk.JSBI.BigInt((_f = balanceState === null || balanceState === void 0 ? void 0 : balanceState.result) === null || _f === void 0 ? void 0 : _f[0]));
                const stakedAmount = new sdk.TokenAmount(lpToken, sdk.JSBI.BigInt((_h = (_g = userPoolInfo === null || userPoolInfo === void 0 ? void 0 : userPoolInfo.result) === null || _g === void 0 ? void 0 : _g['amount']) !== null && _h !== void 0 ? _h : 0));
                const earnedAmount = new sdk.TokenAmount(PNG[chainId], sdk.JSBI.BigInt((_k = (_j = pendingRewardInfo === null || pendingRewardInfo === void 0 ? void 0 : pendingRewardInfo.result) === null || _j === void 0 ? void 0 : _j['pending']) !== null && _k !== void 0 ? _k : 0));
                const multiplier = sdk.JSBI.BigInt((_l = poolInfo === null || poolInfo === void 0 ? void 0 : poolInfo.result) === null || _l === void 0 ? void 0 : _l['allocPoint']);
                let totalStakedInUsd = sdk.CHAINS[chainId || sdk.ChainId].mainnet
                    ? new sdk.TokenAmount(DAIe[chainId], BIG_INT_ZERO)
                    : undefined;
                const totalStakedInWavax = new sdk.TokenAmount(sdk.WAVAX[chainId], BIG_INT_ZERO);
                if (sdk.JSBI.equal(totalSupplyAvailable, BIG_INT_ZERO)) ;
                else if (pair.involvesToken(DAIe[chainId])) {
                    const pairValueInDAI = sdk.JSBI.multiply(pair.reserveOfToken(DAIe[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInDAI = sdk.JSBI.divide(sdk.JSBI.multiply(pairValueInDAI, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = sdk.CHAINS[chainId || sdk.ChainId].mainnet
                        ? new sdk.TokenAmount(DAIe[chainId], stakedValueInDAI)
                        : undefined;
                }
                else if (pair.involvesToken(USDCe[chainId])) {
                    const pairValueInUSDC = sdk.JSBI.multiply(pair.reserveOfToken(USDCe[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInUSDC = sdk.JSBI.divide(sdk.JSBI.multiply(pairValueInUSDC, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = sdk.CHAINS[chainId || sdk.ChainId].mainnet
                        ? new sdk.TokenAmount(USDCe[chainId], stakedValueInUSDC)
                        : undefined;
                }
                else if (pair.involvesToken(USDC[chainId])) {
                    const pairValueInUSDC = sdk.JSBI.multiply(pair.reserveOfToken(USDC[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInUSDC = sdk.JSBI.divide(sdk.JSBI.multiply(pairValueInUSDC, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = sdk.CHAINS[chainId || sdk.ChainId].mainnet
                        ? new sdk.TokenAmount(USDC[chainId], stakedValueInUSDC)
                        : undefined;
                }
                else if (pair.involvesToken(axlUST[chainId])) {
                    const pairValueInUST = sdk.JSBI.multiply(pair.reserveOfToken(axlUST[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInUST = sdk.JSBI.divide(sdk.JSBI.multiply(pairValueInUST, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = sdk.CHAINS[chainId || sdk.ChainId].mainnet
                        ? new sdk.TokenAmount(axlUST[chainId], stakedValueInUST)
                        : undefined;
                }
                else if (pair.involvesToken(USDTe[chainId])) {
                    const pairValueInUSDT = sdk.JSBI.multiply(pair.reserveOfToken(USDTe[chainId]).raw, BIG_INT_TWO);
                    const stakedValueInUSDT = sdk.JSBI.divide(sdk.JSBI.multiply(pairValueInUSDT, totalSupplyStaked), totalSupplyAvailable);
                    totalStakedInUsd = sdk.CHAINS[chainId || sdk.ChainId].mainnet
                        ? new sdk.TokenAmount(USDTe[chainId], stakedValueInUSDT)
                        : undefined;
                }
                else if (pair.involvesToken(sdk.WAVAX[chainId])) {
                    const _totalStakedInWavax = calculateTotalStakedAmountInAvax(totalSupplyStaked, totalSupplyAvailable, pair.reserveOfToken(sdk.WAVAX[chainId]).raw, chainId);
                    totalStakedInUsd = sdk.CHAINS[chainId || sdk.ChainId].mainnet
                        ? _totalStakedInWavax && (usdPrice === null || usdPrice === void 0 ? void 0 : usdPrice.quote(_totalStakedInWavax, chainId))
                        : undefined;
                }
                else if (pair.involvesToken(PNG[chainId])) {
                    const _totalStakedInWavax = calculateTotalStakedAmountInAvaxFromPng(totalSupplyStaked, totalSupplyAvailable, avaxPngPair.reserveOfToken(PNG[chainId]).raw, avaxPngPair.reserveOfToken(sdk.WAVAX[chainId]).raw, pair.reserveOfToken(PNG[chainId]).raw, chainId);
                    totalStakedInUsd = sdk.CHAINS[chainId || sdk.ChainId].mainnet
                        ? _totalStakedInWavax && (usdPrice === null || usdPrice === void 0 ? void 0 : usdPrice.quote(_totalStakedInWavax, chainId))
                        : undefined;
                }
                else {
                    // Contains no stablecoin, WAVAX, nor PNG
                    console.error(`Could not identify total staked value for pair ${pair.liquidityToken.address}`);
                }
                const getHypotheticalWeeklyRewardRate = (_stakedAmount, _totalStakedAmount, _totalRewardRatePerSecond) => {
                    return new sdk.TokenAmount(PNG[chainId], sdk.JSBI.greaterThan(_totalStakedAmount.raw, sdk.JSBI.BigInt(0))
                        ? sdk.JSBI.divide(sdk.JSBI.multiply(sdk.JSBI.multiply(_totalRewardRatePerSecond.raw, _stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK), _totalStakedAmount.raw)
                        : sdk.JSBI.BigInt(0));
                };
                const userRewardRatePerWeek = getHypotheticalWeeklyRewardRate(stakedAmount, totalStakedAmount, poolRewardRate);
                memo.push({
                    pid,
                    stakingRewardAddress: MINICHEF_ADDRESS[chainId],
                    tokens,
                    earnedAmount,
                    rewardRatePerWeek: userRewardRatePerWeek,
                    totalRewardRatePerSecond: poolRewardRate,
                    totalRewardRatePerWeek: totalRewardRatePerWeek,
                    stakedAmount,
                    totalStakedAmount,
                    totalStakedInWavax,
                    totalStakedInUsd,
                    multiplier: sdk.JSBI.divide(multiplier, sdk.JSBI.BigInt(100)),
                    periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,
                    isPeriodFinished,
                    getHypotheticalWeeklyRewardRate,
                    getExtraTokensWeeklyRewardRate,
                    rewardTokensAddress: [(_m = PNG[chainId]) === null || _m === void 0 ? void 0 : _m.address, ...(((_o = rewardTokensAddress === null || rewardTokensAddress === void 0 ? void 0 : rewardTokensAddress.result) === null || _o === void 0 ? void 0 : _o[0]) || [])],
                    rewardTokensMultiplier: [bignumber.BigNumber.from(1), ...(((_p = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier.result) === null || _p === void 0 ? void 0 : _p[0]) || [])],
                    rewardsAddress,
                });
            }
            return memo;
        }, []);
    }, [
        chainId,
        PNG[chainId],
        pairTotalSupplies,
        poolInfos,
        userInfos,
        pairs,
        avaxPngPair,
        avaxPngPairState,
        rewardPerSecond,
        totalAllocPoint,
        pendingRewards,
        rewardsExpiration,
        balances,
        usdPrice,
        pairAddresses,
        rewardTokensAddresses,
        rewardsAddresses,
        rewardTokensMultipliers,
        poolMap,
    ]);
};
const fetchMinichefData = (account, chainId) => () => tslib.__awaiter(void 0, void 0, void 0, function* () {
    const mininchefV2Client = mininchefV2Clients[chainId];
    if (!mininchefV2Client) {
        return null;
    }
    const { minichefs } = yield mininchefV2Client.request(GET_MINICHEF, { userAddress: account });
    return minichefs;
});
function useGetAllFarmData() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const allFarms = reactQuery.useQuery(['get-minichef-farms-v2', account], fetchMinichefData(account || '', chainId), {
        refetchInterval: 1000 * 60 * 5, // 5 minutes
    });
    const dispatch = useDispatch();
    React.useEffect(() => {
        var _a;
        if (allFarms.isError) {
            // if there is error then empty the data in redux
            dispatch(updateMinichefStakingAllData({
                data: {
                    chainId: chainId,
                    data: {
                        id: '',
                        totalAllocPoint: 0,
                        rewardPerSecond: 0,
                        rewardsExpiration: 0,
                        farms: [],
                    },
                },
            }));
        }
        else if (!(allFarms === null || allFarms === void 0 ? void 0 : allFarms.isLoading) && !(allFarms === null || allFarms === void 0 ? void 0 : allFarms.isError)) {
            dispatch(updateMinichefStakingAllData({
                data: {
                    chainId: chainId,
                    data: (_a = allFarms === null || allFarms === void 0 ? void 0 : allFarms.data) === null || _a === void 0 ? void 0 : _a[0],
                },
            }));
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [allFarms === null || allFarms === void 0 ? void 0 : allFarms.data, allFarms === null || allFarms === void 0 ? void 0 : allFarms.isLoading, allFarms === null || allFarms === void 0 ? void 0 : allFarms.isError]);
}
function useGetDummyAllFarmData() {
    // This is intentional
}
function useAllMinichefStakingInfoData() {
    const chainId = useChainId();
    return useSelector((state) => { var _a, _b; return ((_b = (_a = state === null || state === void 0 ? void 0 : state.pstake) === null || _a === void 0 ? void 0 : _a.minichefStakingData) === null || _b === void 0 ? void 0 : _b[chainId]) || {}; });
}
// get data for all farms
const useGetMinichefStakingInfosViaSubgraph = () => {
    const minichefData = useAllMinichefStakingInfoData();
    const farms = minichefData === null || minichefData === void 0 ? void 0 : minichefData.farms;
    const chainId = useChainId();
    const png = PNG[chainId];
    const rewardsExpiration = minichefData === null || minichefData === void 0 ? void 0 : minichefData.rewardsExpiration;
    const totalAllocPoint = minichefData === null || minichefData === void 0 ? void 0 : minichefData.totalAllocPoint;
    const rewardPerSecond = minichefData === null || minichefData === void 0 ? void 0 : minichefData.rewardPerSecond;
    return React.useMemo(() => {
        if (!chainId || !png || !(farms === null || farms === void 0 ? void 0 : farms.length))
            return [];
        return farms.reduce(function (memo, farm) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            const rewardsAddress = farm === null || farm === void 0 ? void 0 : farm.rewarderAddress;
            const rewardsAddresses = farm.rewarder.rewards;
            const pair = farm.pair;
            const axlUSTToken = axlUST[chainId];
            const axlUSTAddress = axlUSTToken.address;
            const pairToken0 = pair === null || pair === void 0 ? void 0 : pair.token0;
            const token0 = new sdk.Token(chainId, utils.getAddress(pairToken0.id), Number(pairToken0.decimals), axlUSTAddress.toLowerCase() === pairToken0.id.toLowerCase() ? axlUSTToken.symbol : pairToken0.symbol, pairToken0.name);
            const pairToken1 = pair === null || pair === void 0 ? void 0 : pair.token1;
            const token1 = new sdk.Token(chainId, utils.getAddress(pairToken1.id), Number(pairToken1.decimals), axlUSTAddress.toLowerCase() === pairToken1.id.toLowerCase() ? axlUSTToken.symbol : pairToken1.symbol, pairToken1.name);
            const tokens = [token0, token1].sort(tokenComparator);
            const dummyPair = new sdk.Pair(new sdk.TokenAmount(tokens[0], '0'), new sdk.TokenAmount(tokens[1], '0'), chainId);
            const lpToken = dummyPair.liquidityToken;
            const poolAllocPointAmount = new sdk.TokenAmount(lpToken, sdk.JSBI.BigInt(farm === null || farm === void 0 ? void 0 : farm.allocPoint));
            const totalAllocPointAmount = new sdk.TokenAmount(lpToken, sdk.JSBI.BigInt(totalAllocPoint !== null && totalAllocPoint !== void 0 ? totalAllocPoint : 0));
            const rewardRatePerSecAmount = new sdk.TokenAmount(png, sdk.JSBI.BigInt(rewardPerSecond !== null && rewardPerSecond !== void 0 ? rewardPerSecond : 0));
            const poolRewardRate = new sdk.TokenAmount(png, sdk.JSBI.divide(sdk.JSBI.multiply(poolAllocPointAmount.raw, rewardRatePerSecAmount.raw), totalAllocPointAmount.raw));
            const totalRewardRatePerWeek = new sdk.TokenAmount(png, sdk.JSBI.multiply(poolRewardRate.raw, BIG_INT_SECONDS_IN_WEEK));
            const periodFinishMs = (rewardsExpiration || 0) * 1000;
            // periodFinish will be 0 immediately after a reward contract is initialized
            const isPeriodFinished = periodFinishMs === 0 ? false : periodFinishMs < Date.now() || poolAllocPointAmount.equalTo('0');
            const minichefTvl = utils.parseUnits((_a = farm === null || farm === void 0 ? void 0 : farm.tvl) === null || _a === void 0 ? void 0 : _a.toString());
            const totalSupplyReserve0 = utils.parseUnits((_b = farm === null || farm === void 0 ? void 0 : farm.pair) === null || _b === void 0 ? void 0 : _b.reserve0.toString());
            const totalSupply = utils.parseUnits(((_c = farm === null || farm === void 0 ? void 0 : farm.pair) === null || _c === void 0 ? void 0 : _c.totalSupply.toString()) === '0' ? '1' : (_d = farm === null || farm === void 0 ? void 0 : farm.pair) === null || _d === void 0 ? void 0 : _d.totalSupply.toString());
            const token0derivedUSD = utils.parseUnits((_g = Number((_f = (_e = farm === null || farm === void 0 ? void 0 : farm.pair) === null || _e === void 0 ? void 0 : _e.token0) === null || _f === void 0 ? void 0 : _f.derivedUSD)) === null || _g === void 0 ? void 0 : _g.toFixed(10));
            const pairTokenValueInUSD = token0derivedUSD.mul(utils.parseUnits('2'));
            const calculatedStakedUsdValue = minichefTvl.mul(totalSupplyReserve0).div(totalSupply);
            // we have 2 10^18, so we need to divide ONE_TOKEN 2 times
            const finalStakedValueInUSD = pairTokenValueInUSD
                .mul(calculatedStakedUsdValue)
                .div(ONE_TOKEN.toString())
                .div(ONE_TOKEN.toString());
            const totalStakedAmount = new sdk.TokenAmount(lpToken, minichefTvl.toString() || sdk.JSBI.BigInt(0));
            const totalStakedInUsd = new sdk.TokenAmount(lpToken, finalStakedValueInUSD.toString() || sdk.JSBI.BigInt(0));
            const stakedAmount = new sdk.TokenAmount(lpToken, utils.parseUnits((_l = (_k = (_j = (_h = farm === null || farm === void 0 ? void 0 : farm.farmingPositions) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.stakedTokenBalance) === null || _k === void 0 ? void 0 : _k.toString()) !== null && _l !== void 0 ? _l : '0').toString());
            const earnedAmount = new sdk.TokenAmount(png, sdk.JSBI.BigInt((_m = farm === null || farm === void 0 ? void 0 : farm.earnedAmount) !== null && _m !== void 0 ? _m : 0));
            const multiplier = sdk.JSBI.BigInt(farm === null || farm === void 0 ? void 0 : farm.allocPoint);
            const pid = farm === null || farm === void 0 ? void 0 : farm.pid;
            const rewardTokens = rewardsAddresses.map((rewardToken) => {
                const tokenObj = rewardToken.token;
                return new sdk.Token(chainId, utils.getAddress(tokenObj.id), tokenObj.decimals, tokenObj.symbol, tokenObj.name);
            });
            const rewardTokensAddress = rewardsAddresses.map((rewardToken) => {
                const tokenObj = rewardToken.token;
                return utils.getAddress(tokenObj.id);
            });
            const getHypotheticalWeeklyRewardRate = (_stakedAmount, _totalStakedAmount, _totalRewardRatePerSecond) => {
                return new sdk.TokenAmount(png, sdk.JSBI.greaterThan(_totalStakedAmount.raw, sdk.JSBI.BigInt(0))
                    ? sdk.JSBI.divide(sdk.JSBI.multiply(sdk.JSBI.multiply(_totalRewardRatePerSecond.raw, _stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK), _totalStakedAmount.raw)
                    : sdk.JSBI.BigInt(0));
            };
            const userRewardRatePerWeek = getHypotheticalWeeklyRewardRate(stakedAmount, totalStakedAmount, poolRewardRate);
            memo.push({
                stakingRewardAddress: MINICHEF_ADDRESS[chainId],
                pid,
                tokens,
                multiplier,
                isPeriodFinished,
                totalStakedAmount,
                totalStakedInUsd,
                rewardRatePerWeek: userRewardRatePerWeek,
                totalRewardRatePerSecond: poolRewardRate,
                totalRewardRatePerWeek: totalRewardRatePerWeek,
                getHypotheticalWeeklyRewardRate,
                getExtraTokensWeeklyRewardRate,
                stakedAmount,
                earnedAmount,
                rewardsAddress,
                rewardsAddresses,
                rewardTokens,
                rewardTokensAddress,
            });
            return memo;
        }, []);
    }, [chainId, png, rewardPerSecond, totalAllocPoint, rewardsExpiration, farms]);
};
/* eslint-disable @typescript-eslint/no-unused-vars */
const useDummyMinichefStakingInfosViaSubgraph = () => {
    return [];
};
/* eslint-enable max-lines */

const ZERO$1 = sdk.JSBI.BigInt(0);
function useMintState() {
    return useSelector((state) => state.pmint);
}
function useDerivedMintInfo(currencyA, currencyB) {
    var _a, _b, _c, _d;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useTotalSupply = useTotalSupplyHook[chainId];
    const { t } = reactI18next.useTranslation();
    const { independentField, typedValue, otherTypedValue } = useMintState();
    const dependentField = independentField === Field$1.CURRENCY_A ? Field$1.CURRENCY_B : Field$1.CURRENCY_A;
    // error handling
    let insufficientInput = false;
    // tokens
    const currencies = React.useMemo(() => ({
        [Field$1.CURRENCY_A]: currencyA !== null && currencyA !== void 0 ? currencyA : undefined,
        [Field$1.CURRENCY_B]: currencyB !== null && currencyB !== void 0 ? currencyB : undefined,
    }), [currencyA, currencyB]);
    // pair
    const [pairState, pair] = usePair(currencies[Field$1.CURRENCY_A], currencies[Field$1.CURRENCY_B]);
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    const totalSupply = useTotalSupply(pairOrToken);
    const noLiquidity = pairState === PairState.NOT_EXISTS || !totalSupply || Boolean(totalSupply && sdk.JSBI.equal(totalSupply.raw, ZERO$1));
    // balances
    const balances = useCurrencyBalances(chainId, account !== null && account !== void 0 ? account : undefined, [
        currencies[Field$1.CURRENCY_A],
        currencies[Field$1.CURRENCY_B],
    ]);
    const currencyBalances = {
        [Field$1.CURRENCY_A]: balances[0],
        [Field$1.CURRENCY_B]: balances[1],
    };
    // amounts
    const independentAmount = tryParseAmount(typedValue, currencies[independentField], chainId);
    const dependentAmount = React.useMemo(() => {
        if (noLiquidity) {
            if (otherTypedValue && currencies[dependentField]) {
                return tryParseAmount(otherTypedValue, currencies[dependentField], chainId);
            }
            return undefined;
        }
        else if (independentAmount) {
            // we wrap the currencies just to get the price in terms of the other token
            const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId);
            const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];
            if (tokenA && tokenB && wrappedIndependentAmount && pair && chainId) {
                const dependentCurrency = dependentField === Field$1.CURRENCY_B ? currencyB : currencyA;
                const dependentTokenAmount = dependentField === Field$1.CURRENCY_B
                    ? pair.priceOf(tokenA, tokenB).quote(wrappedIndependentAmount, chainId)
                    : pair.priceOf(tokenB, tokenA).quote(wrappedIndependentAmount, chainId);
                return dependentCurrency === sdk.CAVAX[chainId]
                    ? sdk.CurrencyAmount.ether(dependentTokenAmount.raw, chainId)
                    : dependentTokenAmount;
            }
            return undefined;
        }
        else {
            return undefined;
        }
    }, [
        noLiquidity,
        otherTypedValue,
        currencies,
        dependentField,
        independentAmount,
        currencyA,
        chainId,
        currencyB,
        pair,
    ]);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const parsedAmounts = {
        [Field$1.CURRENCY_A]: independentField === Field$1.CURRENCY_A ? independentAmount : dependentAmount,
        [Field$1.CURRENCY_B]: independentField === Field$1.CURRENCY_A ? dependentAmount : independentAmount,
    };
    const price = React.useMemo(() => {
        if (noLiquidity) {
            const { [Field$1.CURRENCY_A]: _currencyAAmount, [Field$1.CURRENCY_B]: _currencyBAmount } = parsedAmounts;
            if (_currencyAAmount && _currencyBAmount) {
                return new sdk.Price(_currencyAAmount.currency, _currencyBAmount.currency, _currencyAAmount.raw, _currencyBAmount.raw);
            }
            return undefined;
        }
        else {
            const wrappedCurrencyA = wrappedCurrency(currencyA, chainId);
            const wrappedCurrencyB = wrappedCurrency(currencyB, chainId);
            return pair && wrappedCurrencyA && wrappedCurrencyB
                ? pair.priceOf(wrappedCurrencyA, wrappedCurrencyB)
                : undefined;
        }
    }, [chainId, currencyA, currencyB, noLiquidity, pair, parsedAmounts]);
    // liquidity minted
    const liquidityMinted = React.useMemo(() => {
        const { [Field$1.CURRENCY_A]: _currencyAAmount, [Field$1.CURRENCY_B]: _currencyBAmount } = parsedAmounts;
        const [tokenAmountA, tokenAmountB] = [
            wrappedCurrencyAmount(_currencyAAmount, chainId),
            wrappedCurrencyAmount(_currencyBAmount, chainId),
        ];
        insufficientInput = false; // eslint-disable-line react-hooks/exhaustive-deps
        if (pair && totalSupply && tokenAmountA && tokenAmountB) {
            try {
                return pair.getLiquidityMinted(totalSupply, [tokenAmountA, tokenAmountB]);
            }
            catch (err) {
                if (err instanceof sdk.InsufficientInputAmountError) {
                    insufficientInput = true;
                    return undefined;
                }
                else {
                    throw err;
                }
            }
        }
        else {
            return undefined;
        }
    }, [parsedAmounts, chainId, pair, totalSupply]);
    const poolTokenPercentage = React.useMemo(() => {
        if (liquidityMinted && totalSupply) {
            return new sdk.Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);
        }
        else {
            return undefined;
        }
    }, [liquidityMinted, totalSupply]);
    let error;
    if (!account) {
        error = t('mintHooks.connectWallet');
    }
    if (insufficientInput) {
        error = t('mintHooks.insufficientInputAmount');
    }
    if (pairState === PairState.INVALID) {
        error = error !== null && error !== void 0 ? error : t('mintHooks.invalidPair');
    }
    if (!parsedAmounts[Field$1.CURRENCY_A] || !parsedAmounts[Field$1.CURRENCY_B]) {
        error = error !== null && error !== void 0 ? error : t('mintHooks.enterAmount');
    }
    const { [Field$1.CURRENCY_A]: currencyAAmount, [Field$1.CURRENCY_B]: currencyBAmount } = parsedAmounts;
    if (currencyAAmount && ((_a = currencyBalances === null || currencyBalances === void 0 ? void 0 : currencyBalances[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.lessThan(currencyAAmount))) {
        error = t('mintHooks.insufficient') + ((_b = currencies[Field$1.CURRENCY_A]) === null || _b === void 0 ? void 0 : _b.symbol) + t('mintHooks.balance');
    }
    if (currencyBAmount && ((_c = currencyBalances === null || currencyBalances === void 0 ? void 0 : currencyBalances[Field$1.CURRENCY_B]) === null || _c === void 0 ? void 0 : _c.lessThan(currencyBAmount))) {
        error = t('mintHooks.insufficient') + ((_d = currencies[Field$1.CURRENCY_B]) === null || _d === void 0 ? void 0 : _d.symbol) + t('mintHooks.balance');
    }
    return {
        dependentField,
        currencies,
        pair,
        pairState,
        currencyBalances,
        parsedAmounts,
        price,
        noLiquidity,
        liquidityMinted,
        poolTokenPercentage,
        error,
    };
}
function useMintActionHandlers(noLiquidity) {
    const dispatch = useDispatch();
    const onFieldAInput = React.useCallback((typedValue) => {
        dispatch(typeInput$1({ field: Field$1.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }));
    }, [dispatch, noLiquidity]);
    const onFieldBInput = React.useCallback((typedValue) => {
        dispatch(typeInput$1({ field: Field$1.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }));
    }, [dispatch, noLiquidity]);
    return {
        onFieldAInput,
        onFieldBInput,
    };
}

const Root$d = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const Header$2 = styled__default["default"](Box) `
  padding: 0px 20px;
`;
const OutputText = styled__default["default"](Text) `
  width: 100%;
  line-height: 18px;
  text-align: left;
  color: ${({ theme }) => theme.color11};
`;
const Footer$1 = styled__default["default"](Box) `
  padding: 0px 10px;
`;
const ErrorWrapper$4 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: minmax(100px, auto) max-content;
  height: 100%;
  padding: 10px;
`;
const ErrorBox$4 = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const StatWrapper$4 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: minmax(auto, 33%) minmax(auto, 33%) minmax(auto, 33%);
  ${({ theme }) => theme.mediaWidth.upToSmall `
    grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  `};
  grid-gap: 12px;
`;

const ConfirmSwapDrawer = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    const { isOpen, onClose, allowedSlippage, attemptingTxn, liquidityMinted, poolErrorMessage, txHash, noLiquidity, price, currencies, parsedAmounts, poolTokenPercentage, onAdd, onComplete = () => {
        /**/
    }, onAddToFarm, type, } = props;
    const theme = React.useContext(styled.ThemeContext);
    const { t } = reactI18next.useTranslation();
    const pendingText = `Supplying ${(_a = parsedAmounts[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.toSignificant(6)} ${(_b = currencies[Field$1.CURRENCY_A]) === null || _b === void 0 ? void 0 : _b.symbol} and ${(_c = parsedAmounts[Field$1.CURRENCY_B]) === null || _c === void 0 ? void 0 : _c.toSignificant(6)} ${(_d = currencies[Field$1.CURRENCY_B]) === null || _d === void 0 ? void 0 : _d.symbol}`;
    const DetailConfirmContent = (jsxRuntime.jsxs(Root$d, { children: [jsxRuntime.jsxs(Header$2, { children: [noLiquidity ? (jsxRuntime.jsxs(Box, Object.assign({ display: "flex" }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: ['26px', '22px'], fontWeight: 500, lineHeight: "42px", marginRight: 10, color: "text1" }, { children: ((_e = currencies[Field$1.CURRENCY_A]) === null || _e === void 0 ? void 0 : _e.symbol) + '/' + ((_f = currencies[Field$1.CURRENCY_B]) === null || _f === void 0 ? void 0 : _f.symbol) })), jsxRuntime.jsx(DoubleCurrencyLogo, { currency0: currencies[Field$1.CURRENCY_A], currency1: currencies[Field$1.CURRENCY_B], size: 24 })] }))) : (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex" }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: ['26px', '22px'], fontWeight: 500, lineHeight: "42px", marginRight: 10, color: "text1" }, { children: liquidityMinted === null || liquidityMinted === void 0 ? void 0 : liquidityMinted.toSignificant(6) })), jsxRuntime.jsx(DoubleCurrencyLogo, { currency0: currencies[Field$1.CURRENCY_A], currency1: currencies[Field$1.CURRENCY_B], size: 24 })] })), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Text, Object.assign({ fontSize: ['20px', '16px'], color: "text1", lineHeight: "40px" }, { children: ((_g = currencies[Field$1.CURRENCY_A]) === null || _g === void 0 ? void 0 : _g.symbol) +
                                        '/' +
                                        ((_h = currencies[Field$1.CURRENCY_B]) === null || _h === void 0 ? void 0 : _h.symbol) +
                                        t('addLiquidity.poolTokens') })) }), jsxRuntime.jsx(OutputText, { children: t('addLiquidity.outputEstimated', { allowedSlippage: allowedSlippage / 100 }) })] })), jsxRuntime.jsxs(Box, Object.assign({ mt: 20 }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center" }, { children: [jsxRuntime.jsxs(Text, Object.assign({ fontSize: "12px", color: "text1" }, { children: [(_j = currencies[Field$1.CURRENCY_A]) === null || _j === void 0 ? void 0 : _j.symbol, " ", t('addLiquidity.deposited')] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex" }, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: currencies[Field$1.CURRENCY_A], size: 24 }), jsxRuntime.jsx(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: (_k = parsedAmounts[Field$1.CURRENCY_A]) === null || _k === void 0 ? void 0 : _k.toSignificant(6) }))] }))] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", mt: "5px" }, { children: [jsxRuntime.jsxs(Text, Object.assign({ fontSize: "12px", color: "text1" }, { children: [(_l = currencies[Field$1.CURRENCY_B]) === null || _l === void 0 ? void 0 : _l.symbol, " ", t('addLiquidity.deposited')] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex" }, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: currencies[Field$1.CURRENCY_B], size: 24 }), jsxRuntime.jsx(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: (_m = parsedAmounts[Field$1.CURRENCY_B]) === null || _m === void 0 ? void 0 : _m.toSignificant(6) }))] }))] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", mt: "5px" }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: "12px", color: "text1" }, { children: t('addLiquidity.rates') })), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: `1 ${(_o = currencies[Field$1.CURRENCY_A]) === null || _o === void 0 ? void 0 : _o.symbol} = ${price === null || price === void 0 ? void 0 : price.toSignificant(4)} ${(_p = currencies[Field$1.CURRENCY_B]) === null || _p === void 0 ? void 0 : _p.symbol}` })), jsxRuntime.jsx(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: `1 ${(_q = currencies[Field$1.CURRENCY_B]) === null || _q === void 0 ? void 0 : _q.symbol} = ${price === null || price === void 0 ? void 0 : price.invert().toSignificant(4)} ${(_r = currencies[Field$1.CURRENCY_A]) === null || _r === void 0 ? void 0 : _r.symbol}` }))] })] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", mt: "5px" }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: "12px", color: "text1" }, { children: t('addLiquidity.shareOfPool') })), jsxRuntime.jsxs(Text, Object.assign({ fontSize: "14px", color: "text1", ml: "10px" }, { children: [noLiquidity ? '100' : poolTokenPercentage === null || poolTokenPercentage === void 0 ? void 0 : poolTokenPercentage.toSignificant(4), "%"] }))] }))] }))] }), jsxRuntime.jsx(Footer$1, { children: jsxRuntime.jsx(Box, Object.assign({ my: '10px' }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onAdd }, { children: noLiquidity ? t('addLiquidity.createPoolSupply') : t('addLiquidity.confirmSupply') })) })) })] }));
    const CardConfirmContent = (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", px: 20, pb: 20, height: "100%" }, { children: [jsxRuntime.jsxs(Box, Object.assign({ flex: 1 }, { children: [jsxRuntime.jsxs(StatWrapper$4, { children: [jsxRuntime.jsxs(Hidden, Object.assign({ upToSmall: true, display: "inline-block" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: 'text1', fontSize: [16, 14] }, { children: t('addLiquidity.deposited') })), jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsxRuntime.jsxs(Text, Object.assign({ color: 'text1', fontSize: [20, 16] }, { children: [(_s = parsedAmounts[Field$1.CURRENCY_A]) === null || _s === void 0 ? void 0 : _s.toSignificant(6), " ", (_t = currencies[Field$1.CURRENCY_A]) === null || _t === void 0 ? void 0 : _t.symbol] })) })), jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsxRuntime.jsxs(Text, Object.assign({ color: 'text1', fontSize: [20, 16] }, { children: [(_u = parsedAmounts[Field$1.CURRENCY_B]) === null || _u === void 0 ? void 0 : _u.toSignificant(6), " ", (_v = currencies[Field$1.CURRENCY_B]) === null || _v === void 0 ? void 0 : _v.symbol] })) }))] })), jsxRuntime.jsx(Stat, { title: `PGL`, stat: noLiquidity ? '-' : `     ${liquidityMinted === null || liquidityMinted === void 0 ? void 0 : liquidityMinted.toSignificant(6)}`, titlePosition: "top", titleFontSize: 16, statFontSize: [20, 16] }), jsxRuntime.jsx(Stat, { title: t('addLiquidity.shareOfPool'), stat: `${noLiquidity ? '100' : poolTokenPercentage === null || poolTokenPercentage === void 0 ? void 0 : poolTokenPercentage.toSignificant(4)}%`, titlePosition: "top", titleFontSize: 14, statFontSize: 16 })] }), jsxRuntime.jsx(Box, Object.assign({ mt: 10 }, { children: jsxRuntime.jsx(OutputText, Object.assign({ fontSize: 12, fontWeight: 400 }, { children: t('addLiquidity.outputEstimated', { allowedSlippage: allowedSlippage / 100 }) })) }))] })), jsxRuntime.jsx(Box, Object.assign({ mt: '10px' }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onAdd, height: "46px" }, { children: noLiquidity ? t('addLiquidity.createPoolSupply') : t('addLiquidity.giveOrder') })) }))] })));
    const PendingContent = jsxRuntime.jsx(Loader, { size: 100, label: pendingText });
    const ErrorContent = (jsxRuntime.jsxs(ErrorWrapper$4, { children: [jsxRuntime.jsxs(ErrorBox$4, { children: [jsxRuntime.jsx(reactFeather.AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, fontSize: [16, 14], color: 'red1', style: { textAlign: 'center', width: '85%' } }, { children: poolErrorMessage }))] }), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] }));
    const SubmittedContent = (jsxRuntime.jsx(Box, Object.assign({ padding: "10px", height: "100%" }, { children: jsxRuntime.jsx(TransactionCompleted, { submitText: `Liquidity Added`, isShowButtton: Boolean((type === SpaceType.card && onAddToFarm) || type === SpaceType.detail), onButtonClick: () => {
                onClose();
                if (onAddToFarm) {
                    onAddToFarm();
                }
                else {
                    onComplete();
                }
            }, buttonText: onAddToFarm ? t('transactionConfirmation.addToFarm') : t('transactionConfirmation.close') }) })));
    const renderBody = () => {
        if (txHash) {
            return SubmittedContent;
        }
        if (attemptingTxn) {
            return PendingContent;
        }
        if (poolErrorMessage) {
            return ErrorContent;
        }
        if (type === SpaceType.detail) {
            return DetailConfirmContent;
        }
        return CardConfirmContent;
    };
    return (jsxRuntime.jsx(Drawer, Object.assign({ title: noLiquidity ? t('addLiquidity.creatingPool') : t('addLiquidity.willReceive'), isOpen: isOpen, onClose: () => {
            type === SpaceType.card ? onComplete() : onClose();
        }, backgroundColor: type === SpaceType.card ? 'color5' : 'bg2' }, { children: renderBody() })));
};

const Root$c = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  overflow: hidden;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
`;
const GridContainer = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-gap: 8px;
`;

const PoolPriceBar = ({ currencies, noLiquidity, poolTokenPercentage, price, parsedAmounts }) => {
    var _a, _b;
    const { t } = reactI18next.useTranslation();
    const currency0InputValue = (_a = parsedAmounts[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.toSignificant(6);
    const chainId = useChainId();
    const currency0 = currencies[Field$1.CURRENCY_A];
    const useUSDCPrice = useUSDCPriceHook[chainId];
    const currency0PriceTmp = useUSDCPrice(currency0);
    const currency0Price = ((_b = sdk.CHAINS[chainId]) === null || _b === void 0 ? void 0 : _b.mainnet) ? currency0PriceTmp : undefined;
    const multipyAmount = currency0Price ? Number(currency0Price.toFixed()) * 2 * Number(currency0InputValue) : 0;
    const sharePoolStat = multipyAmount ? `$${multipyAmount === null || multipyAmount === void 0 ? void 0 : multipyAmount.toFixed(4)}` : '-';
    function getShareOfPool() {
        var _a;
        if (noLiquidity && price) {
            return '100%';
        }
        else if (poolTokenPercentage === null || poolTokenPercentage === void 0 ? void 0 : poolTokenPercentage.lessThan(ONE_BIPS)) {
            return '<0.01%';
        }
        else {
            return `${(_a = poolTokenPercentage === null || poolTokenPercentage === void 0 ? void 0 : poolTokenPercentage.toFixed(2)) !== null && _a !== void 0 ? _a : 0}%`;
        }
    }
    return (jsxRuntime.jsx(Root$c, { children: jsxRuntime.jsxs(GridContainer, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { title: `${t('migratePage.usd')}`, stat: sharePoolStat, titlePosition: "top", titleFontSize: 12, statFontSize: 14, titleColor: "text2" }) }), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { title: `${t('addLiquidity.shareOfPool')}`, stat: getShareOfPool(), titlePosition: "top", titleFontSize: 12, statFontSize: 14, titleColor: "text2" }) })] }) }));
};

const AddWrapper = styled__default["default"](Box) `
  width: 100%;
  padding-right: 20px;
  padding-left: 20px;
  padding-bottom: 20px;
  height: 100%;
  display: flex;
  flex-direction: column;
`;
const StyledBalanceMax = styled__default["default"].button `
  height: 28px;
  background-color: ${({ theme }) => theme.bg2};
  border: 1px solid ${({ theme }) => theme.bg2};
  border-radius: 0.5rem;
  font-size: 0.875rem;

  font-weight: 500;
  cursor: pointer;
  margin-right: 0.5rem;
  color: ${({ theme }) => theme.text2};

  ${({ theme }) => theme.mediaWidth.upToExtraSmall `
    margin-right: 0.5rem;
  `};
`;
const ArrowWrapper$2 = styled__default["default"].div `
  background-color: ${({ theme }) => theme.bg6};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;
const LightCard$1 = styled__default["default"](Box) `
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
`;
const InputWrapper$2 = styled__default["default"](Box) `
  display: grid;
  grid-auto-flow: ${({ type }) => (type === SpaceType.detail ? 'row' : 'column')};
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 5px;
`;
const Buttons$a = styled__default["default"](Box) `
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 10px;
  margin-top: 10px;
`;
const ButtonWrapper$1 = styled__default["default"](Box) `
  justify-content: space-between;
  width: 100%;
  display: flex;
  padding: 0;
  align-items: center;
`;

const AddLiquidity = ({ currencyA, currencyB, onComplete, onAddToFarm, type }) => {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const theme = React.useContext(styled.ThemeContext);
    const { t } = reactI18next.useTranslation();
    const expertMode = useIsExpertMode();
    // mint state
    const { independentField, typedValue, otherTypedValue } = useMintState();
    const { dependentField, currencies, 
    // pair,
    pairState, currencyBalances, parsedAmounts, price, noLiquidity, liquidityMinted, poolTokenPercentage, error, } = useDerivedMintInfo(currencyA !== null && currencyA !== void 0 ? currencyA : undefined, currencyB !== null && currencyB !== void 0 ? currencyB : undefined);
    const { onFieldAInput, onFieldBInput } = useMintActionHandlers(noLiquidity);
    const addLiquidity = useAddLiquidityHook[chainId]();
    const useApproveCallback = useApproveCallbackHook[chainId];
    const isValid = !error;
    // modal and loading
    const [showConfirm, setShowConfirm] = React.useState(false);
    const [attemptingTxn, setAttemptingTxn] = React.useState(false); // clicked confirm
    // txn values
    const deadline = useTransactionDeadline(); // custom from users settings
    const [allowedSlippage] = useUserSlippageTolerance(); // custom from users
    const [txHash, setTxHash] = React.useState('');
    // get formatted amounts
    const formattedAmounts = {
        [independentField]: typedValue,
        [dependentField]: noLiquidity ? otherTypedValue : (_b = (_a = parsedAmounts[dependentField]) === null || _a === void 0 ? void 0 : _a.toSignificant(6)) !== null && _b !== void 0 ? _b : '',
    };
    // get the max amounts user can add
    const maxAmounts = [Field$1.CURRENCY_A, Field$1.CURRENCY_B].reduce((accumulator, field) => {
        return Object.assign(Object.assign({}, accumulator), { [field]: maxAmountSpend(chainId, currencyBalances[field]) });
    }, {});
    const atMaxAmounts = [Field$1.CURRENCY_A, Field$1.CURRENCY_B].reduce((accumulator, field) => {
        var _a, _b;
        return Object.assign(Object.assign({}, accumulator), { [field]: (_a = maxAmounts[field]) === null || _a === void 0 ? void 0 : _a.equalTo((_b = parsedAmounts[field]) !== null && _b !== void 0 ? _b : '0') });
    }, {});
    // check whether the user has approved the router on the tokens
    const [approvalA, approveACallback] = useApproveCallback(chainId, parsedAmounts[Field$1.CURRENCY_A], ROUTER_ADDRESS[chainId]);
    const [approvalB, approveBCallback] = useApproveCallback(chainId, parsedAmounts[Field$1.CURRENCY_B], ROUTER_ADDRESS[chainId]);
    function onAdd() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!chainId || !library || !account)
                return;
            try {
                setAttemptingTxn(true);
                const addData = {
                    parsedAmounts,
                    deadline,
                    noLiquidity,
                    allowedSlippage,
                    currencies,
                };
                const response = yield addLiquidity(addData);
                setTxHash(response === null || response === void 0 ? void 0 : response.hash);
            }
            catch (err) {
                const _err = err;
                console.error(_err);
            }
            finally {
                setAttemptingTxn(false);
            }
        });
    }
    const handleDismissConfirmation = React.useCallback(() => {
        setShowConfirm(false);
        // if there was a tx hash, we want to clear the input
        if (txHash) {
            onFieldAInput('');
        }
        setTxHash('');
        setAttemptingTxn(false);
    }, [onFieldAInput, txHash]);
    const handleTypeInput = React.useCallback((value) => {
        onFieldAInput(value);
    }, [onFieldAInput]);
    const handleTypeOutput = React.useCallback((value) => {
        onFieldBInput(value);
    }, [onFieldBInput]);
    // toggle wallet when disconnected
    const toggleWalletModal = useWalletModalToggle();
    const selectedCurrencyBalanceA = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, currencyA !== null && currencyA !== void 0 ? currencyA : undefined);
    const selectedCurrencyBalanceB = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, currencyB !== null && currencyB !== void 0 ? currencyB : undefined);
    const renderButton = () => {
        var _a, _b, _c, _d;
        if (!account) {
            return (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: toggleWalletModal, height: "46px" }, { children: t('swapPage.connectWallet') })));
        }
        else {
            return (jsxRuntime.jsxs(Buttons$a, { children: [(approvalA === ApprovalState.NOT_APPROVED ||
                        approvalA === ApprovalState.PENDING ||
                        approvalB === ApprovalState.NOT_APPROVED ||
                        approvalB === ApprovalState.PENDING) &&
                        isValid && (jsxRuntime.jsxs(ButtonWrapper$1, { children: [approvalA !== ApprovalState.APPROVED && (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: approveACallback, isDisabled: approvalA === ApprovalState.PENDING, width: approvalB !== ApprovalState.APPROVED ? '48%' : '100%', loading: approvalA === ApprovalState.PENDING, loadingText: `${t('swapPage.approving')} ${(_a = currencies[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.symbol}`, height: "46px" }, { children: t('addLiquidity.approve') + ((_b = currencies[Field$1.CURRENCY_A]) === null || _b === void 0 ? void 0 : _b.symbol) }))), approvalB !== ApprovalState.APPROVED && (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: approveBCallback, isDisabled: approvalB === ApprovalState.PENDING, width: approvalA !== ApprovalState.APPROVED ? '48%' : '100%', loading: approvalB === ApprovalState.PENDING, loadingText: `${t('swapPage.approving')} ${(_c = currencies[Field$1.CURRENCY_B]) === null || _c === void 0 ? void 0 : _c.symbol}`, height: "46px" }, { children: t('addLiquidity.approve') + ((_d = currencies[Field$1.CURRENCY_B]) === null || _d === void 0 ? void 0 : _d.symbol) })))] })), jsxRuntime.jsx(Button, Object.assign({ height: "46px", variant: "primary", onClick: () => {
                            expertMode ? onAdd() : setShowConfirm(true);
                        }, isDisabled: !isValid || approvalA !== ApprovalState.APPROVED || approvalB !== ApprovalState.APPROVED }, { children: error !== null && error !== void 0 ? error : t('addLiquidity.supply') }))] }));
        }
    };
    return (jsxRuntime.jsxs(AddWrapper, { children: [jsxRuntime.jsxs(Box, Object.assign({ flex: 1 }, { children: [jsxRuntime.jsxs(InputWrapper$2, Object.assign({ type: type }, { children: [jsxRuntime.jsx(TextInput, { value: formattedAmounts[Field$1.CURRENCY_A], addonAfter: !atMaxAmounts[Field$1.CURRENCY_A] ? (jsxRuntime.jsx(Box, Object.assign({ display: 'flex', alignItems: 'center', height: '100%', justifyContent: 'center' }, { children: jsxRuntime.jsx(StyledBalanceMax, Object.assign({ onClick: () => { var _a, _b; return onFieldAInput((_b = (_a = maxAmounts[Field$1.CURRENCY_A]) === null || _a === void 0 ? void 0 : _a.toExact()) !== null && _b !== void 0 ? _b : ''); } }, { children: t('currencyInputPanel.max') })) }))) : (''), onChange: (value) => {
                                    handleTypeInput(value);
                                }, label: `${currencyA === null || currencyA === void 0 ? void 0 : currencyA.symbol}`, fontSize: 16, isNumeric: true, placeholder: "0.00", addonLabel: account && (jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 12 }, { children: !!currencyA && selectedCurrencyBalanceA ? selectedCurrencyBalanceA === null || selectedCurrencyBalanceA === void 0 ? void 0 : selectedCurrencyBalanceA.toSignificant(4) : ' -' }))) }), jsxRuntime.jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: type === 'card' ? 'none' : 'flex', justifyContent: 'center', mt: 10 }, { children: jsxRuntime.jsx(ArrowWrapper$2, { children: jsxRuntime.jsx(reactFeather.Plus, { size: "16", color: theme.text1 }) }) })), jsxRuntime.jsx(TextInput, { value: formattedAmounts[Field$1.CURRENCY_B], addonAfter: !atMaxAmounts[Field$1.CURRENCY_B] ? (jsxRuntime.jsx(Box, Object.assign({ display: 'flex', alignItems: 'center', height: '100%', justifyContent: 'center' }, { children: jsxRuntime.jsx(StyledBalanceMax, Object.assign({ onClick: () => { var _a, _b; return onFieldBInput((_b = (_a = maxAmounts[Field$1.CURRENCY_B]) === null || _a === void 0 ? void 0 : _a.toExact()) !== null && _b !== void 0 ? _b : ''); } }, { children: t('currencyInputPanel.max') })) }))) : (''), onChange: (value) => {
                                    handleTypeOutput(value);
                                }, label: `${currencyB === null || currencyB === void 0 ? void 0 : currencyB.symbol}`, fontSize: 16, isNumeric: true, placeholder: "0.00", addonLabel: account && (jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 12 }, { children: !!currencyB && selectedCurrencyBalanceB ? selectedCurrencyBalanceB === null || selectedCurrencyBalanceB === void 0 ? void 0 : selectedCurrencyBalanceB.toSignificant(4) : ' -' }))) })] })), currencies[Field$1.CURRENCY_A] && currencies[Field$1.CURRENCY_B] && pairState !== PairState.INVALID && (jsxRuntime.jsx(LightCard$1, Object.assign({ padding: "0px" }, { children: jsxRuntime.jsx(PoolPriceBar, { currencies: currencies, poolTokenPercentage: poolTokenPercentage, noLiquidity: noLiquidity, price: price, parsedAmounts: parsedAmounts }) })))] })), jsxRuntime.jsx(Box, Object.assign({ width: "100%" }, { children: renderButton() })), showConfirm && (jsxRuntime.jsx(ConfirmSwapDrawer, { isOpen: showConfirm, allowedSlippage: allowedSlippage, poolErrorMessage: error, price: price, currencies: currencies, parsedAmounts: parsedAmounts, noLiquidity: noLiquidity, liquidityMinted: liquidityMinted, onAdd: onAdd, poolTokenPercentage: poolTokenPercentage, attemptingTxn: attemptingTxn, txHash: txHash, onClose: handleDismissConfirmation, onComplete: onComplete, onAddToFarm: onAddToFarm, type: type }))] }));
};

const AddLiquidityDrawer = ({ isOpen, onClose, onAddToFarm, clickedLpTokens, backgroundColor }) => {
    const { t } = reactI18next.useTranslation();
    const chainId = useChainId();
    const token0 = clickedLpTokens === null || clickedLpTokens === void 0 ? void 0 : clickedLpTokens[0];
    const token1 = clickedLpTokens === null || clickedLpTokens === void 0 ? void 0 : clickedLpTokens[1];
    const currencyA = token0 && unwrappedToken(token0, chainId);
    const currencyB = token1 && unwrappedToken(token1, chainId);
    return (jsxRuntime.jsx(Drawer, Object.assign({ title: t('pool.addLiquidity'), isOpen: isOpen, onClose: onClose, backgroundColor: backgroundColor }, { children: isOpen && (jsxRuntime.jsx(AddLiquidity, { currencyA: currencyA, currencyB: currencyB, onComplete: onClose, onAddToFarm: onAddToFarm, type: SpaceType.card })) })));
};

const ClaimWrapper$1 = styled__default["default"](Box) `
  width: 100%;
  height: 100%;
`;
const Root$b = styled__default["default"](Box) `
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 0px 10px;
`;
const RewardWrapper$1 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: ${({ isSuperFarm }) => isSuperFarm ? 'minmax(auto, 50%) minmax(auto, 50%)' : 'minmax(auto, 100%)'};
  grid-gap: 8px;
  justify-content: center;
`;
const StatWrapper$3 = styled__default["default"](Box) `
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
`;

const ClaimReward = ({ stakingInfo, version, onClose }) => {
    var _a;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    // monitor call to help UI loading state
    const addTransaction = useTransactionAdder();
    const [hash, setHash] = React.useState();
    const [attempting, setAttempting] = React.useState(false);
    const poolMap = useMinichefPools();
    const stakingContract = useStakingContract(stakingInfo.stakingRewardAddress);
    const { rewardTokensAmount } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_a = (rewardTokensAmount || [])) === null || _a === void 0 ? void 0 : _a.length) > 0;
    function wrappedOnDismiss() {
        setHash(undefined);
        setAttempting(false);
        onClose();
    }
    const png = PNG[chainId];
    function onClaimReward() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (stakingContract && poolMap && (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
                setAttempting(true);
                const method = version < 2 ? 'getReward' : 'harvest';
                const args = version < 2 ? [] : [poolMap[stakingInfo.stakedAmount.token.address], account];
                try {
                    const response = yield stakingContract[method](...args);
                    yield waitForTransaction(response, 1);
                    addTransaction(response, {
                        summary: t('earn.claimAccumulated', { symbol: png.symbol }),
                    });
                    setHash(response.hash);
                }
                catch (error) {
                    setAttempting(false);
                    const err = error;
                    // we only care if the error is something _other_ than the user rejected the tx
                    if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                        console.error(err);
                    }
                }
            }
        });
    }
    let _error;
    if (!account) {
        _error = t('earn.connectWallet');
    }
    if (!(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
        _error = _error !== null && _error !== void 0 ? _error : t('earn.enterAmount');
    }
    const { earnedAmount } = useGetEarnedAmount(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const newEarnedAmount = version < 2 ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount : earnedAmount;
    return (jsxRuntime.jsxs(ClaimWrapper$1, { children: [!attempting && !hash && (jsxRuntime.jsxs(Root$b, { children: [jsxRuntime.jsxs(Box, Object.assign({ flex: "1", display: "flex", flexDirection: "column", justifyContent: "center" }, { children: [jsxRuntime.jsxs(RewardWrapper$1, Object.assign({ isSuperFarm: isSuperFarm }, { children: [jsxRuntime.jsx(StatWrapper$3, { children: jsxRuntime.jsx(Stat, { title: t('earn.unclaimedReward', { symbol: 'PNG' }), stat: newEarnedAmount === null || newEarnedAmount === void 0 ? void 0 : newEarnedAmount.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [24, 18], titleColor: "text1", statAlign: "center" }) }), isSuperFarm &&
                                        (rewardTokensAmount === null || rewardTokensAmount === void 0 ? void 0 : rewardTokensAmount.map((rewardAmount, i) => {
                                            var _a;
                                            return (jsxRuntime.jsx(StatWrapper$3, { children: jsxRuntime.jsx(Stat, { title: t('earn.unclaimedReward', { symbol: (_a = rewardAmount === null || rewardAmount === void 0 ? void 0 : rewardAmount.token) === null || _a === void 0 ? void 0 : _a.symbol }), stat: rewardAmount === null || rewardAmount === void 0 ? void 0 : rewardAmount.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [24, 18], titleColor: "text1", statAlign: "center" }) }, i));
                                        }))] })), jsxRuntime.jsx(Text, Object.assign({ fontSize: "13px", color: "text2", textAlign: "center" }, { children: t('earn.liquidityRemainsPool') }))] })), jsxRuntime.jsx(Box, Object.assign({ my: '10px' }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClaimReward }, { children: _error !== null && _error !== void 0 ? _error : t('earn.claimReward', { symbol: 'PNG' }) })) }))] })), attempting && !hash && jsxRuntime.jsx(Loader, { size: 100, label: " Claiming..." }), hash && jsxRuntime.jsx(TransactionCompleted, { onClose: wrappedOnDismiss, submitText: "Your rewards claimed" })] }));
};

const ClaimDrawer = ({ isOpen, onClose, stakingInfo, version, backgroundColor }) => {
    const { t } = reactI18next.useTranslation();
    return (jsxRuntime.jsx(Drawer, Object.assign({ title: t('earn.claim'), isOpen: isOpen, onClose: onClose, backgroundColor: backgroundColor }, { children: isOpen && jsxRuntime.jsx(ClaimReward, { stakingInfo: stakingInfo, onClose: onClose, version: version }) })));
};

var CircleTick = "data:image/svg+xml,%3Csvg%20width%3D%2275%22%20height%3D%2275%22%20viewBox%3D%220%200%20100%20101%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M41.9568%200.970354L41.9588%200.970004C52.2154%20-0.813656%2062.7724%200.737028%2072.0869%205.39547L72.0869%205.39554L72.0925%205.39821C72.7816%205.72146%2073.3747%206.21899%2073.8136%206.84186C74.125%207.33236%2074.2295%207.83111%2074.1662%208.31425C74.1022%208.80202%2073.8646%209.29173%2073.4626%209.7513C72.6978%2010.6255%2071.5412%2010.803%2070.2097%2010.2817L70.2095%2010.2817C69.3975%209.96428%2068.5851%209.62326%2067.769%209.28072C65.6499%208.39127%2063.5064%207.49151%2061.2818%206.96855C44.0184%202.90944%2029.1105%207.36731%2017.1063%2020.4078L17.1062%2020.4079C8.38435%2029.8929%204.82205%2041.4128%205.9675%2054.2342C7.64211%2073.1615%2021.4792%2088.9118%2040.097%2093.3534C64.8784%2099.2631%2089.8666%2082.5598%2093.9783%2057.3453C94.9766%2051.3574%2094.7476%2045.2284%2093.3051%2039.3321L93.3045%2039.3294C93.1365%2038.6746%2093.0599%2038.07%2093.153%2037.5233C93.2446%2036.9858%2093.5027%2036.4895%2094.0352%2036.0476C95.5993%2034.763%2097.8887%2035.5655%2098.246%2037.7395L98.2461%2037.7397C98.3493%2038.3651%2098.456%2038.9907%2098.5627%2039.6164C99.1502%2043.0615%2099.7381%2046.5094%2099.7497%2049.9435C99.8316%2072.6235%2084.6475%2092.2578%2062.7597%2098.1047C35.7798%20105.313%207.77252%2088.253%201.78549%2060.8669L1.78544%2060.8667C1.25591%2058.454%200.968037%2055.9972%200.678568%2053.5268C0.54421%2052.3802%200.409509%2051.2306%200.250142%2050.0812C0.453584%2025.876%2018.1556%204.90887%2041.9568%200.970354Z%22%20fill%3D%22%2318C145%22%20stroke%3D%22%23111111%22%20stroke-width%3D%220.5%22%2F%3E%3Cpath%20d%3D%22M48.6453%2055.5479L48.8719%2055.7756L49.037%2055.5C49.322%2055.024%2049.6427%2054.5704%2049.9963%2054.1432C64.3053%2039.7934%2078.6189%2025.4506%2092.9372%2011.1146L92.9373%2011.1147L92.9431%2011.1085C93.3154%2010.7094%2093.7133%2010.3351%2094.1344%209.98814C94.6193%209.61736%2095.2199%209.43142%2095.829%209.46352C96.4394%209.49569%2097.0186%209.7448%2097.4625%2010.1663L97.4647%2010.1684C97.9139%2010.5846%2098.1979%2011.1497%2098.2639%2011.7595C98.3299%2012.368%2098.1744%2012.9798%2097.8262%2013.4824C97.5281%2013.8837%2097.1943%2014.257%2096.829%2014.5978L96.8289%2014.5977L96.8225%2014.6041C81.6114%2029.8625%2066.3877%2045.1197%2051.1514%2060.3758L51.1512%2060.376C50.1611%2061.37%2049.3807%2061.8116%2048.6452%2061.8157C47.9106%2061.8199%2047.1363%2061.3881%2046.1572%2060.4068L46.157%2060.4066C45.5237%2059.7734%2044.8902%2059.1404%2044.2569%2058.5076C40.4579%2054.7116%2036.6612%2050.9179%2032.9023%2047.0711C32.6049%2046.7648%2032.3119%2046.3563%2032.0995%2045.9284C31.885%2045.4964%2031.7644%2045.0688%2031.782%2044.7195C31.7994%2044.3732%2031.9665%2043.97%2032.2283%2043.5735C32.4877%2043.1808%2032.8247%2042.8178%2033.1487%2042.5548L33.1491%2042.5545C33.8727%2041.9649%2034.856%2042.0816%2035.7268%2042.7C36.1245%2043.0003%2036.4952%2043.3351%2036.8344%2043.7005L36.8343%2043.7006L36.8409%2043.7072C40.517%2047.3815%2044.1836%2051.0653%2048.1543%2055.0546L48.6453%2055.5479Z%22%20fill%3D%22%2318C145%22%20stroke%3D%22%23111111%22%20stroke-width%3D%220.5%22%2F%3E%3C%2Fsvg%3E";

const StakeWrapper$1 = styled__default["default"](Box) `
  width: 100%;
  padding: 0px 10px 10px 10px;
  height: 100%;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;
styled__default["default"](TextInput) `
  background-color: ${({ theme }) => theme.color10};
  padding: 15px;
  align-items: center;
  border-radius: 4px;
`;
const ContentBox$1 = styled__default["default"](Box) `
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.color10};
  margin-top: 10px;
  padding: 10px;
`;
const DataBox$1 = styled__default["default"](Box) `
  align-items: center;
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const ExtraRewardDataBox$1 = styled__default["default"](Box) `
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const PoolSelectWrapper$1 = styled__default["default"](Box) `
  width: 100%;
  border-radius: 8px;
  padding: 10px;
  border: 1px solid transparent;
  display: flex;
  position: relative;
  box-sizing: border-box;
  justify-content: space-between;
  align-items: center;
  background-color: ${({ theme }) => theme.color10};
  color: ${({ theme }) => theme.text4};
  cursor: pointer;
`;
const InputWrapper$1 = styled__default["default"](Box) `
  display: grid;
  grid-auto-flow: ${({ type }) => (type === SpaceType.detail ? 'row' : 'column')};
  grid-auto-columns: minmax(0, 1fr);
  margin-top: ${({ type }) => (type === SpaceType.detail ? '10px' : '0px')};
  grid-gap: 5px;
  align-items: ${({ type }) => (type === SpaceType.detail ? 'normal' : 'center')};
`;
const Buttons$9 = styled__default["default"](Box) `
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 10px;
  margin-top: 10px;
`;
const CardContentBox$1 = styled__default["default"](Box) `
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.color10};
  margin-top: 10px;
  padding: 10px;
  display: grid;
  grid-template-columns: ${({ isSuperFarm }) => isSuperFarm ? 'minmax(auto, 50%) minmax(auto, 50%)' : 'minmax(auto, 33%) minmax(auto, 33%) minmax(auto, 33%)'};
  grid-gap: 10px;
`;
const ErrorWrapper$3 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ErrorBox$3 = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const SubmittedWrapper$1 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ContentWrapper = styled__default["default"](Box) `
  display: grid;
  grid-gap: 20px;
  padding: 20px;
  height: 100%;
`;
const Link$1 = styled__default["default"](Text) `
  text-decoration: none;
  color: ${({ theme }) => theme.blue1};
`;

const ConfirmDrawer$1 = (props) => {
    const { isOpen, attemptingTxn, errorMessage, txHash, tokens, amount, dollarValue, apr, type, onClose, onStake } = props;
    const { chainId } = usePangolinWeb3();
    const theme = React.useContext(styled.ThemeContext);
    const { t } = reactI18next.useTranslation();
    const PendingContent = jsxRuntime.jsx(Loader, { size: 100 });
    const token0 = tokens[0];
    const token1 = tokens[1];
    const ErroContent = (jsxRuntime.jsxs(ErrorWrapper$3, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxRuntime.jsxs(ErrorBox$3, { children: [jsxRuntime.jsx(reactFeather.AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'red1', textAlign: "center", style: { width: '85%' } }, { children: errorMessage }))] }), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] })));
    const SubmittedContent = (jsxRuntime.jsxs(SubmittedWrapper$1, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", paddingY: '20px' }, { children: [jsxRuntime.jsx(Box, Object.assign({ flex: "1", display: "flex", alignItems: "center" }, { children: jsxRuntime.jsx("img", { src: CircleTick, alt: "circle-tick" }) })), jsxRuntime.jsx(Text, Object.assign({ fontSize: 16, color: "text1", textAlign: "center" }, { children: "You have successfully staked your liq. Your stakes apr will start from 0 and the longer you stay in the pool your share of the rewards will keep increasing." })), chainId && txHash && (jsxRuntime.jsx(Link$1, Object.assign({ as: "a", fontWeight: 500, fontSize: 14, color: 'primary', href: getEtherscanLink(chainId, txHash, 'transaction'), target: "_blank" }, { children: t('transactionConfirmation.viewExplorer') })))] })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.close') }))] })));
    const confirmContent = (jsxRuntime.jsxs(ContentWrapper, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", width: "100%" }, { children: [jsxRuntime.jsxs(Text, Object.assign({ fontSize: '28px', fontWeight: 500, color: "text1" }, { children: [amount === null || amount === void 0 ? void 0 : amount.toFixed(8), " ARL"] })), jsxRuntime.jsx(DoubleCurrencyLogo, { size: 24, currency0: token0, currency1: token1 })] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", width: "100%" }, { children: [jsxRuntime.jsx(Stat, { title: "USD Deposited", stat: dollarValue, titlePosition: "top", titleFontSize: 16, statFontSize: [28, 20] }), jsxRuntime.jsx(Stat, { title: "Average APR", stat: apr, titlePosition: "top", titleFontSize: 16, statFontSize: [28, 20] })] })), jsxRuntime.jsx(Box, Object.assign({ padding: "20px", bgColor: "color3", borderRadius: "8px" }, { children: jsxRuntime.jsxs(Text, Object.assign({ color: "text1", textAlign: "center" }, { children: ["You are now adding liquidity into ", token0 === null || token0 === void 0 ? void 0 : token0.symbol, "-", token1 === null || token1 === void 0 ? void 0 : token1.symbol, " Farm. Longer you stake in the pool better share of the rewards you\u2019ll get."] })) })), jsxRuntime.jsx(Box, Object.assign({ alignSelf: "flex-end" }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onStake }, { children: "Stake" })) }))] }));
    const renderBody = () => {
        if (errorMessage) {
            return ErroContent;
        }
        if (txHash) {
            return SubmittedContent;
        }
        if (attemptingTxn) {
            return PendingContent;
        }
        return confirmContent;
    };
    return (jsxRuntime.jsx(Drawer, Object.assign({ isOpen: isOpen, onClose: onClose, title: !errorMessage && !txHash && !attemptingTxn ? 'Summary' : undefined, backgroundColor: type === SpaceType.card ? 'color5' : undefined }, { children: renderBody() })));
};

const Stake$1 = ({ onComplete, type, stakingInfo, combinedApr }) => {
    var _a, _b, _c, _d, _e;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const [, stakingTokenPair] = usePair(token0, token1);
    const userLiquidityUnstaked = useTokenBalance(account !== null && account !== void 0 ? account : undefined, stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.liquidityToken);
    const { liquidityInUSD } = useGetPoolDollerWorth(stakingTokenPair);
    // track and parse user input
    const [typedValue, setTypedValue] = React.useState((userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact()) || '');
    const { parsedAmount, error } = useDerivedStakeInfo(typedValue, (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.token, userLiquidityUnstaked);
    const parsedAmountWrapped = wrappedCurrencyAmount(parsedAmount, chainId);
    let hypotheticalWeeklyRewardRate = new sdk.TokenAmount((_b = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek) === null || _b === void 0 ? void 0 : _b.token, '0');
    if (parsedAmountWrapped === null || parsedAmountWrapped === void 0 ? void 0 : parsedAmountWrapped.greaterThan('0')) {
        hypotheticalWeeklyRewardRate = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getHypotheticalWeeklyRewardRate(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount.add(parsedAmountWrapped), stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount.add(parsedAmountWrapped), stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalRewardRatePerSecond);
    }
    const { rewardTokensAmount, rewardTokensMultiplier } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_c = (rewardTokensAmount || [])) === null || _c === void 0 ? void 0 : _c.length) > 0;
    // state for pending and submitted txn views
    const addTransaction = useTransactionAdder();
    const [attempting, setAttempting] = React.useState(false);
    const [hash, setHash] = React.useState();
    const [stakeError, setStakeError] = React.useState();
    const [openDrawer, setOpenDrawer] = React.useState(false);
    // pair contract for this token to be staked
    const dummyPair = new sdk.Pair(new sdk.TokenAmount(stakingInfo.tokens[0], '0'), new sdk.TokenAmount(stakingInfo.tokens[1], '0'), chainId);
    const pairContract = usePairContract(dummyPair.liquidityToken.address);
    // approval data for stake
    const deadline = useTransactionDeadline();
    const { t } = reactI18next.useTranslation();
    const [stepIndex, setStepIndex] = React.useState(4);
    const [approval, approveCallback] = useApproveCallback(chainId, parsedAmount, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakingRewardAddress);
    const pangochefContract = usePangoChefContract();
    const currency0 = unwrappedToken(stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.token0, chainId);
    const currency1 = unwrappedToken(stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.token1, chainId);
    const onChangePercentage = (value) => {
        if (!userLiquidityUnstaked) {
            setTypedValue('0');
            return;
        }
        if (value === 100) {
            setTypedValue(userLiquidityUnstaked.toExact());
        }
        else {
            const newAmount = userLiquidityUnstaked
                .multiply(sdk.JSBI.BigInt(value))
                .divide(sdk.JSBI.BigInt(100));
            setTypedValue(newAmount.toFixed(18));
        }
    };
    function onStake() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (pangochefContract && parsedAmount && deadline) {
                setAttempting(true);
                if (approval === ApprovalState.APPROVED) {
                    try {
                        const response = yield pangochefContract.stake(stakingInfo.pid, parsedAmount.raw.toString());
                        yield waitForTransaction(response, 5);
                        addTransaction(response, {
                            summary: t('earn.depositLiquidity'),
                        });
                        setHash(response.hash);
                    }
                    catch (err) {
                        const _err = err;
                        // we only care if the error is something _other_ than the user rejected the tx
                        if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                            setStakeError(_err === null || _err === void 0 ? void 0 : _err.message);
                            console.error(_err);
                        }
                    }
                    finally {
                        setAttempting(false);
                    }
                }
                else {
                    setAttempting(false);
                    throw new Error(t('earn.attemptingToStakeError'));
                }
            }
        });
    }
    // wrapped onUserInput to clear signatures
    const onUserInput = React.useCallback((_typedValue) => {
        setTypedValue(_typedValue);
        const percentage = Math.ceil(Number(userLiquidityUnstaked && _typedValue
            ? sdk.JSBI.divide(sdk.JSBI.multiply(sdk.JSBI.BigInt(units.parseUnits(_typedValue, userLiquidityUnstaked.currency.decimals)), sdk.JSBI.BigInt(100)), userLiquidityUnstaked.raw).toString()
            : 0));
        setStepIndex(percentage > 100 ? 4 : Math.round(percentage / 25));
    }, []);
    function onAttemptToApprove() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!pairContract)
                throw new Error(t('earn.missingDependencies'));
            const liquidityAmount = parsedAmount;
            if (!liquidityAmount)
                throw new Error(t('earn.missingLiquidityAmount'));
            approveCallback();
        });
    }
    const renderPoolDataRow = (label, value) => {
        return (jsxRuntime.jsxs(DataBox$1, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: label })), jsxRuntime.jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: value }))] }, label));
    };
    const handleDismissConfirmation = React.useCallback(() => {
        // if there was a tx hash, we want to clear the input
        if (hash) {
            setTypedValue('');
            setStepIndex(0);
        }
        setHash('');
        setStakeError(undefined);
        setAttempting(false);
        setOpenDrawer(false);
        onComplete && onComplete();
    }, [setTypedValue, hash, onComplete]);
    React.useEffect(() => {
        if (userLiquidityUnstaked) {
            setTypedValue(userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact());
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact()]);
    React.useEffect(() => {
        if (openDrawer && !attempting && !hash && !stakeError) {
            handleDismissConfirmation();
        }
        if (!openDrawer && attempting) {
            setOpenDrawer(true);
        }
    }, [attempting, hash, stakeError]);
    const onConfirm = () => {
        setOpenDrawer(true);
    };
    // userLiquidityUnstaked?.toExact() -> liquidityInUSD
    // typedValue -> ?
    const finalUsd = (userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.greaterThan('0'))
        ? (Number(typedValue) * liquidityInUSD) / Number(userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact())
        : undefined;
    const getApr = () => {
        if (combinedApr) {
            return `${combinedApr}%`;
        }
        else if (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr) {
            return `${stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr}%`;
        }
        else {
            return '-';
        }
    };
    const dollerWarth = finalUsd ? `$${Number(finalUsd).toFixed(2)}` : '-';
    const png = PNG[chainId];
    const balanceLabel = !!((_d = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _d === void 0 ? void 0 : _d.token) && userLiquidityUnstaked
        ? t('currencyInputPanel.balance') + (userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toSignificant(6))
        : '-';
    return (jsxRuntime.jsxs(StakeWrapper$1, { children: [!attempting && !hash && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(Box, Object.assign({ flex: 1 }, { children: [type === SpaceType.detail && (jsxRuntime.jsx(PoolSelectWrapper$1, { children: jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsx(DoubleCurrencyLogo, { size: 24, currency0: currency0, currency1: currency1 }), jsxRuntime.jsxs(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] }))] })) })), jsxRuntime.jsxs(InputWrapper$1, Object.assign({ type: type }, { children: [jsxRuntime.jsx(TextInput, { value: typedValue, addonAfter: jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text4", fontSize: [24, 18] }, { children: "ARL" })) })), onChange: (value) => {
                                            onUserInput(value);
                                        }, fontSize: 24, isNumeric: true, placeholder: "0.00", addonLabel: account &&
                                            type === SpaceType.detail && (jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 14 }, { children: balanceLabel }))), label: type === SpaceType.card ? balanceLabel : undefined }), jsxRuntime.jsx(Box, Object.assign({ mt: type === 'card' ? '25px' : '0px' }, { children: jsxRuntime.jsx(NumberOptions, { onChange: (value) => {
                                                setStepIndex(type === 'card' ? value / 25 : value);
                                                onChangePercentage(type === 'card' ? value : value * 25);
                                            }, currentValue: type === 'card' ? stepIndex * 25 : stepIndex, variant: type === 'card' ? 'box' : 'step', isPercentage: true, isDisabled: (_e = userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.equalTo('0')) !== null && _e !== void 0 ? _e : true }) }))] })), type === 'card' && (jsxRuntime.jsxs(CardContentBox$1, Object.assign({ isSuperFarm: isSuperFarm }, { children: [jsxRuntime.jsx(Stat, { title: t('migratePage.dollarWorth'), stat: dollerWarth, titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" }), !isSuperFarm && (jsxRuntime.jsx(Stat, { title: t('dashboardPage.earned_weeklyIncome'), stat: `${hypotheticalWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })} ${png.symbol}`, titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" })), jsxRuntime.jsx(Stat, { title: `APR`, stat: getApr(), titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" })] }))), type === SpaceType.detail && (jsxRuntime.jsx(Box, { children: jsxRuntime.jsxs(ContentBox$1, { children: [renderPoolDataRow(t('migratePage.dollarWorth'), `${dollerWarth}`), renderPoolDataRow(`${t('dashboardPage.earned_weeklyIncome')}`, `${hypotheticalWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })} PNG`), isSuperFarm && (jsxRuntime.jsxs(ExtraRewardDataBox$1, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: t('earn.extraReward') })), jsxRuntime.jsx(Box, Object.assign({ textAlign: "right" }, { children: rewardTokensAmount === null || rewardTokensAmount === void 0 ? void 0 : rewardTokensAmount.map((reward, index) => {
                                                        var _a, _b;
                                                        const tokenMultiplier = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier[index];
                                                        const extraTokenWeeklyRewardRate = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getExtraTokensWeeklyRewardRate) === null || _a === void 0 ? void 0 : _a.call(stakingInfo, hypotheticalWeeklyRewardRate, reward === null || reward === void 0 ? void 0 : reward.token, tokenMultiplier);
                                                        if (extraTokenWeeklyRewardRate) {
                                                            return (jsxRuntime.jsxs(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: [extraTokenWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' }), ' ', (_b = reward === null || reward === void 0 ? void 0 : reward.token) === null || _b === void 0 ? void 0 : _b.symbol] }), index));
                                                        }
                                                        return null;
                                                    }) }))] }, "extra-reward"))] }) }))] })), jsxRuntime.jsxs(Buttons$9, { children: [jsxRuntime.jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', onClick: onAttemptToApprove, isDisabled: approval !== ApprovalState.NOT_APPROVED, loading: attempting && !hash, loadingText: t('migratePage.loading') }, { children: t('earn.approve') })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", isDisabled: !!error || approval !== ApprovalState.APPROVED, onClick: type === SpaceType.detail ? onConfirm : onStake, loading: attempting && !hash, loadingText: t('migratePage.loading') }, { children: error !== null && error !== void 0 ? error : t('earn.deposit') }))] })] })), jsxRuntime.jsx(ConfirmDrawer$1, { isOpen: openDrawer, onClose: handleDismissConfirmation, attemptingTxn: attempting, errorMessage: stakeError, txHash: hash, type: type, onStake: onStake, tokens: [currency0, currency1], amount: parsedAmount, dollarValue: dollerWarth, apr: '0%' })] }));
};

const CurrencyList$1 = styled__default["default"].div `
  display: flex;
  flex: 1;
  flex-direction: column;
  overflow-y: auto;
`;
const CurrencyRowRoot$1 = styled__default["default"].div `
  min-height: 56px;
  font-size: 16px;
  cursor: ${({ disabled }) => !disabled && 'pointer'};
  pointer-events: ${({ disabled }) => disabled && 'none'};
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;

  &:hover {
    background-color: ${({ theme, disabled }) => !disabled && theme.bg3};
  }

  opacity: ${({ disabled }) => (disabled ? 0.5 : 1)};
`;
const Balance$1 = styled__default["default"](Text) `
  justify-self: flex-end;
  white-space: nowrap;
`;

const PoolRow = (props) => {
    const { pair, style, onSelect, isSelected } = props;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const currency0 = unwrappedToken(pair.token0, chainId);
    const currency1 = unwrappedToken(pair.token1, chainId);
    const userPgl = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pair === null || pair === void 0 ? void 0 : pair.liquidityToken);
    const handleSelect = React.useCallback(() => {
        onSelect(pair);
    }, [onSelect, pair]);
    return (jsxRuntime.jsxs(CurrencyRowRoot$1, Object.assign({ style: style, onClick: handleSelect, disabled: isSelected }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsx(DoubleCurrencyLogo, { size: 24, currency0: currency0, currency1: currency1 }), jsxRuntime.jsxs(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] }))] })), jsxRuntime.jsx(Balance$1, Object.assign({ color: "text1", fontSize: 14 }, { children: userPgl ? userPgl.toSignificant(4) : '-' }))] })));
};

const SelectPoolDrawer = (props) => {
    const { isOpen, onClose, onPoolSelect, selectedPair } = props;
    // fetch the user's balances of all tracked V2 LP tokens
    const { allV2PairsWithLiquidity } = useGetUserLP();
    const onSelect = React.useCallback((pair) => {
        onPoolSelect(pair);
        onClose();
    }, [onPoolSelect, onClose]);
    const Row = React.useCallback(({ data, index, style }) => {
        const pair = data === null || data === void 0 ? void 0 : data[index];
        const isSelected = (selectedPair === null || selectedPair === void 0 ? void 0 : selectedPair.liquidityToken) === (pair === null || pair === void 0 ? void 0 : pair.liquidityToken);
        return pair ? jsxRuntime.jsx(PoolRow, { style: style, pair: pair, isSelected: isSelected, onSelect: onSelect }) : null;
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [selectedPair, onPoolSelect, onClose, onSelect]);
    return (jsxRuntime.jsx(Drawer, Object.assign({ title: "Select a token", isOpen: isOpen, onClose: onClose }, { children: jsxRuntime.jsx(CurrencyList$1, { children: jsxRuntime.jsx(AutoSizer__default["default"], Object.assign({ disableWidth: true }, { children: ({ height }) => (jsxRuntime.jsx(reactWindow.FixedSizeList, Object.assign({ height: height, width: "100%", itemCount: allV2PairsWithLiquidity.length, itemSize: 56, itemData: allV2PairsWithLiquidity, itemKey: (index) => index }, { children: Row }))) })) }) })));
};

const StakeWrapper = styled__default["default"](Box) `
  width: 100%;
  padding-left: 20px;
  padding-right: 20px;
  padding-bottom: 20px;
  height: 100%;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;
styled__default["default"](TextInput) `
  background-color: ${({ theme }) => theme.bg6};
  padding: 15px;
  align-items: center;
  border-radius: 4px;
`;
const ContentBox = styled__default["default"](Box) `
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
`;
const DataBox = styled__default["default"](Box) `
  align-items: center;
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const ExtraRewardDataBox = styled__default["default"](Box) `
  justify-content: space-between;
  display: flex;
  margin: 5px 0px 5px 0px;
`;
const PoolSelectWrapper = styled__default["default"](Box) `
  width: 100%;
  border-radius: 8px;
  padding: 10px;
  border: 1px solid transparent;
  display: flex;
  position: relative;
  box-sizing: border-box;
  justify-content: space-between;
  align-items: center;
  background-color: ${({ theme }) => theme.bg6};
  color: ${({ theme }) => theme.text4};
  cursor: pointer;
`;
const InputWrapper = styled__default["default"](Box) `
  display: grid;
  grid-auto-flow: ${({ type }) => (type === SpaceType.detail ? 'row' : 'column')};
  grid-auto-columns: minmax(0, 1fr);
  margin-top: ${({ type }) => (type === SpaceType.detail ? '10px' : '0px')};
  grid-gap: 5px;
  align-items: ${({ type }) => (type === SpaceType.detail ? 'normal' : 'center')};
`;
const Buttons$8 = styled__default["default"](Box) `
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 10px;
  margin-top: 10px;
`;
const CardContentBox = styled__default["default"](Box) `
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
  display: grid;
  grid-template-columns: ${({ isSuperFarm }) => isSuperFarm ? 'minmax(auto, 50%) minmax(auto, 50%)' : 'minmax(auto, 33%) minmax(auto, 33%) minmax(auto, 33%)'};
  grid-gap: 10px;
`;

const Stake = ({ version, onComplete, type, stakingInfo, combinedApr }) => {
    var _a, _b, _c, _d;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const [, stakingTokenPair] = usePair(token0, token1);
    const [selectedPair, setSelectedPair] = React.useState(stakingTokenPair);
    const userLiquidityUnstaked = useTokenBalance(account !== null && account !== void 0 ? account : undefined, selectedPair === null || selectedPair === void 0 ? void 0 : selectedPair.liquidityToken);
    const { liquidityInUSD } = useGetPoolDollerWorth(selectedPair);
    const [isPoolDrawerOpen, setIsPoolDrawerOpen] = React.useState(false);
    // track and parse user input
    const [typedValue, setTypedValue] = React.useState((userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact()) || '');
    const getSignature = useGetTransactionSignature();
    const { parsedAmount, error } = useDerivedStakeInfo(typedValue, (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.token, userLiquidityUnstaked);
    const parsedAmountWrapped = wrappedCurrencyAmount(parsedAmount, chainId);
    let hypotheticalWeeklyRewardRate = new sdk.TokenAmount((_b = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek) === null || _b === void 0 ? void 0 : _b.token, '0');
    if (parsedAmountWrapped === null || parsedAmountWrapped === void 0 ? void 0 : parsedAmountWrapped.greaterThan('0')) {
        hypotheticalWeeklyRewardRate = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getHypotheticalWeeklyRewardRate(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount.add(parsedAmountWrapped), stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount.add(parsedAmountWrapped), stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalRewardRatePerSecond);
    }
    const { rewardTokensAmount, rewardTokensMultiplier } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_c = (rewardTokensAmount || [])) === null || _c === void 0 ? void 0 : _c.length) > 0;
    // state for pending and submitted txn views
    const addTransaction = useTransactionAdder();
    const [attempting, setAttempting] = React.useState(false);
    const [hash, setHash] = React.useState();
    // pair contract for this token to be staked
    const dummyPair = new sdk.Pair(new sdk.TokenAmount(stakingInfo.tokens[0], '0'), new sdk.TokenAmount(stakingInfo.tokens[1], '0'), chainId);
    const pairContract = usePairContract(dummyPair.liquidityToken.address);
    // approval data for stake
    const deadline = useTransactionDeadline();
    const { t } = reactI18next.useTranslation();
    const [stepIndex, setStepIndex] = React.useState(4);
    const [signatureData, setSignatureData] = React.useState(null);
    const [approval, approveCallback] = useApproveCallback(chainId, parsedAmount, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakingRewardAddress);
    const stakingContract = useStakingContract(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakingRewardAddress);
    const currency0 = unwrappedToken(selectedPair === null || selectedPair === void 0 ? void 0 : selectedPair.token0, chainId);
    const currency1 = unwrappedToken(selectedPair === null || selectedPair === void 0 ? void 0 : selectedPair.token1, chainId);
    const poolMap = useMinichefPools();
    const refetchMinichefSubgraph = useRefetchMinichefSubgraph();
    const onChangePercentage = (value) => {
        if (!userLiquidityUnstaked) {
            setTypedValue('0');
            return;
        }
        if (value === 100) {
            setTypedValue(userLiquidityUnstaked.toExact());
        }
        else {
            const newAmount = userLiquidityUnstaked
                .multiply(sdk.JSBI.BigInt(value))
                .divide(sdk.JSBI.BigInt(100));
            setTypedValue(newAmount.toSignificant(6));
        }
    };
    function onStake() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (stakingContract && poolMap && parsedAmount && deadline) {
                setAttempting(true);
                const method = version < 2 ? 'stake' : 'deposit';
                const args = version < 2
                    ? [`0x${parsedAmount.raw.toString(16)}`]
                    : [poolMap[stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount.token.address], `0x${parsedAmount.raw.toString(16)}`, account];
                if (approval === ApprovalState.APPROVED) {
                    try {
                        const response = yield stakingContract[method](...args);
                        yield waitForTransaction(response, 5);
                        addTransaction(response, {
                            summary: t('earn.depositLiquidity'),
                        });
                        yield refetchMinichefSubgraph();
                        setHash(response.hash);
                    }
                    catch (err) {
                        setAttempting(false);
                        const _err = err;
                        // we only care if the error is something _other_ than the user rejected the tx
                        if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                            console.error(_err);
                        }
                    }
                }
                else if (signatureData) {
                    const permitMethod = version < 2 ? 'stakeWithPermit' : 'depositWithPermit';
                    const permitArgs = version < 2
                        ? [
                            `0x${parsedAmount.raw.toString(16)}`,
                            signatureData.deadline,
                            signatureData.v,
                            signatureData.r,
                            signatureData.s,
                        ]
                        : [
                            poolMap[stakingInfo.stakedAmount.token.address],
                            `0x${parsedAmount.raw.toString(16)}`,
                            account,
                            signatureData.deadline,
                            signatureData.v,
                            signatureData.r,
                            signatureData.s,
                        ];
                    try {
                        const response = yield stakingContract[permitMethod](...permitArgs);
                        yield waitForTransaction(response, 1);
                        addTransaction(response, {
                            summary: t('earn.depositLiquidity'),
                        });
                        setHash(response.hash);
                    }
                    catch (err) {
                        setAttempting(false);
                        const _err = err;
                        // we only care if the error is something _other_ than the user rejected the tx
                        if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                            console.error(_err);
                        }
                    }
                }
                else {
                    setAttempting(false);
                    throw new Error(t('earn.attemptingToStakeError'));
                }
            }
        });
    }
    // wrapped onUserInput to clear signatures
    const onUserInput = React.useCallback((_typedValue) => {
        setSignatureData(null);
        setTypedValue(_typedValue);
    }, []);
    // used for max input button
    // const maxAmountInput = maxAmountSpend(userLiquidityUnstaked)
    // const atMaxAmount = Boolean(maxAmountInput && parsedAmount?.equalTo(maxAmountInput))
    // const handleMax = useCallback(() => {
    //   maxAmountInput && onUserInput(maxAmountInput.toExact())
    // }, [maxAmountInput, onUserInput])
    function onAttemptToApprove() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!pairContract || !library || !deadline)
                throw new Error(t('earn.missingDependencies'));
            const liquidityAmount = parsedAmount;
            if (!liquidityAmount)
                throw new Error(t('earn.missingLiquidityAmount'));
            // try to gather a signature for permission
            const nonce = yield pairContract.nonces(account);
            const EIP712Domain = [
                { name: 'name', type: 'string' },
                { name: 'version', type: 'string' },
                { name: 'chainId', type: 'uint256' },
                { name: 'verifyingContract', type: 'address' },
            ];
            const domain = {
                name: 'Arcanum Liquidity',
                version: '1',
                chainId: chainId,
                verifyingContract: pairContract.address,
            };
            const Permit = [
                { name: 'owner', type: 'address' },
                { name: 'spender', type: 'address' },
                { name: 'value', type: 'uint256' },
                { name: 'nonce', type: 'uint256' },
                { name: 'deadline', type: 'uint256' },
            ];
            const message = {
                owner: account,
                spender: stakingInfo.stakingRewardAddress,
                value: liquidityAmount.raw.toString(),
                nonce: nonce.toHexString(),
                deadline: deadline.toNumber(),
            };
            const data = JSON.stringify({
                types: {
                    EIP712Domain,
                    Permit,
                },
                domain,
                primaryType: 'Permit',
                message,
            });
            try {
                const signature = yield getSignature(data);
                setSignatureData({
                    v: signature.v,
                    r: signature.r,
                    s: signature.s,
                    deadline: deadline.toNumber(),
                });
            }
            catch (err) {
                approveCallback();
            }
        });
    }
    const renderPoolDataRow = (label, value) => {
        return (jsxRuntime.jsxs(DataBox, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: label })), jsxRuntime.jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: value }))] }, label));
    };
    const handleDismissConfirmation = React.useCallback(() => {
        // if there was a tx hash, we want to clear the input
        if (hash) {
            setTypedValue('');
            setStepIndex(0);
        }
        setHash('');
        setSignatureData(null);
        setAttempting(false);
        onComplete && onComplete();
    }, [setTypedValue, hash, onComplete]);
    const handleSelectPoolDrawerClose = React.useCallback(() => {
        setIsPoolDrawerOpen(false);
    }, [setIsPoolDrawerOpen]);
    React.useEffect(() => {
        if (userLiquidityUnstaked) {
            setTypedValue(userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact());
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact()]);
    const onPoolSelect = React.useCallback((pairSelected) => {
        setSelectedPair(pairSelected);
    }, [setSelectedPair]);
    // userLiquidityUnstaked?.toExact() -> liquidityInUSD
    // typedValue -> ?
    const finalUsd = (userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.greaterThan('0'))
        ? (Number(typedValue) * liquidityInUSD) / Number(userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toExact())
        : undefined;
    const getApr = () => {
        if (combinedApr) {
            return `${combinedApr}%`;
        }
        else if (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr) {
            return `${stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr}%`;
        }
        else {
            return '-';
        }
    };
    const dollerWarth = finalUsd ? `$${Number(finalUsd).toFixed(2)}` : '-';
    const balanceLabel = !!((_d = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _d === void 0 ? void 0 : _d.token) && userLiquidityUnstaked
        ? t('currencyInputPanel.balance') + (userLiquidityUnstaked === null || userLiquidityUnstaked === void 0 ? void 0 : userLiquidityUnstaked.toSignificant(6))
        : '-';
    return (jsxRuntime.jsxs(StakeWrapper, { children: [!attempting && !hash && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(Box, Object.assign({ flex: 1 }, { children: [type === SpaceType.detail && (jsxRuntime.jsx(PoolSelectWrapper, { children: jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsx(DoubleCurrencyLogo, { size: 24, currency0: currency0, currency1: currency1 }), jsxRuntime.jsxs(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] }))] })) })), jsxRuntime.jsxs(InputWrapper, Object.assign({ type: type }, { children: [jsxRuntime.jsx(TextInput, { value: typedValue, addonAfter: jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text4", fontSize: [24, 18] }, { children: "ARL" })) })), onChange: (value) => {
                                            onUserInput(value);
                                        }, fontSize: 24, isNumeric: true, placeholder: "0.00", addonLabel: account &&
                                            type === SpaceType.detail && (jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 14 }, { children: balanceLabel }))), label: type === SpaceType.card ? balanceLabel : undefined }), jsxRuntime.jsx(Box, Object.assign({ mt: type === 'card' ? '25px' : '0px' }, { children: jsxRuntime.jsx(NumberOptions, { onChange: (value) => {
                                                setStepIndex(type === 'card' ? value / 25 : value);
                                                onChangePercentage(type === 'card' ? value : value * 25);
                                            }, currentValue: type === 'card' ? stepIndex * 25 : stepIndex, variant: type === 'card' ? 'box' : 'step', isPercentage: true }) }))] })), type === 'card' && (jsxRuntime.jsxs(CardContentBox, Object.assign({ isSuperFarm: isSuperFarm }, { children: [jsxRuntime.jsx(Stat, { title: t('migratePage.dollarWorth'), stat: dollerWarth, titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" }), !isSuperFarm && (jsxRuntime.jsx(Stat, { title: t('dashboardPage.earned_weeklyIncome'), stat: `${hypotheticalWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })} PNG`, titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" })), jsxRuntime.jsx(Stat, { title: `APR`, stat: getApr(), titlePosition: "top", titleFontSize: 14, statFontSize: 16, titleColor: "text4" })] }))), type === SpaceType.detail && (jsxRuntime.jsx(Box, { children: jsxRuntime.jsxs(ContentBox, { children: [renderPoolDataRow(t('migratePage.dollarWorth'), `${dollerWarth}`), renderPoolDataRow(`${t('dashboardPage.earned_weeklyIncome')}`, `${hypotheticalWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })} PNG`), isSuperFarm && (jsxRuntime.jsxs(ExtraRewardDataBox, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: t('earn.extraReward') })), jsxRuntime.jsx(Box, Object.assign({ textAlign: "right" }, { children: rewardTokensAmount === null || rewardTokensAmount === void 0 ? void 0 : rewardTokensAmount.map((reward, index) => {
                                                        var _a, _b;
                                                        const tokenMultiplier = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier[index];
                                                        const extraTokenWeeklyRewardRate = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getExtraTokensWeeklyRewardRate) === null || _a === void 0 ? void 0 : _a.call(stakingInfo, hypotheticalWeeklyRewardRate, reward === null || reward === void 0 ? void 0 : reward.token, tokenMultiplier);
                                                        if (extraTokenWeeklyRewardRate) {
                                                            return (jsxRuntime.jsxs(Text, Object.assign({ color: "text4", fontSize: 16 }, { children: [extraTokenWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' }), ' ', (_b = reward === null || reward === void 0 ? void 0 : reward.token) === null || _b === void 0 ? void 0 : _b.symbol] }), index));
                                                        }
                                                        return null;
                                                    }) }))] }, "extra-reward"))] }) }))] })), jsxRuntime.jsxs(Buttons$8, { children: [jsxRuntime.jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED || signatureData !== null ? 'confirm' : 'primary', onClick: onAttemptToApprove, isDisabled: approval !== ApprovalState.NOT_APPROVED || signatureData !== null, loading: attempting && !hash, loadingText: t('migratePage.loading') }, { children: t('earn.approve') })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", isDisabled: !!error || (signatureData === null && approval !== ApprovalState.APPROVED), onClick: onStake, loading: attempting && !hash, loadingText: t('migratePage.loading') }, { children: error !== null && error !== void 0 ? error : t('earn.deposit') }))] })] })), attempting && !hash && jsxRuntime.jsx(Loader, { size: 100, label: `${t('earn.depositingLiquidity')}` }), attempting && hash && (jsxRuntime.jsx(TransactionCompleted, { submitText: `${t('earn.deposited')}`, isShowButtton: type === 'card' ? false : true, onButtonClick: handleDismissConfirmation, buttonText: "Close" })), isPoolDrawerOpen && (jsxRuntime.jsx(SelectPoolDrawer, { isOpen: isPoolDrawerOpen, onClose: handleSelectPoolDrawerClose, onPoolSelect: onPoolSelect, selectedPair: selectedPair }))] }));
};

const FarmDrawer = ({ isOpen, onClose, backgroundColor, version, stakingInfo, combinedApr }) => {
    var _a, _b;
    const { t } = reactI18next.useTranslation();
    const chainId = useChainId();
    const chefType = (_b = (_a = sdk.CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef) === null || _b === void 0 ? void 0 : _b.type;
    const renderBody = () => {
        if (chefType === sdk.ChefType.PANGO_CHEF) {
            return (jsxRuntime.jsx(Stake$1, { onComplete: onClose, type: SpaceType.card, stakingInfo: stakingInfo, combinedApr: combinedApr }));
        }
        return (jsxRuntime.jsx(Stake, { version: version, onComplete: onClose, type: SpaceType.card, stakingInfo: stakingInfo, combinedApr: combinedApr }));
    };
    return (jsxRuntime.jsx(Drawer, Object.assign({ title: t('earn.deposit'), pb: 10, isOpen: isOpen, onClose: onClose, backgroundColor: backgroundColor }, { children: isOpen && renderBody() })));
};

const Wrapper$9 = styled__default["default"].div `
  position: relative;
  display: flex;
  flex-direction: row;
  margin-right: ${({ sizeraw, margin }) => margin && (sizeraw / 3 + 8).toString() + 'px'};
`;
const CoveredLogo = styled__default["default"](CurrencyLogo) `
  position: absolute;
  left: ${({ sizeraw }) => '-' + (sizeraw / 2).toString() + 'px'} !important;
`;
function RewardTokens({ rewardTokens = [], size = 24, margin = false }) {
    const tokens = rewardTokens || []; // add PNG as default reward
    return (jsxRuntime.jsx(Wrapper$9, Object.assign({ sizeraw: size, margin: margin }, { children: (tokens || []).map((token, i) => {
            return jsxRuntime.jsx(CoveredLogo, { currency: token, size: size, sizeraw: size, imageSize: 48 }, i);
        }) })));
}

const Panel$1 = styled__default["default"](Box) `
  background-color: ${({ theme }) => theme.color5};
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  padding: 20px;
  border-radius: 10px;
  height: 295px;
  * {
    box-sizing: border-box;
  }
`;
styled__default["default"].div `
  display: flex;
  align-items: center;
  flex-direction: row;
  grid-column-gap: 40px;
`;
const Divider$1 = styled__default["default"](Box) `
  height: 1px;
  background-color: ${({ theme }) => theme.bg7};
  margin: 10px 0px 10px 0px;
  width: 100%;
`;
const ActionButon$1 = styled__default["default"](Button) `
  width: 100%;
`;
const DetailButton$1 = styled__default["default"](ActionButon$1) `
  border: 1px solid !important;
  border-color: ${({ theme }) => theme.text10}!important;
`;
const InnerWrapper$4 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-gap: 12px;
  margin-top: 10px;
`;
const StatWrapper$2 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: minmax(auto, 33%) minmax(auto, 33%) minmax(auto, 33%);
  grid-gap: 12px;
  margin-top: 10px;
  flex: 1;
`;
const OptionButton = styled__default["default"].div `
  font-weight: 500;
  width: fit-content;
  white-space: nowrap;
  padding: 2px 6px;
  border-radius: 6px;
  background-color: ${({ theme }) => theme.primary};
  font-size: 13px;
`;
const OptionsWrapper = styled__default["default"].div `
  display: grid;
  grid-template-columns: auto auto auto auto;
  grid-gap: 10px;
`;

const PoolCardView = ({ stakingInfo, onClickViewDetail, version, combinedApr, earnedAmount, rewardTokens, }) => {
    var _a, _b, _c, _d;
    const { t } = reactI18next.useTranslation();
    const [isClaimDrawerVisible, setShowClaimDrawer] = React.useState(false);
    const [isFarmDrawerVisible, setShowFarmDrawer] = React.useState(false);
    const [isAddLiquidityDrawerVisible, setShowAddLiquidityDrawer] = React.useState(false);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const [, stakingTokenPair] = usePair(token0, token1);
    const isStaking = Boolean(stakingInfo.stakedAmount.greaterThan('0'));
    const yourStackedInUsd = ((_a = sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet)
        ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd.multiply(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount).divide(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount)
        : undefined;
    const userPgl = useTokenBalance(account !== null && account !== void 0 ? account : undefined, stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.liquidityToken);
    const isLiquidity = Boolean(userPgl === null || userPgl === void 0 ? void 0 : userPgl.greaterThan('0'));
    const isSuperFarm = version > 1 ? ((_b = (rewardTokens || [])) === null || _b === void 0 ? void 0 : _b.length) > 1 : ((_c = ((stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokensAddress) || [])) === null || _c === void 0 ? void 0 : _c.length) > 1;
    const redirectToFarmDrawer = () => {
        setShowFarmDrawer(true);
        setShowAddLiquidityDrawer(false);
    };
    const renderButton = () => {
        if (isStaking && Boolean(earnedAmount.greaterThan('0')))
            return (jsxRuntime.jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowClaimDrawer(true), backgroundColor: "bg2", color: "text1", height: "45px" }, { children: t('earnPage.claim') })));
        else if (isLiquidity) {
            return (jsxRuntime.jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowFarmDrawer(true), backgroundColor: "bg2", color: "text1", height: "45px" }, { children: t('header.farm') })));
        }
        else {
            return (jsxRuntime.jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowAddLiquidityDrawer(true), backgroundColor: "bg2", color: "text1", height: "45px" }, { children: t('pool.addLiquidity') })));
        }
    };
    return (jsxRuntime.jsxs(Panel$1, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, { children: [jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: 24, fontWeight: 500 }, { children: [currency0.symbol, "-", currency1.symbol] })), isSuperFarm && (jsxRuntime.jsx(OptionsWrapper, { children: jsxRuntime.jsx(OptionButton, { children: "Super farm" }) }))] }), jsxRuntime.jsx(DoubleCurrencyLogo, { size: 48, currency0: currency0, currency1: currency1 })] })), jsxRuntime.jsx(Divider$1, {}), jsxRuntime.jsx(Box, Object.assign({ display: "flex", flex: "1", alignItems: "center" }, { children: jsxRuntime.jsxs(StatWrapper$2, { children: [isStaking ? (jsxRuntime.jsx(Stat, { title: 'Your TVL', stat: numeral__default["default"](yourStackedInUsd === null || yourStackedInUsd === void 0 ? void 0 : yourStackedInUsd.toFixed(2)).format('$0.00a'), titlePosition: "top", titleFontSize: [16, 14], statFontSize: [24, 18] })) : (jsxRuntime.jsx(Stat, { title: 'TVL', stat: numeral__default["default"]((_d = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd) === null || _d === void 0 ? void 0 : _d.toFixed(2)).format('$0.00a'), titlePosition: "top", titleFontSize: 14, statFontSize: 18 })), jsxRuntime.jsx(Stat, { title: `APR`, stat: combinedApr ? `${numeral__default["default"](combinedApr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: [16, 14], statFontSize: [24, 18] }), jsxRuntime.jsxs(Box, Object.assign({ display: "inline-block" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: [16, 14] }, { children: t('earn.rewardsIn') })), jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center", mt: "5px" }, { children: jsxRuntime.jsx(RewardTokens, { rewardTokens: rewardTokens, size: 24 }) }))] }))] }) })), jsxRuntime.jsxs(InnerWrapper$4, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(DetailButton$1, Object.assign({ variant: "plain", onClick: onClickViewDetail, color: "text1", height: "45px" }, { children: t('pool.seeDetails') })) }), jsxRuntime.jsx(Box, { children: renderButton() })] }), isClaimDrawerVisible && (jsxRuntime.jsx(ClaimDrawer, { isOpen: isClaimDrawerVisible, onClose: () => {
                    setShowClaimDrawer(false);
                }, stakingInfo: stakingInfo, version: version, backgroundColor: "color5" })), isFarmDrawerVisible && (jsxRuntime.jsx(FarmDrawer, { isOpen: isFarmDrawerVisible, onClose: () => {
                    setShowFarmDrawer(false);
                }, version: version, backgroundColor: "color5", stakingInfo: stakingInfo, combinedApr: version > 1 ? combinedApr : undefined })), isAddLiquidityDrawerVisible && (jsxRuntime.jsx(AddLiquidityDrawer, { isOpen: isAddLiquidityDrawerVisible, onClose: () => {
                    setShowAddLiquidityDrawer(false);
                }, onAddToFarm: redirectToFarmDrawer, clickedLpTokens: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens, backgroundColor: "color5" }))] }));
};

const PoolCardV1 = ({ stakingInfo, onClickViewDetail, version }) => {
    const rewardTokens = useTokens(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokensAddress);
    return (jsxRuntime.jsx(PoolCardView, { combinedApr: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.combinedApr, earnedAmount: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount, rewardTokens: rewardTokens, stakingInfo: stakingInfo, onClickViewDetail: onClickViewDetail, version: version }));
};

const EarnWrapper = styled__default["default"](Box) `
  width: 100%;
`;

var TradeType;
(function (TradeType) {
    TradeType["Pool"] = "Pool";
    TradeType["Farm"] = "Farm";
})(TradeType || (TradeType = {}));
const TradeOption = ({ type, setType }) => {
    const { t } = reactI18next.useTranslation();
    return (jsxRuntime.jsx(EarnWrapper, { children: jsxRuntime.jsx(Box, Object.assign({ p: 20 }, { children: jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: [20, 16], fontWeight: 500, style: { whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' } }, { children: type === 'Pool' ? t('pool.addLiquidity') : t('header.farm') })), jsxRuntime.jsx(Box, Object.assign({ width: "120px" }, { children: jsxRuntime.jsx(ToggleButtons, { options: [TradeType.Pool, TradeType.Farm], value: type, onChange: (value) => {
                                setType(value);
                            } }) }))] })) })) }));
};

const Root$a = styled__default["default"](Box) `
  width: 100%;
  background-color: ${({ theme }) => theme.bg2};
  border-radius: 10px;
  position: relative;
  display: flex;
  flex-direction: column;
  height: 500px;
  * {
    box-sizing: border-box;
  }
  overflow: hidden;
`;

const EarnWidget = ({ currencyA, currencyB, version, stakingInfo }) => {
    var _a, _b;
    const [type, setType] = React.useState(TradeType.Pool);
    const chainId = useChainId();
    const chefType = (_b = (_a = sdk.CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef) === null || _b === void 0 ? void 0 : _b.type;
    return (jsxRuntime.jsxs(Root$a, { children: [jsxRuntime.jsx(TradeOption, { type: type, setType: setType }), type === TradeType.Pool ? (jsxRuntime.jsx(AddLiquidity, { currencyA: currencyA, currencyB: currencyB, type: SpaceType.detail })) : chefType === sdk.ChefType.PANGO_CHEF ? (jsxRuntime.jsx(Stake$1, { type: SpaceType.detail, stakingInfo: stakingInfo })) : (jsxRuntime.jsx(Stake, { version: version, type: SpaceType.detail, stakingInfo: stakingInfo }))] }));
};

var PoolType;
(function (PoolType) {
    PoolType[PoolType["UNSET_POOL"] = 0] = "UNSET_POOL";
    PoolType[PoolType["ERC20_POOL"] = 1] = "ERC20_POOL";
    PoolType[PoolType["RELAYER_POOL"] = 2] = "RELAYER_POOL";
})(PoolType || (PoolType = {}));

/* eslint-disable max-lines */
function usePangoChefInfos() {
    var _a, _b, _c;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const pangoChefContract = usePangoChefContract();
    const png = PNG[chainId];
    // get the length of pools
    const poolLenght = (_a = useSingleCallResult(pangoChefContract, 'poolsLength').result) === null || _a === void 0 ? void 0 : _a[0];
    // create array with length of pools
    const allPoolsIds = new Array(Number(poolLenght ? poolLenght.toString() : 0))
        .fill(0)
        .map((_, index) => [index.toString()]);
    const poolsState = useSingleContractMultipleData(pangoChefContract, 'pools', allPoolsIds);
    // format the data to Pool type
    const [pools, poolsIds] = React.useMemo(() => {
        var _a;
        const _pools = [];
        const _poolsIds = [];
        for (let i = 0; i < poolsState.length; i++) {
            const result = (_a = poolsState[i]) === null || _a === void 0 ? void 0 : _a.result;
            if (!result) {
                continue;
            }
            const tokenOrRecipient = result.tokenOrRecipient;
            const poolType = result.poolType;
            const rewarder = result.rewarder;
            const rewardPair = result.rewardPair;
            const valueVariables = result.valueVariables;
            const rewardSummations = result.rewardSummationsStored;
            if (!tokenOrRecipient || !poolType || !rewarder || !rewardPair || !valueVariables || !rewardSummations) {
                continue;
            }
            // remove not erc20 pool and remove this pool from poolsIds
            if (poolType !== PoolType.ERC20_POOL) {
                continue;
            }
            _pools.push({
                tokenOrRecipient: tokenOrRecipient,
                poolType: poolType,
                rewarder: rewarder,
                rewardPair: rewardPair,
                valueVariables: {
                    balance: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.balance,
                    sumOfEntryTimes: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.sumOfEntryTimes,
                },
                rewardSummations: rewardSummations,
            });
            _poolsIds.push([i.toString()]);
        }
        return [_pools, _poolsIds];
    }, [poolsState]);
    // get reward rates for each pool
    const poolsRewardsRateState = useSingleContractMultipleData(pangoChefContract, 'poolRewardRate', poolsIds);
    // get total reward rate
    const totalRewardRateState = useSingleCallResult(pangoChefContract, 'rewardRate');
    const totalRewardRate = (_c = (_b = totalRewardRateState === null || totalRewardRateState === void 0 ? void 0 : totalRewardRateState.result) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : bignumber.BigNumber.from(0);
    const totalRewardRatePerSecond = new sdk.TokenAmount(png, totalRewardRate.toString());
    const totalRewardRatePerWeek = new sdk.TokenAmount(png, totalRewardRate.mul(60 * 60 * 24 * 7).toString());
    // get the address of the rewarder for each pool
    const rewardsAddresses = React.useMemo(() => {
        if ((pools || []).length === 0)
            return [];
        return pools.map((pool) => {
            if (!!(pool === null || pool === void 0 ? void 0 : pool.rewarder) && (pool === null || pool === void 0 ? void 0 : pool.rewarder) !== ZERO_ADDRESS) {
                return pool.rewarder;
            }
            return undefined;
        });
    }, [pools]);
    const rewardsTokensState = useMultipleContractSingleData(rewardsAddresses, REWARDER_VIA_MULTIPLIER_INTERFACE, 'getRewardTokens', []);
    // get the address of lp tokens for each pool
    const lpTokens = React.useMemo(() => {
        if ((pools || []).length === 0)
            return [];
        return pools.map((pool) => pool === null || pool === void 0 ? void 0 : pool.tokenOrRecipient);
    }, [pools]);
    // get the tokens for each pool
    const tokens0State = useMultipleContractSingleData(lpTokens, PANGOLIN_PAIR_INTERFACE, 'token0', []);
    const tokens1State = useMultipleContractSingleData(lpTokens, PANGOLIN_PAIR_INTERFACE, 'token1', []);
    const tokens0Adrr = React.useMemo(() => {
        return tokens0State.map((result) => (result.result && result.result.length > 0 ? result.result[0] : null));
    }, [tokens0State]);
    const tokens1Adrr = React.useMemo(() => {
        return tokens1State.map((result) => (result.result && result.result.length > 0 ? result.result[0] : null));
    }, [tokens1State]);
    const tokens0 = useTokens(tokens0Adrr);
    const tokens1 = useTokens(tokens1Adrr);
    const tokensPairs = React.useMemo(() => {
        if (tokens0 && tokens1 && (tokens0 === null || tokens0 === void 0 ? void 0 : tokens0.length) === (tokens1 === null || tokens1 === void 0 ? void 0 : tokens1.length)) {
            const tokens = [];
            tokens0.forEach((token0, index) => {
                const token1 = tokens1[index];
                if (token0 && token1) {
                    tokens.push([token0, token1]);
                }
            });
            return tokens;
        }
        return [];
    }, [tokens0, tokens1]);
    // get the pairs for each pool
    const pairs = usePairs(tokensPairs);
    const pairAddresses = React.useMemo(() => {
        return pairs.map(([, pair]) => { var _a; return (_a = pair === null || pair === void 0 ? void 0 : pair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address; });
    }, [pairs]);
    const pairTotalSuppliesState = useMultipleContractSingleData(pairAddresses, ERC20_INTERFACE, 'totalSupply');
    const userInfoInput = React.useMemo(() => {
        if (poolsIds.length === 0 || !account)
            return [];
        return poolsIds.map((pid) => [pid[0], account]);
    }, [poolsIds, account]); // [[pid, account], ...] [[0, account], [1, account], [2, account] ...]
    const userInfosState = useSingleContractMultipleData(pangoChefContract, 'getUser', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    // format the data to UserInfo type
    const userInfos = React.useMemo(() => {
        return userInfosState.map((callState) => {
            var _a, _b;
            const result = (_a = callState === null || callState === void 0 ? void 0 : callState.result) === null || _a === void 0 ? void 0 : _a[0];
            if (!result || callState.loading) {
                return {
                    valueVariables: {
                        balance: bignumber.BigNumber.from(0),
                        sumOfEntryTimes: bignumber.BigNumber.from(0),
                    },
                    isLockingPoolZero: false,
                };
            }
            const valueVariables = result.valueVariables;
            const rewardSummations = result.rewardSummationsPaid;
            const previousValues = result.previousValues;
            const isLockingPoolZero = (_b = result.isLockingPoolZero) !== null && _b !== void 0 ? _b : false;
            if (!valueVariables || !rewardSummations || !previousValues) {
                return {
                    valueVariables: {
                        balance: bignumber.BigNumber.from(0),
                        sumOfEntryTimes: bignumber.BigNumber.from(0),
                    },
                    isLockingPoolZero: false,
                };
            }
            return {
                valueVariables: {
                    balance: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.balance,
                    sumOfEntryTimes: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.sumOfEntryTimes,
                },
                rewardSummations: rewardSummations,
                previousValues: previousValues,
                isLockingPoolZero: isLockingPoolZero,
            };
        });
    }, [userInfosState]);
    // get the user pending rewards for each pool
    const userPendingRewardsState = useSingleContractMultipleData(pangoChefContract, 'userPendingRewards', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const userRewardRatesState = useSingleContractMultipleData(pangoChefContract, 'userRewardRate', userInfoInput !== null && userInfoInput !== void 0 ? userInfoInput : []);
    const wavax = sdk.WAVAX[chainId];
    const [avaxPngPairState, avaxPngPair] = usePair(wavax, png);
    const pairsToGetPrice = React.useMemo(() => {
        const _pairs = [];
        pairs.forEach(([, pair], index) => {
            var _a;
            const pairTotalSupplyState = pairTotalSuppliesState[index];
            if (pair && pairTotalSupplyState.result) {
                _pairs.push({
                    pair: pair,
                    totalSupply: new sdk.TokenAmount(pair.liquidityToken, sdk.JSBI.BigInt((_a = pairTotalSupplyState === null || pairTotalSupplyState === void 0 ? void 0 : pairTotalSupplyState.result) === null || _a === void 0 ? void 0 : _a[0])),
                });
            }
        });
        return _pairs;
    }, [pairs, pairTotalSuppliesState]);
    const pairPrices = usePairsCurrencyPrice(pairsToGetPrice);
    const { data: currencyPrice = 0 } = useCoinGeckoCurrencyPrice(chainId);
    return React.useMemo(() => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!chainId || !png || pairs.length == 0)
            return [];
        const farms = [];
        for (let index = 0; index < poolsIds.length; index++) {
            const poolState = poolsState[index];
            const poolRewardRateState = poolsRewardsRateState[index];
            const userInfoState = userInfosState[index];
            const token0State = tokens0State[index];
            const token1State = tokens1State[index];
            const rewardTokensState = rewardsTokensState[index];
            const userPendingRewardState = userPendingRewardsState[index];
            const pairTotalSupplyState = pairTotalSuppliesState[index];
            const userRewardRateState = userRewardRatesState[index];
            const [pairState, pair] = pairs[index];
            // if is loading or not exist pair continue
            if (poolState.loading ||
                poolRewardRateState.loading ||
                userInfoState.loading ||
                token0State.loading ||
                token1State.loading ||
                rewardTokensState.loading ||
                userPendingRewardState.loading ||
                userRewardRateState.loading ||
                pairTotalSupplyState.loading ||
                totalRewardRateState.loading ||
                pairState === PairState.LOADING ||
                avaxPngPairState == PairState.LOADING ||
                !pair ||
                !avaxPngPair) {
                continue;
            }
            const pid = poolsIds[index][0];
            const pool = pools[index];
            const rewardRate = (_b = (_a = poolRewardRateState.result) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : bignumber.BigNumber.from(0);
            const totalStakedAmount = new sdk.TokenAmount(pair.liquidityToken, sdk.JSBI.BigInt(pool.valueVariables.balance.toString()));
            const userInfo = userInfos[index];
            const userTotalStakedAmount = new sdk.TokenAmount(pair.liquidityToken, sdk.JSBI.BigInt((_c = userInfo === null || userInfo === void 0 ? void 0 : userInfo.valueVariables.balance) !== null && _c !== void 0 ? _c : 0));
            const pendingRewards = new sdk.TokenAmount(png, sdk.JSBI.BigInt((_e = (_d = userPendingRewardState === null || userPendingRewardState === void 0 ? void 0 : userPendingRewardState.result) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : 0));
            const pairPrice = pairPrices[pair.liquidityToken.address];
            const pngPrice = avaxPngPair.priceOf(png, wavax);
            const _totalStakedInWavax = pairPrice.raw.multiply(totalStakedAmount.raw);
            const currencyPriceFraction = decimalToFraction(currencyPrice);
            // calculate the total staked amount in usd
            const totalStakedInUsd = new sdk.TokenAmount(USDC[chainId], currencyPriceFraction.multiply(_totalStakedInWavax).toFixed(0));
            const totalStakedInWavax = new sdk.TokenAmount(wavax, _totalStakedInWavax.toFixed(0));
            const getHypotheticalWeeklyRewardRate = (_stakedAmount, _totalStakedAmount, _totalRewardRatePerSecond) => {
                return new sdk.TokenAmount(png, sdk.JSBI.greaterThan(_totalStakedAmount.raw, sdk.JSBI.BigInt(0))
                    ? sdk.JSBI.divide(sdk.JSBI.multiply(sdk.JSBI.multiply(_totalRewardRatePerSecond.raw, _stakedAmount.raw), BIG_INT_SECONDS_IN_WEEK), _totalStakedAmount.raw)
                    : sdk.JSBI.BigInt(0));
            };
            // poolAPR = poolRewardRate(POOL_ID) * 365 days * 100 * PNG_PRICE / (pools(POOL_ID).valueVariables.balance * STAKING_TOKEN_PRICE)
            const apr = pool.valueVariables.balance.isZero() || pairPrice.equalTo('0')
                ? 0
                : Number(pngPrice.raw
                    .multiply(rewardRate.mul(365 * 86400 * 100).toString())
                    .divide(pairPrice.raw.multiply(pool.valueVariables.balance.toString()))
                    .toSignificant(2));
            farms.push({
                pid: pid,
                tokens: [pair.token0, pair.token1],
                stakingRewardAddress: pangoChefContract === null || pangoChefContract === void 0 ? void 0 : pangoChefContract.address,
                totalStakedAmount: totalStakedAmount,
                totalStakedInUsd: totalStakedInUsd !== null && totalStakedInUsd !== void 0 ? totalStakedInUsd : new sdk.TokenAmount(USDC[chainId], BIG_INT_ZERO),
                totalStakedInWavax: totalStakedInWavax,
                multiplier: BIG_INT_ZERO,
                stakedAmount: userTotalStakedAmount,
                isPeriodFinished: rewardRate.isZero(),
                periodFinish: undefined,
                rewardsAddress: pool.rewarder,
                rewardTokensAddress: [png.address, ...(((_f = rewardTokensState === null || rewardTokensState === void 0 ? void 0 : rewardTokensState.result) === null || _f === void 0 ? void 0 : _f[0]) || [])],
                totalRewardRatePerSecond: totalRewardRatePerSecond,
                totalRewardRatePerWeek: totalRewardRatePerWeek,
                rewardRatePerWeek: new sdk.TokenAmount(png, rewardRate.mul(60 * 60 * 24 * 7).toString()),
                getHypotheticalWeeklyRewardRate: getHypotheticalWeeklyRewardRate,
                getExtraTokensWeeklyRewardRate: getExtraTokensWeeklyRewardRate,
                earnedAmount: pendingRewards,
                valueVariables: pool.valueVariables,
                userValueVariables: userInfo === null || userInfo === void 0 ? void 0 : userInfo.valueVariables,
                isLockingPoolZero: userInfo.isLockingPoolZero,
                userRewardRate: (_h = (_g = userRewardRateState.result) === null || _g === void 0 ? void 0 : _g[0]) !== null && _h !== void 0 ? _h : bignumber.BigNumber.from(0),
                stakingApr: apr,
                pairPrice: pairPrice,
                poolType: pool.poolType,
                poolRewardRate: rewardRate,
            });
        }
        return farms;
    }, [
        poolsIds,
        poolsState,
        poolsRewardsRateState,
        userInfosState,
        tokens0State,
        tokens1State,
        rewardsTokensState,
        pairTotalSuppliesState,
        userPendingRewardsState,
        pairs,
    ]);
}
function useUserPangoChefAPR(stakingInfo) {
    const blockTime = useGetBlockTimestamp();
    return React.useMemo(() => {
        var _a;
        if (!stakingInfo)
            return '0';
        const userBalance = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.userValueVariables.balance;
        const userSumOfEntryTimes = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.userValueVariables.sumOfEntryTimes;
        const poolBalance = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.valueVariables.balance;
        const poolSumOfEntryTimes = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.valueVariables.sumOfEntryTimes;
        if (userBalance.isZero() || poolBalance.isZero() || !blockTime)
            return '0';
        const blockTimestamp = bignumber.BigNumber.from(blockTime.toString());
        //userAPR = poolAPR * (blockTime - (userValueVariables.sumOfEntryTimes / userValueVariables.balance)) / (blockTime - (poolValueVariables.sumOfEntryTimes / poolValueVariables.balance))
        const a = userSumOfEntryTimes.div(userBalance);
        const b = poolSumOfEntryTimes.div(poolBalance);
        const c = blockTimestamp.sub(a);
        const d = blockTimestamp.sub(b);
        return bignumber.BigNumber.from((_a = stakingInfo.stakingApr) !== null && _a !== void 0 ? _a : 0)
            .mul(c)
            .div(d)
            .toString();
    }, [blockTime, stakingInfo]);
}
function useUserPangoChefRewardRate(stakingInfo) {
    const blockTime = useGetBlockTimestamp();
    return React.useMemo(() => {
        const userBalance = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.userValueVariables.balance;
        const userSumOfEntryTimes = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.userValueVariables.sumOfEntryTimes;
        const poolBalance = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.valueVariables.balance;
        const poolSumOfEntryTimes = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.valueVariables.sumOfEntryTimes;
        if (userBalance.isZero() || poolBalance.isZero() || !blockTime)
            return bignumber.BigNumber.from(0);
        const blockTimestamp = bignumber.BigNumber.from(blockTime.toString());
        const userValue = blockTimestamp.mul(userBalance).sub(userSumOfEntryTimes);
        const poolValue = blockTimestamp.mul(poolBalance).sub(poolSumOfEntryTimes);
        return userValue.lte(0) || poolValue.lte(0)
            ? bignumber.BigNumber.from(0)
            : stakingInfo.poolRewardRate.mul(userValue).div(poolValue);
    }, [blockTime, stakingInfo]);
}
function useIsLockingPoolZero() {
    const stakingInfos = usePangoChefInfos();
    const pairs = React.useMemo(() => {
        const _pairs = [];
        stakingInfos.forEach((stakingInfo) => {
            if (stakingInfo.isLockingPoolZero) {
                const [token0, token1] = stakingInfo.tokens;
                _pairs.push([token0, token1]);
            }
        });
        return _pairs;
    }, [stakingInfos]);
    return pairs;
}

function useBurnState() {
    return useSelector((state) => state.pburn);
}
function useDerivedBurnInfo(currencyA, currencyB) {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useTokenBalances = useTokenBalancesHook[chainId];
    const useTotalSupply = useTotalSupplyHook[chainId];
    const { t } = reactI18next.useTranslation();
    const { independentField, typedValue } = useBurnState();
    // pair + totalsupply
    const [, pair] = usePair(currencyA, currencyB);
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    // balances
    const relevantTokenBalances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, [pairOrToken]);
    const userLiquidity = relevantTokenBalances === null || relevantTokenBalances === void 0 ? void 0 : relevantTokenBalances[(_b = (_a = pair === null || pair === void 0 ? void 0 : pair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : ''];
    const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];
    const tokens = {
        [Field$2.CURRENCY_A]: tokenA,
        [Field$2.CURRENCY_B]: tokenB,
        [Field$2.LIQUIDITY]: pair === null || pair === void 0 ? void 0 : pair.liquidityToken,
    };
    // liquidity values
    const totalSupply = useTotalSupply(pairOrToken);
    const [liquidityValue0, liquidityValue1] = pair &&
        totalSupply &&
        userLiquidity &&
        tokenA &&
        tokenB &&
        sdk.JSBI.greaterThan(totalSupply.raw, BIG_INT_ZERO) &&
        sdk.JSBI.greaterThan(userLiquidity.raw, BIG_INT_ZERO) &&
        sdk.JSBI.greaterThanOrEqual(totalSupply.raw, userLiquidity.raw)
        ? pair.getLiquidityValues(totalSupply, userLiquidity, { feeOn: false })
        : [undefined, undefined];
    const liquidityValueA = tokenA && (pair === null || pair === void 0 ? void 0 : pair.token0.equals(tokenA)) ? liquidityValue0 : liquidityValue1;
    const liquidityValueB = tokenB && (pair === null || pair === void 0 ? void 0 : pair.token0.equals(tokenB)) ? liquidityValue0 : liquidityValue1;
    const liquidityValues = {
        [Field$2.CURRENCY_A]: liquidityValueA,
        [Field$2.CURRENCY_B]: liquidityValueB,
    };
    let percentToRemove = new sdk.Percent('0', '100');
    // user specified a %
    if (independentField === Field$2.LIQUIDITY_PERCENT) {
        percentToRemove = new sdk.Percent(typedValue, '100');
    }
    // user specified a specific amount of liquidity tokens
    else if (independentField === Field$2.LIQUIDITY) {
        if (pair === null || pair === void 0 ? void 0 : pair.liquidityToken) {
            const independentAmount = tryParseAmount(typedValue, pair.liquidityToken, chainId);
            if (independentAmount && userLiquidity && !independentAmount.greaterThan(userLiquidity)) {
                percentToRemove = new sdk.Percent(independentAmount.raw, userLiquidity.raw);
            }
        }
    }
    // user specified a specific amount of token a or b
    else {
        if (tokens[independentField]) {
            const independentAmount = tryParseAmount(typedValue, tokens[independentField], chainId);
            const liquidityValue = liquidityValues[independentField];
            if (independentAmount && liquidityValue && !independentAmount.greaterThan(liquidityValue)) {
                percentToRemove = new sdk.Percent(independentAmount.raw, liquidityValue.raw);
            }
        }
    }
    const parsedAmounts = {
        [Field$2.LIQUIDITY_PERCENT]: percentToRemove,
        [Field$2.LIQUIDITY]: userLiquidity && percentToRemove && percentToRemove.greaterThan('0')
            ? new sdk.TokenAmount(userLiquidity.token, percentToRemove.multiply(userLiquidity.raw).quotient)
            : undefined,
        [Field$2.CURRENCY_A]: tokenA && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueA
            ? new sdk.TokenAmount(tokenA, percentToRemove.multiply(liquidityValueA.raw).quotient)
            : undefined,
        [Field$2.CURRENCY_B]: tokenB && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueB
            ? new sdk.TokenAmount(tokenB, percentToRemove.multiply(liquidityValueB.raw).quotient)
            : undefined,
    };
    let error;
    if (!account) {
        error = t('burnHooks.connectWallet');
    }
    if (!parsedAmounts[Field$2.LIQUIDITY] || !parsedAmounts[Field$2.CURRENCY_A] || !parsedAmounts[Field$2.CURRENCY_B]) {
        error = error !== null && error !== void 0 ? error : t('burnHooks.enterAmount');
    }
    return { pair, parsedAmounts, error, userLiquidity };
}
function useBurnActionHandlers() {
    const dispatch = useDispatch();
    const onUserInput = React.useCallback((field, typedValue) => {
        dispatch(typeInput$2({ field, typedValue }));
    }, [dispatch]);
    return {
        onUserInput,
    };
}

const RemoveWrapper$1 = styled__default["default"](Box) `
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
`;
const ButtonWrapper = styled__default["default"](Box) `
  justify-content: space-between;
  width: 100%;
  display: flex;
  padding: 0;
  align-items: center;
`;

const RemoveLiquidity = ({ currencyA, currencyB, onLoadingOrComplete }) => {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { library } = useLibrary();
    const useApproveCallback = useApproveCallbackHook[chainId];
    const useRemoveLiquidity = useRemoveLiquidityHook[chainId];
    // toggle wallet when disconnected
    const toggleWalletModal = useWalletModalToggle();
    const { independentField, typedValue } = useBurnState();
    const { pair, parsedAmounts, error, userLiquidity } = useDerivedBurnInfo(currencyA !== null && currencyA !== void 0 ? currencyA : undefined, currencyB !== null && currencyB !== void 0 ? currencyB : undefined);
    const { removeLiquidity, onAttemptToApprove, signatureData, setSignatureData } = useRemoveLiquidity(pair);
    const { onUserInput: _onUserInput } = useBurnActionHandlers();
    const isValid = !error;
    // state for pending and submitted txn views
    const [attempting, setAttempting] = React.useState(false);
    const [hash, setHash] = React.useState();
    const deadline = useTransactionDeadline();
    const [allowedSlippage] = useUserSlippageTolerance();
    const formattedAmounts = {
        [Field$2.LIQUIDITY_PERCENT]: parsedAmounts[Field$2.LIQUIDITY_PERCENT].equalTo('0')
            ? '0'
            : parsedAmounts[Field$2.LIQUIDITY_PERCENT].lessThan(new sdk.Percent('1', '100'))
                ? '<1'
                : parsedAmounts[Field$2.LIQUIDITY_PERCENT].toFixed(0),
        [Field$2.LIQUIDITY]: independentField === Field$2.LIQUIDITY ? typedValue : (_b = (_a = parsedAmounts[Field$2.LIQUIDITY]) === null || _a === void 0 ? void 0 : _a.toExact()) !== null && _b !== void 0 ? _b : '',
    };
    // allowance handling
    // const [signatureData, setSignatureData] = useState<{ v: number; r: string; s: string; deadline: number } | null>(
    //   null,
    // );
    const [approval, approveCallback] = useApproveCallback(chainId, parsedAmounts[Field$2.LIQUIDITY], ROUTER_ADDRESS[chainId]);
    const { t } = reactI18next.useTranslation();
    const [percetage, setPercetage] = React.useState(100);
    React.useEffect(() => {
        _onUserInput(Field$2.LIQUIDITY_PERCENT, `100`);
    }, [_onUserInput]);
    React.useEffect(() => {
        if (onLoadingOrComplete) {
            if (hash || attempting) {
                onLoadingOrComplete(true);
            }
            else {
                onLoadingOrComplete(false);
            }
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [hash, attempting]);
    const onChangePercentage = (value) => {
        _onUserInput(Field$2.LIQUIDITY_PERCENT, `${value}`);
    };
    // wrapped onUserInput to clear signatures
    const onUserInput = React.useCallback((_typedValue) => {
        setSignatureData(null);
        _onUserInput(Field$2.LIQUIDITY, _typedValue);
        setPercetage(0);
    }, [_onUserInput]);
    React.useEffect(() => {
        setPercetage(Number(parsedAmounts[Field$2.LIQUIDITY_PERCENT].toFixed(0)) / 25);
    }, [parsedAmounts]);
    function onRemove() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!chainId || !library || !account || !deadline)
                throw new Error(t('error.missingDependencies'));
            try {
                setAttempting(true);
                const removeData = {
                    parsedAmounts,
                    deadline,
                    allowedSlippage,
                    approval,
                };
                const response = yield removeLiquidity(removeData);
                setHash(response === null || response === void 0 ? void 0 : response.hash);
            }
            catch (err) {
                const _err = err;
                console.error(_err);
            }
            finally {
                setAttempting(false);
            }
        });
    }
    function getApproveButtonVariant() {
        if (approval === ApprovalState.APPROVED || signatureData !== null) {
            return 'confirm';
        }
        return 'primary';
    }
    function getApproveButtonText() {
        if (approval === ApprovalState.PENDING) {
            return t('removeLiquidity.approving');
        }
        else if (approval === ApprovalState.APPROVED || signatureData !== null) {
            return t('removeLiquidity.approved');
        }
        return t('removeLiquidity.approve');
    }
    return (jsxRuntime.jsxs(RemoveWrapper$1, { children: [!attempting && !hash && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Box, Object.assign({ flex: 1 }, { children: jsxRuntime.jsx(Box, { children: jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column" }, { children: [jsxRuntime.jsx(TextInput, { value: formattedAmounts[Field$2.LIQUIDITY], addonAfter: jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text4", fontSize: [24, 18] }, { children: "ARL" })) })), onChange: (value) => {
                                            onUserInput(value);
                                        }, fontSize: 24, isNumeric: true, placeholder: "0.00", addonLabel: account && (jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontWeight: 500, fontSize: 14 }, { children: !!userLiquidity ? t('currencyInputPanel.balance') + (userLiquidity === null || userLiquidity === void 0 ? void 0 : userLiquidity.toSignificant(6)) : ' -' }))) }), jsxRuntime.jsx(Box, Object.assign({ my: "5px" }, { children: jsxRuntime.jsx(NumberOptions, { onChange: (value) => {
                                                setPercetage(value);
                                                onChangePercentage(value * 25);
                                            }, currentValue: percetage, variant: "step", isPercentage: true }) }))] })) }) })), jsxRuntime.jsx(Box, Object.assign({ mt: 0 }, { children: !account ? (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: toggleWalletModal, height: "46px" }, { children: t('earn.deposit') }))) : (jsxRuntime.jsxs(ButtonWrapper, { children: [isEvmChain(chainId) && (jsxRuntime.jsx(Box, Object.assign({ mr: "5px", width: "100%" }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: getApproveButtonVariant(), onClick: () => {
                                            onAttemptToApprove({ parsedAmounts, deadline, approveCallback });
                                        }, isDisabled: approval !== ApprovalState.NOT_APPROVED || signatureData !== null, loading: attempting && !hash, loadingText: t('removeLiquidity.approving'), height: "46px" }, { children: getApproveButtonText() })) }))), jsxRuntime.jsx(Box, Object.assign({ width: "100%" }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", isDisabled: !isValid || (signatureData === null && approval !== ApprovalState.APPROVED), onClick: onRemove, loading: attempting && !hash, loadingText: t('migratePage.loading'), height: "46px" }, { children: error || t('removeLiquidity.remove') })) }))] })) }))] })), attempting && !hash && jsxRuntime.jsx(Loader, { size: 100, label: `Removing Liquidity...` }), hash && jsxRuntime.jsx(TransactionCompleted, { submitText: `Removed Liquidity` })] }));
};

const RemoveLiquidityDrawer = ({ isOpen, onClose, clickedLpTokens, backgroundColor }) => {
    const { t } = reactI18next.useTranslation();
    const chainId = useChainId();
    const token0 = clickedLpTokens === null || clickedLpTokens === void 0 ? void 0 : clickedLpTokens[0];
    const token1 = clickedLpTokens === null || clickedLpTokens === void 0 ? void 0 : clickedLpTokens[1];
    const currencyA = token0 && unwrappedToken(token0, chainId);
    const currencyB = token1 && unwrappedToken(token1, chainId);
    return (jsxRuntime.jsx(Drawer, Object.assign({ title: t('navigationTabs.removeLiquidity'), isOpen: isOpen, onClose: onClose, backgroundColor: backgroundColor }, { children: isOpen && (jsxRuntime.jsx(Box, Object.assign({ padding: "10px", display: "flex", flexDirection: "column", flex: "1" }, { children: jsxRuntime.jsx(RemoveLiquidity, { currencyA: currencyA, currencyB: currencyB }) }))) })));
};

const FarmRemoveWrapper = styled__default["default"](Box) `
  width: 100%;
  flex: 1;
`;
const Root$9 = styled__default["default"](Box) `
  height: 100%;
  display: flex;
  flex-direction: column;
`;
const RewardWrapper = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-row-gap: 0px;
  grid-column-gap: 5px;
  justify-content: center;
  height: 100%;
`;
const StatWrapper$1 = styled__default["default"](Box) `
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
`;
const Buttons$7 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: 1fr ${({ chefType }) => (chefType === sdk.ChefType.PANGO_CHEF ? '1fr' : '')};
  grid-gap: 20px;
  align-self: end;
  margin-top: 10px;
`;

const RemoveFarm = ({ stakingInfo, version, onClose, onLoadingOrComplete, redirectToCompound }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { account } = usePangolinWeb3();
    const [isRemoveLiquidityDrawerVisible, setShowRemoveLiquidityDrawer] = React.useState(false);
    const [confirmRemove, setConfirmRemove] = React.useState(false);
    const { t } = reactI18next.useTranslation();
    // monitor call to help UI loading state
    const addTransaction = useTransactionAdder();
    const [hash, setHash] = React.useState();
    const [attempting, setAttempting] = React.useState(false);
    const poolMap = useMinichefPools();
    const stakingContract = useStakingContract(stakingInfo.stakingRewardAddress);
    const pangoChefContract = usePangoChefContract();
    const chainId = useChainId();
    const png = PNG[chainId];
    const contract = version <= 2 ? stakingContract : pangoChefContract;
    const { rewardTokensAmount } = useMinichefPendingRewards(stakingInfo);
    const refetchMinichefSubgraph = useRefetchMinichefSubgraph();
    const isSuperFarm = ((_a = (rewardTokensAmount || [])) === null || _a === void 0 ? void 0 : _a.length) > 0;
    const chefType = (_d = (_c = (_b = sdk.CHAINS[chainId].contracts) === null || _b === void 0 ? void 0 : _b.mini_chef) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : sdk.ChefType.MINI_CHEF_V2;
    React.useEffect(() => {
        if (onLoadingOrComplete) {
            if (hash || attempting || confirmRemove) {
                onLoadingOrComplete(true);
            }
            else {
                onLoadingOrComplete(false);
            }
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [hash, attempting, confirmRemove]);
    function wrappedOnDismiss() {
        setHash(undefined);
        setAttempting(false);
        onClose();
    }
    function onWithdraw() {
        var _a, _b;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!contract || (version === 2 && !poolMap))
                return;
            if (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) {
                setAttempting(true);
                const method = version === 1 ? 'exit' : version === 2 ? 'withdrawAndHarvest' : 'withdraw';
                const args = version === 1
                    ? []
                    : version === 2
                        ? [
                            poolMap[stakingInfo.stakedAmount.token.address],
                            `0x${(_a = stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.raw.toString(16)}`,
                            account,
                        ]
                        : [stakingInfo.pid, `0x${(_b = stakingInfo.stakedAmount) === null || _b === void 0 ? void 0 : _b.raw.toString(16)}`];
                try {
                    const response = yield contract[method](...args);
                    yield waitForTransaction(response, 5);
                    addTransaction(response, {
                        summary: t('earn.withdrawDepositedLiquidity'),
                    });
                    yield refetchMinichefSubgraph();
                    setHash(response.hash);
                }
                catch (err) {
                    setAttempting(false);
                    const _err = err;
                    // we only care if the error is something _other_ than the user rejected the tx
                    if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                        console.error(err);
                    }
                }
            }
        });
    }
    let error;
    if (!account) {
        error = t('earn.connectWallet');
    }
    if (!(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
        error = error !== null && error !== void 0 ? error : t('earn.enterAmount');
    }
    const { earnedAmount } = useGetEarnedAmount(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const newEarnedAmount = version !== 2 ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount : earnedAmount;
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const cheftType = (_g = (_f = (_e = sdk.CHAINS[chainId].contracts) === null || _e === void 0 ? void 0 : _e.mini_chef) === null || _f === void 0 ? void 0 : _f.type) !== null && _g !== void 0 ? _g : sdk.ChefType.MINI_CHEF_V2;
    return (jsxRuntime.jsxs(FarmRemoveWrapper, { children: [!attempting && !hash && (jsxRuntime.jsx(Root$9, { children: !confirmRemove ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Box, Object.assign({ flex: "1" }, { children: jsxRuntime.jsxs(RewardWrapper, { children: [(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) && (jsxRuntime.jsx(StatWrapper$1, { children: jsxRuntime.jsx(Stat, { title: t('earn.depositedToken', { symbol: 'ARL' }), stat: (_h = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _h === void 0 ? void 0 : _h.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [20, 18], titleColor: "text1", statAlign: "center" }) })), newEarnedAmount && (jsxRuntime.jsx(StatWrapper$1, { children: jsxRuntime.jsx(Stat, { title: t('earn.unclaimedReward', { symbol: png.symbol }), stat: newEarnedAmount === null || newEarnedAmount === void 0 ? void 0 : newEarnedAmount.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [20, 18], titleColor: "text1", statAlign: "center" }) })), isSuperFarm &&
                                        (rewardTokensAmount === null || rewardTokensAmount === void 0 ? void 0 : rewardTokensAmount.map((rewardAmount, i) => {
                                            var _a;
                                            return (jsxRuntime.jsx(StatWrapper$1, { children: jsxRuntime.jsx(Stat, { title: t('earn.unclaimedReward', { symbol: (_a = rewardAmount === null || rewardAmount === void 0 ? void 0 : rewardAmount.token) === null || _a === void 0 ? void 0 : _a.symbol }), stat: rewardAmount === null || rewardAmount === void 0 ? void 0 : rewardAmount.toSignificant(4), titlePosition: "top", titleFontSize: 12, statFontSize: [20, 18], titleColor: "text1", statAlign: "center" }) }, i));
                                        }))] }) })), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: cheftType === sdk.ChefType.PANGO_CHEF && !confirmRemove ? () => setConfirmRemove(true) : onWithdraw }, { children: error !== null && error !== void 0 ? error : t('earn.withdrawAndClaim') })) })] })) : (jsxRuntime.jsxs(Box, Object.assign({ display: "grid", height: "100%" }, { children: [jsxRuntime.jsx(Box, Object.assign({ bgColor: "color3", borderRadius: "8px", padding: "15px", display: "flex", flexDirection: "column", justifyContent: "center" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1", textAlign: "center" }, { children: t(chefType === sdk.ChefType.PANGO_CHEF ? 'pangoChef.removeWarning' : 'earn.removeWarning') })) })), jsxRuntime.jsxs(Buttons$7, Object.assign({ chefType: chefType }, { children: [chefType === sdk.ChefType.PANGO_CHEF && (jsxRuntime.jsx(Button, Object.assign({ variant: "outline", onClick: redirectToCompound }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: t('sarCompound.compound') })) })) }))), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onWithdraw }, { children: error !== null && error !== void 0 ? error : t('earn.withdrawAndClaim') }))] }))] }))) })), attempting && !hash && jsxRuntime.jsx(Loader, { size: 100, label: "Withdrawing & Claiming..." }), hash && (jsxRuntime.jsx(TransactionCompleted, { onClose: wrappedOnDismiss, submitText: t('pool.successWithdraw'), isShowButtton: true, onButtonClick: () => setShowRemoveLiquidityDrawer(true), buttonText: t('navigationTabs.removeLiquidity') })), isRemoveLiquidityDrawerVisible && (jsxRuntime.jsx(RemoveLiquidityDrawer, { isOpen: isRemoveLiquidityDrawerVisible, onClose: () => {
                    setShowRemoveLiquidityDrawer(false);
                    wrappedOnDismiss();
                }, clickedLpTokens: [token0, token1] }))] }));
};

const RemoveWrapper = styled__default["default"](Box) `
  width: 100%;
  padding: 0px 10px 10px 10px;
  flex: 1;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;

var REMOVE_TYPE;
(function (REMOVE_TYPE) {
    REMOVE_TYPE["FARM"] = "Farm";
    REMOVE_TYPE["LIQUIDITY"] = "Liquidity";
})(REMOVE_TYPE || (REMOVE_TYPE = {}));
const Remove = ({ stakingInfo, version, onClose, redirectToCompound }) => {
    var _a;
    const chainId = useChainId();
    const [removeType, setRemoveType] = React.useState(((_a = stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.greaterThan('0')) ? REMOVE_TYPE.FARM : REMOVE_TYPE.LIQUIDITY);
    const [showRemoveTab, setShowRemoveTab] = React.useState(true);
    const { t } = reactI18next.useTranslation();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const currencyA = unwrappedToken(token0, chainId);
    const currencyB = unwrappedToken(token1, chainId);
    const { userLiquidity } = useDerivedBurnInfo(currencyA !== null && currencyA !== void 0 ? currencyA : undefined, currencyB !== null && currencyB !== void 0 ? currencyB : undefined);
    const renderRemoveContent = () => {
        if (!!userLiquidity && Number(userLiquidity === null || userLiquidity === void 0 ? void 0 : userLiquidity.toSignificant()) > 0) {
            return (jsxRuntime.jsx(RemoveLiquidity, { currencyA: currencyA, currencyB: currencyB, onLoadingOrComplete: (isLoadingOrComplete) => {
                    setShowRemoveTab(!isLoadingOrComplete);
                } }));
        }
        else {
            return (jsxRuntime.jsx(Box, Object.assign({ display: "flex", justifyContent: "center", alignItems: "center", height: "100%" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, textAlign: "center" }, { children: t('pool.noLiquidity') })) })));
        }
    };
    return (jsxRuntime.jsxs(RemoveWrapper, { children: [showRemoveTab && (jsxRuntime.jsx(Box, Object.assign({ mt: "5px", width: "100%", mb: "5px" }, { children: jsxRuntime.jsx(ToggleButtons, { options: [REMOVE_TYPE.FARM, REMOVE_TYPE.LIQUIDITY], value: removeType, onChange: (value) => {
                        setRemoveType(value);
                    } }) }))), removeType === REMOVE_TYPE.FARM ? (jsxRuntime.jsx(RemoveFarm, { stakingInfo: stakingInfo, onClose: onClose, version: version, onLoadingOrComplete: (isLoadingOrComplete) => {
                    setShowRemoveTab(!isLoadingOrComplete);
                }, redirectToCompound: redirectToCompound })) : (renderRemoveContent())] }));
};

const RemoveDrawer = ({ isOpen, onClose, stakingInfo, version, redirectToCompound }) => {
    const { t } = reactI18next.useTranslation();
    return (jsxRuntime.jsx(Drawer, Object.assign({ title: t('removeLiquidity.remove'), isOpen: isOpen, onClose: onClose }, { children: isOpen && (jsxRuntime.jsx(Remove, { stakingInfo: stakingInfo, onClose: onClose, version: version, redirectToCompound: redirectToCompound })) })));
};

const ClaimWrapper = styled__default["default"](Box) `
  width: 100%;
  height: 100%;
`;
const Root$8 = styled__default["default"](Box) `
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 0px 10px;
`;
styled__default["default"](Box) `
  display: grid;
  grid-template-columns: ${({ isSuperFarm }) => isSuperFarm ? 'minmax(auto, 50%) minmax(auto, 50%)' : 'minmax(auto, 100%)'};
  grid-gap: 8px;
  justify-content: center;
`;
const ErrorWrapper$2 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ErrorBox$2 = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const Buttons$6 = styled__default["default"](Box) `
  display: grid;
  grid-gap: 10px;
  grid-template-columns: 1fr 1fr;
  margin-top: 10px;
  margin-bottom: 10px;
`;

const ClaimRewardV3 = ({ stakingInfo, onClose, redirectToCompound }) => {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const theme = React.useContext(styled.ThemeContext);
    const png = PNG[chainId];
    // monitor call to help UI loading state
    const addTransaction = useTransactionAdder();
    const [hash, setHash] = React.useState();
    const [attempting, setAttempting] = React.useState(false);
    const [claimError, setClaimError] = React.useState();
    const pangoChefContract = usePangoChefContract();
    function wrappedOnDismiss() {
        setHash(undefined);
        setAttempting(false);
        setClaimError(undefined);
        onClose();
    }
    function onClaimReward() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (pangoChefContract && (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
                setAttempting(true);
                try {
                    const method = stakingInfo.poolType === PoolType.RELAYER_POOL ? 'claim' : 'harvest';
                    const response = yield pangoChefContract[method](stakingInfo.pid);
                    yield waitForTransaction(response, 1);
                    addTransaction(response, {
                        summary: t('earn.claimAccumulated', { symbol: png.symbol }),
                    });
                    setHash(response.hash);
                }
                catch (error) {
                    const err = error;
                    // we only care if the error is something _other_ than the user rejected the tx
                    if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                        setClaimError(err === null || err === void 0 ? void 0 : err.message);
                        console.error(err);
                    }
                }
                finally {
                    setAttempting(false);
                }
            }
        });
    }
    let _error;
    if (!account) {
        _error = t('earn.connectWallet');
    }
    if (!(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount)) {
        _error = _error !== null && _error !== void 0 ? _error : t('earn.enterAmount');
    }
    return (jsxRuntime.jsxs(ClaimWrapper, { children: [!attempting && !hash && !claimError && (jsxRuntime.jsxs(Root$8, { children: [jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", padding: "20px", bgColor: "color3", borderRadius: "8px", margin: "auto" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1", textAlign: "center" }, { children: t('pangoChef.claimWarning2') })) })), jsxRuntime.jsxs(Buttons$6, { children: [jsxRuntime.jsx(Button, Object.assign({ variant: "outline", onClick: onClaimReward, color: theme.text10 }, { children: _error !== null && _error !== void 0 ? _error : t('earn.claimReward', { symbol: png.symbol }) })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: redirectToCompound }, { children: t('sarCompound.compound') }))] })] })), claimError && (jsxRuntime.jsxs(ErrorWrapper$2, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxRuntime.jsxs(ErrorBox$2, { children: [jsxRuntime.jsx(reactFeather.AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'red1', textAlign: "center", style: { width: '85%' } }, { children: claimError }))] }), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] }))), attempting && !hash && jsxRuntime.jsx(Loader, { size: 100, label: `${t('sarClaim.pending')}...` }), hash && jsxRuntime.jsx(TransactionCompleted, { onClose: wrappedOnDismiss, submitText: "Your rewards claimed" })] }));
};

const CompoundWrapper = styled__default["default"](Box) `
  width: 100%;
  height: 100%;
`;
const Root$7 = styled__default["default"](Box) `
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 0px 10px 10px 10px !important;
`;
styled__default["default"](Box) `
  display: grid;
  grid-gap: 8px;
  justify-content: center;
`;
const ErrorWrapper$1 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ErrorBox$1 = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const Buttons$5 = styled__default["default"](Box) `
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(0, 1fr);
  grid-gap: 10px;
  align-self: end;
`;

const CompoundV3 = ({ stakingInfo, onClose }) => {
    var _a, _b, _c;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const theme = React.useContext(styled.ThemeContext);
    // monitor call to help UI loading state
    const addTransaction = useTransactionAdder();
    const [confirm, setConfirm] = React.useState(false);
    const [hash, setHash] = React.useState();
    const [attempting, setAttempting] = React.useState(false);
    const [compoundError, setCompound] = React.useState();
    const pangoChefContract = usePangoChefContract();
    function wrappedOnDismiss() {
        setHash(undefined);
        setAttempting(false);
        setCompound(undefined);
        onClose();
    }
    const png = PNG[chainId];
    const wrappedCurrency = sdk.WAVAX[chainId];
    const currency = sdk.CAVAX[chainId];
    const [token0, token1] = stakingInfo.tokens;
    const [, pair] = usePair(token0, token1);
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const useETHBalances = useAccountBalanceHook[chainId];
    const currencyBalance = useETHBalances(chainId, [account !== null && account !== void 0 ? account : ZERO_ADDRESS]);
    const tokensBalances = useTokenBalances(account !== null && account !== void 0 ? account : ZERO_ADDRESS, [token0, token1]);
    const isPNGPool = token0.equals(png) || token1.equals(png);
    const isWrappedCurrencyPool = token0.equals(wrappedCurrency) || token1.equals(wrappedCurrency);
    const tokensToGetPrice = [token0, token1];
    if (!isPNGPool) {
        tokensToGetPrice.push(png);
    }
    const tokensPrices = useTokensCurrencyPrice(tokensToGetPrice);
    let message = '';
    let _error;
    if (!account) {
        _error = t('earn.connectWallet');
    }
    if (!(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) || stakingInfo.stakedAmount.equalTo('0')) {
        _error = _error !== null && _error !== void 0 ? _error : t('earn.enterAmount');
    }
    const earnedAmount = stakingInfo.earnedAmount;
    const pngPrice = (_a = tokensPrices[png.address]) !== null && _a !== void 0 ? _a : new sdk.Price(png, wrappedCurrency, '1', '0');
    let amountToAdd = new sdk.TokenAmount(wrappedCurrency, '0');
    // if is png pool and not is wrapped token as second token (eg PNG/USDC, PSB/SDOOD)
    if (isPNGPool && !isWrappedCurrencyPool) {
        // need to calculate the token price in png, for this we using the token price on currency and png price on currency
        const token = token0.equals(png) ? token1 : token0;
        const tokenBalance = tokensBalances[token.address];
        const tokenPrice = (_b = tokensPrices[token.address]) !== null && _b !== void 0 ? _b : new sdk.Price(token, wrappedCurrency, '1', '0');
        const tokenPngPrice = pngPrice.equalTo('0') ? new sdk.Fraction('0') : pngPrice.divide(tokenPrice);
        amountToAdd = new sdk.TokenAmount(token, tokenPngPrice.multiply(earnedAmount.raw).toFixed(0));
        if (amountToAdd.greaterThan(tokenBalance !== null && tokenBalance !== void 0 ? tokenBalance : '0')) {
            _error = _error !== null && _error !== void 0 ? _error : t('stakeHooks.insufficientBalance', { symbol: token.symbol });
        }
        message += `${t('pangoChef.compoundAmountWarning', {
            amount: numeral__default["default"](amountToAdd.toFixed(2)).format('0.00a'),
            symbol: token.symbol,
        })} ${t('pangoChef.compoundAmountWarning2', {
            symbol: token.symbol,
            png: png.symbol,
        })}`;
    }
    else {
        amountToAdd = sdk.CurrencyAmount.ether(pngPrice.raw.multiply(earnedAmount.raw).toFixed(0), chainId);
        if (amountToAdd.greaterThan(currencyBalance ? (_c = currencyBalance[account !== null && account !== void 0 ? account : ZERO_ADDRESS]) !== null && _c !== void 0 ? _c : '0' : '0')) {
            _error = _error !== null && _error !== void 0 ? _error : t('stakeHooks.insufficientBalance', { symbol: currency.symbol });
        }
        message += t('pangoChef.compoundAmountWarning', {
            amount: numeral__default["default"](amountToAdd.toFixed(2)).format('0.00a'),
            symbol: currency.symbol,
        });
    }
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = React.useState(false);
    const [approval, approveCallback] = useApproveCallback(chainId, amountToAdd, pangoChefContract === null || pangoChefContract === void 0 ? void 0 : pangoChefContract.address);
    React.useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const showApproveFlow = !_error &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED)) &&
        amountToAdd instanceof sdk.TokenAmount;
    const handleApprove = React.useCallback(() => tslib.__awaiter(void 0, void 0, void 0, function* () {
        yield approveCallback();
    }), [approveCallback]);
    const userRewardRate = useUserPangoChefRewardRate(stakingInfo);
    /*
    Let's say you get 1 png per sec, and 1 png equals 1 avax.
    In 10 secs you have 10 png rewards. you make a tx to send 10 avax.
    5 more seconds pass until you do the transaction, so you have 15 png rewards, and it needs to be paired with 15 avax. so tx will revert. bad for ux.
    The less pending rewards you have the more pronounced the issue. so you have to wait an hour or so, such that the rewards you receive do not so rapidly increase in proportion to your pending rewards. that's why we have to grey it out.
  
    1% slippage we have to hard code, otherwise any tx changing the reserve amounts in the pool would make it revert.
    also even after an hour or so, the rewards keep consantly increase, so 0% slippage would never work.
    */
    if (!sdk.JSBI.greaterThan(sdk.JSBI.divide(earnedAmount.raw, sdk.JSBI.BigInt(userRewardRate.isZero() ? '1' : userRewardRate.toString())), sdk.JSBI.BigInt(30 * 55))) {
        _error = _error !== null && _error !== void 0 ? _error : t('pangoChef.highVolalityWarning');
    }
    const tokenOrCurrency = amountToAdd instanceof sdk.TokenAmount ? amountToAdd.token : amountToAdd.currency;
    // Minimium amount to compound
    if (sdk.JSBI.LE(amountToAdd.raw, utils.parseUnits('0.0001', tokenOrCurrency.decimals).toString())) {
        _error = _error !== null && _error !== void 0 ? _error : t('pangoChef.highVolalityWarning');
    }
    function onCompound() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (pangoChefContract && (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) && pair && !_error) {
                setAttempting(true);
                try {
                    const method = isPNGPool ? 'compound' : 'compoundToPoolZero';
                    const minPairAmount = sdk.JSBI.BigInt(ONE_FRACTION.subtract(PANGOCHEF_COMPOUND_SLIPPAGE).multiply(amountToAdd.raw).toFixed(0));
                    const maxPairAmount = sdk.JSBI.BigInt(ONE_FRACTION.add(PANGOCHEF_COMPOUND_SLIPPAGE).multiply(amountToAdd.raw).toFixed(0));
                    // the minPairAmount and maxPairAmount is amount of other token/currency to sent to compound with slippage tolerance
                    const slippage = {
                        minPairAmount: sdk.JSBI.lessThan(minPairAmount, sdk.JSBI.BigInt(0)) ? '0x0' : `0x${minPairAmount.toString(16)}`,
                        maxPairAmount: `0x${maxPairAmount.toString(16)}`,
                    };
                    const estimatedGas = yield pangoChefContract.estimateGas[method](Number(stakingInfo.pid).toString(16), slippage, { value: amountToAdd instanceof sdk.TokenAmount ? '0x0' : `0x${maxPairAmount.toString(16)}` });
                    const response = yield pangoChefContract[method](Number(stakingInfo.pid).toString(16), slippage, {
                        gasLimit: calculateGasMargin(estimatedGas),
                        value: amountToAdd instanceof sdk.TokenAmount ? '0x0' : `0x${maxPairAmount.toString(16)}`,
                    });
                    yield waitForTransaction(response, 1);
                    addTransaction(response, {
                        summary: t('pangoChef.compoundTransactionSummary'),
                    });
                    setHash(response.hash);
                }
                catch (error) {
                    const err = error;
                    // we only care if the error is something _other_ than the user rejected the tx
                    if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                        setCompound(err === null || err === void 0 ? void 0 : err.message);
                        console.error(err);
                    }
                }
                finally {
                    setAttempting(false);
                }
            }
        });
    }
    const renderDrawer = () => {
        if (compoundError) {
            return (jsxRuntime.jsxs(ErrorWrapper$1, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxRuntime.jsxs(ErrorBox$1, { children: [jsxRuntime.jsx(reactFeather.AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'red1', textAlign: "center", style: { width: '85%' } }, { children: compoundError }))] }), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] })));
        }
        if (attempting) {
            return jsxRuntime.jsx(Loader, { size: 100, label: `${t('sarCompound.pending')}...` });
        }
        if (hash) {
            return jsxRuntime.jsx(TransactionCompleted, { onClose: wrappedOnDismiss, submitText: t('pangoChef.compoundSuccess') });
        }
    };
    const confirmContent = (jsxRuntime.jsxs(Box, Object.assign({ display: "grid", padding: "10px", style: { gap: '10px' }, height: "100%" }, { children: [jsxRuntime.jsx(TextInput, { addonAfter: jsxRuntime.jsx(Box, Object.assign({ padding: "5px", bgColor: "color2", borderRadius: "8px" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: tokenOrCurrency.symbol })) })), disabled: true, value: units.formatUnits(amountToAdd.raw.toString(), tokenOrCurrency.decimals) }), jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", padding: "20px", bgColor: "color3", borderRadius: "8px", margin: "auto", width: "100%", flexGrow: 1 }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1", textAlign: "center", fontSize: "12px" }, { children: message })) })), jsxRuntime.jsxs(Buttons$5, { children: [showApproveFlow && (jsxRuntime.jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', isDisabled: approval !== ApprovalState.NOT_APPROVED, onClick: handleApprove, height: "46px" }, { children: t('earn.approve') }))), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", isDisabled: !!_error, onClick: onCompound }, { children: _error !== null && _error !== void 0 ? _error : `${t('sarStakeMore.add')} & ${t('sarCompound.compound')}` }))] })] })));
    return (jsxRuntime.jsx(CompoundWrapper, { children: !confirm ? (jsxRuntime.jsxs(Root$7, { children: [jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", padding: "10px", bgColor: "color3", borderRadius: "8px", margin: "auto", flexGrow: 1 }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1", textAlign: "center" }, { children: t('pangoChef.compoundWarning', {
                            token0: currency0.symbol,
                            token1: currency1.symbol,
                            currency: isPNGPool ? currency0.symbol : currency.symbol,
                            png: isPNGPool ? currency1.symbol : png.symbol,
                        }) })) })), jsxRuntime.jsx(Box, Object.assign({ width: "100%", mt: "10px" }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: () => setConfirm(true) }, { children: t('sarCompound.compound') })) }))] })) : !compoundError && !attempting && !hash ? (confirmContent) : (renderDrawer()) }));
};

const Wrapper$8 = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  overflow: hidden;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.color2};
  margin-top: 10px;
  padding: 10px;
  height: 310px;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;
const InnerWrapper$3 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: 50% 50%;
  grid-gap: 12px;
  margin-top: 10px;
`;
const Container = styled__default["default"](Box) `
  display: grid;
  grid-gap: 5px;
  margin-top: 10px;
  flex: 1;
  width: 100%;
`;
const Buttons$4 = styled__default["default"](Box) `
  display: grid;
  grid-gap: 10px;
  grid-template-columns: 1fr 1fr;
  margin-top: 10px;
`;

const EarnedDetailV3 = ({ stakingInfo, version }) => {
    var _a;
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const [isClaimDrawerVisible, setShowClaimDrawer] = React.useState(false);
    const [isCompoundDrawerVisible, setShowCompoundDrawer] = React.useState(false);
    const [isRemoveDrawerVisible, setShowRemoveDrawer] = React.useState(false);
    const { rewardTokensAmount, rewardTokensMultiplier } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_a = (rewardTokensAmount || [])) === null || _a === void 0 ? void 0 : _a.length) > 0;
    const earnedAmount = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount;
    const redirectToCompound = () => {
        setShowClaimDrawer(false);
        setShowRemoveDrawer(false);
        setShowCompoundDrawer(true);
    };
    const onClose = () => {
        setShowClaimDrawer(false);
        setShowRemoveDrawer(false);
        setShowCompoundDrawer(false);
    };
    const drawerTitle = () => {
        if (isClaimDrawerVisible) {
            return t('earn.claim');
        }
        if (isRemoveDrawerVisible) {
            return t('removeLiquidity.remove');
        }
        return t('sarCompound.compound');
    };
    const theme = React.useContext(styled.ThemeContext);
    const isDisabledButtons = !(earnedAmount === null || earnedAmount === void 0 ? void 0 : earnedAmount.greaterThan(BIG_INT_ZERO));
    const png = PNG[chainId];
    const lockingPoolZeroPairs = useIsLockingPoolZero();
    const isLockingToPoolZero = lockingPoolZeroPairs.length > 0 && stakingInfo.pid === '0';
    return (jsxRuntime.jsxs(Wrapper$8, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: t('dashboardPage.earned') })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", width: "100px", height: "30px", onClick: () => setShowRemoveDrawer(true), isDisabled: isLockingToPoolZero }, { children: t('removeLiquidity.remove') }))] })), jsxRuntime.jsxs(Container, { children: [jsxRuntime.jsxs(Box, Object.assign({ width: "100%" }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: "12px", color: "text1", textAlign: "center" }, { children: t('earn.unclaimedReward', { symbol: png.symbol }) })), jsxRuntime.jsx(Tooltip, Object.assign({ id: "earnedAmount", effect: "solid", backgroundColor: theme.primary }, { children: jsxRuntime.jsxs(Text, Object.assign({ color: "eerieBlack", fontSize: "12px", fontWeight: 500, textAlign: "center" }, { children: [units.formatEther(earnedAmount.raw.toString()), " ", png.symbol] })) })), jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "16px", fontWeight: 700, textAlign: "center", "data-tip": true, "data-for": "earnedAmount" }, { children: earnedAmount.toFixed(2) }))] })), isSuperFarm && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (rewardTokensAmount || []).map((reward, index) => {
                            var _a, _b, _c, _d;
                            const tokenMultiplier = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier[index];
                            const extraTokenWeeklyRewardRate = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getExtraTokensWeeklyRewardRate) === null || _a === void 0 ? void 0 : _a.call(stakingInfo, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek, reward === null || reward === void 0 ? void 0 : reward.token, tokenMultiplier);
                            return (jsxRuntime.jsxs(InnerWrapper$3, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { stat: `${(_b = extraTokenWeeklyRewardRate === null || extraTokenWeeklyRewardRate === void 0 ? void 0 : extraTokenWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })) !== null && _b !== void 0 ? _b : '-'} `, statFontSize: [20, 18], currency: reward === null || reward === void 0 ? void 0 : reward.token }) }), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { stat: `${(_d = reward === null || reward === void 0 ? void 0 : reward.toFixed(Math.min(6, (_c = reward.token) === null || _c === void 0 ? void 0 : _c.decimals))) !== null && _d !== void 0 ? _d : '0'}`, statFontSize: [20, 18], currency: reward === null || reward === void 0 ? void 0 : reward.token }) })] }, index));
                        }) })), jsxRuntime.jsx(Box, Object.assign({ bgColor: "color3", borderRadius: "8px", padding: "20px", justifyContent: "center", alignItems: "center", display: "flex" }, { children: jsxRuntime.jsx(Text, Object.assign({ fontSize: "12px", color: "text1", textAlign: "center" }, { children: isLockingToPoolZero
                                ? `${t('pangoChef.lockingPoolZeroWarning')}${lockingPoolZeroPairs
                                    .map((pair) => `${unwrappedToken(pair[0], chainId).symbol}-${unwrappedToken(pair[1], chainId).symbol}`)
                                    .join(', ')}.`
                                : t('pangoChef.claimWarning1') })) }))] }), jsxRuntime.jsxs(Buttons$4, { children: [jsxRuntime.jsx(Button, Object.assign({ padding: "10px", variant: "outline", isDisabled: isDisabledButtons || isLockingToPoolZero, onClick: () => setShowClaimDrawer(true), color: !isDisabledButtons && !isLockingToPoolZero ? theme.text10 : undefined }, { children: t('earnPage.claim') })), jsxRuntime.jsx(Button, Object.assign({ padding: "10px", isDisabled: isDisabledButtons, variant: "primary", onClick: () => setShowCompoundDrawer(true) }, { children: t('sarCompound.compound') }))] }), jsxRuntime.jsxs(Drawer, Object.assign({ title: drawerTitle(), isOpen: isClaimDrawerVisible || isCompoundDrawerVisible, onClose: onClose }, { children: [isClaimDrawerVisible && (jsxRuntime.jsx(ClaimRewardV3, { onClose: () => setShowClaimDrawer(false), redirectToCompound: redirectToCompound, stakingInfo: stakingInfo })), isCompoundDrawerVisible && (jsxRuntime.jsx(CompoundV3, { onClose: () => setShowCompoundDrawer(false), stakingInfo: stakingInfo }))] })), jsxRuntime.jsx(RemoveDrawer, { isOpen: isRemoveDrawerVisible, onClose: () => {
                    setShowRemoveDrawer(false);
                }, stakingInfo: stakingInfo, version: version, redirectToCompound: redirectToCompound })] }));
};

const StateContainer = styled__default["default"].div `
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  display: grid;
  width: 100%;
  align-items: start;
  margin-top: 12px;

  @media screen and (max-width: 1024px) {
    grid-template-columns: 1fr;
    align-items: stretch;
  }

  ${({ theme }) => theme.mediaWidth.upToSmall `
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    grid-column-gap: 6px;
    grid-row-gap:6px;
  `};
`;

function StatDetail({ title, totalAmount, pair, arl, currency0, currency1, link }) {
    const totalPoolTokens = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);
    const [token0Deposited, token1Deposited] = !!pair &&
        !!totalPoolTokens &&
        !!arl &&
        sdk.JSBI.greaterThan(totalPoolTokens.raw, BIG_INT_ZERO) &&
        sdk.JSBI.greaterThan(arl.raw, BIG_INT_ZERO) &&
        // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply
        sdk.JSBI.greaterThanOrEqual(totalPoolTokens.raw, arl.raw)
        ? pair.getLiquidityValues(totalPoolTokens, arl, { feeOn: false })
        : [undefined, undefined];
    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: 24, fontWeight: 400, style: { display: 'flex', gap: '1rem' } }, { children: [title, link && (jsxRuntime.jsx(AnalyticsLink, Object.assign({ href: link, target: "_blank" }, { children: jsxRuntime.jsx("img", { src: AnalyticsIcon, alt: "analytics-icon" }) })))] })), jsxRuntime.jsxs(StateContainer, { children: [jsxRuntime.jsx(Stat, { title: title, stat: totalAmount !== null && totalAmount !== void 0 ? totalAmount : '-', titlePosition: "top", titleFontSize: 12, statFontSize: [20, 16], titleColor: "text2" }), currency0 && (jsxRuntime.jsx(Stat, { title: `Underlying ${(currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol) ? currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol : ''}`, stat: `${token0Deposited ? numeral__default["default"](parseFloat(token0Deposited === null || token0Deposited === void 0 ? void 0 : token0Deposited.toSignificant(6))).format('0.00a') : '-'}`, titlePosition: "top", titleFontSize: 12, statFontSize: [20, 16], titleColor: "text2", currency: currency0, showAnalytics: true })), currency1 && (jsxRuntime.jsx(Stat, { title: `Underlying ${(currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol) ? currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol : ''}`, stat: `${token1Deposited ? numeral__default["default"](parseFloat(token1Deposited === null || token1Deposited === void 0 ? void 0 : token1Deposited.toSignificant(6))).format('0.00a') : '-'}`, titlePosition: "top", titleFontSize: 12, statFontSize: [20, 16], titleColor: "text2", currency: currency1, showAnalytics: true }))] })] }));
}

const DetailsContainer = styled__default["default"](Box) `
  overflow: hidden;
  width: 100%;
  background-color: ${({ theme }) => theme.bg2};
  padding: 20px;
  flex: 1;
  display: flex;
  flex-direction: column;
`;

const Details = ({ stakingInfo }) => {
    var _a, _b;
    const { account } = usePangolinWeb3();
    const token0 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[0];
    const token1 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[1];
    const chainId = useChainId();
    const totalStakedInUsd = ((_a = sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet)
        ? numeral__default["default"](stakingInfo.totalStakedInUsd.toSignificant(4)).format('$0.00a')
        : numeral__default["default"](stakingInfo.totalStakedInUsd).format('$0.00a');
    const yourStakeInUsd = ((_b = sdk.CHAINS[chainId]) === null || _b === void 0 ? void 0 : _b.mainnet)
        ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd.multiply(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount).divide(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount)
        : undefined;
    const [, stakingTokenPair] = usePair(token0, token1);
    const pair = stakingTokenPair;
    const { userPgl, liquidityInUSD } = useGetPoolDollerWorth(pair);
    const isStaking = Boolean(stakingInfo.stakedAmount.greaterThan('0'));
    // if pair is available then taking tokens from pair otherwise display tokens from staking info
    // we are taking token from pair because sometime order of tokens is different
    const tokenA = (pair === null || pair === void 0 ? void 0 : pair.token0) || token0;
    const tokenB = (pair === null || pair === void 0 ? void 0 : pair.token1) || token1;
    const currency0 = tokenA ? unwrappedToken(tokenA, chainId) : undefined;
    const currency1 = tokenB ? unwrappedToken(tokenB, chainId) : undefined;
    const yourLiquidity = liquidityInUSD ? `${numeral__default["default"](liquidityInUSD).format('$0.00a')}` : '-';
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs(DetailsContainer, { children: [jsxRuntime.jsx(StatDetail, { title: `Total Stake`, currency0: currency0, currency1: currency1, pair: pair, totalAmount: `${totalStakedInUsd}`, arl: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount, link: `${ANALYTICS_PAGE}/#/pair/${pair === null || pair === void 0 ? void 0 : pair.liquidityToken.address}` }), (userPgl === null || userPgl === void 0 ? void 0 : userPgl.greaterThan('0')) && (jsxRuntime.jsx(Box, Object.assign({ mt: 25 }, { children: jsxRuntime.jsx(StatDetail, { title: `Your Liquidity`, currency0: currency0, currency1: currency1, pair: pair, totalAmount: yourLiquidity, arl: userPgl, link: `${ANALYTICS_PAGE}/#/account/${account}` }) }))), isStaking && (jsxRuntime.jsx(Box, Object.assign({ mt: 25 }, { children: jsxRuntime.jsx(StatDetail, { title: `Your Stake`, currency0: currency0, currency1: currency1, pair: pair, totalAmount: `${numeral__default["default"](yourStakeInUsd === null || yourStakeInUsd === void 0 ? void 0 : yourStakeInUsd.toFixed(2)).format('$0.00a')}`, arl: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount, link: `${ANALYTICS_PAGE}/#/account/${account}` }) }))), currency0 !== sdk.CAVAX[chainId] && currency0 instanceof sdk.Token && (jsxRuntime.jsx(Box, Object.assign({ mt: 20 }, { children: jsxRuntime.jsx(CoinDescription, { coin: currency0 }) }))), currency1 !== sdk.CAVAX[chainId] && currency1 instanceof sdk.Token && (jsxRuntime.jsx(Box, Object.assign({ mt: 20 }, { children: jsxRuntime.jsx(CoinDescription, { coin: currency1 }) })))] }) }));
};

const Wrapper$7 = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  overflow: hidden;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg2};
  margin-top: 10px;
  padding: 10px;
  height: 295px;
  display: flex;
  flex-direction: column;
  * {
    box-sizing: border-box;
  }
`;
const InnerWrapper$2 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: 50% 50%;
  grid-gap: 12px;
  margin-top: 10px;
`;

const EarnedDetail = ({ stakingInfo, version }) => {
    var _a, _b, _c, _d;
    const { t } = reactI18next.useTranslation();
    const chainId = useChainId();
    const [isClaimDrawerVisible, setShowClaimDrawer] = React.useState(false);
    const [isRemoveDrawerVisible, setShowRemoveDrawer] = React.useState(false);
    const { rewardTokensAmount, rewardTokensMultiplier } = useMinichefPendingRewards(stakingInfo);
    const isSuperFarm = ((_a = (rewardTokensAmount || [])) === null || _a === void 0 ? void 0 : _a.length) > 0;
    const png = PNG[chainId]; // add PNG as default reward
    const { earnedAmount } = useGetEarnedAmount(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const newEarnedAmount = version < 2 ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.earnedAmount : earnedAmount;
    return (jsxRuntime.jsxs(Wrapper$7, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: t('dashboardPage.earned') })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", width: "100px", height: "30px", onClick: () => setShowRemoveDrawer(true) }, { children: t('removeLiquidity.remove') }))] })), jsxRuntime.jsxs(Box, Object.assign({ flex: "1" }, { children: [jsxRuntime.jsxs(InnerWrapper$2, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { title: t('dashboardPage.earned_weeklyIncome'), stat: `${(_c = (_b = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek) === null || _b === void 0 ? void 0 : _b.toSignificant(4, { groupSeparator: ',' })) !== null && _c !== void 0 ? _c : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 18], titleColor: "text2", currency: png }) }), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { title: t('dashboardPage.earned_totalEarned'), stat: `${(_d = newEarnedAmount === null || newEarnedAmount === void 0 ? void 0 : newEarnedAmount.toFixed(6)) !== null && _d !== void 0 ? _d : '0'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 18], titleColor: "text2", currency: png }) })] }), isSuperFarm && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (rewardTokensAmount || []).map((reward, index) => {
                            var _a, _b, _c, _d;
                            const tokenMultiplier = rewardTokensMultiplier === null || rewardTokensMultiplier === void 0 ? void 0 : rewardTokensMultiplier[index];
                            const extraTokenWeeklyRewardRate = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.getExtraTokensWeeklyRewardRate) === null || _a === void 0 ? void 0 : _a.call(stakingInfo, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardRatePerWeek, reward === null || reward === void 0 ? void 0 : reward.token, tokenMultiplier);
                            return (jsxRuntime.jsxs(InnerWrapper$2, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { stat: `${(_b = extraTokenWeeklyRewardRate === null || extraTokenWeeklyRewardRate === void 0 ? void 0 : extraTokenWeeklyRewardRate.toSignificant(4, { groupSeparator: ',' })) !== null && _b !== void 0 ? _b : '-'} `, statFontSize: [20, 18], currency: reward === null || reward === void 0 ? void 0 : reward.token }) }), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { stat: `${(_d = reward === null || reward === void 0 ? void 0 : reward.toFixed(Math.min(6, (_c = reward.token) === null || _c === void 0 ? void 0 : _c.decimals))) !== null && _d !== void 0 ? _d : '0'}`, statFontSize: [20, 18], currency: reward === null || reward === void 0 ? void 0 : reward.token }) })] }, index));
                        }) }))] })), jsxRuntime.jsx(Box, Object.assign({ mt: 10 }, { children: jsxRuntime.jsx(Button, Object.assign({ padding: "15px 18px", isDisabled: !(newEarnedAmount === null || newEarnedAmount === void 0 ? void 0 : newEarnedAmount.greaterThan(BIG_INT_ZERO)), variant: "primary", onClick: () => setShowClaimDrawer(true) }, { children: t('earnPage.claim') })) })), jsxRuntime.jsx(ClaimDrawer, { isOpen: isClaimDrawerVisible, onClose: () => {
                    setShowClaimDrawer(false);
                }, stakingInfo: stakingInfo, version: version }), jsxRuntime.jsx(RemoveDrawer, { isOpen: isRemoveDrawerVisible, onClose: () => {
                    setShowRemoveDrawer(false);
                }, stakingInfo: stakingInfo, version: version })] }));
};

const HeaderRoot = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px;
  border-bottom: 1px solid ${({ theme }) => theme.text9};

  ${({ theme }) => theme.mediaWidth.upToSmall `
    border-bottom: none;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
  `};
`;
const StatsWrapper = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: repeat(${({ cheftType }) => (cheftType === sdk.ChefType.PANGO_CHEF ? 6 : 5)}, auto);
  grid-gap: 20px;
  align-items: center;
  ${({ theme }) => theme.mediaWidth.upToSmall `
    width: 100%;
    grid-gap: 10px;
    margin-top: 10px;
    grid-template-columns: 50% 50%;
`};
`;
const HeaderWrapper = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: space-between;
  ${({ theme }) => theme.mediaWidth.upToSmall `
    width: 100%
  `};
`;

const Header$1 = ({ stakingInfo, version, onClose }) => {
    var _a, _b, _c;
    const theme = React.useContext(styled.ThemeContext);
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const token0 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[0];
    const token1 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[1];
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const rewardTokens = useGetRewardTokens(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokens, stakingInfo.rewardTokensAddress);
    const { swapFeeApr: _swapFeeApr, stakingApr: _stakingApr } = useGetFarmApr(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const stakingApr = version !== 2 ? (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakingApr) || 0 : _stakingApr;
    const swapFeeApr = version !== 2 ? (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.swapFeeApr) || 0 : _swapFeeApr;
    const totalApr = stakingApr + swapFeeApr;
    const cheftType = (_c = (_b = (_a = sdk.CHAINS[chainId].contracts) === null || _a === void 0 ? void 0 : _a.mini_chef) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : sdk.ChefType.MINI_CHEF_V2;
    // old calculation, it's using if the userRewardRate is not broken
    //userApr = userRewardRate(POOL_ID, USER_ADDRESS) * 365 days * 100 * PNG_PRICE / (getUser(POOL_ID, USER_ADDRESS).valueVariables.balance * STAKING_TOKEN_PRICE)
    const userApr = useUserPangoChefAPR(cheftType === sdk.ChefType.PANGO_CHEF ? stakingInfo : undefined);
    return (jsxRuntime.jsxs(HeaderRoot, { children: [jsxRuntime.jsxs(HeaderWrapper, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsx(DoubleCurrencyLogo, { currency0: currency0, currency1: currency1, size: 48 }), jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500, marginLeft: 10 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] }))] })), jsxRuntime.jsx(Visible, Object.assign({ upToSmall: true }, { children: jsxRuntime.jsx(CloseIcon, { onClick: onClose, color: theme.text3 }) }))] }), jsxRuntime.jsxs(StatsWrapper, Object.assign({ cheftType: cheftType }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "inline-block" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontSize: 14 }, { children: t('earn.poolRewards') })), jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center", mt: "8px" }, { children: jsxRuntime.jsx(RewardTokens, { rewardTokens: rewardTokens, size: 24 }) }))] })), cheftType === sdk.ChefType.PANGO_CHEF && stakingInfo.stakedAmount.greaterThan('0') && (jsxRuntime.jsx(Stat, { title: `Your APR:`, stat: `${numeral__default["default"](userApr).format('0.00a')}%`, titlePosition: "top", titleFontSize: 14, statFontSize: [24, 18], titleColor: "text2" })), jsxRuntime.jsx(Stat, { title: `Swap fee APR:`, stat: swapFeeApr && !stakingInfo.isPeriodFinished ? `${numeral__default["default"](swapFeeApr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: 14, statFontSize: [24, 18], titleColor: "text2" }), jsxRuntime.jsx(Stat, { title: `Reward APR:`, stat: !stakingInfo.isPeriodFinished ? `${numeral__default["default"](stakingApr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: 14, statFontSize: [24, 18], titleColor: "text2" }), jsxRuntime.jsx(Stat, { title: `Total APR:`, stat: !stakingInfo.isPeriodFinished ? `${numeral__default["default"](totalApr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: 14, statFontSize: [24, 18], titleColor: "text2" }), jsxRuntime.jsx(Hidden, Object.assign({ upToSmall: true }, { children: jsxRuntime.jsx(CloseIcon, { onClick: onClose, color: theme.text3 }) }))] }))] }));
};

const DesktopWrapper = styled__default["default"](Box) `
  width: 1080px;
  overflow: auto;
  border-radius: 10px;
  ${({ theme }) => theme.mediaWidth.upToSmall `
    display: none;
  `};
  * {
    box-sizing: border-box;
  }
`;
const MobileWrapper = styled__default["default"](Box) `
  width: 100%;
  height: 100%;
  display: none;
  ${({ theme }) => theme.mediaWidth.upToSmall `
  display: block;
  overflow: scroll;
`};
`;
const LeftSection = styled__default["default"](Box) `
  border-right: 2px solid ${({ theme }) => theme.text9};
  display: flex;
  flex-direction: column;
`;
const DetailsWrapper = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: minmax(auto, 65%) minmax(auto, 35%);
  grid-gap: 0px;
`;
const Tabs$1 = styled__default["default"](Box) `
  width: 100%;
  display: flex;
  align-items: center;
`;
const Tab$1 = styled__default["default"](Box) `
  padding: 15px 50px;
  font-size: 18px;
  color: ${({ theme }) => theme.text10};
  background-color: ${({ theme }) => theme.bg2};

  ${({ theme }) => theme.mediaWidth.upToSmall `
    border-radius: 10px 10px 0 0;
  `};
`;
const RightSection = styled__default["default"](Box) `
  padding: 20px;
`;

const DetailView = ({ stakingInfo, onDismiss, version }) => {
    var _a;
    const { height } = reactUse.useWindowSize();
    const chainId = useChainId();
    const chain = sdk.CHAINS[chainId];
    const token0 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[0];
    const token1 = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens[1];
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const isStaking = Boolean((_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount) === null || _a === void 0 ? void 0 : _a.greaterThan('0'));
    const renderEarnedDetail = () => {
        var _a, _b;
        const miniChefType = (_b = (_a = chain.contracts) === null || _a === void 0 ? void 0 : _a.mini_chef) === null || _b === void 0 ? void 0 : _b.type;
        if (miniChefType === sdk.ChefType.PANGO_CHEF) {
            return jsxRuntime.jsx(EarnedDetailV3, { stakingInfo: stakingInfo, version: version });
        }
        return jsxRuntime.jsx(EarnedDetail, { stakingInfo: stakingInfo, version: version });
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(MobileWrapper, { children: [jsxRuntime.jsx(Header$1, { stakingInfo: stakingInfo, version: version, onClose: onDismiss }), jsxRuntime.jsxs(Box, Object.assign({ p: 10 }, { children: [isStaking && renderEarnedDetail(), jsxRuntime.jsx(Box, Object.assign({ mt: isStaking ? '10px' : '0px' }, { children: jsxRuntime.jsx(EarnWidget, { currencyA: currency0, currencyB: currency1, version: version, stakingInfo: stakingInfo }) })), jsxRuntime.jsxs(Box, Object.assign({ mt: 25 }, { children: [jsxRuntime.jsx(Tabs$1, { children: jsxRuntime.jsx(Tab$1, { children: "Details" }) }), jsxRuntime.jsx(Details, { stakingInfo: stakingInfo })] }))] }))] }), jsxRuntime.jsxs(DesktopWrapper, Object.assign({ style: { maxHeight: height - 150 } }, { children: [jsxRuntime.jsx(Header$1, { stakingInfo: stakingInfo, version: version, onClose: onDismiss }), jsxRuntime.jsxs(DetailsWrapper, { children: [jsxRuntime.jsxs(LeftSection, { children: [jsxRuntime.jsx(Tabs$1, { children: jsxRuntime.jsx(Tab$1, { children: "Details" }) }), jsxRuntime.jsx(Details, { stakingInfo: stakingInfo })] }), jsxRuntime.jsxs(RightSection, { children: [jsxRuntime.jsx(EarnWidget, { currencyA: currency0, currencyB: currency1, version: version, stakingInfo: stakingInfo }), isStaking && renderEarnedDetail()] })] })] }))] }));
};

const DetailModal = ({ stakingInfo, version }) => {
    const detailModalOpen = useModalOpen(ApplicationModal.POOL_DETAIL);
    const togglePoolDetailModal = usePoolDetailnModalToggle();
    const theme = React.useContext(styled.ThemeContext);
    const dispatch = useDispatch();
    React.useEffect(() => {
        dispatch(resetMintState());
    }, [detailModalOpen, dispatch]);
    return (jsxRuntime.jsx(Modal, Object.assign({ isOpen: detailModalOpen, onDismiss: togglePoolDetailModal, overlayBG: theme.modalBG2, closeOnClickOutside: false }, { children: jsxRuntime.jsx(DetailView, { stakingInfo: stakingInfo, onDismiss: togglePoolDetailModal, version: version }) })));
};

const PoolsWrapper = styled__default["default"](Box) `
  width: 100%;
  background-color: ${({ theme }) => theme.color8};
  padding: 10px;
  border-radius: 0px;
  overflow: hidden;
  color: ${({ theme }) => theme.text7};
  ${({ theme }) => theme.mediaWidth.upToSmall `
    padding-bottom : 50px;
  `};
`;
const LoadingWrapper = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
`;
const PanelWrapper$1 = styled__default["default"].div `
  grid-template-columns: repeat(auto-fill, minmax(360px, 1fr));
  grid-template-rows: max-content;
  gap: 15px;
  display: inline-grid;
  width: 100%;
  align-items: start;
  padding-bottom: 65px;

  @media screen and (max-width: 1024px) {
    grid-template-columns: 1fr;
    align-items: stretch;
    > * {
      grid-column: 1 / 4;
    }

    > * {
      &:first-child {
        width: 100%;
      }
    }
  }
`;
styled__default["default"](TextInput) `
  background-color: ${({ theme }) => theme.bg8};
`;
const MobileGridContainer = styled__default["default"](Box) `
  display: none;
  ${({ theme }) => theme.mediaWidth.upToSmall `
    display: grid;
    grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
    grid-gap: 8px;
    margin-bottom : 10px;
  `};
`;

var SortingType;
(function (SortingType) {
    SortingType["totalStakedInUsd"] = "totalStakedInUsd";
    SortingType["totalApr"] = "totalApr";
})(SortingType || (SortingType = {}));
const SortOptions = [
    {
        label: 'Liquidity',
        value: SortingType.totalStakedInUsd,
    },
    {
        label: 'APR',
        value: SortingType.totalApr,
    },
];
const PoolCardListView = ({ version, setMenu, activeMenu, menuItems, handleSearch, sortBy, searchQuery, onChangeSortBy, isLoading, doesNotPoolExist, children, selectedPool, }) => {
    const { t } = reactI18next.useTranslation();
    const theme = React.useContext(styled.ThemeContext);
    const renderPoolCardListView = () => {
        if (isLoading && !searchQuery)
            return (jsxRuntime.jsx(LoadingWrapper, {}));
        else if (doesNotPoolExist && !searchQuery) {
            return (jsxRuntime.jsx(Box, Object.assign({ textAlign: "center", color: "color4" }, { children: t('earnPage.noActiveRewards') })));
        }
        else {
            return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", mb: 10 }, { children: [jsxRuntime.jsx(Box, Object.assign({ width: "100%" }, { children: jsxRuntime.jsx(TextInput, { placeholder: t('searchModal.tokenName'), onChange: handleSearch, value: searchQuery, id: "token-search-input", addonAfter: jsxRuntime.jsx(reactFeather.Search, { style: { marginTop: '5px' }, color: theme.text2, size: 20 }) }) })), jsxRuntime.jsx(Hidden, Object.assign({ upToSmall: true }, { children: jsxRuntime.jsx(Box, Object.assign({ ml: 10 }, { children: jsxRuntime.jsx(DropdownMenu, { placeHolder: "Sort by:", options: SortOptions, defaultValue: sortBy, onSelect: (value) => {
                                                    onChangeSortBy(value);
                                                }, height: "54px" }) })) }))] })), jsxRuntime.jsxs(MobileGridContainer, { children: [jsxRuntime.jsx(DropdownMenu, { options: menuItems, defaultValue: activeMenu, onSelect: (value) => {
                                            setMenu(value);
                                        } }), jsxRuntime.jsx(DropdownMenu, { placeHolder: "Sort by:", options: SortOptions, defaultValue: sortBy, onSelect: (value) => {
                                            onChangeSortBy(value);
                                        } })] })] }), doesNotPoolExist && searchQuery ? (jsxRuntime.jsx(Box, Object.assign({ textAlign: "center", color: "color4" }, { children: t('pool.noFarms') }))) : (jsxRuntime.jsx(Scrollbars__default["default"], { children: jsxRuntime.jsx(PanelWrapper$1, { children: children }) }))] }));
        }
    };
    return (jsxRuntime.jsxs(PoolsWrapper, { children: [renderPoolCardListView(), jsxRuntime.jsx(DetailModal, { stakingInfo: selectedPool, version: Number(version) })] }));
};

const PoolListV1 = ({ version, stakingInfos, setMenu, activeMenu, menuItems }) => {
    const chainId = useChainId();
    const [poolCardsLoading, setPoolCardsLoading] = React.useState(false);
    const [poolCards, setPoolCards] = React.useState();
    const [filteredPoolCards, setFilteredPoolCards] = React.useState();
    const [searchQuery, setSearchQuery] = React.useState('');
    const [sortBy, setSortBy] = React.useState('');
    const debouncedSearchQuery = useDebounce(searchQuery, 250);
    const [stakingInfoData, setStakingInfoData] = React.useState(stakingInfos);
    const [selectedPoolIndex, setSelectedPoolIndex] = React.useState(-1);
    const togglePoolDetailModal = usePoolDetailnModalToggle();
    const handleSearch = React.useCallback((value) => {
        setSearchQuery(value.trim().toUpperCase());
    }, []);
    React.useEffect(() => {
        const filtered = poolCards === null || poolCards === void 0 ? void 0 : poolCards.filter((card) => {
            var _a, _b, _c, _d;
            return ((_b = (_a = card === null || card === void 0 ? void 0 : card.props) === null || _a === void 0 ? void 0 : _a.stakingInfo) === null || _b === void 0 ? void 0 : _b.tokens[0].symbol.toUpperCase().includes(debouncedSearchQuery)) ||
                ((_d = (_c = card === null || card === void 0 ? void 0 : card.props) === null || _c === void 0 ? void 0 : _c.stakingInfo) === null || _d === void 0 ? void 0 : _d.tokens[1].symbol.toUpperCase().includes(debouncedSearchQuery));
        });
        setFilteredPoolCards(filtered);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [poolCards, debouncedSearchQuery]);
    React.useEffect(() => {
        Promise.all(stakingInfoData.sort(function (info_a, info_b) {
            var _a, _b;
            if (sortBy === SortingType.totalStakedInUsd) {
                return ((_a = info_a.totalStakedInUsd) === null || _a === void 0 ? void 0 : _a.greaterThan((_b = info_b.totalStakedInUsd) !== null && _b !== void 0 ? _b : BIG_INT_ZERO)) ? -1 : 1;
            }
            if (sortBy === SortingType.totalApr) {
                return info_a.stakingApr + info_a.swapFeeApr > info_b.stakingApr + info_b.swapFeeApr ? -1 : 1;
            }
            return 0;
        })).then((newStakingInfoData) => {
            const newPoolCards = newStakingInfoData.map((stakingInfo, index) => {
                return (jsxRuntime.jsx(PoolCardV1, { stakingInfo: stakingInfo, onClickViewDetail: () => {
                        // let container = {} as { [address: string]: { staking: StakingInfo } }
                        // container[stakingInfo.stakingRewardAddress] = stakingInfo
                        setSelectedPoolIndex(index);
                        togglePoolDetailModal();
                    }, version: Number(version) }, index));
            });
            setPoolCards(newPoolCards);
        });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [sortBy, stakingInfoData]);
    React.useEffect(() => {
        setPoolCardsLoading(true);
        if ((stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length) > 0) {
            const filteredStakingInfos = stakingInfos
                .filter(function (info) {
                // Only include pools that are live or require a migration
                return !info.isPeriodFinished || info.stakedAmount.greaterThan(BIG_INT_ZERO);
            })
                .sort(sortingOnAvaxStake)
                .sort(sortingOnStakedAmount);
            const pids = filteredStakingInfos.map((stakingInfo) => stakingInfo.stakingRewardAddress);
            fetchChunkedAprs(pids, chainId)
                .then((aprResponses) => {
                return filteredStakingInfos.map((filteredStakingInfo, i) => (Object.assign(Object.assign({}, filteredStakingInfo), aprResponses[i])));
            })
                .then((updatedStakingInfos) => {
                const sortedPoolCards = updatedStakingInfos.map((stakingInfo, index) => {
                    return (jsxRuntime.jsx(PoolCardV1, { stakingInfo: stakingInfo, onClickViewDetail: () => {
                            // let container = {} as { [address: string]: { staking: StakingInfo } }
                            // container[stakingInfo.stakingRewardAddress] = { staking: stakingInfo }
                            setSelectedPoolIndex(index);
                            togglePoolDetailModal();
                        }, version: Number(version) }, index));
                });
                setStakingInfoData(updatedStakingInfos);
                setPoolCards(sortedPoolCards);
            })
                .finally(() => {
                setPoolCardsLoading(false);
            });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length, chainId, version]);
    const selectedPool = selectedPoolIndex !== -1 ? stakingInfoData[selectedPoolIndex] : undefined;
    return (jsxRuntime.jsx(PoolCardListView, Object.assign({ version: version, setMenu: setMenu, activeMenu: activeMenu, menuItems: menuItems, handleSearch: handleSearch, onChangeSortBy: setSortBy, sortBy: sortBy, searchQuery: searchQuery, isLoading: (stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length) === 0 || poolCardsLoading, doesNotPoolExist: (poolCards === null || poolCards === void 0 ? void 0 : poolCards.length) === 0 && !poolCardsLoading, selectedPool: selectedPool }, { children: filteredPoolCards })));
};

const PoolV1 = ({ type, stakingInfos, setMenu, activeMenu, menuItems }) => {
    if (type === exports.PoolType.own) {
        stakingInfos = (stakingInfos || []).filter((stakingInfo) => {
            return Boolean(stakingInfo.stakedAmount.greaterThan('0'));
        });
    }
    return (jsxRuntime.jsx(PoolListV1, { version: "1", stakingInfos: stakingInfos, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems }));
};

const PoolCardV2 = ({ stakingInfo, onClickViewDetail, version }) => {
    const { combinedApr } = useGetFarmApr(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const { earnedAmount } = useGetEarnedAmount(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
    const rewardTokens = useGetRewardTokens(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokens, stakingInfo.rewardTokensAddress);
    return (jsxRuntime.jsx(PoolCardView, { combinedApr: combinedApr, earnedAmount: earnedAmount, rewardTokens: rewardTokens, stakingInfo: stakingInfo, onClickViewDetail: onClickViewDetail, version: version }));
};

const PoolListV2 = ({ version, stakingInfos, setMenu, activeMenu, menuItems }) => {
    const [poolCardsLoading] = React.useState(false);
    const [searchQuery, setSearchQuery] = React.useState('');
    const [sortBy, setSortBy] = React.useState('');
    const debouncedSearchQuery = useDebounce(searchQuery, 250);
    const [stakingInfoData, setStakingInfoData] = React.useState([]);
    const [stakingInfoByPid, setStakingInfoByPid] = React.useState({});
    const [selectedPoolIndex, setSelectedPoolIndex] = React.useState('');
    const togglePoolDetailModal = usePoolDetailnModalToggle();
    // fetch farms earned amount
    useUpdateAllFarmsEarnAmount();
    // fetch farms apr
    useFetchFarmAprs();
    const sortedFarmsApr = useSortFarmAprs();
    const handleSearch = React.useCallback((value) => {
        setSearchQuery(value.trim());
    }, []);
    React.useEffect(() => {
        if (sortBy === SortingType.totalStakedInUsd) {
            const sortedFarms = [...stakingInfoData].sort(function (info_a, info_b) {
                var _a, _b;
                return ((_a = info_a.totalStakedInUsd) === null || _a === void 0 ? void 0 : _a.greaterThan((_b = info_b.totalStakedInUsd) !== null && _b !== void 0 ? _b : BIG_INT_ZERO)) ? -1 : 1;
            });
            setStakingInfoData(sortedFarms);
        }
        else if (sortBy === SortingType.totalApr) {
            const sortedFarms = sortedFarmsApr
                .map((item) => stakingInfoData.find((infoItem) => (infoItem === null || infoItem === void 0 ? void 0 : infoItem.pid) === item.pid))
                .filter((element) => !!element);
            setStakingInfoData(sortedFarms);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [sortBy]);
    React.useEffect(() => {
        if ((stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length) > 0) {
            const updatedStakingInfos = stakingInfos
                // sort by total staked
                .sort(sortingOnAvaxStake)
                .sort(sortingOnStakedAmount);
            let finalArr = updatedStakingInfos;
            // if user has searched something, then filter those results
            if (debouncedSearchQuery) {
                const filtered = stakingInfos.filter(function (stakingInfo) {
                    var _a, _b, _c, _d;
                    return ((((_b = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.symbol) || '').toUpperCase().includes(debouncedSearchQuery.toUpperCase()) ||
                        (((_d = (_c = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.symbol) || '').toUpperCase().includes(debouncedSearchQuery.toUpperCase()));
                });
                finalArr = filtered;
            }
            const finalArrByPid = finalArr.reduce((acc, info) => {
                acc[info === null || info === void 0 ? void 0 : info.pid] = info;
                return acc;
            }, {});
            setStakingInfoByPid(finalArrByPid);
            setStakingInfoData(finalArr);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [stakingInfos, debouncedSearchQuery]);
    const selectedPool = !!selectedPoolIndex ? stakingInfoByPid[selectedPoolIndex] : {};
    return (jsxRuntime.jsx(PoolCardListView, Object.assign({ version: version, setMenu: setMenu, activeMenu: activeMenu, menuItems: menuItems, handleSearch: handleSearch, onChangeSortBy: setSortBy, sortBy: sortBy, searchQuery: searchQuery, isLoading: ((stakingInfoData === null || stakingInfoData === void 0 ? void 0 : stakingInfoData.length) === 0 && !searchQuery) || poolCardsLoading, doesNotPoolExist: (stakingInfoData === null || stakingInfoData === void 0 ? void 0 : stakingInfoData.length) === 0 && !poolCardsLoading, selectedPool: selectedPool }, { children: stakingInfoData.map((stakingInfo) => (jsxRuntime.jsx(PoolCardV2, { stakingInfo: stakingInfo, onClickViewDetail: () => {
                setSelectedPoolIndex(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
                togglePoolDetailModal();
            }, version: Number(version) }, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid))) })));
};
var PoolListV2$1 = React.memo(PoolListV2);

const PoolV2 = ({ type, setMenu, activeMenu, menuItems, miniChefStakingInfo }) => {
    const poolMap = useMinichefPools();
    if (type === exports.PoolType.own) {
        miniChefStakingInfo = (miniChefStakingInfo || []).filter((stakingInfo) => {
            return Boolean(stakingInfo.stakedAmount.greaterThan('0'));
        });
    }
    if (type === exports.PoolType.superFarms) {
        miniChefStakingInfo = (miniChefStakingInfo || []).filter((item) => { var _a; return (((_a = item === null || item === void 0 ? void 0 : item.rewardTokensAddress) === null || _a === void 0 ? void 0 : _a.length) || 0) > 1; });
    }
    return (jsxRuntime.jsx(PoolListV2$1, { version: "2", stakingInfos: miniChefStakingInfo, poolMap: poolMap, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems }));
};

const PoolCardViewV3 = ({ stakingInfo, onClickViewDetail, version, rewardTokens }) => {
    var _a, _b, _c, _d;
    const { t } = reactI18next.useTranslation();
    const [isCompoundDrawerVisible, setShowCompoundDrawer] = React.useState(false);
    const [isFarmDrawerVisible, setShowFarmDrawer] = React.useState(false);
    const [isAddLiquidityDrawerVisible, setShowAddLiquidityDrawer] = React.useState(false);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const token0 = stakingInfo.tokens[0];
    const token1 = stakingInfo.tokens[1];
    const currency0 = unwrappedToken(token0, chainId);
    const currency1 = unwrappedToken(token1, chainId);
    const [, stakingTokenPair] = usePair(token0, token1);
    const isStaking = Boolean(stakingInfo.stakedAmount.greaterThan('0'));
    const yourStackedInUsd = ((_a = sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.mainnet)
        ? stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd.multiply(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.stakedAmount).divide(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedAmount)
        : undefined;
    const userPgl = useTokenBalance(account !== null && account !== void 0 ? account : undefined, stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.liquidityToken);
    const isLiquidity = Boolean(userPgl === null || userPgl === void 0 ? void 0 : userPgl.greaterThan('0'));
    const isSuperFarm = version > 1 ? ((_b = (rewardTokens || [])) === null || _b === void 0 ? void 0 : _b.length) > 1 : ((_c = ((stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokensAddress) || [])) === null || _c === void 0 ? void 0 : _c.length) > 1;
    const redirectToFarmDrawer = () => {
        setShowFarmDrawer(true);
        setShowAddLiquidityDrawer(false);
    };
    const farmApr = stakingInfo.stakingApr;
    const earnedAmount = stakingInfo.earnedAmount;
    const userApr = useUserPangoChefAPR(stakingInfo);
    const apr = isStaking ? userApr : farmApr;
    const renderButton = () => {
        if (isStaking && Boolean(earnedAmount.greaterThan('0')))
            return (jsxRuntime.jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowCompoundDrawer(true), backgroundColor: "color2", color: "text1", height: "45px" }, { children: t('sarCompound.compound') })));
        else if (isLiquidity) {
            return (jsxRuntime.jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowFarmDrawer(true), backgroundColor: "color2", color: "text1", height: "45px" }, { children: t('header.farm') })));
        }
        else {
            return (jsxRuntime.jsx(ActionButon$1, Object.assign({ variant: "plain", onClick: () => setShowAddLiquidityDrawer(true), backgroundColor: "color2", color: "text1", height: "45px" }, { children: t('pool.addLiquidity') })));
        }
    };
    return (jsxRuntime.jsxs(Panel$1, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, { children: [jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: 24, fontWeight: 500 }, { children: [currency0.symbol, "-", currency1.symbol] })), isSuperFarm && (jsxRuntime.jsx(OptionsWrapper, { children: jsxRuntime.jsx(OptionButton, { children: "Super farm" }) }))] }), jsxRuntime.jsx(DoubleCurrencyLogo, { size: 48, currency0: currency0, currency1: currency1 })] })), jsxRuntime.jsx(Divider$1, {}), jsxRuntime.jsx(Box, Object.assign({ display: "flex", flex: "1", alignItems: "center" }, { children: jsxRuntime.jsxs(StatWrapper$2, { children: [isStaking ? (jsxRuntime.jsx(Stat, { title: 'Your TVL', stat: numeral__default["default"](yourStackedInUsd === null || yourStackedInUsd === void 0 ? void 0 : yourStackedInUsd.toFixed(2)).format('$0.00a'), titlePosition: "top", titleFontSize: [16, 14], statFontSize: [24, 18] })) : (jsxRuntime.jsx(Stat, { title: 'TVL', stat: numeral__default["default"]((_d = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.totalStakedInUsd) === null || _d === void 0 ? void 0 : _d.toFixed(2)).format('$0.00a'), titlePosition: "top", titleFontSize: 14, statFontSize: 18 })), jsxRuntime.jsx(Stat, { title: isStaking ? 'Your APR' : 'Average APR', stat: apr ? `${numeral__default["default"](apr).format('0a')}%` : '-', titlePosition: "top", titleFontSize: [16, 14], statFontSize: [24, 18] }), jsxRuntime.jsxs(Box, Object.assign({ display: "inline-block" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: [16, 14] }, { children: t('earn.rewardsIn') })), jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center", mt: "5px" }, { children: jsxRuntime.jsx(RewardTokens, { rewardTokens: rewardTokens, size: 24 }) }))] }))] }) })), jsxRuntime.jsxs(InnerWrapper$4, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(DetailButton$1, Object.assign({ variant: "plain", onClick: onClickViewDetail, color: "text1", height: "45px" }, { children: t('pool.seeDetails') })) }), jsxRuntime.jsx(Box, { children: renderButton() })] }), isCompoundDrawerVisible && (jsxRuntime.jsx(Drawer, Object.assign({ title: t('sarCompound.compound'), isOpen: isCompoundDrawerVisible, onClose: () => setShowCompoundDrawer(false), backgroundColor: "color5" }, { children: jsxRuntime.jsx(CompoundV3, { onClose: () => setShowCompoundDrawer(false), stakingInfo: stakingInfo }) }))), isFarmDrawerVisible && (jsxRuntime.jsx(FarmDrawer, { isOpen: isFarmDrawerVisible, onClose: () => {
                    setShowFarmDrawer(false);
                }, version: version, backgroundColor: "color5", stakingInfo: stakingInfo, combinedApr: farmApr })), isAddLiquidityDrawerVisible && (jsxRuntime.jsx(AddLiquidityDrawer, { isOpen: isAddLiquidityDrawerVisible, onClose: () => {
                    setShowAddLiquidityDrawer(false);
                }, onAddToFarm: redirectToFarmDrawer, clickedLpTokens: stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens, backgroundColor: "color5" }))] }));
};

const PoolCardV3 = ({ stakingInfo, onClickViewDetail, version }) => {
    const rewardTokens = useGetRewardTokens(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.rewardTokens, stakingInfo.rewardTokensAddress);
    return (jsxRuntime.jsx(PoolCardViewV3, { rewardTokens: rewardTokens, stakingInfo: stakingInfo, onClickViewDetail: onClickViewDetail, version: version }));
};

const PoolListV3 = ({ version, stakingInfos, setMenu, activeMenu, menuItems }) => {
    const [poolCardsLoading] = React.useState(false);
    const [searchQuery, setSearchQuery] = React.useState('');
    const [sortBy, setSortBy] = React.useState('');
    const debouncedSearchQuery = useDebounce(searchQuery, 250);
    const [stakingInfoData, setStakingInfoData] = React.useState([]);
    const [stakingInfoByPid, setStakingInfoByPid] = React.useState({});
    const [selectedPoolIndex, setSelectedPoolIndex] = React.useState('');
    const togglePoolDetailModal = usePoolDetailnModalToggle();
    const handleSearch = React.useCallback((value) => {
        setSearchQuery(value.trim());
    }, []);
    React.useEffect(() => {
        if (sortBy === SortingType.totalStakedInUsd) {
            const sortedFarms = [...stakingInfoData].sort(function (info_a, info_b) {
                var _a, _b;
                return ((_a = info_a.totalStakedInUsd) === null || _a === void 0 ? void 0 : _a.greaterThan((_b = info_b.totalStakedInUsd) !== null && _b !== void 0 ? _b : BIG_INT_ZERO)) ? -1 : 1;
            });
            setStakingInfoData(sortedFarms);
        }
        else if (sortBy === SortingType.totalApr) {
            const sortedFarms = [...stakingInfoData].sort((a, b) => { var _a, _b; return ((_a = b === null || b === void 0 ? void 0 : b.stakingApr) !== null && _a !== void 0 ? _a : 0) - ((_b = a === null || a === void 0 ? void 0 : a.stakingApr) !== null && _b !== void 0 ? _b : 0); });
            setStakingInfoData(sortedFarms);
        }
    }, [sortBy]);
    React.useEffect(() => {
        if ((stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.length) > 0) {
            const updatedStakingInfos = stakingInfos
                // sort by total staked
                .sort(sortingOnAvaxStake)
                .sort(sortingOnStakedAmount);
            let finalArr = updatedStakingInfos;
            // if user has searched something, then filter those results
            if (debouncedSearchQuery) {
                const filtered = stakingInfos.filter(function (stakingInfo) {
                    var _a, _b, _c, _d;
                    return ((((_b = (_a = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.symbol) || '').toUpperCase().includes(debouncedSearchQuery.toUpperCase()) ||
                        (((_d = (_c = stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.tokens) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.symbol) || '').toUpperCase().includes(debouncedSearchQuery.toUpperCase()));
                });
                finalArr = filtered;
            }
            const finalArrByPid = finalArr.reduce((acc, info) => {
                acc[info === null || info === void 0 ? void 0 : info.pid] = info;
                return acc;
            }, {});
            setStakingInfoByPid(finalArrByPid);
            setStakingInfoData(finalArr);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [stakingInfos, debouncedSearchQuery]);
    const selectedPool = !!selectedPoolIndex ? stakingInfoByPid[selectedPoolIndex] : {};
    return (jsxRuntime.jsx(PoolCardListView, Object.assign({ version: version, setMenu: setMenu, activeMenu: activeMenu, menuItems: menuItems, handleSearch: handleSearch, onChangeSortBy: setSortBy, sortBy: sortBy, searchQuery: searchQuery, isLoading: ((stakingInfoData === null || stakingInfoData === void 0 ? void 0 : stakingInfoData.length) === 0 && !searchQuery) || poolCardsLoading, doesNotPoolExist: (stakingInfoData === null || stakingInfoData === void 0 ? void 0 : stakingInfoData.length) === 0 && !poolCardsLoading, selectedPool: selectedPool }, { children: stakingInfoData.map((stakingInfo) => (jsxRuntime.jsx(PoolCardV3, { stakingInfo: stakingInfo, onClickViewDetail: () => {
                setSelectedPoolIndex(stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid);
                togglePoolDetailModal();
            }, version: Number(version) }, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.pid))) })));
};
var PoolListV3$1 = React.memo(PoolListV3);

const PoolV3 = ({ type, setMenu, activeMenu, menuItems, pangoChefStakingInfos }) => {
    if (type === exports.PoolType.own) {
        pangoChefStakingInfos = (pangoChefStakingInfos || []).filter((stakingInfo) => {
            return Boolean(stakingInfo.stakedAmount.greaterThan('0'));
        });
    }
    if (type === exports.PoolType.superFarms) {
        pangoChefStakingInfos = (pangoChefStakingInfos || []).filter((item) => { var _a; return (((_a = item === null || item === void 0 ? void 0 : item.rewardTokensAddress) === null || _a === void 0 ? void 0 : _a.length) || 0) > 1; });
    }
    return (jsxRuntime.jsx(PoolListV3$1, { version: "3", stakingInfos: pangoChefStakingInfos, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems }));
};

const Pools = ({ version, type, stakingInfoV1, miniChefStakingInfo, pangoChefStakingInfo, setMenu, activeMenu, menuItems, }) => {
    if (version == 1) {
        return (jsxRuntime.jsx(PoolV1, { type: type, stakingInfos: stakingInfoV1, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems }));
    }
    else if (version === 2) {
        return (jsxRuntime.jsx(PoolV2, { type: type, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems, miniChefStakingInfo: miniChefStakingInfo }));
    }
    else if (version === 3) {
        return (jsxRuntime.jsx(PoolV3, { type: type, activeMenu: activeMenu, setMenu: setMenu, menuItems: menuItems, pangoChefStakingInfos: pangoChefStakingInfo }));
    }
    return null;
};

const DropdownMenu = ({ defaultValue, onSelect, placeHolder, isMulti = false, menuPlacement, options, height, }) => {
    const theme = React.useContext(styled.ThemeContext);
    const colourStyles = {
        control: (styles) => {
            var _a, _b;
            return Object.assign(Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color, backgroundColor: (_b = theme.dropdown) === null || _b === void 0 ? void 0 : _b.primaryBgColor, '&:hover': {
                    borderColor: theme.primary,
                } }), (height && { height: height }));
        },
        multiValue: (styles) => {
            var _a, _b, _c;
            return Object.assign(Object.assign({}, styles), { backgroundColor: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.primaryBgColor, border: `1px solid ${(_b = theme.dropdown) === null || _b === void 0 ? void 0 : _b.color}`, color: (_c = theme.dropdown) === null || _c === void 0 ? void 0 : _c.color });
        },
        multiValueLabel: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        placeholder: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        singleValue: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        input: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        indicatorsContainer: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
        indicatorSeparator: (styles) => {
            return Object.assign(Object.assign({}, styles), { display: 'none' });
        },
        option: (styles, { isDisabled }) => {
            var _a, _b;
            return Object.assign(Object.assign({}, styles), { color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color, backgroundColor: (_b = theme.dropdown) === null || _b === void 0 ? void 0 : _b.primaryBgColor, cursor: isDisabled ? 'not-allowed' : 'default' });
        },
        menuList: (styles) => {
            var _a;
            return Object.assign(Object.assign({}, styles), { padding: 0, color: (_a = theme.dropdown) === null || _a === void 0 ? void 0 : _a.color });
        },
    };
    const { t } = reactI18next.useTranslation();
    return (jsxRuntime.jsx(Select__default["default"], Object.assign({ options: options, onChange: (selectedItems) => {
            onSelect((selectedItems === null || selectedItems === void 0 ? void 0 : selectedItems.value) || '');
        } }, (menuPlacement && { menuPlacement }), { defaultValue: defaultValue, placeholder: placeHolder || t('dropdown.select'), isMulti: isMulti, styles: colourStyles, theme: (thm) => (Object.assign(Object.assign({}, thm), { colors: Object.assign(Object.assign({}, thm.colors), { primary50: theme.primary, primary75: theme.primary, primary: theme.primary }) })) })));
};

const Panel = styled__default["default"](Box) `
  background-color: ${({ theme }) => theme.bg8};
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  padding: 20px;
  border-radius: 10px;
  height: 295px;
  * {
    box-sizing: border-box;
  }
`;
const Divider = styled__default["default"](Box) `
  height: 1px;
  background-color: ${({ theme }) => theme.bg7};
  margin: 10px 0px 10px 0px;
  width: 100%;
`;
const ActionButon = styled__default["default"](Button) `
  width: 100%;
`;
const DetailButton = styled__default["default"](ActionButon) `
  border: 1px solid !important;
  border-color: ${({ theme }) => theme.text10}!important;
`;
const StatWrapper = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-gap: 12px;
  margin-top: 10px;
  flex: 1;
  height: 100%;
  align-items: center;
`;
const InnerWrapper$1 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: minmax(auto, 50%) minmax(auto, 50%);
  grid-gap: 12px;
  margin-top: 10px;
`;

const WalletCard = ({ pair }) => {
    const { t } = reactI18next.useTranslation();
    const chainId = useChainId();
    const [isRemoveLiquidityDrawerVisible, setShowRemoveLiquidityDrawer] = React.useState(false);
    const [isAddLiquidityDrawerVisible, setShowAddLiquidityDrawer] = React.useState(false);
    const currency0 = unwrappedToken(pair.token0, chainId);
    const currency1 = unwrappedToken(pair.token1, chainId);
    const { liquidityInUSD, userPgl } = useGetPoolDollerWorth(pair);
    const yourLiquidity = liquidityInUSD ? `$${liquidityInUSD === null || liquidityInUSD === void 0 ? void 0 : liquidityInUSD.toFixed(4)}` : '-';
    return (jsxRuntime.jsxs(Panel, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", justifyContent: "space-between" }, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: [currency0.symbol, "-", currency1.symbol] })) }), jsxRuntime.jsx(DoubleCurrencyLogo, { size: 48, currency0: currency0, currency1: currency1 })] })), jsxRuntime.jsx(Divider, {}), jsxRuntime.jsxs(StatWrapper, { children: [jsxRuntime.jsx(Stat, { title: t('pool.yourLiquidity'), stat: yourLiquidity, titlePosition: "top", titleFontSize: 16, statFontSize: [24, 18] }), jsxRuntime.jsx(Stat, { title: t('positionCard.poolTokens'), stat: userPgl ? userPgl.toSignificant(4) : '-', titlePosition: "top", titleFontSize: 16, statFontSize: [24, 18] })] }), jsxRuntime.jsxs(InnerWrapper$1, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(DetailButton, Object.assign({ variant: "plain", onClick: () => setShowAddLiquidityDrawer(true), color: "text1", height: "45px" }, { children: t('positionCard.add') })) }), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(ActionButon, Object.assign({ variant: "plain", onClick: () => setShowRemoveLiquidityDrawer(true), backgroundColor: "bg2", color: "text1", height: "45px" }, { children: t('positionCard.remove') })) })] }), isAddLiquidityDrawerVisible && (jsxRuntime.jsx(AddLiquidityDrawer, { isOpen: isAddLiquidityDrawerVisible, onClose: () => {
                    setShowAddLiquidityDrawer(false);
                }, clickedLpTokens: [pair === null || pair === void 0 ? void 0 : pair.token0, pair === null || pair === void 0 ? void 0 : pair.token1], backgroundColor: "color5" })), isRemoveLiquidityDrawerVisible && (jsxRuntime.jsx(RemoveLiquidityDrawer, { isOpen: isRemoveLiquidityDrawerVisible, onClose: () => {
                    setShowRemoveLiquidityDrawer(false);
                }, clickedLpTokens: [pair === null || pair === void 0 ? void 0 : pair.token0, pair === null || pair === void 0 ? void 0 : pair.token1], backgroundColor: "color5" }))] }));
};

const PageWrapper$1 = styled__default["default"](Box) `
  width: 100%;
  background-color: ${({ theme }) => theme.bg2};
  padding: 10px;
  border-radius: 0px 10px 10px 0px;
  overflow: hidden;
`;
const EmptyProposals = styled__default["default"].div `
  border: 1px solid ${({ theme }) => theme.text4};
  padding: 16px 12px;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;
const PanelWrapper = styled__default["default"].div `
  grid-template-columns: repeat(auto-fill, minmax(360px, 1fr));
  grid-template-rows: max-content;
  gap: 15px;
  display: inline-grid;
  width: 100%;
  align-items: start;
  padding-bottom: 65px;

  @media screen and (max-width: 1024px) {
    grid-template-columns: 1fr;
    align-items: stretch;
    > * {
      grid-column: 1 / 4;
    }

    > * {
      &:first-child {
        width: 100%;
      }
    }
  }
`;
const MobileContainer = styled__default["default"](Box) `
  display: none;
  ${({ theme }) => theme.mediaWidth.upToSmall `
    display: block;
    width: 100%
    margin-bottom : 10px;
  `};
`;

const Wallet = ({ setMenu, activeMenu, menuItems }) => {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const useGetUserLP = useGetUserLPHook[chainId];
    const { v2IsLoading, allV2PairsWithLiquidity } = useGetUserLP();
    // fetch the user's balances of all tracked V2 LP tokens
    const { t } = reactI18next.useTranslation();
    function getWalletCardView() {
        if (!account) {
            return (jsxRuntime.jsx(Box, Object.assign({ padding: "40px", width: "100%", borderRadius: "16px" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text3", textAlign: "center", fontWeight: 500 }, { children: t('pool.connectWalletToView') })) })));
        }
        else if (v2IsLoading) {
            return jsxRuntime.jsx(Loader, { size: 100 });
        }
        else if ((allV2PairsWithLiquidity === null || allV2PairsWithLiquidity === void 0 ? void 0 : allV2PairsWithLiquidity.length) > 0) {
            return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx(Scrollbars__default["default"], { children: jsxRuntime.jsx(PanelWrapper, { children: allV2PairsWithLiquidity.map((v2Pair) => {
                            var _a;
                            return (jsxRuntime.jsx(WalletCard, { pair: v2Pair }, (_a = v2Pair === null || v2Pair === void 0 ? void 0 : v2Pair.liquidityToken) === null || _a === void 0 ? void 0 : _a.address));
                        }) }) }) }));
        }
        else {
            return (jsxRuntime.jsx(EmptyProposals, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text3", textAlign: "center", fontWeight: 500 }, { children: t('pool.noLiquidity') })) }));
        }
    }
    return (jsxRuntime.jsxs(PageWrapper$1, { children: [jsxRuntime.jsx(MobileContainer, { children: jsxRuntime.jsx(DropdownMenu, { options: menuItems, defaultValue: activeMenu, onSelect: (value) => {
                        setMenu(value);
                    } }) }), getWalletCardView()] }));
};

const PoolImportWrapper = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  overflow: hidden;
`;
const ArrowWrapper$1 = styled__default["default"].div `
  background-color: ${({ theme }) => theme.bg6};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;
const LightCard = styled__default["default"](Box) `
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
`;
const CurrencySelectWrapper = styled__default["default"](Box) `
  width: 100%;
  border-radius: 8px;
  padding: 10px;
  border: 1px solid transparent;
  display: flex;
  position: relative;
  box-sizing: border-box;
  justify-content: space-between;
  align-items: center;
  background-color: ${({ theme }) => theme.color3};
  color: ${({ theme }) => theme.text4};
  cursor: pointer;
`;
const Dots = styled__default["default"].span `
  &::after {
    display: inline-block;
    animation: ellipsis 1.25s infinite;
    content: '.';
    width: 1em;
    text-align: left;
  }
  @keyframes ellipsis {
    0% {
      content: '.';
    }
    33% {
      content: '..';
    }
    66% {
      content: '...';
    }
  }
`;

const Wrapper$6 = styled__default["default"].div `
  ${({ theme }) => theme.flexColumnNoWrap}
  margin: 0;
  width: 100%;
  align-items: center;
  max-width: 420px;
  min-width: 420px;
  padding: 10px;
  position: relative;
  overflow: hidden;
  * {
    box-sizing: border-box;
  }
`;
const ConfirmButton = styled__default["default"].button `
  width: 100%;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
  border: none;
  color: ${({ theme }) => theme.text1};
  font-size: 14px;
  cursor: pointer;

  :hover,
  :focus {
    opacity: 0.8;
  }
`;

var Fields$2;
(function (Fields) {
    Fields[Fields["TOKEN0"] = 0] = "TOKEN0";
    Fields[Fields["TOKEN1"] = 1] = "TOKEN1";
})(Fields$2 || (Fields$2 = {}));
var BodyState;
(function (BodyState) {
    BodyState[BodyState["SELECT_TOKENS"] = 0] = "SELECT_TOKENS";
    BodyState[BodyState["ADD_LIQUIDITY"] = 1] = "ADD_LIQUIDITY";
    BodyState[BodyState["CREATE_PAIR"] = 2] = "CREATE_PAIR";
})(BodyState || (BodyState = {}));
const SearchToken = ({ currency0, currency1, onTokenClick, onClick }) => {
    const { account } = usePangolinWeb3();
    const theme = React.useContext(styled.ThemeContext);
    const { t } = reactI18next.useTranslation();
    const [pairState, pair] = usePair(currency0, currency1);
    function renderButton() {
        if (!account) {
            return (jsxRuntime.jsx(LightCard, { children: jsxRuntime.jsx(Text, Object.assign({ textAlign: "center", color: "color6", fontSize: [14, 12] }, { children: t('walletModal.connectToWallet') })) }));
        }
        if (!currency0 || !currency1) {
            return (jsxRuntime.jsx(LightCard, { children: jsxRuntime.jsx(Text, Object.assign({ textAlign: "center", color: "text1", fontSize: [14, 12] }, { children: t('poolFinder.selectToken') })) }));
        }
        if (pair) {
            return (jsxRuntime.jsx(ConfirmButton, Object.assign({ onClick: () => onClick(BodyState.ADD_LIQUIDITY) }, { children: t('navigationTabs.addLiquidity') })));
        }
        if (pairState === PairState.NOT_EXISTS || (currency0 && currency1 && !pair)) {
            return (jsxRuntime.jsx(ConfirmButton, Object.assign({ onClick: () => onClick(BodyState.CREATE_PAIR) }, { children: t('navigationTabs.createPair') })));
        }
        return (jsxRuntime.jsx(LightCard, { children: jsxRuntime.jsx(Text, Object.assign({ textAlign: "center", color: "text1", fontSize: [16, 12] }, { children: t('poolFinder.invalidPair') })) }));
    }
    function renderCurrency(currency) {
        if (!currency) {
            return (jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: [16, 12] }, { children: t('poolFinder.selectToken') })));
        }
        return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(CurrencyLogo, { size: 24, currency: currency, imageSize: 48 }), jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontSize: [16, 14], fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: currency === null || currency === void 0 ? void 0 : currency.symbol }))] }));
    }
    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(CurrencySelectWrapper, Object.assign({ onClick: () => {
                    onTokenClick(Fields$2.TOKEN0);
                } }, { children: [jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: renderCurrency(currency0) })), jsxRuntime.jsx(reactFeather.ChevronDown, { size: "16", color: theme.text1 })] })), jsxRuntime.jsx(Box, Object.assign({ display: "flex", justifyContent: "center", width: "100%", my: 10 }, { children: jsxRuntime.jsx(reactFeather.Plus, { size: "16", color: theme.text1 }) })), jsxRuntime.jsxs(CurrencySelectWrapper, Object.assign({ onClick: () => {
                    onTokenClick(Fields$2.TOKEN1);
                } }, { children: [jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: renderCurrency(currency1) })), jsxRuntime.jsx(reactFeather.ChevronDown, { size: "16", color: theme.text1 })] })), renderButton()] }));
};

const AddLiquidityModal = ({ isOpen, onClose }) => {
    const theme = React.useContext(styled.ThemeContext);
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const [activeField, setActiveField] = React.useState(Fields$2.TOKEN0);
    const [currency0, setCurrency0] = React.useState(sdk.CAVAX[chainId]);
    const [currency1, setCurrency1] = React.useState(undefined);
    const [showSearch, setShowSearch] = React.useState(false);
    const [bodyState, setBodyState] = React.useState(BodyState.SELECT_TOKENS);
    const createPool = useNearCreatePool();
    const parsedQs = useParsedQueryString();
    // token warning stuff
    const [loadedInputCurrency, loadedOutputCurrency] = [
        useCurrency(parsedQs === null || parsedQs === void 0 ? void 0 : parsedQs.currency0),
        useCurrency(parsedQs === null || parsedQs === void 0 ? void 0 : parsedQs.currency1),
    ];
    React.useEffect(() => {
        if (loadedInputCurrency) {
            setCurrency0(loadedInputCurrency);
        }
        if (loadedOutputCurrency) {
            setCurrency1(loadedOutputCurrency);
        }
    }, [loadedInputCurrency, loadedOutputCurrency]);
    const onTokenClick = React.useCallback((field) => {
        setActiveField(field);
        setShowSearch(true);
    }, [setActiveField, setShowSearch]);
    function onButtonClick(value) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!chainId)
                return;
            try {
                if (isEvmChain(chainId) && value) {
                    setBodyState(value);
                }
                else if (!isEvmChain(chainId)) {
                    const tokenA = currency0 ? wrappedCurrency(currency0, chainId) : undefined;
                    const tokenB = currency1 ? wrappedCurrency(currency1, chainId) : undefined;
                    const poolId = yield nearFn.getPoolId(chainId, tokenA, tokenB);
                    if (poolId > 0 && value) {
                        setBodyState(value);
                    }
                    else {
                        const createPoolData = {
                            tokenA,
                            tokenB,
                        };
                        yield createPool(createPoolData);
                    }
                }
            }
            catch (err) {
                const _err = err;
                console.error(_err);
            }
        });
    }
    const switchCurrencies = React.useCallback(() => {
        const temp = currency0;
        setCurrency0(currency1);
        setCurrency1(temp);
    }, [currency0, currency1]);
    const handleCurrencySelect = React.useCallback((currency) => {
        setShowSearch(false);
        if (activeField === Fields$2.TOKEN0) {
            if (currency1 === currency) {
                switchCurrencies();
            }
            else {
                setCurrency0(currency);
            }
        }
        else {
            if (currency0 === currency) {
                switchCurrencies();
            }
            else {
                setCurrency1(currency);
            }
        }
    }, [activeField, switchCurrencies, currency0, currency1]);
    const handleClose = React.useCallback(() => {
        setShowSearch(false);
    }, [setShowSearch]);
    function renderTitle() {
        if (bodyState === BodyState.SELECT_TOKENS) {
            return t('poolFinder.selectToken');
        }
        else if (bodyState === BodyState.ADD_LIQUIDITY) {
            return t('poolFinder.addLiquidity');
        }
        else {
            return t('navigationTabs.createPair');
        }
    }
    function renderBody() {
        if (bodyState === BodyState.SELECT_TOKENS) {
            return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(SearchToken, { currency0: currency0, currency1: currency1, onTokenClick: onTokenClick, onClick: onButtonClick }), jsxRuntime.jsx(SelectTokenDrawer$1, { isOpen: showSearch, selectedCurrency: currency0, otherSelectedCurrency: currency1, onCurrencySelect: handleCurrencySelect, onClose: handleClose })] }));
        }
        else if (currency0 && currency1) {
            return (jsxRuntime.jsx(AddLiquidity, { currencyA: currency0, currencyB: currency1, type: SpaceType.card, onComplete: () => setBodyState(0) }));
        }
        return jsxRuntime.jsx(jsxRuntime.Fragment, {});
    }
    return (jsxRuntime.jsx(Modal, Object.assign({ isOpen: isOpen, onDismiss: onClose, overlayBG: theme.modalBG2 }, { children: jsxRuntime.jsxs(Wrapper$6, { children: [jsxRuntime.jsxs(Box, Object.assign({ p: 10, display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: renderTitle() })), jsxRuntime.jsx(CloseIcon, { onClick: () => {
                                if (bodyState === BodyState.SELECT_TOKENS) {
                                    onClose();
                                }
                                else {
                                    setBodyState(0);
                                }
                            }, color: theme.text1 })] })), jsxRuntime.jsx(Box, Object.assign({ width: "100%" }, { children: renderBody() }))] }) })));
};

const Wrapper$5 = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  border-radius: 10px;
  background-color: ${({ theme }) => theme.bg6};
  margin-top: 10px;
  padding: 10px;
`;
const InnerWrapper = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: 50% 50%;
  grid-gap: 12px;
  margin-top: 10px;
`;

const PositionCard = ({ pair, onManagePoolsClick }) => {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const currency0 = unwrappedToken(pair === null || pair === void 0 ? void 0 : pair.token0, chainId);
    const currency1 = unwrappedToken(pair === null || pair === void 0 ? void 0 : pair.token1, chainId);
    const { t } = reactI18next.useTranslation();
    const useTokenBalance = useTokenBalanceHook[chainId];
    const useTotalSupply = useTotalSupplyHook[chainId];
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    const userPoolBalance = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pairOrToken);
    const totalPoolTokens = useTotalSupply(pairOrToken);
    const poolTokenPercentage = !!userPoolBalance && !!totalPoolTokens && sdk.JSBI.greaterThanOrEqual(totalPoolTokens.raw, userPoolBalance.raw)
        ? new sdk.Percent(userPoolBalance.raw, totalPoolTokens.raw)
        : undefined;
    const [token0Deposited, token1Deposited] = !!pair &&
        !!totalPoolTokens &&
        !!userPoolBalance &&
        sdk.JSBI.greaterThan(totalPoolTokens.raw, BIG_INT_ZERO) &&
        sdk.JSBI.greaterThan(userPoolBalance.raw, BIG_INT_ZERO) &&
        // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply
        sdk.JSBI.greaterThanOrEqual(totalPoolTokens.raw, userPoolBalance.raw)
        ? pair.getLiquidityValues(totalPoolTokens, userPoolBalance, { feeOn: false })
        : [undefined, undefined];
    return (jsxRuntime.jsxs(Wrapper$5, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 16, color: "oceanBlue" }, { children: t('poolFinder.poolFound') })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", mt: 10 }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, color: "color6", fontSize: 16 }, { children: t('positionCard.yourPosition') })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsx(DoubleCurrencyLogo, { size: 24, currency0: currency0, currency1: currency1 }), jsxRuntime.jsx(Box, Object.assign({ marginLeft: 10 }, { children: jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: 20, fontWeight: 500 }, { children: [currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol, "/", currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol] })) }))] }))] })), jsxRuntime.jsxs(InnerWrapper, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { title: 'ARL', stat: `${userPoolBalance ? userPoolBalance.toSignificant(4) : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 16], titleColor: "text2" }) }), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { title: t('positionCard.poolShare'), stat: `${poolTokenPercentage ? poolTokenPercentage.toFixed(6) + '%' : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 16], titleColor: "text2" }) })] }), jsxRuntime.jsxs(InnerWrapper, { children: [jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { title: currency0.symbol, stat: `${token0Deposited ? token0Deposited === null || token0Deposited === void 0 ? void 0 : token0Deposited.toSignificant(6) : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 16], titleColor: "text2" }) }), jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Stat, { title: currency1.symbol, stat: `${token1Deposited ? token1Deposited === null || token1Deposited === void 0 ? void 0 : token1Deposited.toSignificant(6) : '-'}`, titlePosition: "top", titleFontSize: 14, statFontSize: [20, 16], titleColor: "text2" }) })] }), jsxRuntime.jsx(Box, Object.assign({ mt: 10 }, { children: jsxRuntime.jsx(Box, Object.assign({ mr: "5px", width: "100%" }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: 'primary', onClick: onManagePoolsClick }, { children: t('positionCard.manage') })) })) }))] }));
};

var Fields$1;
(function (Fields) {
    Fields[Fields["TOKEN0"] = 0] = "TOKEN0";
    Fields[Fields["TOKEN1"] = 1] = "TOKEN1";
})(Fields$1 || (Fields$1 = {}));
const PoolImport = ({ currency0, currency1, openTokenDrawer, setActiveField, onManagePoolsClick }) => {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const theme = React.useContext(styled.ThemeContext);
    const useTokenBalance = useTokenBalanceHook[chainId];
    const [pairState, pair] = usePair(currency0 !== null && currency0 !== void 0 ? currency0 : undefined, currency1 !== null && currency1 !== void 0 ? currency1 : undefined);
    const addPair = usePairAdder();
    React.useEffect(() => {
        if (pair) {
            addPair(pair);
        }
    }, [pair, addPair]);
    const validPairNoLiquidity = pairState === PairState.NOT_EXISTS ||
        Boolean(pairState === PairState.EXISTS &&
            pair &&
            sdk.JSBI.equal(pair.reserve0.raw, sdk.JSBI.BigInt(0)) &&
            sdk.JSBI.equal(pair.reserve1.raw, sdk.JSBI.BigInt(0)));
    const pairOrToken = isEvmChain(chainId) ? pair === null || pair === void 0 ? void 0 : pair.liquidityToken : pair;
    const position = useTokenBalance(account !== null && account !== void 0 ? account : undefined, pairOrToken);
    const hasPosition = Boolean(position && sdk.JSBI.greaterThan(position.raw, sdk.JSBI.BigInt(0)));
    const prerequisiteMessage = (jsxRuntime.jsx(LightCard, { children: jsxRuntime.jsx(Text, Object.assign({ textAlign: "center", color: "color6", fontSize: 14 }, { children: !account ? t('poolFinder.connectToFind') : t('poolFinder.selectTokenToFind') })) }));
    function getCard() {
        if (pairState === PairState.EXISTS) {
            if (hasPosition && pair) {
                return jsxRuntime.jsx(PositionCard, { pair: pair, onManagePoolsClick: onManagePoolsClick });
            }
            return (jsxRuntime.jsx(LightCard, { children: jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexDirection: "column", alignItems: "center" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "color6", fontSize: 14, textAlign: "center" }, { children: t('poolFinder.noLiquidityYet') })) })) }));
        }
        if (validPairNoLiquidity) {
            return (jsxRuntime.jsx(LightCard, { children: jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexDirection: "column", alignItems: "center" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "color6", fontSize: 14, textAlign: "center" }, { children: t('poolFinder.noPoolFound') })) })) }));
        }
        if (pairState === PairState.INVALID) {
            return (jsxRuntime.jsx(LightCard, { children: jsxRuntime.jsx(Box, Object.assign({ display: "flex", flexDirection: "column", alignItems: "center" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "color6", fontSize: 14, textAlign: "center", fontWeight: 500 }, { children: t('poolFinder.invalidPair') })) })) }));
        }
        if (pairState === PairState.LOADING) {
            return (jsxRuntime.jsx(LightCard, { children: jsxRuntime.jsx(Box, Object.assign({ textAlign: "center" }, { children: jsxRuntime.jsxs(Text, Object.assign({ textAlign: "center", color: "white" }, { children: [t('poolFinder.loading'), jsxRuntime.jsx(Dots, {})] })) })) }));
        }
        return null;
    }
    return (jsxRuntime.jsxs(PoolImportWrapper, { children: [jsxRuntime.jsxs(CurrencySelectWrapper, Object.assign({ onClick: () => {
                    openTokenDrawer();
                    setActiveField(Fields$1.TOKEN0);
                } }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsx(CurrencyLogo, { size: 24, currency: currency0, imageSize: 48 }), jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: currency0 === null || currency0 === void 0 ? void 0 : currency0.symbol }))] })), jsxRuntime.jsx(reactFeather.ChevronDown, { size: "16", color: theme.text1 })] })), jsxRuntime.jsx(Box, Object.assign({ width: "100%", textAlign: "center", alignItems: "center", display: "flex", justifyContent: 'center', mt: 10, mb: 10 }, { children: jsxRuntime.jsx(ArrowWrapper$1, { children: jsxRuntime.jsx(reactFeather.Plus, { size: "16", color: theme.text1 }) }) })), jsxRuntime.jsxs(CurrencySelectWrapper, Object.assign({ onClick: () => {
                    openTokenDrawer();
                    setActiveField(Fields$1.TOKEN1);
                } }, { children: [currency1 ? (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center" }, { children: [jsxRuntime.jsx(CurrencyLogo, { size: 24, currency: currency1, imageSize: 48 }), jsxRuntime.jsx(Text, Object.assign({ color: "text2", fontSize: 16, fontWeight: 500, lineHeight: "40px", marginLeft: 10 }, { children: currency1 === null || currency1 === void 0 ? void 0 : currency1.symbol }))] }))) : (jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: 16, fontWeight: 500, padding: "8px 0px" }, { children: t('searchModal.selectToken') }))), jsxRuntime.jsx(reactFeather.ChevronDown, { size: "16", color: theme.text1 })] })), currency0 && currency1 ? getCard() : prerequisiteMessage] }));
};

const Wrapper$4 = styled__default["default"].div `
  ${({ theme }) => theme.flexColumnNoWrap}
  margin: 0;
  width: 100%;
  align-items: center;
  max-width: 420px;
  min-width: 420px;
  padding: 10px;
  position: relative;
  overflow: hidden;
  * {
    box-sizing: border-box;
  }
`;

var Fields;
(function (Fields) {
    Fields[Fields["TOKEN0"] = 0] = "TOKEN0";
    Fields[Fields["TOKEN1"] = 1] = "TOKEN1";
})(Fields || (Fields = {}));
const PoolImportModal = ({ isOpen, onClose, onManagePoolsClick }) => {
    const theme = React.useContext(styled.ThemeContext);
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const [currency0, setCurrency0] = React.useState(sdk.CAVAX[chainId]);
    const [currency1, setCurrency1] = React.useState(undefined);
    const [activeField, setActiveField] = React.useState(Fields.TOKEN1);
    const [showSearch, setShowSearch] = React.useState(false);
    const handleCurrencySelect = React.useCallback((currency) => {
        if (activeField === Fields.TOKEN0) {
            setCurrency0(currency);
        }
        else {
            setCurrency1(currency);
        }
    }, [activeField]);
    const handleSearchDismiss = React.useCallback(() => {
        setShowSearch(false);
    }, [setShowSearch]);
    return (jsxRuntime.jsx(Modal, Object.assign({ isOpen: isOpen, onDismiss: onClose, overlayBG: theme.modalBG2 }, { children: jsxRuntime.jsxs(Wrapper$4, { children: [jsxRuntime.jsxs(Box, Object.assign({ p: 10, display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: [24, 18], fontWeight: 500 }, { children: t('navigationTabs.importPool') })), jsxRuntime.jsx(CloseIcon, { onClick: onClose, color: theme.text1 })] })), jsxRuntime.jsx(PoolImport, { onClose: onClose, currency0: currency0, currency1: currency1, openTokenDrawer: () => setShowSearch(true), setActiveField: setActiveField, onManagePoolsClick: onManagePoolsClick }), jsxRuntime.jsx(SelectTokenDrawer$1, { isOpen: showSearch, onClose: handleSearchDismiss, onCurrencySelect: handleCurrencySelect, selectedCurrency: activeField === Fields.TOKEN0 ? currency0 : currency1, otherSelectedCurrency: activeField === Fields.TOKEN0 ? currency1 : currency0 })] }) })));
};

function CoinDescription({ coin }) {
    const { data } = useCoinGeckoTokenData(coin);
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: data && (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: 16, fontWeight: "bold", mb: "15px" }, { children: coin === null || coin === void 0 ? void 0 : coin.name })), jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: 14 }, { children: ReactHtmlParser__default["default"](data === null || data === void 0 ? void 0 : data.description) })), jsxRuntime.jsx(Box, Object.assign({ mt: "5px" }, { children: jsxRuntime.jsx(ExternalLink, Object.assign({ style: { color: 'white', textDecoration: 'underline' }, href: data.homePage, target: "_blank" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: 16, fontWeight: 500 }, { children: "Visit Website" })) })) }))] })) }));
}

const Root$6 = styled__default["default"](Box) `
  display: flex;
  flex-direction: column;
  height: 100%;
`;
styled__default["default"](Text) `
  text-decoration: none;
  color: ${({ theme }) => theme.blue1};
`;

const TransactionCompleted = ({ onClose, submitText, showCloseIcon, isShowButtton, onButtonClick, buttonText, }) => {
    const theme = React.useContext(styled.ThemeContext);
    return (jsxRuntime.jsxs(Root$6, { children: [showCloseIcon && (jsxRuntime.jsx(Box, Object.assign({ display: "flex", justifyContent: "flex-end" }, { children: jsxRuntime.jsx(CloseIcon, { onClick: () => onClose && onClose(), color: theme.text4 }) }))), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", flex: 1, paddingY: '20px' }, { children: [jsxRuntime.jsx(Box, Object.assign({ display: "flex", alignItems: "center", mb: 10 }, { children: jsxRuntime.jsx("img", { src: CircleTick, alt: "circle-tick" }) })), submitText && (jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: "text1", textAlign: "center" }, { children: submitText })))] })), isShowButtton && (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onButtonClick }, { children: buttonText })))] }));
};

const ZERO = bignumber.BigNumber.from('0');
// Return the info of the sar stake
function useSarStakeInfo() {
    var _a, _b;
    const chainId = useChainId();
    const sarStakingContract = useSarStakingContract();
    const png = PNG[chainId];
    const rewardRate = (_a = useSingleCallResult(sarStakingContract, 'rewardRate').result) === null || _a === void 0 ? void 0 : _a[0];
    const totalValueVariables = (_b = useSingleCallResult(sarStakingContract, 'totalValueVariables')) === null || _b === void 0 ? void 0 : _b.result;
    return React.useMemo(() => {
        const apr = rewardRate && totalValueVariables && (totalValueVariables === null || totalValueVariables === void 0 ? void 0 : totalValueVariables.balance) && !totalValueVariables.balance.isZero()
            ? rewardRate.mul(86400).mul(365).mul(100).div(totalValueVariables.balance)
            : null;
        const totalStaked = new sdk.TokenAmount(png, totalValueVariables ? totalValueVariables === null || totalValueVariables === void 0 ? void 0 : totalValueVariables.balance.toString() : '0');
        const weeklyPNG = !!rewardRate ? rewardRate.mul(86400).mul(7) : ZERO;
        const sumOfEntryTimes = totalValueVariables ? totalValueVariables === null || totalValueVariables === void 0 ? void 0 : totalValueVariables.sumOfEntryTimes : ZERO;
        return { apr, totalStaked, sumOfEntryTimes, rewardRate: rewardRate !== null && rewardRate !== void 0 ? rewardRate : ZERO, weeklyPNG };
    }, [rewardRate, totalValueVariables]);
}
// Return some utils functions for stake more or create a new Position
function useDerivativeSarStake(positionId) {
    const [attempting, setAttempting] = React.useState(false);
    const [hash, setHash] = React.useState(null);
    const [typedValue, setTypedValue] = React.useState('');
    const [stepIndex, setStepIndex] = React.useState(4);
    const [stakeError, setStakeError] = React.useState(null);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const sarStakingContract = useSarStakingContract();
    const addTransaction = useTransactionAdder();
    const { t } = reactI18next.useTranslation();
    const png = PNG[chainId];
    const userPngBalance = useTokenBalance(account !== null && account !== void 0 ? account : ZERO_ADDRESS, png);
    // used for max input button
    const maxAmountInput = maxAmountSpend(chainId, userPngBalance);
    const usdcPrice = useUSDCPrice(png);
    const dollerWorth = (userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.greaterThan('0')) && usdcPrice ? Number(typedValue) * Number(usdcPrice.toFixed()) : undefined;
    const wrappedOnDismiss = React.useCallback(() => {
        setStakeError(null);
        setTypedValue('');
        setStepIndex(0);
        setHash(null);
        setAttempting(false);
    }, []);
    const { parsedAmount, error } = useDerivedStakeInfo(typedValue, png, userPngBalance);
    const [approval, approveCallback] = useApproveCallback(chainId, parsedAmount, sarStakingContract === null || sarStakingContract === void 0 ? void 0 : sarStakingContract.address);
    const onUserInput = React.useCallback((_typedValue) => {
        setTypedValue(_typedValue);
    }, []);
    const handleMax = React.useCallback(() => {
        maxAmountInput && onUserInput(maxAmountInput.toExact());
        setStepIndex(4);
    }, [maxAmountInput, onUserInput]);
    const onChangePercentage = (value) => {
        if (!userPngBalance) {
            setTypedValue('0');
            return;
        }
        if (value === 100) {
            setTypedValue(userPngBalance.toExact());
        }
        else if (value === 0) {
            setTypedValue('0');
        }
        else {
            const newAmount = userPngBalance
                .multiply(sdk.JSBI.BigInt(value))
                .divide(sdk.JSBI.BigInt(100));
            setTypedValue(newAmount.toSignificant(6));
        }
    };
    const onStake = () => tslib.__awaiter(this, void 0, void 0, function* () {
        if (!sarStakingContract || !parsedAmount) {
            return;
        }
        setAttempting(true);
        try {
            let response;
            if (!positionId) {
                const estimatedGas = yield sarStakingContract.estimateGas.mint(`0x${parsedAmount.raw.toString(16)}`);
                // create a new position
                response = yield sarStakingContract.mint(`0x${parsedAmount.raw.toString(16)}`, {
                    gasLimit: calculateGasMargin(estimatedGas),
                });
            }
            else {
                const estimatedGas = yield sarStakingContract.estimateGas.mint(`0x${parsedAmount.raw.toString(16)}`);
                // adding more png to an existing position
                response = yield sarStakingContract.stake(positionId.toHexString(), `0x${parsedAmount.raw.toString(16)}`, {
                    gasLimit: calculateGasMargin(estimatedGas),
                });
            }
            yield waitForTransaction(response, 3);
            addTransaction(response, {
                summary: t('sarStake.transactionSummary', { symbol: png.symbol, balance: parsedAmount.toSignificant(2) }),
            });
            setHash(response.hash);
        }
        catch (err) {
            // we only care if the error is something _other_ than the user rejected the tx
            const _err = error;
            if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                console.error(_err);
                setStakeError(_err === null || _err === void 0 ? void 0 : _err.message);
            }
        }
        finally {
            setAttempting(false);
        }
    });
    return React.useMemo(() => ({
        attempting,
        typedValue,
        parsedAmount,
        hash,
        stepIndex,
        dollerWorth,
        error,
        approval,
        account,
        png,
        stakeError,
        onAttemptToApprove: approveCallback,
        onUserInput,
        wrappedOnDismiss,
        handleMax,
        onStake,
        onChangePercentage,
        setStepIndex,
    }), [
        attempting,
        typedValue,
        parsedAmount,
        hash,
        stepIndex,
        dollerWorth,
        error,
        approval,
        account,
        sarStakingContract,
        approveCallback,
        onUserInput,
        handleMax,
    ]);
}
function useUnstakeParseAmount(typedValue, stakingToken, userLiquidityStaked) {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const parsedInput = tryParseAmount(typedValue, stakingToken, chainId);
    const parsedAmount = parsedInput && userLiquidityStaked && sdk.JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityStaked.raw)
        ? parsedInput
        : undefined;
    let error;
    if (!account) {
        error = t('stakeHooks.connectWallet');
    }
    if (parsedInput && !parsedAmount) {
        error = error !== null && error !== void 0 ? error : t('stakeHooks.insufficientBalance', { symbol: stakingToken.symbol });
    }
    if (!parsedAmount) {
        error = error !== null && error !== void 0 ? error : t('stakeHooks.enterAmount');
    }
    return {
        parsedAmount,
        error,
    };
}
// Return some utils functions for unstake
function useDerivativeSarUnstake(position) {
    var _a;
    const [typedValue, setTypedValue] = React.useState('');
    const [stepIndex, setStepIndex] = React.useState(0);
    const [unstakeError, setUnstakeError] = React.useState(null);
    const [attempting, setAttempting] = React.useState(false);
    const [hash, setHash] = React.useState(null);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const { t } = reactI18next.useTranslation();
    const addTransaction = useTransactionAdder();
    const png = PNG[chainId];
    const sarStakingContract = useSarStakingContract();
    const stakedAmount = new sdk.TokenAmount(png, ((_a = position === null || position === void 0 ? void 0 : position.balance) !== null && _a !== void 0 ? _a : 0).toString());
    const { parsedAmount, error } = useUnstakeParseAmount(typedValue, png, stakedAmount);
    // used for max input button
    const maxAmountInput = maxAmountSpend(chainId, stakedAmount);
    const wrappedOnDismiss = React.useCallback(() => {
        setUnstakeError(null);
        setTypedValue('');
        setStepIndex(0);
        setHash(null);
        setAttempting(false);
    }, []);
    const onUserInput = React.useCallback((_typedValue) => {
        setTypedValue(_typedValue);
    }, []);
    const handleMax = React.useCallback(() => {
        maxAmountInput && onUserInput(maxAmountInput.toExact());
        setStepIndex(4);
    }, [maxAmountInput, onUserInput]);
    const onChangePercentage = (value) => {
        if (stakedAmount.lessThan('0')) {
            setTypedValue('0');
            return;
        }
        if (value === 100) {
            setTypedValue(stakedAmount.toExact());
        }
        else if (value === 0) {
            setTypedValue('0');
        }
        else {
            const newAmount = stakedAmount.multiply(sdk.JSBI.BigInt(value)).divide(sdk.JSBI.BigInt(100));
            setTypedValue(newAmount.toSignificant(6));
        }
    };
    const onUnstake = () => tslib.__awaiter(this, void 0, void 0, function* () {
        if (!sarStakingContract || !parsedAmount || !position) {
            return;
        }
        setAttempting(true);
        try {
            const estimatedGas = yield sarStakingContract.estimateGas.withdraw(position.id.toHexString(), `0x${parsedAmount.raw.toString(16)}`);
            const response = yield sarStakingContract.withdraw(position.id.toHexString(), `0x${parsedAmount.raw.toString(16)}`, {
                gasLimit: calculateGasMargin(estimatedGas),
            });
            yield waitForTransaction(response, 3);
            addTransaction(response, {
                summary: t('sarUnstake.transactionSummary', { symbol: png.symbol, balance: parsedAmount.toSignificant(2) }),
            });
            setHash(response.hash);
        }
        catch (err) {
            const _err = err;
            if ((_err === null || _err === void 0 ? void 0 : _err.code) !== 4001) {
                console.error(_err);
                setUnstakeError(_err === null || _err === void 0 ? void 0 : _err.message);
            }
        }
        finally {
            setAttempting(false);
        }
    });
    return React.useMemo(() => ({
        attempting,
        hash,
        stepIndex,
        typedValue,
        parsedAmount,
        error,
        unstakeError,
        onUserInput,
        wrappedOnDismiss,
        handleMax,
        onUnstake,
        onChangePercentage,
        setStepIndex,
    }), [
        attempting,
        typedValue,
        parsedAmount,
        hash,
        stepIndex,
        error,
        account,
        sarStakingContract,
        onUserInput,
        handleMax,
        position,
    ]);
}
function useDerivativeSarCompound(position) {
    const [attempting, setAttempting] = React.useState(false);
    const [hash, setHash] = React.useState(null);
    const [compoundError, setCompoundError] = React.useState(null);
    const { account } = usePangolinWeb3();
    const sarStakingContract = useSarStakingContract();
    const { t } = reactI18next.useTranslation();
    const addTransaction = useTransactionAdder();
    const wrappedOnDismiss = React.useCallback(() => {
        setCompoundError(null);
        setHash(null);
        setAttempting(false);
    }, []);
    const onCompound = () => tslib.__awaiter(this, void 0, void 0, function* () {
        if (!sarStakingContract || !position) {
            return;
        }
        setAttempting(true);
        try {
            const estimatedGas = yield sarStakingContract.estimateGas.compound(position.id.toHexString());
            const response = yield sarStakingContract.compound(position.id.toHexString(), {
                gasLimit: calculateGasMargin(estimatedGas),
            });
            yield waitForTransaction(response, 3);
            addTransaction(response, {
                summary: t('sarCompound.transactionSummary'),
            });
            setHash(response.hash);
        }
        catch (error) {
            const err = error;
            if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                console.error(err);
                setCompoundError(err === null || err === void 0 ? void 0 : err.message);
            }
        }
        finally {
            setAttempting(false);
        }
    });
    return React.useMemo(() => ({
        attempting,
        hash,
        compoundError,
        wrappedOnDismiss,
        onCompound,
    }), [sarStakingContract, attempting, hash, account, position]);
}
function useDerivativeSarClaim(position) {
    const [attempting, setAttempting] = React.useState(false);
    const [hash, setHash] = React.useState(null);
    const [claimError, setClaimError] = React.useState(null);
    const { account } = usePangolinWeb3();
    const sarStakingContract = useSarStakingContract();
    const { t } = reactI18next.useTranslation();
    const addTransaction = useTransactionAdder();
    const wrappedOnDismiss = React.useCallback(() => {
        setClaimError(null);
        setHash(null);
        setAttempting(false);
    }, []);
    const onClaim = () => tslib.__awaiter(this, void 0, void 0, function* () {
        if (!sarStakingContract || !position) {
            return;
        }
        setAttempting(true);
        try {
            const estimatedGas = yield sarStakingContract.estimateGas.harvest(position.id.toHexString());
            const response = yield sarStakingContract.harvest(position.id.toHexString(), {
                gasLimit: calculateGasMargin(estimatedGas),
            });
            yield waitForTransaction(response, 3);
            addTransaction(response, {
                summary: t('sarClaim.transactionSummary'),
            });
            setHash(response.hash);
        }
        catch (error) {
            const err = error;
            if ((err === null || err === void 0 ? void 0 : err.code) !== 4001) {
                console.error(err);
                setClaimError(err === null || err === void 0 ? void 0 : err.message);
            }
        }
        finally {
            setAttempting(false);
        }
    });
    return React.useMemo(() => ({
        attempting,
        hash,
        claimError,
        wrappedOnDismiss,
        onClaim,
    }), [sarStakingContract, attempting, hash, account, position]);
}
// Returns a list of user positions
function useSarPositions() {
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const sarStakingContract = useSarStakingContract();
    const [nftsIndexes, setNftsIndexes] = React.useState();
    React.useEffect(() => {
        const getNftsIndexes = () => tslib.__awaiter(this, void 0, void 0, function* () {
            if (!sarStakingContract)
                return;
            const balance = yield sarStakingContract.balanceOf(account);
            if (balance.isZero()) {
                setNftsIndexes([]);
                return;
            }
            // get all positions ids
            const indexes = yield sarStakingContract.tokensOfOwnerByIndex(account, ZERO.toHexString(), balance.sub(1).toHexString());
            const _nftsIndexes = indexes === null || indexes === void 0 ? void 0 : indexes.map((index) => {
                return [index.toHexString()];
            });
            setNftsIndexes(_nftsIndexes);
        });
        getNftsIndexes();
    }, [sarStakingContract]);
    // get the staked amount for each position
    const positionsAmountState = useSingleContractMultipleData(sarStakingContract, 'positions', nftsIndexes !== null && nftsIndexes !== void 0 ? nftsIndexes : []);
    // get the reward rate for each position
    const positionsRewardRateState = useSingleContractMultipleData(sarStakingContract, 'positionRewardRate', nftsIndexes !== null && nftsIndexes !== void 0 ? nftsIndexes : []);
    const positionsPedingRewardsState = useSingleContractMultipleData(sarStakingContract, 'positionPendingRewards', nftsIndexes !== null && nftsIndexes !== void 0 ? nftsIndexes : []);
    //get all NFTs URIs from the positions
    const nftsURIsState = useSingleContractMultipleData(sarStakingContract, 'tokenURI', nftsIndexes !== null && nftsIndexes !== void 0 ? nftsIndexes : []);
    return React.useMemo(() => {
        const isAllFetchedURI = nftsURIsState.every((result) => !result.loading);
        const existErrorURI = nftsURIsState.some((result) => result.error);
        const isValidURIs = nftsURIsState.every((result) => result.valid);
        const isAllFetchedAmount = positionsAmountState.every((result) => !result.loading);
        const existErrorAmount = positionsAmountState.some((result) => result.error);
        const isValidAmounts = positionsAmountState.every((result) => result.valid);
        const isAllFetchedRewardRate = positionsRewardRateState.every((result) => !result.loading);
        const existErrorRewardRate = positionsRewardRateState.some((result) => result.error);
        const isValidRewardRates = positionsRewardRateState.every((result) => result.valid);
        const isAllFetchedPendingReward = positionsPedingRewardsState.every((result) => !result.loading);
        const existErrorPendingReward = positionsPedingRewardsState.some((result) => result.error);
        const isValidPendingRewards = positionsPedingRewardsState.every((result) => result.valid);
        const isLoading = !isAllFetchedURI || !isAllFetchedAmount || !isAllFetchedRewardRate || !isAllFetchedPendingReward;
        // first moments loading is false and valid is false then is loading the query is true
        const isValid = isValidURIs && isValidAmounts && isValidRewardRates && isValidPendingRewards;
        const error = existErrorURI || existErrorAmount || existErrorRewardRate || existErrorPendingReward;
        if (error || !account || !existSarContract(chainId) || (!!nftsIndexes && nftsIndexes.length === 0)) {
            return { positions: [], isLoading: false };
        }
        // if is loading or exist error or not exist account return empty array
        if (isLoading || !isValid || !nftsIndexes) {
            return { positions: [], isLoading: true };
        }
        // we need to decode the base64 uri to get the real uri
        const nftsURIs = nftsURIsState.map((value) => {
            if (value.result) {
                const base64 = value.result[0];
                //need to remove the data:application/json;base64, to decode the base64
                const nftUri = Buffer.from(base64.replace('data:application/json;base64,', ''), 'base64').toString();
                return JSON.parse(nftUri);
            }
            return {};
        });
        const positions = nftsURIs.map((uri, index) => {
            var _a, _b, _c, _d;
            const valueVariables = (_a = positionsAmountState[index].result) === null || _a === void 0 ? void 0 : _a.valueVariables;
            const rewardRate = (_b = positionsRewardRateState[index].result) === null || _b === void 0 ? void 0 : _b[0];
            const pendingRewards = (_c = positionsPedingRewardsState[index].result) === null || _c === void 0 ? void 0 : _c[0];
            const id = nftsIndexes[index][0];
            const balance = (_d = valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.balance) !== null && _d !== void 0 ? _d : bignumber.BigNumber.from(0);
            const apr = rewardRate === null || rewardRate === void 0 ? void 0 : rewardRate.mul(86400).mul(365).mul(100).div(balance.isZero() ? 1 : balance);
            if (!valueVariables || !rewardRate || !pendingRewards || !uri) {
                return {};
            }
            return {
                id: bignumber.BigNumber.from(id),
                balance: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.balance,
                sumOfEntryTimes: valueVariables === null || valueVariables === void 0 ? void 0 : valueVariables.sumOfEntryTimes,
                apr: apr,
                rewardRate: rewardRate,
                uri: uri,
                pendingRewards: pendingRewards,
            };
        });
        // remove the empty positions
        return { positions: positions.filter((position) => !!position), isLoading: false };
    }, [account, positionsAmountState, positionsRewardRateState, nftsURIsState, nftsIndexes]);
}

styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
  padding: 20px;
`;
const ErrorWrapper = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const ErrorBox = styled__default["default"](Box) `
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;
const SubmittedWrapper = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;
const Link = styled__default["default"](Text) `
  text-decoration: none;
  color: ${({ theme }) => theme.blue1};
`;
const Header = styled__default["default"](Box) `
  padding: 0px 10px;
  display: grid;
  grid-gap: 10px;
`;
const TokenRow = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: max-content max-content;
  align-items: center;
`;
const Footer = styled__default["default"](Box) `
  padding: 0px 10px;
`;

const ConfirmDrawer = (props) => {
    const { isOpen, attemptingTxn, title, errorMessage, pendingMessage, successMessage, txHash, confirmContent, onClose, } = props;
    const { chainId } = usePangolinWeb3();
    const theme = React.useContext(styled.ThemeContext);
    const { t } = reactI18next.useTranslation();
    const PendingContent = jsxRuntime.jsx(Loader, { size: 100, label: pendingMessage });
    const ErroContent = (jsxRuntime.jsxs(ErrorWrapper, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxRuntime.jsxs(ErrorBox, { children: [jsxRuntime.jsx(reactFeather.AlertTriangle, { color: theme.red1, style: { strokeWidth: 1.5 }, size: 64 }), jsxRuntime.jsx(Text, Object.assign({ fontWeight: 500, fontSize: 16, color: 'red1', textAlign: "center", style: { width: '85%' } }, { children: errorMessage }))] }), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.dismiss') }))] })));
    const SubmittedContent = (jsxRuntime.jsxs(SubmittedWrapper, Object.assign({ paddingX: "30px", paddingBottom: "30px" }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", paddingY: '20px' }, { children: [jsxRuntime.jsx(Box, Object.assign({ flex: "1", display: "flex", alignItems: "center" }, { children: jsxRuntime.jsx("img", { src: CircleTick, alt: "circle-tick" }) })), jsxRuntime.jsxs(Text, Object.assign({ fontSize: 16, color: "text1", textAlign: "center" }, { children: [successMessage, jsxRuntime.jsx("br", {}), t('sarStake.yourAprRecalculated')] })), chainId && txHash && (jsxRuntime.jsx(Link, Object.assign({ as: "a", fontWeight: 500, fontSize: 14, color: 'primary', href: getEtherscanLink(chainId, txHash, 'transaction'), target: "_blank" }, { children: t('transactionConfirmation.viewExplorer') })))] })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onClose }, { children: t('transactionConfirmation.close') }))] })));
    const renderBody = () => {
        if (errorMessage) {
            return ErroContent;
        }
        if (txHash) {
            return SubmittedContent;
        }
        if (attemptingTxn) {
            return PendingContent;
        }
        return confirmContent;
    };
    return (jsxRuntime.jsx(Drawer, Object.assign({ isOpen: isOpen, onClose: onClose, title: title }, { children: renderBody() })));
};

var Options;
(function (Options) {
    Options["UNSTAKE"] = "Unstake";
    Options["CLAIM"] = "Claim";
    Options["COMPOUND"] = "Compound";
    Options["ADD"] = "Add";
})(Options || (Options = {}));

function Title({ selectPosition, selectedOption, onChange }) {
    const { t } = reactI18next.useTranslation();
    const renderTitle = () => {
        switch (selectedOption) {
            case Options.ADD:
                return t('sarTitle.addMore');
            case Options.UNSTAKE:
                return t('sarTitle.unstake');
            case Options.COMPOUND:
                return t('sarTitle.compound');
            case Options.CLAIM:
                return t('sarTitle.claim');
            default:
                return '';
        }
    };
    return (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column" }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: selectPosition ? 'space-between' : 'start', alignItems: "center" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "15.75px", fontWeight: 700 }, { children: renderTitle() })), selectPosition && (jsxRuntime.jsx(Text, Object.assign({ color: "text8", fontSize: "10px" }, { children: t('sarTitle.interactingID', { id: selectPosition === null || selectPosition === void 0 ? void 0 : selectPosition.id.toString() }) })))] })), jsxRuntime.jsx(ToggleButtons, { options: [Options.COMPOUND, Options.ADD, Options.UNSTAKE, Options.CLAIM], value: selectedOption, onChange: onChange })] })));
}

const Root$5 = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;
const Buttons$3 = styled__default["default"](Box) `
  display: grid;
  grid-auto-flow: ${({ isStaked }) => (isStaked ? 'column' : 'row')};
  grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 10px;
  margin-top: 5px;
`;
const Wrapper$3 = styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;

// Add more png on existing position
function AddStake({ selectedOption, selectedPosition, onChange }) {
    var _a, _b, _c, _d, _e;
    const [openDrawer, setOpenDrawer] = React.useState(false);
    const chainId = useChainId();
    const { account } = usePangolinWeb3();
    const png = PNG[chainId];
    const userPngBalance = useTokenBalance(account !== null && account !== void 0 ? account : ZERO_ADDRESS, png);
    const { t } = reactI18next.useTranslation();
    const { apr } = useSarStakeInfo();
    const toggleWalletModal = useWalletModalToggle();
    const { attempting, typedValue, parsedAmount, hash, dollerWorth, error, approval, stakeError, onAttemptToApprove, onUserInput, wrappedOnDismiss, handleMax, onStake, } = useDerivativeSarStake(selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.id);
    const oldBalance = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.balance;
    const newBalance = oldBalance === null || oldBalance === void 0 ? void 0 : oldBalance.add(((_a = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.raw) !== null && _a !== void 0 ? _a : 0).toString()).add((_b = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.pendingRewards) !== null && _b !== void 0 ? _b : 0);
    // if new balance is zero return 1, if not exist position return 1 , if exist position return new balance
    const _newBalance = (newBalance === null || newBalance === void 0 ? void 0 : newBalance.isZero()) ? 1 : newBalance !== null && newBalance !== void 0 ? newBalance : 1;
    const newAPR = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.rewardRate.mul(86400).mul(365).mul(100).div(_newBalance);
    const weeklyPNG = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.rewardRate.mul(86400).mul(7);
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = React.useState(false);
    // mark when a user has submitted an approval, reset onTokenSelection for input field
    React.useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const handleConfirmDismiss = React.useCallback(() => {
        setOpenDrawer(false);
        // if there was a tx hash, we want to clear the input
        if (hash) {
            onUserInput('');
        }
        wrappedOnDismiss();
    }, [onUserInput]);
    const showApproveFlow = !error &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED));
    const renderButtons = () => {
        if (!account) {
            return (jsxRuntime.jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", onClick: toggleWalletModal }, { children: t('earn.connectWallet') })));
        }
        else if (!(userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.greaterThan('0'))) {
            return (jsxRuntime.jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", as: "a", href: getBuyUrl(png, chainId) }, { children: t('sarStake.buy', { symbol: png.symbol }) })));
        }
        else {
            return (jsxRuntime.jsxs(Buttons$3, { children: [showApproveFlow && (jsxRuntime.jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', isDisabled: approval !== ApprovalState.NOT_APPROVED, onClick: onAttemptToApprove, height: "46px" }, { children: t('earn.approve') }))), jsxRuntime.jsx(Button, Object.assign({ variant: 'primary', isDisabled: !selectedPosition || !!error || approval !== ApprovalState.APPROVED, onClick: () => setOpenDrawer(true), height: "46px" }, { children: !selectedPosition ? t('sarStakeMore.choosePosition') : error !== null && error !== void 0 ? error : t('sarStakeMore.add') }))] }));
        }
    };
    const ConfirmContent = (jsxRuntime.jsxs(Wrapper$3, Object.assign({ paddingX: "20px", paddingBottom: "20px" }, { children: [jsxRuntime.jsxs(Header, { children: [jsxRuntime.jsxs(TokenRow, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: "text1", style: { marginRight: '12px' } }, { children: (_c = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toSignificant(6)) !== null && _c !== void 0 ? _c : 0 })), jsxRuntime.jsx(CurrencyLogo, { currency: png, size: 24, imageSize: 48 })] }), jsxRuntime.jsxs(Box, Object.assign({ display: "inline-grid", style: { gridGap: '10px', gridTemplateColumns: 'auto auto' } }, { children: [jsxRuntime.jsx(Stat, { title: t('sarStake.dollarValue'), titlePosition: "top", stat: `$${dollerWorth !== null && dollerWorth !== void 0 ? dollerWorth : 0}`, titleColor: "text2" }), jsxRuntime.jsx(Stat, { title: t('sarStakeMore.newAPR'), titlePosition: "top", stat: `${newAPR}%`, titleColor: "text2" })] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "row", justifyContent: "space-between" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: t('sarStake.weeklyDistributed', { symbol: png.symbol }) })), jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: numeral__default["default"](units.formatEther(weeklyPNG !== null && weeklyPNG !== void 0 ? weeklyPNG : 0)).format('0.00a') }))] })), jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: [t('sarStake.confirmDescription', { symbol: png.symbol }), jsxRuntime.jsx("br", {}), jsxRuntime.jsx("br", {}), t('sarStakeMore.confirmDescription', { symbol: png.symbol })] }))] }), jsxRuntime.jsx(Footer, { children: jsxRuntime.jsx(Box, Object.assign({ my: '10px' }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onStake }, { children: t('sarStakeMore.add') })) })) })] })));
    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Root$5, { children: [jsxRuntime.jsx(Title, { selectPosition: selectedPosition, selectedOption: selectedOption, onChange: onChange }), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Box, Object.assign({ justifyContent: "space-between", display: "flex" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "18px", fontWeight: 500 }, { children: t('sarStakeMore.stakeMore') })), jsxRuntime.jsx(Text, Object.assign({ color: "text4" }, { children: t('sarStake.walletBalance', { symbol: png.symbol, balance: (_d = userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.toFixed(2)) !== null && _d !== void 0 ? _d : 0 }) }))] })), jsxRuntime.jsx(TextInput, { value: typedValue, isNumeric: true, placeholder: "0.00", onChange: (value) => {
                                    onUserInput(value);
                                }, addonAfter: jsxRuntime.jsx(Button, Object.assign({ variant: "plain", backgroundColor: "color2", padding: "6px", height: "auto", onClick: handleMax }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: "MAX" })) })) })] }), jsxRuntime.jsxs(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.dollarValue') })), jsxRuntime.jsxs(Text, Object.assign({ color: "text1" }, { children: ["$", dollerWorth !== null && dollerWorth !== void 0 ? dollerWorth : '0'] }))] }), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.averageAPR') })), jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: `${(apr !== null && apr !== void 0 ? apr : '-').toString()}%` }))] })] })), jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: [t('sarStake.confirmDescription', { symbol: png.symbol }), jsxRuntime.jsx("br", {}), jsxRuntime.jsx("br", {}), t('sarStakeMore.confirmDescription', { symbol: png.symbol })] }))] })), renderButtons()] }), jsxRuntime.jsx(ConfirmDrawer, { title: stakeError || hash || attempting ? '' : t('sarStake.summary'), isOpen: openDrawer && !!selectedPosition, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: stakeError, pendingMessage: t('sarStakeMore.pending', { balance: (_e = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toFixed(2)) !== null && _e !== void 0 ? _e : 0, symbol: png.symbol }), successMessage: t('sarStake.successSubmit'), confirmContent: ConfirmContent })] }));
}

function RewardsInfo({ selectedOption, selectedPosition, pendingRewards, onChange }) {
    const { t } = reactI18next.useTranslation();
    const chainId = useChainId();
    const png = PNG[chainId];
    const theme = React.useContext(styled.ThemeContext);
    const formattedPedingRewards = numeral__default["default"](pendingRewards).format('0.00a');
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Title, { selectPosition: selectedPosition, selectedOption: selectedOption, onChange: onChange }), !selectedPosition ? (jsxRuntime.jsx(Box, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "24px", fontWeight: 500, textAlign: "center" }, { children: t('sarStakeMore.choosePosition') })) })) : (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: "16px", fontWeight: 500, textAlign: "center" }, { children: [t('sarCompound.reward'), ":"] })), jsxRuntime.jsx(Tooltip, Object.assign({ id: "pendingRewards", effect: "solid", backgroundColor: theme.primary }, { children: jsxRuntime.jsxs(Text, Object.assign({ color: "eerieBlack", fontSize: "12px", fontWeight: 500, textAlign: "center" }, { children: [pendingRewards, " ", png.symbol] })) })), jsxRuntime.jsxs(Text, Object.assign({ color: "text1", fontSize: "36px", fontWeight: 500, textAlign: "center", "data-tip": true, "data-for": "pendingRewards" }, { children: [formattedPedingRewards === 'NaN' ? '0.00' : formattedPedingRewards, jsxRuntime.jsx(CurrencyLogo, { currency: png })] }))] }))] }));
}

const Root$4 = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;
const Buttons$2 = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-gap: 20px;
`;

function Claim({ selectedOption, selectedPosition, onChange }) {
    var _a;
    const [openDrawer, setOpenDrawer] = React.useState(false);
    const { attempting, hash, claimError, wrappedOnDismiss, onClaim } = useDerivativeSarClaim(selectedPosition);
    const { t } = reactI18next.useTranslation();
    const apr = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.apr;
    const handleConfirmDismiss = React.useCallback(() => {
        setOpenDrawer(false);
        wrappedOnDismiss();
    }, []);
    const handleConfirm = React.useCallback(() => {
        onClaim();
    }, [onClaim]);
    React.useEffect(() => {
        if (openDrawer && !attempting && !hash && !claimError) {
            handleConfirmDismiss();
        }
        if (!openDrawer && attempting) {
            setOpenDrawer(true);
        }
    }, [attempting]);
    const pendingRewards = (_a = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.pendingRewards) !== null && _a !== void 0 ? _a : bignumber.BigNumber.from('0');
    const renderButton = () => {
        let error;
        if (!selectedPosition) {
            error = t('sarStakeMore.choosePosition');
        }
        else if (pendingRewards.isZero()) {
            error = t('sarClaim.noRewards');
        }
        return (jsxRuntime.jsxs(Buttons$2, { children: [jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: () => onChange(Options.COMPOUND) }, { children: t('sarCompound.compound') })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: handleConfirm, isDisabled: !!error }, { children: error !== null && error !== void 0 ? error : t('sarClaim.claim') }))] }));
    };
    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Root$4, { children: [jsxRuntime.jsx(RewardsInfo, { selectedOption: selectedOption, onChange: onChange, pendingRewards: units.formatEther(pendingRewards), selectedPosition: selectedPosition }), jsxRuntime.jsxs(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarUnstake.currentAPR') })), jsxRuntime.jsxs(Text, Object.assign({ color: "text1" }, { children: [(apr !== null && apr !== void 0 ? apr : '-').toString(), "%"] }))] }), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarClaim.aprAfter') })), jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: "0%" }))] })] })), jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: "Due to the nature of SAR staking system claiming your rewards will drop your APR to 0. You can instead compound your rewards without losing your APR." }))] })), renderButton()] }), jsxRuntime.jsx(ConfirmDrawer, { isOpen: openDrawer && !!selectedPosition, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: claimError, pendingMessage: t('sarClaim.pending'), successMessage: t('sarClaim.successSubmit'), confirmContent: null })] }));
}

const Root$3 = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;

function Compound({ selectedOption, selectedPosition, onChange }) {
    var _a, _b, _c;
    const [openDrawer, setOpenDrawer] = React.useState(false);
    const { attempting, hash, compoundError, wrappedOnDismiss, onCompound } = useDerivativeSarCompound(selectedPosition);
    const { apr } = useSarStakeInfo();
    const oldBalance = (_a = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.balance) !== null && _a !== void 0 ? _a : bignumber.BigNumber.from('0');
    const pendingRewards = (_b = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.pendingRewards) !== null && _b !== void 0 ? _b : bignumber.BigNumber.from('0');
    const chainId = useChainId();
    const png = PNG[chainId];
    const useUSDPrice = useUSDCPriceHook[chainId];
    const pngPrice = useUSDPrice(png);
    const dollarValue = parseFloat(units.formatEther(oldBalance.add(pendingRewards))) * Number((_c = pngPrice === null || pngPrice === void 0 ? void 0 : pngPrice.toFixed()) !== null && _c !== void 0 ? _c : 0);
    const { t } = reactI18next.useTranslation();
    const handleConfirmDismiss = React.useCallback(() => {
        setOpenDrawer(false);
        wrappedOnDismiss();
    }, []);
    React.useEffect(() => {
        if (openDrawer && !attempting && !hash && !compoundError) {
            handleConfirmDismiss();
        }
        if (!openDrawer && attempting) {
            setOpenDrawer(true);
        }
    }, [attempting]);
    const renderButton = () => {
        let error;
        if (!selectedPosition) {
            error = t('sarStakeMore.choosePosition');
        }
        else if (oldBalance === null || oldBalance === void 0 ? void 0 : oldBalance.isZero()) {
            error = t('sarCompound.noRewards');
        }
        return (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onCompound, isDisabled: !!error }, { children: error !== null && error !== void 0 ? error : t('sarCompound.compound') })));
    };
    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Root$3, { children: [jsxRuntime.jsx(RewardsInfo, { selectedOption: selectedOption, onChange: onChange, pendingRewards: units.formatEther(pendingRewards.toString()), selectedPosition: selectedPosition }), jsxRuntime.jsxs(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.dollarValue') })), jsxRuntime.jsxs(Text, Object.assign({ color: "text1" }, { children: ["$", dollarValue] }))] }), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.averageAPR') })), jsxRuntime.jsxs(Text, Object.assign({ color: "text1" }, { children: [(apr !== null && apr !== void 0 ? apr : '-').toString(), "%"] }))] })] })), jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: t('sarCompound.description') }))] })), renderButton()] }), jsxRuntime.jsx(ConfirmDrawer, { isOpen: openDrawer && !!selectedPosition, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: compoundError, pendingMessage: t('sarCompound.pending'), successMessage: t('sarCompound.successSubmit'), confirmContent: null })] }));
}

const Wrapper$2 = styled__default["default"](Box) `
  border-radius: 10px;
  width: 100%;
  background-color: ${({ theme }) => theme.color2};
  position: relative;
  overflow: hidden;
  padding: 30px;
  box-sizing: border-box;
`;

const Root$2 = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;
styled__default["default"](Box) `
  display: grid;
  grid-template-rows: auto max-content;
  height: 100%;
`;

function Unstake({ selectedOption, selectedPosition, onChange }) {
    var _a, _b, _c, _d, _e;
    const [openDrawer, setOpenDrawer] = React.useState(false);
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const png = PNG[chainId];
    const stakedAmount = (_a = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.balance) !== null && _a !== void 0 ? _a : 0;
    const { t } = reactI18next.useTranslation();
    const { attempting, hash, typedValue, parsedAmount, error, unstakeError, onUserInput, wrappedOnDismiss, handleMax, onUnstake, } = useDerivativeSarUnstake(selectedPosition);
    const toggleWalletModal = useWalletModalToggle();
    const handleConfirmDismiss = React.useCallback(() => {
        setOpenDrawer(false);
        // if there was a tx hash, we want to clear the input
        if (hash) {
            onUserInput('');
        }
        wrappedOnDismiss();
    }, [onUserInput]);
    const renderButton = () => {
        if (!account) {
            return (jsxRuntime.jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", onClick: toggleWalletModal }, { children: t('removeLiquidity.connectWallet') })));
        }
        else {
            return (jsxRuntime.jsx(Button, Object.assign({ variant: 'primary', isDisabled: !selectedPosition || !!error, onClick: () => setOpenDrawer(true), height: "46px" }, { children: !selectedPosition ? t('sarStakeMore.choosePosition') : error !== null && error !== void 0 ? error : t('sarUnstake.unstake') })));
        }
    };
    const ConfirmContent = (jsxRuntime.jsxs(Wrapper$2, Object.assign({ paddingX: "20px", paddingBottom: "20px" }, { children: [jsxRuntime.jsxs(Header, { children: [jsxRuntime.jsxs(TokenRow, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 24, fontWeight: 500, color: "text1", style: { marginRight: '12px' } }, { children: t('sarUnstake.unstaking', { balance: (_b = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toSignificant(6)) !== null && _b !== void 0 ? _b : 0 }) })), jsxRuntime.jsx(CurrencyLogo, { currency: png, size: 24, imageSize: 48 })] }), jsxRuntime.jsxs(Box, Object.assign({ display: "inline-grid", style: { gridGap: '10px', gridTemplateColumns: 'auto auto' } }, { children: [jsxRuntime.jsx(Stat, { title: t('sarUnstake.currentAPR'), titlePosition: "top", stat: `${((_c = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.apr) !== null && _c !== void 0 ? _c : '-').toString()}%`, titleColor: "text2" }), jsxRuntime.jsx(Stat, { title: t('sarStakeMore.newAPR'), titlePosition: "top", stat: '0%', titleColor: "text2" })] })), jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: t('sarUnstake.confirmDescription') }))] }), jsxRuntime.jsx(Footer, { children: jsxRuntime.jsx(Box, Object.assign({ my: '10px' }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onUnstake }, { children: t('sarUnstake.unstake') })) })) })] })));
    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Root$2, { children: [jsxRuntime.jsx(Title, { selectPosition: selectedPosition, selectedOption: selectedOption, onChange: onChange }), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Box, Object.assign({ justifyContent: "space-between", display: "flex" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "18px", fontWeight: 500 }, { children: t('sarUnstake.unstake') })), jsxRuntime.jsx(Text, Object.assign({ color: "text4" }, { children: t('sarUnstake.stakedBalance', {
                                            symbol: png.symbol,
                                            balance: numeral__default["default"](units.formatEther(stakedAmount)).format('0.00a'),
                                        }) }))] })), jsxRuntime.jsx(TextInput, { value: typedValue, isNumeric: true, placeholder: "0.00", addonAfter: jsxRuntime.jsx(Button, Object.assign({ variant: "plain", backgroundColor: "color2", padding: "6px", height: "auto", onClick: handleMax }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: t('sarStake.max') })) })), onChange: (value) => {
                                    onUserInput(value);
                                } })] }), jsxRuntime.jsxs(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarUnstake.currentAPR') })), jsxRuntime.jsxs(Text, Object.assign({ color: "text1" }, { children: [((_d = selectedPosition === null || selectedPosition === void 0 ? void 0 : selectedPosition.apr) !== null && _d !== void 0 ? _d : '-').toString(), "%"] }))] }), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarUnstake.aprAfter') })), jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: "0%" }))] })] })), jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "14px", textAlign: "center" }, { children: t('sarUnstake.unstakeWarning') }))] })), renderButton()] }), jsxRuntime.jsx(ConfirmDrawer, { title: unstakeError || hash || attempting ? '' : t('sarStake.summary'), isOpen: openDrawer && !!selectedPosition, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: unstakeError, pendingMessage: t('sarUnstake.pending', { balance: (_e = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toSignificant(2)) !== null && _e !== void 0 ? _e : 0, symbol: png.symbol }), successMessage: t('sarUnstake.successSubmit'), confirmContent: ConfirmContent })] }));
}

function SarMangePortfolio({ selectedPosition }) {
    const [type, setType] = React.useState(Options.ADD);
    const handleChange = (value) => {
        setType(value);
    };
    const renderBody = () => {
        switch (type) {
            case Options.ADD:
                return jsxRuntime.jsx(AddStake, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
            case Options.UNSTAKE:
                return jsxRuntime.jsx(Unstake, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
            case Options.CLAIM:
                return jsxRuntime.jsx(Claim, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
            case Options.COMPOUND:
                return jsxRuntime.jsx(Compound, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
            default:
                return jsxRuntime.jsx(AddStake, { selectedPosition: selectedPosition, selectedOption: type, onChange: handleChange });
        }
    };
    return jsxRuntime.jsx(Wrapper$2, Object.assign({ id: "sar-manage-widget" }, { children: renderBody() }));
}

const Paginate = styled__default["default"](ReactPaginate__default["default"]) `
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  list-style-type: none;
  padding: 0 5rem;

  li a {
    border-radius: 7px;
    padding: 0.1rem 1rem;
    cursor: pointer;
    color: ${({ theme }) => theme.text1};
  }

  li.previous a,
  li.next a,
  li.break a {
    border-color: transparent;
  }

  li.active a {
    background-color: ${({ theme }) => theme.primary};
    border-color: transparent;
    color: black;
    min-width: 32px;
  }

  li.disabled a {
    color: ${({ theme }) => { var _a, _b; return (_b = (_a = theme.button) === null || _a === void 0 ? void 0 : _a.disable) === null || _b === void 0 ? void 0 : _b.background; }};
    cursor: default;
  }
`;

function Pagination({ pageCount, forcePage, onPageChange }) {
    return (jsxRuntime.jsx(Box, Object.assign({ display: "flex", justifyContent: "center", alignItems: "center" }, { children: jsxRuntime.jsx(Paginate, { onPageChange: onPageChange, pageRangeDisplayed: 3, marginPagesDisplayed: 2, pageCount: pageCount, previousLabel: jsxRuntime.jsx(reactFeather.ChevronLeft, { size: 20 }), nextLabel: jsxRuntime.jsx(reactFeather.ChevronRight, { size: 20 }), breakLabel: "...", activeClassName: "active", forcePage: forcePage }) })));
}

const Root$1 = styled__default["default"](Box) `
  display: flex;
  width: 100%;
  height: 100%;
`;
styled__default["default"](Box) `
  display: inline-grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
`;
const Frame = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  flex-grow: 1;
  grid-gap: 16px;
`;
const StyledSVG = styled__default["default"](Box) `
  svg {
    width: 100%;
    height: auto;
  }
`;
const Overlay = styled__default["default"].div `
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(35, 35, 35);
  opacity: 0.8;
  display: none;
  z-index: 99;
`;

function Portfolio({ positions, onSelectPosition }) {
    const [itemsPerPage, setItemsPerPage] = React.useState(12);
    const [pageCount, setPageCount] = React.useState(0);
    const [itemOffset, setItemOffset] = React.useState(0);
    const [currentItems, setCurrentItems] = React.useState(positions.slice(0, itemsPerPage));
    const [selectedOption, setSelectedOption] = React.useState('');
    const [selectedPositonId, setSelectedPositionId] = React.useState(null);
    const [page, setPage] = React.useState();
    const node = React.useRef(null);
    const imageRef = React.useRef(null);
    const { t } = reactI18next.useTranslation();
    const isMobile = reactUse.useMedia(`(max-width: ${MEDIA_WIDTHS.upToMedium}px)`);
    function sortItems(itemOffset, endOffset, sortOption) {
        if (sortOption === 'apr') {
            setCurrentItems([...positions].sort((a, b) => b.apr.sub(a.apr).toNumber()).slice(itemOffset, endOffset));
        }
        else if (sortOption === 'amount') {
            setCurrentItems([...positions]
                .sort((a, b) => {
                return parseFloat(units.formatEther(b.balance.sub(a.balance)));
            })
                .slice(itemOffset, endOffset));
        }
        else if (sortOption === 'newest') {
            setCurrentItems([...positions].sort((a, b) => b.id.sub(a.id).toNumber()).slice(itemOffset, endOffset));
        }
        else if (sortOption === 'oldest') {
            setCurrentItems([...positions].sort((a, b) => a.id.sub(b.id).toNumber()).slice(itemOffset, endOffset));
        }
        else {
            setCurrentItems(positions.slice(itemOffset, endOffset));
        }
    }
    const onSelect = (value) => {
        setSelectedOption(value);
        sortItems(0, itemsPerPage, value);
        setPage(0);
        setItemOffset(0);
    };
    const { width, height } = reactUse.useWindowSize();
    React.useEffect(() => {
        const endOffset = itemOffset + itemsPerPage;
        sortItems(itemOffset, endOffset, selectedOption || '');
        setPageCount(Math.ceil(positions.length / itemsPerPage));
        setPage(undefined);
    }, [positions, itemOffset, itemsPerPage]);
    // calcule items per page based on node size and image size
    React.useEffect(() => {
        if (node.current && imageRef.current) {
            const nodeWidth = node.current.offsetWidth;
            const nodeHeight = node.current.offsetHeight;
            const imageWidth = imageRef.current.offsetWidth;
            const imageHeight = imageRef.current.offsetHeight;
            // number of columns = node width  / image width
            // number of rows = node height / image height
            // items per page = number of columns * number of rows
            let _itemsPerPage = Math.floor(nodeWidth / imageWidth); // calculate number of columns
            _itemsPerPage = _itemsPerPage * Math.floor(nodeHeight / imageHeight); // calculate number of rows
            setItemsPerPage(_itemsPerPage);
        }
        else {
            setItemsPerPage(12); // fallback to show 12 items per page
        }
        setPage(undefined);
    }, [width, height]);
    const handlePageClick = (event) => {
        const newOffset = (event.selected * itemsPerPage) % positions.length;
        setItemOffset(newOffset);
    };
    const renderItems = () => {
        return currentItems.map((position, index) => {
            const svg = Buffer.from(position === null || position === void 0 ? void 0 : position.uri.image.replace('data:image/svg+xml;base64,', ''), 'base64').toString(); // decode base64
            const isSelected = !!selectedPositonId && (position === null || position === void 0 ? void 0 : position.id.eq(selectedPositonId));
            return (jsxRuntime.jsxs(Box, Object.assign({ width: "100%", height: "max-content", bgColor: isSelected ? 'primary' : undefined, borderRadius: "5px", paddingX: "5px", paddingBottom: "5px", style: { cursor: 'pointer', boxSizing: 'border-box' }, onClick: () => {
                    if (isMobile) {
                        const element = document.getElementById('sar-manage-widget');
                        scrollElementIntoView(element, 'smooth');
                    }
                    setSelectedPositionId(isSelected ? null : position.id);
                    onSelectPosition(isSelected ? null : position);
                }, ref: imageRef }, { children: [jsxRuntime.jsx(StyledSVG, { dangerouslySetInnerHTML: { __html: svg }, width: "100%" }, svg), jsxRuntime.jsxs(Text, Object.assign({ color: isSelected ? 'black' : 'text1', textAlign: "center", fontWeight: 500 }, { children: [t('sarPortfolio.positionId'), ": ", position === null || position === void 0 ? void 0 : position.id.toString()] }))] }), index));
        });
    };
    return (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", width: "100%" }, { children: [jsxRuntime.jsx(Box, Object.assign({ display: "flex", justifyContent: "end", mb: "20px" }, { children: jsxRuntime.jsx(DropdownMenu, { placeHolder: `${t('sarPortfolio.sortBy')}:`, onSelect: onSelect, defaultValue: selectedOption, isMulti: false, options: [
                        { label: t('sarPortfolio.apr'), value: 'apr' },
                        { label: t('sarPortfolio.amount'), value: 'amount' },
                        { label: t('sarPortfolio.newest'), value: 'newest' },
                        { label: t('sarPortfolio.oldest'), value: 'oldest' },
                    ] }) })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "column", flexGrow: 1 }, { children: [jsxRuntime.jsx(Frame, Object.assign({ ref: node }, { children: renderItems() })), jsxRuntime.jsx(Pagination, { pageCount: pageCount, onPageChange: handlePageClick, forcePage: page })] }))] })));
}

function SarNFTPortfolio({ onSelectPosition }) {
    const { account } = usePangolinWeb3();
    const { positions, isLoading } = useSarPositions();
    // sort by balance
    const filteredPositions = positions === null || positions === void 0 ? void 0 : positions.filter((position) => !position.balance.isZero()).sort((a, b) => Number(b.balance.sub(a.balance).toString())); // remove zero balances and sort by balance
    const toggleWalletModal = useWalletModalToggle();
    const { t } = reactI18next.useTranslation();
    const sarOverlayElement = document.getElementById('sar-portfolio-overlay');
    const displayOverlay = () => {
        if (sarOverlayElement) {
            sarOverlayElement.style.display = 'block';
        }
    };
    const hideOverlay = () => {
        if (sarOverlayElement) {
            sarOverlayElement.style.display = 'none';
        }
    };
    const focusCreatePosition = () => {
        var _a;
        const element = document.getElementById('create-sar-position-widget');
        scrollElementIntoView(element, 'smooth');
        (_a = document.getElementById('sar-stake-input')) === null || _a === void 0 ? void 0 : _a.focus();
        displayOverlay();
    };
    // remove overlay when user change the account
    React.useEffect(() => {
        hideOverlay();
    }, [account]);
    const renderBody = () => {
        if (isLoading || !filteredPositions) {
            return (jsxRuntime.jsx(Box, Object.assign({ justifyContent: "center", alignItems: "center", width: "100%", height: "100%" }, { children: jsxRuntime.jsx(Loader, { size: 100 }) })));
        }
        else if (filteredPositions.length === 0) {
            return (jsxRuntime.jsxs(Box, Object.assign({ display: "grid", justifyItems: "center", alignContent: "center", width: "100%", height: "100%", style: { gridGap: '30px' } }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "18px", fontWeight: 500, textAlign: "center" }, { children: t('sarPortfolio.noPositions') })), !account ? (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", width: "250px", onClick: toggleWalletModal }, { children: t('removeLiquidity.connectWallet') }))) : (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", width: "250px", onClick: focusCreatePosition }, { children: t('sarPortfolio.start') })))] })));
        }
        return jsxRuntime.jsx(Portfolio, { positions: filteredPositions, onSelectPosition: onSelectPosition });
    };
    return (jsxRuntime.jsxs(Root$1, { children: [renderBody(), jsxRuntime.jsx(Overlay, { id: "sar-portfolio-overlay", onClick: hideOverlay })] }));
}

const Root = styled__default["default"](Box) `
  width: 100%;
  position: relative;
  overflow: hidden;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 16px;
`;
const Wrapper$1 = styled__default["default"](Box) `
  border-radius: 10px;
  width: 100%;
  background-color: ${({ theme }) => theme.color2};
  position: relative;
  overflow-x: hidden;
  box-sizing: border-box;
`;
const Buttons$1 = styled__default["default"](Box) `
  display: grid;
  grid-auto-flow: ${({ isStaked }) => (isStaked ? 'column' : 'row')};
  grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
  grid-gap: 10px;
  margin-top: 5px;
`;

function SarManageWidget() {
    var _a, _b, _c;
    const [openDrawer, setOpenDrawer] = React.useState(false);
    const chainId = useChainId();
    const { account } = usePangolinWeb3();
    const png = PNG[chainId];
    const userPngBalance = useTokenBalance(account !== null && account !== void 0 ? account : ZERO_ADDRESS, png);
    const { t } = reactI18next.useTranslation();
    const { apr, weeklyPNG } = useSarStakeInfo();
    const toggleWalletModal = useWalletModalToggle();
    const { positions, isLoading } = useSarPositions();
    // get fist position with balance 0
    const position = positions === null || positions === void 0 ? void 0 : positions.find((value) => value.balance.isZero());
    const { attempting, typedValue, parsedAmount, hash, dollerWorth, error, approval, stakeError, onAttemptToApprove, onUserInput, wrappedOnDismiss, handleMax, onStake, } = useDerivativeSarStake(position === null || position === void 0 ? void 0 : position.id);
    // check if user has gone through approval process, used to show two step buttons, reset on token change
    const [approvalSubmitted, setApprovalSubmitted] = React.useState(false);
    // mark when a user has submitted an approval, reset onTokenSelection for input field
    React.useEffect(() => {
        if (approval === ApprovalState.PENDING) {
            setApprovalSubmitted(true);
        }
    }, [approval, approvalSubmitted]);
    const handleConfirmDismiss = React.useCallback(() => {
        setOpenDrawer(false);
        // if there was a tx hash, we want to clear the input
        if (hash) {
            onUserInput('');
        }
        wrappedOnDismiss();
    }, [onUserInput]);
    const desativeOverlay = () => {
        const sarOverlayElement = document.getElementById('sar-portfolio-overlay');
        if (sarOverlayElement) {
            sarOverlayElement.style.display = 'none';
        }
    };
    const showApproveFlow = !error &&
        (approval === ApprovalState.NOT_APPROVED ||
            approval === ApprovalState.PENDING ||
            (approvalSubmitted && approval === ApprovalState.APPROVED));
    const renderButtons = () => {
        if (!account) {
            return (jsxRuntime.jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", onClick: toggleWalletModal }, { children: t('removeLiquidity.connectWallet') })));
        }
        else if (!(userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.greaterThan('0'))) {
            return (jsxRuntime.jsx(Button, Object.assign({ padding: "15px 18px", variant: "primary", as: "a", href: getBuyUrl(png, chainId), onClick: desativeOverlay }, { children: t('sarStake.buy', { symbol: png.symbol }) })));
        }
        else {
            return (jsxRuntime.jsxs(Buttons$1, { children: [showApproveFlow && (jsxRuntime.jsx(Button, Object.assign({ variant: approval === ApprovalState.APPROVED ? 'confirm' : 'primary', isDisabled: approval !== ApprovalState.NOT_APPROVED || isLoading || !positions, onClick: onAttemptToApprove, height: "46px" }, { children: t('earn.approve') }))), jsxRuntime.jsx(Button, Object.assign({ variant: 'primary', isDisabled: !!error || approval !== ApprovalState.APPROVED || isLoading || !positions, onClick: () => {
                            setOpenDrawer(true);
                            desativeOverlay();
                        }, height: "46px" }, { children: error !== null && error !== void 0 ? error : t('sarStake.stake') }))] }));
        }
    };
    const handleInput = React.useCallback((value) => {
        onUserInput(value);
    }, [onUserInput]);
    const ConfirmContent = (jsxRuntime.jsxs(Box, Object.assign({ width: "100%", height: "100%", paddingX: "20px", paddingBottom: "20px" }, { children: [jsxRuntime.jsxs(Header, { children: [jsxRuntime.jsxs(TokenRow, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 20, fontWeight: 500, color: "text1", style: { marginRight: '12px' } }, { children: (_a = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toSignificant(6)) !== null && _a !== void 0 ? _a : 0 })), jsxRuntime.jsx(CurrencyLogo, { currency: png, size: 24, imageSize: 48 })] }), jsxRuntime.jsxs(Box, Object.assign({ display: "inline-grid", style: { gridGap: '10px', gridTemplateColumns: '1fr 1fr' } }, { children: [jsxRuntime.jsx(Stat, { title: t('sarStake.dollarValue'), titlePosition: "top", titleFontSize: 16, statFontSize: 12, stat: `$${dollerWorth !== null && dollerWorth !== void 0 ? dollerWorth : 0}`, titleColor: "text2" }), jsxRuntime.jsx(Stat, { title: t('sarStake.startingApr'), titlePosition: "top", stat: '0%', titleColor: "text2", titleFontSize: 16, statFontSize: 12 })] })), jsxRuntime.jsxs(Box, Object.assign({ display: "flex", flexDirection: "row", justifyContent: "space-between" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: t('sarStake.weeklyDistributed', { symbol: png.symbol }) })), jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: numeral__default["default"](units.formatEther(weeklyPNG)).format('0.00a') }))] })), jsxRuntime.jsx(Box, Object.assign({ bgColor: "color3", borderRadius: "8px", padding: "10px" }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontWeight: 400, fontSize: "12px", textAlign: "center" }, { children: t('sarStake.confirmDescription', { symbol: png.symbol }) })) }))] }), jsxRuntime.jsx(Footer, { children: jsxRuntime.jsx(Box, Object.assign({ my: '10px' }, { children: jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: onStake }, { children: t('sarStake.stake') })) })) })] })));
    return (jsxRuntime.jsxs(Wrapper$1, Object.assign({ id: "create-sar-position-widget", zIndex: 100 }, { children: [jsxRuntime.jsxs(Root, Object.assign({ padding: "30px" }, { children: [jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Box, Object.assign({ mb: 18 }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "21px", fontWeight: 700 }, { children: t('sarStake.createNewPosition') })) })), jsxRuntime.jsxs(Box, Object.assign({ justifyContent: "space-between", display: "flex" }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text1", fontSize: "18px", fontWeight: 500 }, { children: t('sarStake.stake') })), jsxRuntime.jsx(Text, Object.assign({ color: "text4" }, { children: t('sarStake.walletBalance', { symbol: png.symbol, balance: (_b = userPngBalance === null || userPngBalance === void 0 ? void 0 : userPngBalance.toFixed(2)) !== null && _b !== void 0 ? _b : 0 }) }))] })), jsxRuntime.jsx(TextInput, { id: "sar-stake-input", value: typedValue, placeholder: "0.00", isNumeric: true, onChange: (value) => {
                                    handleInput(value);
                                }, addonAfter: jsxRuntime.jsx(Button, Object.assign({ variant: "plain", backgroundColor: "color2", padding: "6px", height: "auto", onClick: handleMax }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: t('sarStake.max') })) })) })] }), jsxRuntime.jsx(Box, Object.assign({ display: "grid", bgColor: "color3", borderRadius: "4px", padding: "20px", style: { gridGap: '20px' } }, { children: jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between" }, { children: [jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.dollarValue') })), jsxRuntime.jsxs(Text, Object.assign({ color: "text1" }, { children: ["$", dollerWorth !== null && dollerWorth !== void 0 ? dollerWorth : '0'] }))] }), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ color: "text2" }, { children: t('sarStake.averageAPR') })), jsxRuntime.jsx(Text, Object.assign({ color: "text1" }, { children: `${apr !== null && apr !== void 0 ? apr : '-'.toString()}%` }))] })] })) })), renderButtons()] })), jsxRuntime.jsx(ConfirmDrawer, { title: stakeError || hash || attempting ? '' : t('sarStake.summary'), isOpen: openDrawer, onClose: handleConfirmDismiss, attemptingTxn: attempting, txHash: hash, errorMessage: stakeError, pendingMessage: t('sarStake.pending', { balance: (_c = parsedAmount === null || parsedAmount === void 0 ? void 0 : parsedAmount.toFixed(2)) !== null && _c !== void 0 ? _c : 0, symbol: png.symbol }), successMessage: t('sarStake.successSubmit'), confirmContent: ConfirmContent })] })));
}

const STabs = styled__default["default"](reactTabs.Tabs) `
  font-style: normal;
  font-weight: 500;
  font-size: 18px;
`;
const STabPanel = styled__default["default"](reactTabs.TabPanel) `
  display: none;
  min-height: 40vh;
  border-top: 1px solid ${({ theme }) => { var _a; return (_a = theme.tabs) === null || _a === void 0 ? void 0 : _a.tabPanelBorderColor; }};
  padding: 4px;
  margin-top: -5px;

  &.is-selected {
    display: block;
  }
`;
const STabList = styled__default["default"](reactTabs.TabList) `
  color: ${({ theme }) => { var _a; return (_a = theme.tabs) === null || _a === void 0 ? void 0 : _a.tabListColor; }};
  list-style-type: none;
  padding-bottom: 5px;
  padding-left: 0px;
  display: flex;
  justify-content: flex-start;
  gap: 2.5rem;
  margin: 0;
  ${({ theme }) => theme.mediaWidth.upToSmall `
    overflow: auto;
    white-space: nowrap;
  `};
  &::-webkit-scrollbar {
    display: none !important;
  }
  -ms-overflow-style: none;
  scrollbar-width: none;
`;
const STab = styled__default["default"](reactTabs.Tab) `
  padding: 4px;
  user-select: none;
  cursor: arrow;

  &:hover {
    color: ${({ theme }) => theme.primary};
    cursor: pointer;
  }

  &.react-tabs__tab--disabled {
    color: ${({ theme }) => { var _a; return (_a = theme.tabs) === null || _a === void 0 ? void 0 : _a.tabColor; }};
    cursor: not-allowed;
    &:hover {
      color: ${({ theme }) => { var _a; return (_a = theme.tabs) === null || _a === void 0 ? void 0 : _a.tabColor; }};
      cursor: default;
    }
  }

  &.is-selected {
    border-bottom: 3px solid ${({ theme }) => theme.primary};
  }

  &:focus {
    outline: none;
  }
`;

const Tabs = (props) => {
    return jsxRuntime.jsx(STabs, Object.assign({ selectedTabClassName: "is-selected", selectedTabPanelClassName: "is-selected" }, props));
};

const Tab = (props) => {
    return jsxRuntime.jsx(STab, Object.assign({}, props));
};
Tab.tabsRole = 'Tab';

const TabList = (props) => {
    return jsxRuntime.jsx(STabList, Object.assign({}, props));
};
TabList.tabsRole = 'TabList';

const TabPanel = (props) => {
    return jsxRuntime.jsx(STabPanel, Object.assign({}, props));
};
TabPanel.tabsRole = 'TabPanel';

const Currencies = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: 0.5fr 0.5fr;
  grid-gap: 5px;
  padding-bottom: 20px;
`;

const BridgeInputsWidget = (props) => {
    var _a, _b, _c;
    const { onChangeTokenDrawerStatus, title, inputDisabled } = props;
    const theme = React.useContext(styled.ThemeContext);
    const { t } = reactI18next.useTranslation();
    const currency = new sdk.Token(sdk.ChainId.AVALANCHE, sdk.CHAINS[sdk.ChainId.AVALANCHE].contracts.png, 18, sdk.CHAINS[sdk.ChainId.AVALANCHE].png_symbol, 'Arcanum');
    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 18, fontWeight: 500, pb: '4px', color: 'bridge.text' }, { children: title })), jsxRuntime.jsxs(Currencies, { children: [jsxRuntime.jsx(CurrencyInput
                    // value={formattedAmounts[LimitField.INPUT]}
                    , { 
                        // value={formattedAmounts[LimitField.INPUT]}
                        onChange: (value) => {
                            console.log('onChange', value);
                        }, buttonStyle: {
                            backgroundColor: (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.primaryBgColor,
                            padding: '1rem 1.1rem',
                            width: '100%',
                        }, onTokenClick: onChangeTokenDrawerStatus, isShowTextInput: false, currency: currency, fontSize: 24, id: "swap-currency-input" }), jsxRuntime.jsx(CurrencyInput
                    // value={formattedAmounts[LimitField.INPUT]}
                    , { 
                        // value={formattedAmounts[LimitField.INPUT]}
                        onChange: (value) => {
                            console.log('onChange', value);
                        }, buttonStyle: {
                            backgroundColor: (_b = theme.bridge) === null || _b === void 0 ? void 0 : _b.primaryBgColor,
                            padding: '1rem 1.1rem',
                            width: '100%',
                        }, onTokenClick: onChangeTokenDrawerStatus, isShowTextInput: false, currency: currency, fontSize: 24, id: "swap-currency-input" })] }), jsxRuntime.jsx(Tooltip, { effect: "solid" }), jsxRuntime.jsx(TextInput, { value: '', isNumeric: true, disabled: inputDisabled, placeholder: "0.00", addonAfter: inputDisabled ? (jsxRuntime.jsx(reactFeather.Info, { size: 16, color: (_c = theme.bridge) === null || _c === void 0 ? void 0 : _c.infoIconColor, "data-tip": t('bridge.bridgeInputsWidget.tooltip', { amount: 10.3, currency: 'USDC' }) })) : (jsxRuntime.jsx(Button, Object.assign({ variant: "plain", backgroundColor: "bridge.secondaryBgColor", padding: "6px", height: "auto", onClick: () => {
                        console.log('onclick');
                    } }, { children: jsxRuntime.jsx(Text, Object.assign({ color: 'bridge.text' }, { children: t('bridge.bridgeInputsWidget.max') })) }))), onChange: (value) => {
                    console.log(value);
                } })] }));
};

const Wrapper = styled__default["default"](Box) `
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.secondaryBgColor; }};
  border-radius: 10px;
  padding: 30px;
  margin-top: 30px;
  margin-bottom: 30px;
  position: relative;
  overflow: hidden;
  max-width: 30%;
  min-width: 30%;
  height: fit-content;
  ${({ theme }) => theme.mediaWidth.upToMedium `
    min-width: 90%;
    max-width: 90%;
  `};
`;
const FilterBox = styled__default["default"](Box) `
  display: flex;
  flex-direction: column;
  margin-bottom: 20px;
`;
const FilterInputHeader = styled__default["default"](Text) `
  font-size: 16px;
  font-weight: 500;
  color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.text; }};
  margin-bottom: 10px;
`;
const LoaderWrapper = styled__default["default"](Box) `
  flex: 1;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  z-index: 999;
  position: absolute;
  align-items: center;
  pointer-events: all;
  justify-content: center;
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.secondaryBgColor; }};
  margin: -30px;
`;
const CloseCircle$1 = styled__default["default"].div `
  position: absolute;
  top: 30px;
  right: 30px;
  cursor: pointer;
  background-color: ${({ theme }) => theme.closeCircleBG};
  padding: 2.5px 8px;
  -moz-border-radius: 50px;
  -webkit-border-radius: 50px;
  border-radius: 50px;
`;
const BottomText = styled__default["default"](Text) `
  font-size: 13px;
  font-weight: 400;
  color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.text; }};
  position: absolute;
  bottom: 0;
  padding: 30px;
  text-align: center;
`;
const ArrowWrapper = styled__default["default"].div `
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.primaryBgColor; }};
  width: 30px;
  height: 30px;
  border-radius: 50%;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    cursor: pointer;
    opacity: 0.8;
  }
`;

const BridgeCard = () => {
    var _a, _b, _c, _d;
    const { account } = usePangolinWeb3();
    const toggleWalletModal = useWalletModalToggle();
    const theme = React.useContext(styled.ThemeContext);
    const [isTokenDrawerOpen, setIsTokenDrawerOpen] = React.useState(false);
    const [activeBridgePrioritization, setActiveBridgePrioritization] = React.useState('');
    const [activeBridges, setActiveBridges] = React.useState(['']);
    const [activeExchanges, setActiveExchanges] = React.useState(['']);
    const [userslippage] = useUserSlippageTolerance();
    const [slippageTolerance, setSlippageTolerance] = React.useState((userslippage / 100).toString());
    const [isLoading, setIsLoading] = React.useState(false);
    const { t } = reactI18next.useTranslation();
    const BridgePrioritizationItems = [
        {
            label: t('bridge.bridgePrioritizations.recommended'),
            value: 'recommended',
        },
        {
            label: t('bridge.bridgePrioritizations.fast'),
            value: 'fast',
        },
        {
            label: t('bridge.bridgePrioritizations.normal'),
            value: 'normal',
        },
    ];
    const Bridges = [
        {
            label: 'Thorchain',
            value: 'thorchain',
        },
        {
            label: 'DeFiChain',
            value: 'defichain',
        },
    ];
    const Exchanges = [
        {
            label: 'Arcanum',
            value: 'pangolin',
        },
        {
            label: 'Uniswap',
            value: 'uniswap',
        },
        {
            label: '1Inch',
            value: '1inch',
        },
        {
            label: 'Quickswap',
            value: 'quickswap',
        },
    ];
    const onChangeTokenDrawerStatus = React.useCallback(() => {
        setIsTokenDrawerOpen(!isTokenDrawerOpen);
    }, [isTokenDrawerOpen]);
    return (jsxRuntime.jsxs(Wrapper, { children: [isLoading && (jsxRuntime.jsxs(LoaderWrapper, { children: [jsxRuntime.jsx(CloseCircle$1, Object.assign({ onClick: () => {
                            setIsLoading(!isLoading);
                        } }, { children: jsxRuntime.jsx(reactFeather.X, { color: (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.loaderCloseIconColor, size: 10 }) })), jsxRuntime.jsx(Loader, { height: 'auto', label: t('bridge.bridgeCard.loader.labels.waitingReceivingChain'), size: 100 }), jsxRuntime.jsx(BottomText, { children: t('bridge.bridgeCard.loader.bottomText') })] })), jsxRuntime.jsx(Text, Object.assign({ fontSize: 24, fontWeight: 700, color: 'bridge.text', pb: 30 }, { children: t('bridge.bridgeCard.title') })), jsxRuntime.jsx(BridgeInputsWidget, { isTokenDrawerOpen: true, onChangeTokenDrawerStatus: onChangeTokenDrawerStatus, title: "From", inputDisabled: false }), jsxRuntime.jsx(Box, Object.assign({ display: 'flex', justifyContent: 'center', alignContent: 'center', marginY: 20 }, { children: jsxRuntime.jsx(ArrowWrapper, { children: jsxRuntime.jsx(reactFeather.RefreshCcw, { size: "16", color: (_b = theme.bridge) === null || _b === void 0 ? void 0 : _b.text }) }) })), jsxRuntime.jsx(BridgeInputsWidget, { title: "To", inputDisabled: true }), jsxRuntime.jsx(Box, Object.assign({ marginY: 30 }, { children: !account ? (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: toggleWalletModal }, { children: "Connect Wallet" }))) : (jsxRuntime.jsx(Button, Object.assign({ variant: "primary", onClick: () => {
                        setIsLoading(true);
                    } }, { children: t('bridge.bridgeCard.swap') }))) })), jsxRuntime.jsx(Box, Object.assign({ display: 'flex', flexDirection: 'column', justifyContent: 'center' }, { children: jsxRuntime.jsxs(Collapsed, Object.assign({ collapse: jsxRuntime.jsxs(Box, Object.assign({ display: 'flex', flexDirection: 'row', justifyContent: 'center', alignItems: 'center' }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 16, fontWeight: 500, color: 'bridge.text' }, { children: t('bridge.bridgeCard.advanceOptions') })), jsxRuntime.jsx(reactFeather.ChevronDown, { size: 16, color: (_c = theme.bridge) === null || _c === void 0 ? void 0 : _c.text })] })), expand: jsxRuntime.jsxs(Box, Object.assign({ display: 'flex', flexDirection: 'row', justifyContent: 'center', alignItems: 'center' }, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 16, fontWeight: 500, color: 'bridge.text' }, { children: t('bridge.bridgeCard.advanceOptions') })), jsxRuntime.jsx(reactFeather.ChevronRight, { size: 16, color: (_d = theme.bridge) === null || _d === void 0 ? void 0 : _d.text })] })) }, { children: [jsxRuntime.jsxs(FilterBox, Object.assign({ pt: '3.75rem' }, { children: [jsxRuntime.jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.bridgePrioritization') }), jsxRuntime.jsx(DropdownMenu, { options: BridgePrioritizationItems, defaultValue: activeBridgePrioritization, onSelect: (value) => {
                                        setActiveBridgePrioritization(value);
                                    } })] })), jsxRuntime.jsxs(FilterBox, { children: [jsxRuntime.jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.slippage') }), jsxRuntime.jsx(SlippageInput, { showTitle: false, expertMode: false, slippageTolerance: slippageTolerance, setSlippageTolerance: setSlippageTolerance })] }), jsxRuntime.jsxs(FilterBox, { children: [jsxRuntime.jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.infiniteApproval') }), jsxRuntime.jsx(Checkbox, { labelColor: 'bridge.text', label: t('bridge.bridgeCard.filter.activeInfiniteApproval') })] }), jsxRuntime.jsxs(FilterBox, { children: [jsxRuntime.jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.bridges') }), jsxRuntime.jsx(DropdownMenu, { options: Bridges, defaultValue: activeBridges, isMulti: true, menuPlacement: 'top', onSelect: (value) => {
                                        setActiveBridges(value);
                                    } })] }), jsxRuntime.jsxs(FilterBox, { children: [jsxRuntime.jsx(FilterInputHeader, { children: t('bridge.bridgeCard.filter.exchanges') }), jsxRuntime.jsx(DropdownMenu, { options: Exchanges, defaultValue: activeExchanges, isMulti: true, menuPlacement: 'top', onSelect: (value) => {
                                        setActiveExchanges(value);
                                    } })] })] })) })), isTokenDrawerOpen && (jsxRuntime.jsx(SelectTokenDrawer$1, { isOpen: isTokenDrawerOpen, onClose: onChangeTokenDrawerStatus, onCurrencySelect: () => {
                    console.log('onCurrencySelect');
                } }))] }));
};

const Route = styled__default["default"](Box) `
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.primaryBgColor; }};
  border-radius: 10px;
  padding: 30px;
  border: ${({ theme, selected }) => (selected ? `1px solid ${theme.primary}` : 'none')};
`;
const Informations = styled__default["default"](Box) `
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 10px;
`;
const Information = styled__default["default"](Box) `
  padding: 9px 13px;
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.informationBoxesBackgroundColor; }};
  border-radius: 10px;
`;
const StepDetail = styled__default["default"](Box) `
  min-height: 10vh;
  padding-left: 27px;
  margin-left: 10px;
  margin-bottom: 0.5rem;
  border-left: ${({ theme, lastItem }) => (lastItem ? 'none' : `1px solid ${theme.primary}`)};
`;

const BridgeRoute = (props) => {
    const { t } = reactI18next.useTranslation();
    const theme = React.useContext(styled.ThemeContext);
    const { selected, steps, transactionType, estimatedToken, estimatedResult, min, gasCost } = props;
    return (jsxRuntime.jsxs(Route, Object.assign({ selected: selected }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", pb: 30 }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: 'bridge.text', fontSize: [24, 20], fontWeight: 600 }, { children: t(`bridge.bridgePrioritizations.${BridgePrioritizations[transactionType]}`).toLocaleUpperCase() })), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", width: 'fit-content', padding: '8px', height: "30px", isDisabled: selected }, { children: selected ? t('bridge.bridgeRoute.selected') : t('bridge.bridgeRoute.clickToSelect') }))] })), jsxRuntime.jsx("div", { children: steps.map((step, index) => {
                    var _a, _b;
                    return (jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: 'flex', flexDirection: 'row', alignItems: "center", pb: '0.5rem' }, { children: [jsxRuntime.jsx(reactFeather.Anchor, { size: 20, color: (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.text }), jsxRuntime.jsx(Text, Object.assign({ pl: 18, color: 'bridge.text', fontSize: [16, 14], fontWeight: 600 }, { children: step.contractType }))] })), jsxRuntime.jsxs(StepDetail, Object.assign({ lastItem: index === steps.length - 1 }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: 'bridge.text', fontSize: [16, 14], fontWeight: 400, pb: '0.2rem' }, { children: t('bridge.bridgeRoute.singleTransaction') })), (_b = step.subSteps) === null || _b === void 0 ? void 0 : _b.map((subStep, index) => {
                                        return (jsxRuntime.jsx(Text, Object.assign({ pl: 24, color: 'bridge.text', fontSize: [16, 14], fontWeight: 400, pb: '0.2rem' }, { children: subStep }), index));
                                    })] }))] }, index));
                }) }), jsxRuntime.jsxs(Box, Object.assign({ pb: 10 }, { children: [jsxRuntime.jsx(Text, Object.assign({ color: 'bridge.text', fontSize: [16, 14], fontWeight: 600, pb: '0.2rem' }, { children: t('bridge.bridgeRoute.estimatedToken', { token: estimatedToken }) })), jsxRuntime.jsx(Text, Object.assign({ color: 'bridge.text', fontSize: [16, 14], fontWeight: 600 }, { children: t('bridge.bridgeRoute.estimatedResult', { result: estimatedResult }) }))] })), jsxRuntime.jsxs(Informations, { children: [jsxRuntime.jsx(Information, { children: jsxRuntime.jsx(Text, Object.assign({ color: "bridge.routeInfoColor", fontSize: [16, 14], fontWeight: 400 }, { children: t('bridge.bridgeRoute.min', { minute: min }) })) }), jsxRuntime.jsx(Information, { children: jsxRuntime.jsx(Text, Object.assign({ color: "bridge.routeInfoColor", fontSize: [16, 14], fontWeight: 400 }, { children: t('bridge.bridgeRoute.gasCost', { gasCost: gasCost }) })) })] })] })));
};

const Transfer = styled__default["default"].tr `
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.primaryBgColor; }};
  border-radius: 10px;
  padding: 30px;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  width: max-content;
`;
const Data = styled__default["default"].div `
  display: flex;
  flex-direction: column;
  padding-right: 30px;
`;
const ResumeLayout = styled__default["default"](Box) `
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 0.6rem;
`;
const Buttons = styled__default["default"](Box) `
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 1rem;
`;

var BridgeState;
(function (BridgeState) {
    BridgeState["PENDING"] = "PENDING";
    BridgeState["FAILED"] = "FAILED";
    BridgeState["SUCCESS"] = "SUCCESS";
})(BridgeState || (BridgeState = {}));

const BridgeTransfer = (props) => {
    var _a, _b;
    const keys = ['date', 'from', 'to', 'via', 'state'];
    const theme = React.useContext(styled.ThemeContext);
    const { t } = reactI18next.useTranslation();
    const { state } = props;
    const generateData = (key) => {
        if (key === 'from' || key === 'to') {
            const chain = props[`${key.toLowerCase()}Chain`];
            const coin = props[`${key.toLowerCase()}Coin`];
            return (jsxRuntime.jsxs(Box, Object.assign({ display: 'flex', flexDirection: 'row' }, { children: [jsxRuntime.jsx(DoubleCurrencyLogo, { margin: false, currency0: chain, currency1: coin }), jsxRuntime.jsx(Text, Object.assign({ pl: '0.7rem', fontSize: [16, 14], fontWeight: 400, color: 'bridge.text' }, { children: props[key.toLowerCase()] }))] })));
        }
        else {
            return (jsxRuntime.jsx(Text, Object.assign({ fontSize: [16, 14], fontWeight: 400, color: 'bridge.text' }, { children: props[key.toLowerCase()] })));
        }
    };
    return (jsxRuntime.jsxs(Transfer, { children: [jsxRuntime.jsx(Box, Object.assign({ display: 'flex', flexDirection: 'row' }, { children: keys.map((key, index) => (jsxRuntime.jsxs(Data, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: [16, 14], fontWeight: 500, color: 'bridge.transferKeyColor' }, { children: t(`bridge.bridgeTransfer.${key}`) })), generateData(key)] }, index))) })), state === BridgeState.PENDING && (jsxRuntime.jsxs(Buttons, { children: [jsxRuntime.jsx(Button, Object.assign({ backgroundColor: "bridge.secondaryBgColor", variant: "secondary", width: 'fit-content', borderRadius: '4px', padding: '7px 15px', minHeight: "32px" }, { children: jsxRuntime.jsxs(ResumeLayout, { children: [jsxRuntime.jsx(reactFeather.Play, { size: 18, color: (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.text }), jsxRuntime.jsx(Text, Object.assign({ fontSize: [16, 14], fontWeight: 400, color: 'bridge.text' }, { children: t('bridge.bridgeTransfer.resumeSwap') }))] }) })), jsxRuntime.jsx(Button, Object.assign({ backgroundColor: "bridge.secondaryBgColor", variant: "secondary", width: 'fit-content', borderRadius: '4px', padding: '0.5rem 1rem', minHeight: "32px" }, { children: jsxRuntime.jsx(reactFeather.Trash, { size: 16, color: (_b = theme.bridge) === null || _b === void 0 ? void 0 : _b.text }) }))] }))] }));
};

const PageWrapper = styled__default["default"](Box) `
  width: 100%;
  display: flex;
  justify-content: start;
  gap: 30px;
  ${({ theme }) => theme.mediaWidth.upToMedium `
    flex-direction: column;
    align-items: center;
    justify-content: center;
  `};
`;
const Transactions = styled__default["default"](Box) `
  background-color: ${({ theme }) => { var _a; return (_a = theme.bridge) === null || _a === void 0 ? void 0 : _a.secondaryBgColor; }};
  min-width: 70%;
  max-width: 70%;
  border-radius: 16px;
  height: fit-content;
  padding: 30px;
  margin-top: 30px;
  margin-bottom: 30px;
  ${({ theme }) => theme.mediaWidth.upToMedium `
    min-width: 90%;
    max-width: 90%;
  `};
`;
const Routes = styled__default["default"].div `
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-gap: 30px;
  margin-top: 50px;
  ${({ theme }) => theme.mediaWidth.upToMedium `
    display: flex;
    flex-direction: column;
  `};
`;
const Transfers = styled__default["default"].table `
  display: flex;
  flex-direction: column;
  gap: 30px;
  padding-top: 50px;
  padding-bottom: 30px;
  overflow-y: auto;
  white-space: nowrap;
  width: 100%;
`;

var BridgePrioritizations;
(function (BridgePrioritizations) {
    BridgePrioritizations[BridgePrioritizations["recommended"] = 0] = "recommended";
    BridgePrioritizations[BridgePrioritizations["fast"] = 1] = "fast";
    BridgePrioritizations[BridgePrioritizations["normal"] = 2] = "normal";
})(BridgePrioritizations || (BridgePrioritizations = {}));
const Bridge = () => {
    const [tabIndex, setTabIndex] = React.useState(0);
    const steps = [
        {
            contractType: 'LI.FI Contract',
            subSteps: ['1. Swap to 0.0538 USDT via ARCANUM', '2. Transfer to 0.0522 USDT via ARCANUM'],
        },
        {
            contractType: 'LI.FI Contract',
            subSteps: ['1. Swap to 0.0538 USDT via DODO'],
        },
    ];
    const { t } = reactI18next.useTranslation();
    const currency0 = new sdk.Token(sdk.ChainId.AVALANCHE, sdk.CHAINS[sdk.ChainId.AVALANCHE].contracts.png, 18, sdk.CHAINS[sdk.ChainId.AVALANCHE].png_symbol, 'Arcanum');
    const currency1 = new sdk.Token(sdk.ChainId.AVALANCHE, sdk.CHAINS[sdk.ChainId.AVALANCHE].contracts.png, 18, sdk.CHAINS[sdk.ChainId.AVALANCHE].png_symbol, 'Arcanum');
    return (jsxRuntime.jsxs(PageWrapper, { children: [jsxRuntime.jsx(BridgeCard, {}), jsxRuntime.jsx(Transactions, { children: jsxRuntime.jsxs(Tabs, Object.assign({ selectedIndex: tabIndex, onSelect: (index) => setTabIndex(index) }, { children: [jsxRuntime.jsxs(TabList, { children: [jsxRuntime.jsx(Tab, { children: t('bridge.availableRoutes', { number: 0 }) }), jsxRuntime.jsx(Tab, { children: t('bridge.activeTransfers', { number: 0 }) }), jsxRuntime.jsx(Tab, Object.assign({ disabled: true }, { children: t('bridge.historicalTransfers', { number: 0 }) }))] }), jsxRuntime.jsx(TabPanel, { children: jsxRuntime.jsxs(Routes, { children: [jsxRuntime.jsx(BridgeRoute, { steps: steps, transactionType: BridgePrioritizations.recommended, selected: true, estimatedToken: '0.0522 FRAX', estimatedResult: '$0.05 USD', min: '9:00', gasCost: '95.30 USD' }), jsxRuntime.jsx(BridgeRoute, { steps: steps, transactionType: BridgePrioritizations.fast, selected: false, estimatedToken: '0.0520 FRAX', estimatedResult: '$0.0495 USD', min: '2:00', gasCost: '105.30 USD' }), jsxRuntime.jsx(BridgeRoute, { steps: steps, transactionType: BridgePrioritizations.normal, selected: false, estimatedToken: '0.0529 FRAX', estimatedResult: '$0.0503 USD', min: '8:00', gasCost: '100.30 USD' })] }) }), jsxRuntime.jsx(TabPanel, { children: jsxRuntime.jsxs(Transfers, { children: [jsxRuntime.jsx(BridgeTransfer, { date: '9/10/2022, 7:53:00 AM', from: '1.0000', fromChain: currency0, fromCoin: currency1, to: '22.3615', toChain: currency0, toCoin: currency1, via: 'ARCANUM > DODO', state: BridgeState.PENDING }), jsxRuntime.jsx(BridgeTransfer, { date: '9/10/2022, 7:50:00 AM', from: '1.0000', fromChain: currency0, fromCoin: currency1, to: '0.1564', toChain: currency0, toCoin: currency1, via: 'ARCANUM > DODO', state: BridgeState.PENDING })] }) }), jsxRuntime.jsx(TabPanel, { children: "Panel 3" })] })) })] }));
};

const DrawerRoot = styled__default["default"].div `
  overflow: hidden;
  position: absolute;
  z-index: 99;
  transition: all 350ms ease;
  background-color: ${({ theme, backgroundColor }) => { var _a; return backgroundColor ? get__default["default"](theme, backgroundColor) : (_a = theme.drawer) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  transform: ${({ isOpen }) => (!isOpen ? 'translate(100%, 0px)' : 'translate(0px, 0px)')};
  width: 100%;
  display: flex;
  flex-direction: column;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 10px;
  height: 100%;

  /* ${({ theme, isOpen }) => theme.mediaWidth.upToSmall `
    display: ${isOpen ? 'none' : 'flex'};
    width: 100%;
    height: 100%
  `}; */
`;
const DrawerContent = styled__default["default"].div `
  flex: 1;
  height: 100%;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
`;
const CloseCircle = styled__default["default"].div `
  cursor: pointer;
  background-color: ${({ theme }) => theme.closeCircleBG};
  padding: 2.5px 8px;
  -moz-border-radius: 50px;
  -webkit-border-radius: 50px;
  border-radius: 50px;
`;

function Drawer({ isOpen, onClose, children, title, pb, backgroundColor }) {
    const theme = React.useContext(styled.ThemeContext);
    return (jsxRuntime.jsxs(DrawerRoot, Object.assign({ isOpen: isOpen, backgroundColor: backgroundColor }, { children: [title && (jsxRuntime.jsx(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", pb: pb || 20, pt: 20, px: 20 }, { children: jsxRuntime.jsx(Text, Object.assign({ color: "drawer.text", fontSize: 21, fontWeight: 800 }, { children: title })) }))), jsxRuntime.jsx(Box, Object.assign({ position: "absolute", right: 20, top: 20 }, { children: jsxRuntime.jsx(CloseCircle, Object.assign({ onClick: onClose }, { children: jsxRuntime.jsx(reactFeather.X, { color: theme.mustardYellow, size: 10 }) })) })), jsxRuntime.jsx(DrawerContent, { children: children })] })));
}

function filterTokens(tokens, search) {
    if (search.length === 0)
        return tokens;
    const searchingAddress = isAddress(search);
    if (searchingAddress) {
        return tokens.filter((token) => token.address === searchingAddress);
    }
    const lowerSearchParts = search
        .toLowerCase()
        .split(/\s+/)
        .filter((s) => s.length > 0);
    if (lowerSearchParts.length === 0) {
        return tokens;
    }
    const matchesSearch = (s) => {
        const sParts = s
            .toLowerCase()
            .split(/\s+/)
            .filter((s) => s.length > 0);
        return lowerSearchParts.every((p) => p.length === 0 || sParts.some((sp) => sp.startsWith(p) || sp.endsWith(p)));
    };
    return tokens.filter((token) => {
        const { symbol, name } = token;
        return (symbol && matchesSearch(symbol)) || (name && matchesSearch(name));
    });
}

// compare two token amounts with highest one coming first
function balanceComparator(balanceA, balanceB) {
    if (balanceA && balanceB) {
        return balanceA.greaterThan(balanceB) ? -1 : balanceA.equalTo(balanceB) ? 0 : 1;
    }
    else if (balanceA && balanceA.greaterThan('0')) {
        return -1;
    }
    else if (balanceB && balanceB.greaterThan('0')) {
        return 1;
    }
    return 0;
}
function getTokenComparator(balances) {
    return function sortTokens(tokenA, tokenB) {
        // -1 = a is first
        // 1 = b is first
        // sort by balances
        const balanceA = balances[tokenA.address];
        const balanceB = balances[tokenB.address];
        const balanceComp = balanceComparator(balanceA, balanceB);
        if (balanceComp !== 0)
            return balanceComp;
        if (tokenA.symbol && tokenB.symbol) {
            // sort by symbol
            return tokenA.symbol.toLowerCase() < tokenB.symbol.toLowerCase() ? -1 : 1;
        }
        else {
            return tokenA.symbol ? -1 : tokenB.symbol ? -1 : 0;
        }
    };
}
function useTokenComparator(inverted) {
    const balances = useAllTokenBalances();
    const comparator = React.useMemo(() => getTokenComparator(balances !== null && balances !== void 0 ? balances : {}), [balances]);
    return React.useMemo(() => {
        if (inverted) {
            return (tokenA, tokenB) => comparator(tokenA, tokenB) * -1;
        }
        else {
            return comparator;
        }
    }, [inverted, comparator]);
}

/**
 * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content
 * @param uri to convert to fetch-able http url
 */
function uriToHttp(uri) {
    var _a, _b;
    const protocol = uri.split(':')[0].toLowerCase();
    switch (protocol) {
        case 'https':
            return [uri];
        case 'http':
            return ['https' + uri.substr(4), uri];
        case 'ipfs':
            const hash = (_a = uri.match(/^ipfs:(\/\/)?(.*)$/i)) === null || _a === void 0 ? void 0 : _a[2];
            return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`];
        case 'ipns':
            const name = (_b = uri.match(/^ipns:(\/\/)?(.*)$/i)) === null || _b === void 0 ? void 0 : _b[2];
            return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`];
        default:
            return [];
    }
}

const tokenListValidator = new Ajv__default["default"]({ allErrors: true }).compile(schema__default["default"]);
/**
 * Contains the logic for resolving a list URL to a validated token list
 * @param listUrl list url
 * @param resolveENSContentHash resolves an ens name to a contenthash
 */
function getTokenList(listUrl, resolveENSContentHash) {
    var _a, _b;
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const urls = uriToHttp(listUrl);
        for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            const isLast = i === urls.length - 1;
            let response;
            try {
                response = yield fetch(url);
            }
            catch (error) {
                console.debug('Failed to fetch list', listUrl, error);
                if (isLast)
                    throw new Error(`Failed to download list ${listUrl}`);
                continue;
            }
            if (!response.ok) {
                if (isLast)
                    throw new Error(`Failed to download list ${listUrl}`);
                continue;
            }
            const json = yield response.json();
            if (!tokenListValidator(json)) {
                const validationErrors = (_b = (_a = tokenListValidator.errors) === null || _a === void 0 ? void 0 : _a.reduce((memo, error) => {
                    var _a;
                    const add = `${error.dataPath} ${(_a = error.message) !== null && _a !== void 0 ? _a : ''}`;
                    return memo.length > 0 ? `${memo}; ${add}` : `${add}`;
                }, '')) !== null && _b !== void 0 ? _b : 'unknown error';
                throw new Error(`Token list failed validation: ${validationErrors}`);
            }
            return json;
        }
        throw new Error('Unrecognized list URL protocol.');
    });
}

function useFetchListCallback() {
    const dispatch = useDispatch();
    const ensResolver = React.useCallback(() => {
        throw new Error('Could not construct mainnet ENS resolver');
    }, []);
    return React.useCallback((listUrl) => tslib.__awaiter(this, void 0, void 0, function* () {
        const requestId = toolkit.nanoid();
        dispatch(fetchTokenList.pending({ requestId, url: listUrl }));
        return getTokenList(listUrl)
            .then((tokenList) => {
            dispatch(fetchTokenList.fulfilled({ url: listUrl, tokenList, requestId }));
            return tokenList;
        })
            .catch((error) => {
            console.debug(`Failed to get list at url ${listUrl}`, error);
            dispatch(fetchTokenList.rejected({ url: listUrl, requestId, errorMessage: error.message }));
            throw error;
        });
    }), [dispatch, ensResolver]);
}

const ENS_NAME_REGEX = /^(([a-zA-Z0-9]+\.)+)eth(\/.*)?$/;
function parseENSAddress(ensAddress) {
    const match = ensAddress.match(ENS_NAME_REGEX);
    if (!match)
        return undefined;
    return { ensName: `${match[1].toLowerCase()}eth`, ensPath: match[3] };
}

function listVersionLabel(version) {
    return `v${version.major}.${version.minor}.${version.patch}`;
}

function TokenListOrigin({ listUrl }) {
    const ensName = React.useMemo(() => { var _a; return (_a = parseENSAddress(listUrl)) === null || _a === void 0 ? void 0 : _a.ensName; }, [listUrl]);
    const host = React.useMemo(() => {
        if (ensName)
            return undefined;
        const lowerListUrl = listUrl.toLowerCase();
        if (lowerListUrl.startsWith('ipfs://') || lowerListUrl.startsWith('ipns://')) {
            return listUrl;
        }
        try {
            const url = new URL(listUrl);
            return url.host;
        }
        catch (error) {
            return undefined;
        }
    }, [listUrl, ensName]);
    return jsxRuntime.jsx(jsxRuntime.Fragment, { children: ensName !== null && ensName !== void 0 ? ensName : host });
}

styled__default["default"](Box) `
  padding: 10px 20px;
`;
const List = styled__default["default"](Box) `
  padding: 10px 20px;
`;
const AddInputWrapper = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: auto 100px;
  grid-gap: 10px;
`;
const RowRoot = styled__default["default"](Box) `
  display: grid;
  grid-template-columns: max-content auto max-content max-content;
  grid-gap: 10px;
  padding: 15px 0px;
  align-items: center;
  border-bottom-width: 1px;
  border-bottom-style: solid;
  border-bottom-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary; }};

  &:last-child {
    border-bottom: 0px solid;
  }
`;
const ListLogo$1 = styled__default["default"].img `
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
`;
const DownArrow = styled__default["default"].div `
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveBgColor; }};
  color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.interactiveColor; }};
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
`;
const PopoverContainer = styled__default["default"].div `
  z-index: 100;
  background: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.backgroundColor; }};
  border: 1px solid ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary; }};
  box-shadow: 0px 0px 1px rgba(0, 0, 0, 0.01), 0px 4px 8px rgba(0, 0, 0, 0.04), 0px 16px 24px rgba(0, 0, 0, 0.04),
    0px 24px 32px rgba(0, 0, 0, 0.01);
  color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.primary; }};
  border-radius: 0.5rem;
  padding: 5px;
  display: grid;
  grid-template-rows: 1fr;
  grid-gap: 8px;
  font-size: 1rem;
  text-align: left;
  position: absolute;
`;
const Separator = styled__default["default"].div `
  width: 100%;
  height: 1px;
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.secondary; }};
`;
const ViewLink = styled__default["default"](Text) `
  text-decoration: none;
  cursor: pointer;
  pointer-events: ${({ disabled }) => disabled && 'none'};
`;

const TokenListRow = ({ listUrl }) => {
    const lists = useSelector((state) => state.plists.byUrl);
    const { current: list } = lists[listUrl];
    const dispatch = useDispatch();
    const selectedListUrl = useSelectedListUrl();
    const isSelected = (selectedListUrl || []).includes(listUrl);
    const [open, setOpen] = React.useState(false);
    const node = React.useRef();
    const handleClose = React.useCallback(() => {
        setOpen(false);
    }, [setOpen]);
    useOnClickOutside(node, open ? handleClose : undefined);
    const selectThisList = React.useCallback(() => {
        // eslint-disable-next-line import/no-named-as-default-member
        ReactGA__default["default"].event({
            category: 'Lists',
            action: 'Select List',
            label: listUrl,
        });
        dispatch(selectList({ url: listUrl, shouldSelect: !isSelected }));
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [dispatch, isSelected, listUrl]);
    const handleRemoveList = React.useCallback(() => {
        // eslint-disable-next-line import/no-named-as-default-member
        ReactGA__default["default"].event({
            category: 'Lists',
            action: 'Start Remove List',
            label: listUrl,
        });
        const answer = window.prompt('Please confirm you would like to remove this list by typing "remove"');
        if ((answer === null || answer === void 0 ? void 0 : answer.toLocaleLowerCase()) === 'remove') {
            // eslint-disable-next-line import/no-named-as-default-member
            ReactGA__default["default"].event({
                category: 'Lists',
                action: 'Confirm Remove List',
                label: listUrl,
            });
            dispatch(removeList(listUrl));
        }
    }, [dispatch, listUrl]);
    if (!list)
        return null;
    return (jsxRuntime.jsxs(RowRoot, { children: [(list === null || list === void 0 ? void 0 : list.logoURI) ? jsxRuntime.jsx(ListLogo$1, { size: 24, src: list === null || list === void 0 ? void 0 : list.logoURI }) : jsxRuntime.jsx(ListLogo$1, { as: "div", size: 24 }), jsxRuntime.jsxs(Box, { children: [jsxRuntime.jsx(Text, Object.assign({ fontSize: 16, color: "swapWidget.primary", style: { overflow: 'hidden', textOverflow: 'ellipsis' } }, { children: list === null || list === void 0 ? void 0 : list.name })), jsxRuntime.jsx(Text, Object.assign({ fontSize: 12, color: "swapWidget.secondary", style: { overflow: 'hidden', textOverflow: 'ellipsis' }, title: listUrl }, { children: jsxRuntime.jsx(TokenListOrigin, { listUrl: listUrl }) }))] }), jsxRuntime.jsxs(Box, Object.assign({ ref: node }, { children: [jsxRuntime.jsx(DownArrow, Object.assign({ onClick: () => setOpen(!open) }, { children: jsxRuntime.jsx(reactFeather.ChevronDown, {}) })), open && (jsxRuntime.jsxs(PopoverContainer, { children: [jsxRuntime.jsx("div", { children: list && listVersionLabel(list.version) }), jsxRuntime.jsx(Separator, {}), jsxRuntime.jsx(ViewLink, Object.assign({ fontSize: 13, as: "a", color: "swapWidget.primary", href: `https://tokenlists.org/token-list?url=${listUrl}`, target: "_blank" }, { children: "View list" })), jsxRuntime.jsx(ViewLink, Object.assign({ fontSize: 13, color: "swapWidget.primary", onClick: handleRemoveList, disabled: Object.keys(lists).length === 1 }, { children: "Remove list" }))] }))] })), jsxRuntime.jsx(Switch, { checked: isSelected, onChange: () => selectThisList() })] }));
};

const TokenListDrawer = ({ isOpen, onClose }) => {
    var _a;
    const [listUrlInput, setListUrlInput] = React.useState('');
    const dispatch = useDispatch();
    const lists = useSelector((state) => state.plists.byUrl);
    const adding = Boolean((_a = lists[listUrlInput]) === null || _a === void 0 ? void 0 : _a.loadingRequestId);
    const [addError, setAddError] = React.useState(null);
    const fetchList = useFetchListCallback();
    const handleAddList = React.useCallback(() => {
        if (adding)
            return;
        setAddError(null);
        fetchList(listUrlInput)
            .then(() => {
            setListUrlInput('');
            // eslint-disable-next-line import/no-named-as-default-member
            ReactGA__default["default"].event({
                category: 'Lists',
                action: 'Add List',
                label: listUrlInput,
            });
        })
            .catch((error) => {
            // eslint-disable-next-line import/no-named-as-default-member
            ReactGA__default["default"].event({
                category: 'Lists',
                action: 'Add List Failed',
                label: listUrlInput,
            });
            setAddError(error.message);
            dispatch(removeList(listUrlInput));
        });
    }, [adding, dispatch, fetchList, listUrlInput]);
    const validUrl = React.useMemo(() => {
        return uriToHttp(listUrlInput).length > 0 || Boolean(parseENSAddress(listUrlInput));
    }, [listUrlInput]);
    const handleEnterKey = React.useCallback((e) => {
        if (validUrl && e.key === 'Enter') {
            handleAddList();
        }
    }, [handleAddList, validUrl]);
    const sortedLists = React.useMemo(() => {
        const listUrls = Object.keys(lists);
        return listUrls
            .filter((listUrl) => {
            return Boolean(lists[listUrl].current);
        })
            .sort((u1, u2) => {
            const { current: l1 } = lists[u1];
            const { current: l2 } = lists[u2];
            if (l1 && l2) {
                return l1.name.toLowerCase() < l2.name.toLowerCase()
                    ? -1
                    : l1.name.toLowerCase() === l2.name.toLowerCase()
                        ? 0
                        : 1;
            }
            if (l1)
                return -1;
            if (l2)
                return 1;
            return 0;
        });
    }, [lists]);
    return (jsxRuntime.jsxs(Drawer, Object.assign({ title: "Manage Lists", isOpen: isOpen, onClose: onClose }, { children: [jsxRuntime.jsxs(Box, Object.assign({ padding: "0px 20px" }, { children: [jsxRuntime.jsxs(AddInputWrapper, { children: [jsxRuntime.jsx(TextInput, { placeholder: "https:// or ipfs://", onChange: (value) => {
                                    setListUrlInput(value);
                                    setAddError(null);
                                }, onKeyDown: handleEnterKey, value: listUrlInput }), jsxRuntime.jsx(Button, Object.assign({ variant: "primary", padding: '0px', isDisabled: !validUrl, onClick: handleAddList, height: "50px" }, { children: "Add" }))] }), addError ? (jsxRuntime.jsx(Text, Object.assign({ title: addError, color: "error", fontSize: 12 }, { children: addError }))) : null] })), jsxRuntime.jsx(Scrollbars__default["default"], { children: jsxRuntime.jsx(List, { children: sortedLists.map((url) => (jsxRuntime.jsx(TokenListRow, { listUrl: url }, url))) }) })] })));
};

const CurrencyList = styled__default["default"].div `
  display: flex;
  flex: 1;
  flex-direction: column;
  overflow-y: auto;
  &::-webkit-scrollbar {
    display: none !important;
  }
  -ms-overflow-style: none;
  scrollbar-width: none;
`;
const CurrencyRowRoot = styled__default["default"].div `
  min-height: 56px;
  font-size: 16px;
  cursor: ${({ disabled }) => !disabled && 'pointer'};
  pointer-events: ${({ disabled }) => disabled && 'none'};
  display: grid;
  grid-template-columns: auto minmax(auto, 1fr) minmax(0, 72px);
  grid-gap: 16px;
  align-items: center;
  padding: 10px 20px;

  &:hover {
    background-color: ${({ theme, disabled }) => { var _a; return !disabled && polished.opacify(0.9, (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground); }};
  }

  opacity: ${({ disabled, selected }) => (disabled || selected ? 0.5 : 1)};
`;
const Balance = styled__default["default"](Text) `
  justify-self: flex-end;
  white-space: nowrap;
`;
const ManageList = styled__default["default"].div `
  background-color: ${({ theme }) => { var _a; return (_a = theme.swapWidget) === null || _a === void 0 ? void 0 : _a.detailsBackground; }};
  padding: 10px 20px;
  cursor: pointer;
`;
const ListLogo = styled__default["default"].img `
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  margin-right: 10px;
`;

const CurrencyRow = (props) => {
    const { currency, style, onSelect, isSelected, otherSelected } = props;
    const { account } = usePangolinWeb3();
    const chainId = useChainId();
    const balance = useCurrencyBalance(chainId, account !== null && account !== void 0 ? account : undefined, currency);
    const handleSelect = React.useCallback(() => {
        onSelect(currency);
    }, [onSelect, currency]);
    return (jsxRuntime.jsxs(CurrencyRowRoot, Object.assign({ style: style, onClick: handleSelect, disabled: isSelected, selected: otherSelected }, { children: [jsxRuntime.jsx(CurrencyLogo, { currency: currency, size: 24, imageSize: 48 }), jsxRuntime.jsx(Text, Object.assign({ color: "swapWidget.primary", fontSize: 14, title: currency === null || currency === void 0 ? void 0 : currency.name }, { children: currency === null || currency === void 0 ? void 0 : currency.symbol })), jsxRuntime.jsx(Balance, Object.assign({ color: "swapWidget.primary", fontSize: 14 }, { children: balance ? balance.toSignificant(4) : account ? jsxRuntime.jsx(LoaderIcon, {}) : null }))] })));
};

const currencyKey = (currency, chainId) => {
    var _a, _b;
    return currency instanceof sdk.Token
        ? currency.address
        : currency === sdk.CAVAX[chainId] && ((_a = sdk.CAVAX[chainId]) === null || _a === void 0 ? void 0 : _a.symbol)
            ? (_b = sdk.CAVAX[chainId]) === null || _b === void 0 ? void 0 : _b.symbol
            : '';
};
const SelectTokenDrawer = (props) => {
    var _a, _b, _c;
    const { isOpen, onClose, onCurrencySelect, otherSelectedCurrency, selectedCurrency } = props;
    const [searchQuery, setSearchQuery] = React.useState('');
    const [isTokenListOpen, setIsTokenListOpen] = React.useState(false);
    const [invertSearchOrder] = React.useState(false);
    const inputRef = React.useRef(null);
    const lastOpen = usePrevious(isOpen);
    React.useEffect(() => {
        if (isOpen && !lastOpen) {
            setSearchQuery('');
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen]);
    React.useEffect(() => {
        if (isOpen && inputRef.current) {
            setTimeout(() => {
                var _a;
                (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }, 500);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen]);
    const allTokens = useAllTokens();
    const selectedListInfo = useSelectedListInfo();
    const chainId = useChainId();
    const isAddressSearch = isAddress(searchQuery);
    const searchToken = useToken(searchQuery);
    const tokenComparator = useTokenComparator(invertSearchOrder);
    const filteredTokens = React.useMemo(() => {
        if (isAddressSearch)
            return searchToken ? [searchToken] : [];
        const tokens = Object.values(allTokens);
        tokens.unshift(sdk.CAVAX[chainId]);
        return filterTokens(tokens, searchQuery);
    }, [isAddressSearch, searchToken, allTokens, searchQuery]);
    const filteredSortedTokens = React.useMemo(() => {
        if (searchToken)
            return [searchToken];
        const sorted = filteredTokens.sort(tokenComparator);
        const symbolMatch = searchQuery
            .toLowerCase()
            .split(/\s+/)
            .filter((s) => s.length > 0);
        if (symbolMatch.length > 1)
            return sorted;
        return [
            ...(searchToken ? [searchToken] : []),
            // sort any exact symbol matches first
            ...sorted.filter((token) => { var _a; return ((_a = token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === symbolMatch[0]; }),
            ...sorted.filter((token) => { var _a; return ((_a = token.symbol) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== symbolMatch[0]; }),
        ];
    }, [filteredTokens, searchQuery, searchToken, tokenComparator]);
    const currencies = React.useMemo(() => {
        var _a;
        if (searchQuery === '') {
            // remove Currency from array and add in first position
            const _tokens = filteredSortedTokens.filter((token) => token !== sdk.CAVAX[chainId]);
            return ((_a = sdk.CHAINS[chainId]) === null || _a === void 0 ? void 0 : _a.evm) ? [sdk.CAVAX[chainId], ..._tokens] : [..._tokens];
        }
        return filteredSortedTokens;
    }, [filteredSortedTokens, chainId]);
    //const currencies = useMemo(() => [Currency.CAVAX, ...filteredSortedTokens], [filteredSortedTokens]);
    const onSelect = React.useCallback((currency) => {
        onCurrencySelect(currency);
        onClose();
    }, [onCurrencySelect, onClose]);
    const Row = React.useCallback(({ data, index, style }) => {
        const currency = data === null || data === void 0 ? void 0 : data[index];
        const isSelected = Boolean(selectedCurrency && sdk.currencyEquals(selectedCurrency, currency));
        const otherSelected = Boolean(otherSelectedCurrency && sdk.currencyEquals(otherSelectedCurrency, currency));
        return currency ? (jsxRuntime.jsx(CurrencyRow, { style: style, currency: currency, isSelected: isSelected, onSelect: onSelect, otherSelected: otherSelected })) : null;
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [selectedCurrency, otherSelectedCurrency, onCurrencySelect, onClose]);
    return (jsxRuntime.jsxs(Drawer, Object.assign({ title: "Select a token", isOpen: isOpen, onClose: onClose }, { children: [jsxRuntime.jsx(Box, Object.assign({ padding: "0px 20px" }, { children: jsxRuntime.jsx(TextInput, { placeholder: "Search", onChange: (value) => {
                        setSearchQuery(value);
                    }, value: searchQuery, getRef: (ref) => (inputRef.current = ref), onClick: () => {
                        var _a;
                        if (reactDeviceDetect.isMobile) {
                            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ behavior: 'smooth' });
                        }
                    } }) })), jsxRuntime.jsx(CurrencyList, { children: jsxRuntime.jsx(AutoSizer__default["default"], Object.assign({ disableWidth: true }, { children: ({ height }) => (jsxRuntime.jsx(reactWindow.FixedSizeList, Object.assign({ height: height, width: "100%", itemCount: currencies.length, itemSize: 56, itemData: currencies, itemKey: (index, data) => currencyKey(data[index], chainId) }, { children: Row }))) })) }), jsxRuntime.jsx(ManageList, Object.assign({ onClick: () => setIsTokenListOpen(true) }, { children: selectedListInfo.multipleSelected ? (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, { children: [jsxRuntime.jsxs(Text, Object.assign({ fontSize: 14, color: "swapWidget.primary" }, { children: [selectedListInfo.selectedCount, " lists selected"] })), jsxRuntime.jsx(Text, Object.assign({ fontSize: 12, color: "swapWidget.primary" }, { children: "Change" }))] }))) : (jsxRuntime.jsxs(Box, Object.assign({ display: "flex", justifyContent: "space-between", alignItems: "center", width: "100%" }, { children: [jsxRuntime.jsxs(Box, Object.assign({ display: "flex", alignItems: "center", width: "100%" }, { children: [jsxRuntime.jsx(ListLogo, { size: 24, src: (_a = selectedListInfo === null || selectedListInfo === void 0 ? void 0 : selectedListInfo.current) === null || _a === void 0 ? void 0 : _a.logoURI, alt: `${(_b = selectedListInfo === null || selectedListInfo === void 0 ? void 0 : selectedListInfo.current) === null || _b === void 0 ? void 0 : _b.name} list logo` }), jsxRuntime.jsx(Text, Object.assign({ fontSize: 14, color: "swapWidget.primary" }, { children: (_c = selectedListInfo === null || selectedListInfo === void 0 ? void 0 : selectedListInfo.current) === null || _c === void 0 ? void 0 : _c.name }))] })), jsxRuntime.jsx(Text, Object.assign({ fontSize: 12, color: "swapWidget.primary" }, { children: "Change" }))] }))) })), jsxRuntime.jsx(TokenListDrawer, { isOpen: isTokenListOpen, onClose: () => setIsTokenListOpen(false) })] })));
};
var SelectTokenDrawer$1 = React.memo(SelectTokenDrawer, (prevProps, nextProps) => {
    const isEqual = prevProps.isOpen === nextProps.isOpen &&
        prevProps.onClose === nextProps.onClose &&
        prevProps.onCurrencySelect === nextProps.onCurrencySelect &&
        (!!prevProps.selectedCurrency && !!nextProps.selectedCurrency
            ? prevProps.selectedCurrency.symbol === nextProps.selectedCurrency.symbol
            : true) &&
        (!!prevProps.otherSelectedCurrency && !!nextProps.otherSelectedCurrency
            ? prevProps.otherSelectedCurrency.symbol === nextProps.otherSelectedCurrency.symbol
            : true);
    return isEqual;
});

const VISIBILITY_STATE_SUPPORTED = 'visibilityState' in document;
function isWindowVisible() {
    return !VISIBILITY_STATE_SUPPORTED || document.visibilityState !== 'hidden';
}
/**
 * Returns whether the window is currently visible to the user.
 */
function useIsWindowVisible() {
    const [focused, setFocused] = React.useState(isWindowVisible());
    const listener = React.useCallback(() => {
        setFocused(isWindowVisible());
    }, [setFocused]);
    React.useEffect(() => {
        if (!VISIBILITY_STATE_SUPPORTED)
            return undefined;
        document.addEventListener('visibilitychange', listener);
        return () => {
            document.removeEventListener('visibilitychange', listener);
        };
    }, [listener]);
    return focused;
}

const NearApplicationUpdater = () => {
    const chainId = useChainId();
    const { provider } = useLibrary();
    const dispatch = useDispatch();
    const { data: blockNumber } = reactQuery.useQuery('get-block', () => {
        return provider === null || provider === void 0 ? void 0 : provider.getBlockNumber();
    }, { enabled: !!provider, refetchInterval: 60 * 1000 * 2 });
    React.useEffect(() => {
        if (blockNumber) {
            dispatch(updateBlockNumber({ chainId, blockNumber }));
        }
    }, [blockNumber]);
    return null;
};
const EvmApplicationUpdater = () => {
    const { chainId } = usePangolinWeb3();
    const { library, provider } = useLibrary();
    const dispatch = useDispatch();
    const windowVisible = useIsWindowVisible();
    const [state, setState] = React.useState({
        chainId,
        blockNumber: null,
    });
    const blockNumberCallback = React.useCallback((blockNumber) => {
        setState((_state) => {
            if (chainId === _state.chainId) {
                if (typeof _state.blockNumber !== 'number')
                    return { chainId, blockNumber };
                return { chainId, blockNumber: Math.max(blockNumber, _state.blockNumber) };
            }
            return _state;
        });
    }, [chainId, setState]);
    // attach/detach listeners
    React.useEffect(() => {
        if (!library || !chainId || !windowVisible)
            return undefined;
        setState({ chainId, blockNumber: null });
        provider === null || provider === void 0 ? void 0 : provider.getBlockNumber().then(blockNumberCallback).catch((error) => console.error(`Failed to get block number for chainId: ${chainId}`, error));
        library.on && library.on('block', blockNumberCallback);
        return () => {
            library.removeListener && library.removeListener('block', blockNumberCallback);
        };
    }, [dispatch, chainId, library, blockNumberCallback, windowVisible]);
    const debouncedState = useDebounce(state, 100);
    React.useEffect(() => {
        if (!debouncedState.chainId || !(debouncedState === null || debouncedState === void 0 ? void 0 : debouncedState.blockNumber) || !windowVisible)
            return;
        dispatch(updateBlockNumber({ chainId: debouncedState.chainId, blockNumber: debouncedState === null || debouncedState === void 0 ? void 0 : debouncedState.blockNumber }));
    }, [windowVisible, dispatch, debouncedState === null || debouncedState === void 0 ? void 0 : debouncedState.blockNumber, debouncedState.chainId]);
    return null;
};
const updaterMapping = {
    [sdk.ChainId.AVALANCHE]: EvmApplicationUpdater,
    [sdk.ChainId.FUJI]: EvmApplicationUpdater,
    [sdk.ChainId.COSTON]: EvmApplicationUpdater,
    [sdk.ChainId.SONGBIRD]: EvmApplicationUpdater,
    [sdk.ChainId.WAGMI]: EvmApplicationUpdater,
    [sdk.ChainId.NEAR_MAINNET]: NearApplicationUpdater,
    [sdk.ChainId.NEAR_TESTNET]: NearApplicationUpdater,
};
function ApplicationUpdater() {
    const chainId = useChainId();
    const Updater = updaterMapping[chainId];
    return jsxRuntime.jsx(Updater, {});
}

function useInterval(callback, delay, leading = true) {
    const savedCallback = React.useRef();
    // Remember the latest callback.
    React.useEffect(() => {
        savedCallback.current = callback;
    }, [callback]);
    // Set up the interval.
    React.useEffect(() => {
        function tick() {
            const current = savedCallback.current;
            current && current();
        }
        if (delay !== null) {
            if (leading)
                tick();
            const id = setInterval(tick, delay);
            return () => clearInterval(id);
        }
        return undefined;
    }, [delay, leading]);
}

function Updater$3() {
    const { library } = useLibrary();
    const dispatch = useDispatch();
    const lists = useSelector((state) => state.plists.byUrl);
    const isWindowVisible = useIsWindowVisible();
    const fetchList = useFetchListCallback();
    const fetchAllListsCallback = React.useCallback(() => {
        if (!isWindowVisible)
            return;
        Object.keys(lists).forEach((url) => fetchList(url).catch((error) => console.debug('interval list fetching error', error)));
    }, [fetchList, isWindowVisible, lists]);
    // fetch all lists every 10 minutes, but only after we initialize library
    useInterval(fetchAllListsCallback, library ? 1000 * 60 * 10 : null);
    // whenever a list is not loaded and not loading, try again to load it
    React.useEffect(() => {
        Object.keys(lists).forEach((listUrl) => {
            const list = lists[listUrl];
            if (!list.current && !list.loadingRequestId && !list.error) {
                fetchList(listUrl).catch((error) => console.debug('list added fetching error', error));
            }
        });
    }, [dispatch, fetchList, library, lists]);
    // automatically update lists if versions are minor/patch
    React.useEffect(() => {
        Object.keys(lists).forEach((listUrl) => {
            const list = lists[listUrl];
            if (list.current && list.pendingUpdate) {
                const bump = tokenLists.getVersionUpgrade(list.current.version, list.pendingUpdate.version);
                const isDefaultList = DEFAULT_TOKEN_LISTS.includes(listUrl);
                switch (bump) {
                    case tokenLists.VersionUpgrade.NONE:
                        throw new Error('unexpected no version bump');
                    case tokenLists.VersionUpgrade.PATCH:
                    case tokenLists.VersionUpgrade.MINOR:
                        const min = tokenLists.minVersionBump(list.current.tokens, list.pendingUpdate.tokens);
                        // automatically update minor/patch as long as bump matches the min update
                        if (bump >= min) {
                            if (isDefaultList) {
                                //if its pangolin hosted token list then we will autoupdate it
                                // eslint-disable-next-line import/no-named-as-default-member
                                ReactGA__default["default"].event({
                                    category: 'Lists',
                                    action: 'Update List from Popup',
                                    label: listUrl,
                                });
                                dispatch(acceptListUpdate(listUrl));
                            }
                        }
                        else {
                            console.error(`List at url ${listUrl} could not automatically update because the version bump was only PATCH/MINOR while the update had breaking changes and should have been MAJOR`);
                        }
                        break;
                    case tokenLists.VersionUpgrade.MAJOR:
                        if (isDefaultList) {
                            // if its pangolin hosted token list then we will autoupdate it
                            // eslint-disable-next-line import/no-named-as-default-member
                            ReactGA__default["default"].event({
                                category: 'Lists',
                                action: 'Update List from Popup',
                                label: listUrl,
                            });
                            dispatch(acceptListUpdate(listUrl));
                        }
                }
            }
        });
    }, [dispatch, lists]);
    return null;
}

// chunks array into chunks of maximum size
// evenly distributes items among the chunks
function chunkArray(items, maxChunkSize) {
    if (maxChunkSize < 1)
        throw new Error('maxChunkSize must be gte 1');
    if (items.length <= maxChunkSize)
        return [items];
    const numChunks = Math.ceil(items.length / maxChunkSize);
    const chunkSize = Math.ceil(items.length / numChunks);
    return [...Array(numChunks).keys()].map((ix) => items.slice(ix * chunkSize, ix * chunkSize + chunkSize));
}

// chunk calls so we do not exceed the gas limit
const CALL_CHUNK_SIZE = 500;
/**
 * Fetches a chunk of calls, enforcing a minimum block number constraint
 * @param multicallContract multicall contract to fetch against
 * @param chunk chunk of calls to make
 * @param minBlockNumber minimum block number of the result set
 */
function fetchChunk(multicallContract, chunk, minBlockNumber) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber);
        let resultsBlockNumber, returnData;
        try {
            [resultsBlockNumber, returnData] = yield multicallContract.aggregate(chunk.map((obj) => [obj.address, obj.callData]));
        }
        catch (error) {
            console.debug('Failed to fetch chunk inside retry', error);
            throw error;
        }
        if (resultsBlockNumber.toNumber() < minBlockNumber) {
            throw new RetryableError('Fetched for old block number');
        }
        return { results: returnData, blockNumber: resultsBlockNumber.toNumber() };
    });
}
/**
 * From the current all listeners state, return each call key mapped to the
 * minimum number of blocks per fetch. This is how often each key must be fetched.
 * @param allListeners the all listeners state
 * @param chainId the current chain id
 */
function activeListeningKeys(allListeners, chainId) {
    if (!allListeners || !chainId)
        return {};
    const listeners = allListeners[chainId];
    if (!listeners)
        return {};
    return Object.keys(listeners).reduce((memo, callKey) => {
        const keyListeners = listeners[callKey];
        memo[callKey] = Object.keys(keyListeners)
            .filter((key) => {
            const blocksPerFetch = parseInt(key);
            if (blocksPerFetch <= 0)
                return false;
            return keyListeners[blocksPerFetch] > 0;
        })
            .reduce((previousMin, current) => {
            return Math.min(previousMin, parseInt(current));
        }, Infinity);
        return memo;
    }, {});
}
/**
 * Return the keys that need to be refetched
 * @param callResults current call result state
 * @param listeningKeys each call key mapped to how old the data can be in blocks
 * @param chainId the current chain id
 * @param latestBlockNumber the latest block number
 */
function outdatedListeningKeys(callResults, listeningKeys, chainId, latestBlockNumber) {
    if (!chainId || !latestBlockNumber)
        return [];
    const results = callResults[chainId];
    // no results at all, load everything
    if (!results)
        return Object.keys(listeningKeys);
    return Object.keys(listeningKeys).filter((callKey) => {
        const blocksPerFetch = listeningKeys[callKey];
        const data = callResults[chainId][callKey];
        // no data, must fetch
        if (!data)
            return true;
        const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1);
        // already fetching it for a recent enough block, don't refetch it
        if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber)
            return false;
        // if data is older than minDataBlockNumber, fetch it
        return !(data === null || data === void 0 ? void 0 : data.blockNumber) || (data === null || data === void 0 ? void 0 : data.blockNumber) < minDataBlockNumber;
    });
}
function Updater$2() {
    const dispatch = useDispatch();
    const state = useSelector((state) => state.pmulticall);
    // wait for listeners to settle before triggering updates
    const debouncedListeners = useDebounce(state.callListeners, 100);
    const latestBlockNumber = useBlockNumber();
    const { chainId } = usePangolinWeb3();
    const multicallContract = useMulticallContract();
    const cancellations = React.useRef();
    const listeningKeys = React.useMemo(() => {
        return activeListeningKeys(debouncedListeners, chainId);
    }, [debouncedListeners, chainId]);
    const unserializedOutdatedCallKeys = React.useMemo(() => {
        return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber);
    }, [chainId, state.callResults, listeningKeys, latestBlockNumber]);
    const serializedOutdatedCallKeys = React.useMemo(() => JSON.stringify(unserializedOutdatedCallKeys.sort()), [unserializedOutdatedCallKeys]);
    React.useEffect(() => {
        var _a, _b, _c;
        if (!latestBlockNumber || !chainId || !multicallContract)
            return;
        const outdatedCallKeys = JSON.parse(serializedOutdatedCallKeys);
        if (outdatedCallKeys.length === 0)
            return;
        const calls = outdatedCallKeys.map((key) => parseCallKey(key));
        const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE);
        if (((_a = cancellations.current) === null || _a === void 0 ? void 0 : _a.blockNumber) !== latestBlockNumber) {
            (_c = (_b = cancellations.current) === null || _b === void 0 ? void 0 : _b.cancellations) === null || _c === void 0 ? void 0 : _c.forEach((c) => c());
        }
        dispatch(fetchingMulticallResults({
            calls,
            chainId,
            fetchingBlockNumber: latestBlockNumber,
        }));
        cancellations.current = {
            blockNumber: latestBlockNumber,
            cancellations: chunkedCalls.map((chunk, index) => {
                const { cancel, promise } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {
                    n: Infinity,
                    minWait: 2500,
                    maxWait: 3500,
                });
                promise
                    .then(({ results: returnData, blockNumber: fetchBlockNumber }) => {
                    cancellations.current = { cancellations: [], blockNumber: latestBlockNumber };
                    // accumulates the length of all previous indices
                    const firstCallKeyIndex = chunkedCalls
                        .slice(0, index)
                        .reduce((memo, curr) => memo + curr.length, 0);
                    const lastCallKeyIndex = firstCallKeyIndex + returnData.length;
                    dispatch(updateMulticallResults({
                        chainId,
                        results: outdatedCallKeys
                            .slice(firstCallKeyIndex, lastCallKeyIndex)
                            .reduce((memo, callKey, i) => {
                            var _a;
                            memo[callKey] = (_a = returnData[i]) !== null && _a !== void 0 ? _a : null;
                            return memo;
                        }, {}),
                        blockNumber: fetchBlockNumber,
                    }));
                })
                    .catch((error) => {
                    if (error instanceof CancelledError) {
                        console.debug('Cancelled fetch for blockNumber', latestBlockNumber);
                        return;
                    }
                    console.error('Failed to fetch multicall chunk', chunk, chainId, error);
                    dispatch(errorFetchingMulticallResults({
                        calls: chunk,
                        chainId,
                        fetchingBlockNumber: latestBlockNumber,
                    }));
                });
                return cancel;
            }),
        };
    }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber]);
    return null;
}

const useMinichefStakingInfosHook = {
    [sdk.ChainId.FUJI]: useMinichefStakingInfos,
    [sdk.ChainId.AVALANCHE]: useMinichefStakingInfos,
    [sdk.ChainId.WAGMI]: useMinichefStakingInfos,
    [sdk.ChainId.COSTON]: useDummyMinichefHook,
    [sdk.ChainId.SONGBIRD]: useDummyMinichefHook,
    [sdk.ChainId.NEAR_MAINNET]: useDummyMinichefHook,
    [sdk.ChainId.NEAR_TESTNET]: useDummyMinichefHook,
};
const useGetMinichefStakingInfosViaSubgraphHook = {
    [sdk.ChainId.FUJI]: useGetMinichefStakingInfosViaSubgraph,
    [sdk.ChainId.AVALANCHE]: useGetMinichefStakingInfosViaSubgraph,
    [sdk.ChainId.WAGMI]: useGetMinichefStakingInfosViaSubgraph,
    [sdk.ChainId.COSTON]: useGetMinichefStakingInfosViaSubgraph,
    [sdk.ChainId.SONGBIRD]: useGetMinichefStakingInfosViaSubgraph,
    [sdk.ChainId.NEAR_MAINNET]: useDummyMinichefStakingInfosViaSubgraph,
    [sdk.ChainId.NEAR_TESTNET]: useDummyMinichefStakingInfosViaSubgraph,
};
const useGetAllFarmDataHook = {
    [sdk.ChainId.FUJI]: useGetAllFarmData,
    [sdk.ChainId.AVALANCHE]: useGetAllFarmData,
    [sdk.ChainId.WAGMI]: useGetAllFarmData,
    [sdk.ChainId.COSTON]: useGetAllFarmData,
    [sdk.ChainId.SONGBIRD]: useGetAllFarmData,
    [sdk.ChainId.NEAR_MAINNET]: useGetDummyAllFarmData,
    [sdk.ChainId.NEAR_TESTNET]: useGetDummyAllFarmData,
};

function shouldCheck(lastBlockNumber, tx) {
    if (tx.receipt)
        return false;
    if (!tx.lastCheckedBlockNumber)
        return true;
    const blocksSinceCheck = lastBlockNumber - tx.lastCheckedBlockNumber;
    if (blocksSinceCheck < 1)
        return false;
    const minutesPending = (new Date().getTime() - tx.addedTime) / 1000 / 60;
    if (minutesPending > 60) {
        // every 10 blocks if pending for longer than an hour
        return blocksSinceCheck > 9;
    }
    else if (minutesPending > 5) {
        // every 3 blocks if pending more than 5 minutes
        return blocksSinceCheck > 2;
    }
    else {
        // otherwise every block
        return true;
    }
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const txChecker = (_params) => {
    // This is intentional as this is just dummy function to support for evm chains
};
const NEAR_TX_HASH_PARAM = 'transactionHashes';
/**
 * this method is used to check transaction hashes in url and if found then get summary of that transaction and add it to the reducer
 * @returns txChecker function
 */
const nearTxChecker = ({ transactions, dispatch, chainId }) => tslib.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const search = window.location.search;
    // get transactionHashes from url
    const txHashes = ((_a = new URLSearchParams(search).get(NEAR_TX_HASH_PARAM)) === null || _a === void 0 ? void 0 : _a.split(',')) || [];
    const txHash = (txHashes === null || txHashes === void 0 ? void 0 : txHashes.length) > 0 ? txHashes === null || txHashes === void 0 ? void 0 : txHashes[(txHashes === null || txHashes === void 0 ? void 0 : txHashes.length) - 1] : '';
    if (txHash) {
        // get tx details using near sdk
        const tx = yield (nearFn === null || nearFn === void 0 ? void 0 : nearFn.getTransaction(txHash));
        if (tx) {
            // get tx summary
            const summary = nearFn.getTranctionSummary(tx);
            const exists = !!transactions[txHash];
            // if hash doesn't exist then only add it to redux
            if (!exists) {
                dispatch(addTransaction({ hash: txHash, from: nearFn.getAccountId(), chainId, summary }));
            }
        }
        // remove transactionHashes from url without refreshing page
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.delete(NEAR_TX_HASH_PARAM);
        window.history.replaceState({}, document.title, currentUrl.toString());
    }
});
const txCheckerMapping = {
    [sdk.ChainId.AVALANCHE]: txChecker,
    [sdk.ChainId.FUJI]: txChecker,
    [sdk.ChainId.COSTON]: txChecker,
    [sdk.ChainId.SONGBIRD]: txChecker,
    [sdk.ChainId.WAGMI]: txChecker,
    [sdk.ChainId.NEAR_MAINNET]: nearTxChecker,
    [sdk.ChainId.NEAR_TESTNET]: nearTxChecker,
};
function Updater$1() {
    var _a;
    const chainId = useChainId();
    const { library, provider } = useLibrary();
    const lastBlockNumber = useBlockNumber();
    const dispatch = useDispatch();
    const state = useSelector((state) => state.ptransactions);
    const transactions = chainId ? (_a = state[chainId]) !== null && _a !== void 0 ? _a : {} : {}; // eslint-disable-line react-hooks/exhaustive-deps
    const txCheckerFn = txCheckerMapping[chainId];
    // as of now this is specific to Near chain, we are checking user is coming to pangolin after completing tx or not
    React.useEffect(() => {
        if (txCheckerFn) {
            txCheckerFn({ transactions, chainId, dispatch });
        }
    }, [transactions, chainId, dispatch]);
    // show popup on confirm
    const addPopup = useAddPopup();
    React.useEffect(() => {
        if (!chainId || !library || !lastBlockNumber)
            return;
        Object.keys(transactions)
            .filter((hash) => shouldCheck(lastBlockNumber, transactions[hash]))
            .forEach((hash) => tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const receipt = yield provider.getTransactionReceipt(hash);
                const status = receipt.status;
                if (receipt) {
                    dispatch(finalizeTransaction({
                        chainId,
                        hash,
                        receipt: {
                            blockHash: receipt.blockHash,
                            blockNumber: receipt === null || receipt === void 0 ? void 0 : receipt.blockNumber,
                            // contractAddress: receipt.contractAddress,
                            contractAddress: '',
                            from: receipt.from,
                            status,
                            to: receipt.to,
                            // transactionHash: receipt.transactionHash,
                            transactionHash: receipt.hash,
                            transactionIndex: receipt.transactionIndex,
                        },
                    }));
                    addPopup({
                        txn: {
                            hash,
                            success: status === 1,
                            summary: (_a = transactions[hash]) === null || _a === void 0 ? void 0 : _a.summary,
                        },
                    }, hash);
                }
                else {
                    dispatch(checkedTransaction({ chainId, hash, blockNumber: lastBlockNumber }));
                }
            }
            catch (error) {
                console.error(`failed to check transaction hash: ${hash}`, error);
            }
        }));
    }, [chainId, library, transactions, lastBlockNumber, dispatch, addPopup]);
    return null;
}

var header$7 = {
	dashboard: "Dashboard",
	swap: "Tauschen",
	buy: "Kaufen",
	pool: "Pool",
	farm: "Farm",
	version1: "Ausführung 1",
	version2: "Ausführung 2",
	stake: "Stake",
	newPng: "Neues {{ pngSymbol }}",
	oldPng: "Altes {{ pngSymbol }}",
	vote: "Abstimmen",
	ido: "IDO",
	charts: "Diagramme",
	forum: "Forum",
	pngBreakDown: "Deine {{ symbol }}-Übersicht",
	balance: "Kontostand: ",
	unclaimed: "Nicht beansprucht: ",
	pngPrice: "{{ symbol }}-Preis:",
	pngCirculation: "{{ symbol }} im Umlauf:",
	totalSupply: "Gesamtmenge",
	makeSureURLWarning: "Gehe sicher, dass die URL folgende ist:",
	alwaysMakeSureWarning: "Gehe immer sicher, dass die URL folgende ist:",
	bookmarkIt: "Füge sie deinen Favoriten hinzu, um dich abzusichern.",
	addMetamask: "{{ symbol }} zu MetaMask hinzufügen",
	bridge: "Brücke",
	ourPartners: "Unsere Partner",
	usefulLinks: "NÜTZLICHE LINKS",
	comeAndJoinUs: "Komm, schließe dich uns an",
	tryOurNewBetaSite: "Testen Sie unsere neue Beta-Site",
	returnToLegacySite: "Zurück zur alten Website",
	switchToNewUI: "Wechseln Sie zur neuen Benutzeroberfläche "
};
var accountDetails$7 = {
	connectedWith: "Verbunden mit ",
	account: "Konto",
	disconnect: "Trennen",
	change: "Ändern",
	copy: "Adresse kopieren",
	viewExplorer: "Im Explorer anzeigen",
	clearAll: "(alle löschen)",
	transactionAppear: "Deine Transaktionen werden hier erscheinen...",
	recentTransactions: "Jüngste Transaktionen",
	copied: "Kopiert"
};
var addressInputPanel$7 = {
	recipient: "Empfänger",
	viewExplorer: "(Im Explorer anzeigen)",
	walletAddress: "Wallet-Adresse"
};
var currencyInputPanel$7 = {
	selectToken: "Wähle einen Token",
	balance: "Kontostand: ",
	max: "MAX",
	to: "Für"
};
var earn$7 = {
	claimAccumulated: "Ausstehende {{ symbol }}-Vergütung beanspruchen",
	connectWallet: "Mit Wallet verbinden",
	enterAmount: "Gib einen Betrag ein",
	unclaimedReward: "Unbeanspruchte {{ symbol }}",
	claim: "Beanspruchen",
	claimReward: "{{ symbol }} Beanspruchen",
	liquidityRemainsPool: "Wenn du deine Vergütung ohne abzubuchen beanspruchst, wird deine Liquidität im Pool verbleiben.",
	withdrawingLiquidity: "{{ amount }} {{ symbol }} opnemen",
	claimingReward: "Wird beansprucht {{ amount }} {{ symbol }}",
	claimedReward: "{{ symbol }} beansprucht!",
	manage: "Verwalten",
	deposit: "Einzahlen",
	poolRate: "Pool-Rate",
	currentReward: "Momentane Vergütung",
	pngPerAvax: "{{ pngSymbol }} / Woche pro AVAX",
	rewardPerWeek: "{{ symbol }} / Woche",
	earnUpTo: "Verdiene jährlich bis zu",
	yourRate: "Deine Rate",
	totalDeposited: "Gesamte Einlage",
	totalStaked: "Insgesamt gestakt",
	depositLiquidity: "Liquidität hinzufügen",
	attemptingToStakeError: "Es wurde versucht, ohne Bestätigung oder Unterschrift zu staken. Bitte setze dich mit dem Support in Verbindung.",
	transactionSubmitted: "Transaktion eingereicht",
	depositingLiquidity: "Füge Liquidität hinzu",
	depositingToken: "Depositing {{ symbol }}",
	depositedToken: "Deposited {{ symbol }}",
	availableToDeposit: "Zum Hinzufügen verfügbar ",
	weeklyRewards: "Wöchentliche Vergütung",
	missingLiquidityAmount: "Liquiditätsbetrag nicht angegeben",
	missingDependencies: "Fehlende Abhängigkeiten",
	deposited: "Eingezahlt",
	withdrawDepositedLiquidity: "Eingezahlte Liquidität abbuchen",
	depositedPglLiquidity: "Eingezahlte ARL-Liquidität:",
	whenYouWithdrawWarning: "Wenn du abbuchst, wird deine ausstehenden {{ symbol }}-Vergütung beansprucht. Deine Arcanum-Liquiditätstoken, ARL, werden an dich zurückgegeben und du wirst keine {{ symbol }}-Vergütungen mehr auf diese Liquiditätsposition erhalten. Deine ursprüngliche Liquidität wird im Liquiditätspool verbleiben.",
	whenYouWithdrawSingleSideWarning: "When you withdraw, your {{ symbol }} is claimed and your {{ pngSymbol}} is returned to you. You will no longer earn {{ symbol }} rewards on this {{ pngSymbol}}.",
	withdrawAndClaim: "Abbuchen & Beanspruchen",
	withdrewStakingToken: "{{ symbol }} abgebucht!",
	approve: "Bestätigen",
	poolWeight: "Beckengewicht",
	withdraw: "Abheben",
	extraReward: "Zusätzliche Belohnung",
	poolRewards: "Pool-Belohnungen",
	rewardsIn: "Belohnungen ein",
	removeWarning: "Sie entfernen Liquidität aus diesem Pool. Diese Aktion gibt Ihnen Ihre Token zurück. Alternativ können Sie sich dafür entscheiden, Ihre Token zu farmen, um Belohnungen zu verdienen."
};
var menu$7 = {
	code: "Code",
	twitter: "Twitter",
	discord: "Discord",
	telegram: "Telegram",
	tutorials: "Tutorials",
	idos: "IDOs",
	about: "Info"
};
var modalView$7 = {
	confirmTransaction: "Diese Transaktion in deiner Wallet überprüfen",
	viewTransaction: "Sehen Sie sich die Transaktion im Explorer an"
};
var navigationTabs$7 = {
	useThisTool: "Benutze dieses Werkzeug, um dir Paare anzeigen zu lassen, die nicht in der Schnittstelle auftauchen.",
	swap: "Tauschen",
	pool: "Pool",
	importPool: "Pool importieren",
	createPair: "Erstelle ein Paar",
	addLiquidity: "Füge Liquidität hinzu",
	removeLiquidity: "Entferne Liquidität",
	whenYouAddLiquidityInfo: "Wenn du Liquidität hinzufügst, erhältst du Pool-Token, die Deine Position im Pool repräsentieren. Diese Token schütten automatisch Vergütungen aus, die abhängig von deinem Anteil am Pool sind. Du kannst deine Pool-Token können jederzeit einlösen!",
	removingPoolTokensInfo: "Wenn du deine Pool-Token einlöst, erhältst du deine ursprünglich eingezahlten Token im momentanen Verhältnis zurück, abhängig von deinem Anteil am Pool. Von dir verdiente Transaktionsgebühren sind im Betrag inbegriffen."
};
var popups$7 = {
	tokenListUpdated: "Die Token-Liste \" {{oldList}} \" wurde aktualisiert zu ",
	updateAvailable: "Für die Token-Liste ist ein Update verfügbar \" {{oldList}} \"",
	viewExplorer: "Im Explorer anzeigen",
	hash: "Hash: ",
	added: "hinzugefügt",
	removed: "entfernt",
	tokensUpdated: "Token aktualisiert",
	acceptUpdate: "Update bestätigen",
	dismiss: "Abbruch"
};
var positionCard$7 = {
	add: "Hinzufügen",
	remove: "Entfernen",
	poolShare: "Dein Anteil am Pool:",
	pooled: "gepoolt",
	poolTokens: "Deine Pool-Token:",
	manage: "Verwalten",
	loading: "Lädt",
	yourPosition: "Deine Position",
	byAddingLiquidityInfo: "Durch das Bereitstellen von Liquidität verdienst du 0,25% an allen Trades auf diesem Paar, proportional zu deinem Anteil am Pool. \n Gebühren werden dem Pool hinzugefügt, fallen in Echtzeit an und können beansprucht werden, indem die Liquidität abgebucht wird."
};
var searchModal$7 = {
	commonBases: "Übliche Basis-Token",
	tokensPairsHelper: "Diese Token werden häufig im Paar mit anderen Token hinzugefügt.",
	addedByUser: "Hinzugefügt durch",
	foundByAddress: "Gefunden über Adresse",
	remove: "entfernen",
	add: "Hinzufügen",
	findToken: "Finde einen Token, indem du nach seinem Namen oder Symbol suchst oder seine Adresse unten einfügst.",
	selectToken: "Wähle einen Token aus",
	tokenSearchPlaceholder: "Suche nach Name oder Adresse",
	tokenName: "Token-Name",
	change: "Ändern",
	selectList: "Wähle eine Liste aus",
	confirmListRemovalPrompt: "Bitte bestätige, dass du diese Liste entfernen möchtest, indem du \"entfernen\" eingibst.",
	addList: "Eine Liste hinzufügen ",
	tokenListHelper: "Token-Listen sind offene Spezifikationen für Listen von ERC20-Token. Du kannst eine beliebige Token-Liste eingeben, indem du die zugehörige URL unten eingibst. Beachte, dass Listen von Drittanbietern Fake-Token oder Token, die in böser Absicht erstellt worden sind enthalten können.",
	httpsPlaceholder: "https:// oder ipfs://",
	manageLists: "Listen verwalten",
	viewList: "Liste ansehen",
	updateList: "Liste aktualisieren",
	removeList: "Liste entfernen",
	selected: "ausgewählt",
	select: "auswählen",
	manageTokenLists: "Tokenlisten verwalten"
};
var settings$7 = {
	areYouSure: "Bist du dir sicher?",
	expertInfo: "Der Expertenmodus deaktiviert die Aufforderung zur Transaktionsbestätigung und erlaubt Trades mit hoher Slippage, welche oft zu schlechten Tauschraten und unwiderruflich verlorenen Mitteln führen.",
	expertWarningCAPS: "BENUTZE DIESEN MODUS NUR, WENN DU GENAU WEISST, WAS DU TUST.",
	confirm: "bestätige",
	confirmExpertMode: "Bitte gib das Wort \"bestätige\" ein, um den Expertenmodus zu aktivieren.",
	turnOnExpertMode: "Aktiviere Expertenmodus",
	transactionSettings: "Transaktionseinstellungen",
	interfaceSettings: "Schnittstelleneinstellungen",
	toggleExpertMode: "Expertenmodus",
	expertModeHelper: "Umgeht Bestätigungsaufforderungen und ermöglicht Trades mit hoher Slippage. Verwendung auf eigene Gefahr.",
	toggleDarkMode: "Nachtmodus",
	slippage: "Slippage",
	percent: "Percent"
};
var swap$7 = {
	priceImpact: "Preisauswirkungen",
	priceImpactHelper: "Unterschied zwischen Marktpreis und dem durch die Größe des Trades beeinflusstem, geschätzten Preis.",
	liquidityProviderFee: "Gebühren an Liquiditäts-Provider",
	liquidityProviderHelper: "Ein Anteil jedes Trades (0,3%) geht an Liquiditäts-Provider als Anreiz zum Bereitstellen von Liquidität.",
	route: "Tauschpfad",
	routingHelper: "Dieser Tauschpfad ergab den besten Preis für deinen Trade.",
	confirmSwap: "Tausch bestätigen",
	swapAnyway: "Trotzdem tauschen",
	confirm: "bestätige",
	price: "Preis",
	accept: "Bestätigen",
	minimumReceived: "Du erhältst mindestens",
	maximumSold: "Du verkaufst höchstens",
	transactionRevertHelper: "Deine Transaktion wird storniert, wenn es eine große, ungünstige Preisbewegung gibt, bevor sie bestätigt wird.",
	priceUpdated: "Preis aktualisiert",
	outputEstimated: "Die Kaufmenge ist geschätzt. Du erhältst mindestens <strong>{{amount}} {{currencySymbol}}</strong> oder die Transaktion wird storniert.",
	inputEstimated: "Die Verkaufsmenge ist geschätzt. Du verkaufst höchstens <strong>{{amount}} {{currencySymbol}}</strong> oder die Transaktion wird storniert.",
	outputSentTo: "Die Verkaufsmenge wird gesendet an ",
	priceImpactMinPrompt: "Dieser Tausch hat eine Preisauswirkung von mindestens {{ priceImpact }}%. Bitte gib das Wort \"bestätige\" ein, um mit dem Tausch fortzufahren.",
	priceImpactHighPrompt: "Dieser Tausch hat eine Preisauswirkung von mindestens {{ priceImpact }}%. Bitte gib das Wort \"bestätige\" ein, um mit dem Tausch fortzufahren."
};
var toggle$7 = {
	on: "Ein",
	off: "Aus"
};
var tokenWarningModal$7 = {
	tokenImported: "Token importiert",
	anyoneCanCreateWarning: "Jeder kann einen ERC-20-Token auf Avalanche mit <em>beliebigem</em> Namen erstellen, einschließlich der Erstellung von gefakten Versionen bestehender Token und Token, die den Anschein haben, Projekte zu repräsentieren, für die es keinen Token gibt.",
	loadArbitraryWarning: "Mit dieser Schnittstelle kannst du beliebige Token über ihre Token-Adresse laden. Bitte sei besonders vorsichtig und recherchiere gründlich, wenn du beliebige ERC-20 lädst.",
	purchaseArbitraryWarning: "Wenn du einen beliebigen Token kaufst, <strong>kannst du ihn unter Umständen nicht zurückverkaufen.</strong>",
	understand: "Ich verstehe",
	"continue": "Weiter",
	viewExplorer: "Im Explorer anzeigen"
};
var transactionConfirmation$7 = {
	waitingConfirmation: "Warte auf Bestätigung",
	confirmTransaction: "Diese Transaktion in deiner Wallet überprüfen",
	transactionSubmitted: "Transaktion eingereicht",
	viewExplorer: "Im Explorer anzeigen",
	close: "Schließen",
	error: "Fehler",
	dismiss: "Abbruch",
	addToFarm: "Zur Farm hinzufügen"
};
var transactionSettings$7 = {
	slippageTolerance: "Slippage-Toleranz",
	transactionRevertSlippageHelper: "Deine Transaktion wird storniert, wenn sich der Preis um mehr als diesen Prozentsatz zu deinen Ungunsten verändert.",
	transactionDeadline: "Transaktionsfrist",
	transactionRevertDeadlineHelper: "Deine Transaktion wird storniert, wenn sie nach dieser Frist nicht bestätigt wurde.",
	enterValidSlippage: "Gib eine gültige Slippage-Toleranz ein",
	transactionMayFail: "Deine Transaktion kann fehlschlagen",
	transactionMayFrontrun: "Deine Transaktion kann eventell gefrontrunnt werden",
	transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
	minutes: "Minuten"
};
var vote$7 = {
	earnedPng: "Verdiente {{ pngSymbol }}-Token stellen stimmberechtigte Anteile bei Arcanum-Abstimmungen dar.",
	canEitherVote: "Du kannst entweder über jeden Antrag selbst abstimmen oder deine Stimmen an einen Dritten delegieren.",
	delegateVotes: "Stimmen delegieren",
	selfDelegate: "An dich selbst delegieren",
	remove: "Entfernen",
	add: "Hinzufügen",
	delegate: "Delegieren",
	delegatingVotes: "Stimmen werden delegiert",
	unlockingVotes: "Stimmen werden freigeschaltet",
	transactionSubmitted: "Transaktion eingereicht",
	"for": "dafür",
	against: "dagegen",
	vote: "Stimme",
	proposal: "Antrag",
	votes: "Stimmen",
	submittingVote: "Stimme wird abgegeben",
	confirmTransaction: "Diese Transaktion in deiner Wallet überprüfen",
	viewExplorer: "Im Explorer anzeigen"
};
var walletModal$7 = {
	wrongNetwork: "Falsches Netzwerk",
	errorConnecting: "Fehler beim Verbinden",
	pleaseConnectAvalanche: "Bitte verbinde dich mit dem entsprechenden Avalanche-Netzwerk.",
	switchAvalanche: "Zur Avalanche-Chain wechseln",
	errorConnectingRefresh: "Fehler beim Verbinden. Versuch es mit einem Neuladen der Seite.",
	connectToWallet: "Mit einer Wallet verbinden",
	newToAvalanche: "Neu bei Avalanche? ",
	learnMoreWallet: "Erfahre mehr über das Einrichten einer Wallet",
	initializing: "Initialisiere...",
	tryAgain: "Versuch es erneut"
};
var web3ReactManager$7 = {
	unknownError: "Ups! Ein unbekannter Fehler ist aufgetreten. Bitte aktualisiere die Seite, oder ruf die Seite von einem anderen Browser oder Gerät auf."
};
var web3Status$7 = {
	pending: "ausstehend",
	wrongNetwork: "Falsches Netzwerk",
	error: "Fehler",
	connectToWallet: "Mit Wallet verbinden"
};
var gasFeeAlert$7 = {
	gasFeeReduction: "!!! Gasgebühren-Reduzierung !!!",
	transactionsNotAccept: "Transaktionen werden nicht entgegengenommen, wenn die Gasgebühr nicht auf mindestens {{ gasPrice }} eingestellt wird."
};
var addLiquidity$7 = {
	deposited: "Eingezahlt",
	shareOfPool: "Anteil am Pool",
	createPoolSupply: "Pool erstellen & hinzufügen",
	confirmSupply: "Einzahlung bestätigen",
	giveOrder: "GIVE ORDER",
	outputEstimated: "Die Kaufmenge ist geschätzt. Sollte sich der Preis um mehr als {{ allowedSlippage }}% verändern, wird die Transaktion storniert.",
	creatingPool: "Du erstellst einen Pool",
	willReceive: "Du erhältst",
	firstLP: "Du bist der erste Liquiditäts-Provider.",
	ratioTokens: "Das Verhältnis, in dem du diesem Pool Token hinzufügst, wird den Preis für diesen Pool bestimmen.",
	happyRate: "Wenn du mit dem Verhältnis zufrieden bist, klicke auf Hinzufügen, um eine Übersicht zu erhalten.",
	initialPrices: "Ursprüngliche Preise",
	prices: "Preise",
	poolShare: "und Anteil am Pool",
	connectWallet: "Mit Wallet verbinden",
	approve: "Bestätigen ",
	supply: "Hinzufügen",
	per: " pro ",
	rates: "Raten",
	poolTokens: " Pool-Token"
};
var airdrop$7 = {
	claimPngAirdrop: "{{ pngSymbol }} aus Airdrop beanspruchen",
	claimPeriodEnded: "Der Zeitraum für das Beanspruchen von Airdrops ist abgelaufen.",
	connectWalletViewLiquidity: "Verbinde mit einer Wallet, um deine Liquidität zu sehen.",
	noAvailableClaim: "Dir stehen keine zum Beanspruchen zu.",
	noUniNoSushi: "Du hast keine UNI- oder SUSHI Token. Bitte folge diesem Tutorial, um deiner Wallet UNI- oder SUSHI-Token hinzuzufügen.",
	youHave: "Du hast ",
	pngAvailableClaim: " {{ pngSymbol }} verfügbar zum Beanspruchen",
	loading: "Lädt",
	welcomeToTeamPangolin: "Willkommen im Arcanum-Team",
	claim: "Beanspruchen "
};
var earnPage$7 = {
	pangolinLiquidityMining: "Arcanum Liquidity-Mining",
	pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
	depositPangolinLiquidity: "Zahle deine Arcanum Liquiditätsprovider-Token (ARL) ein, um {{ pngSymbol }}, den Governance-Token des Arcanum-Protokolls zu erhalten.",
	depositPangolinStaking: "Deposit and stake your {{ pngSymbol }} tokens to earn more tokens.",
	currentOpportunities: "Current opportunities",
	readMoreAboutPng: "Erfahre mehr über {{ pngSymbol }}",
	getInsuranceCoverage: "Versichern Sie sich auf InsurAce.io",
	getCoverNexusMutual: "Schützen Sie sich bei Nexus Mutual",
	importantUpdate: "WICHTIGES UPDATE",
	pangolinGovernanceProposalResult: "Als Ergebnis des Arcanum-Governance-Antrags 1 ändert Arcanum die Staking-Smart Contracts! Nach ca. 09:59 MEZ am 19.4. werden alle Staking-Vergütungen auf die neuen Staking-Smart Contracts verteilt. Vor der Umstellung werden alle Vergütungen noch auf die alten Verträge verteilt. Um Unterbrechungen bei den Yield Farming-Vergütungen zu vermeiden, musst du deine Liquidität aus den alten Smart Contracts herausnehmen und in den neuen Smart Contracts staken. Du musst weder Liquidität aus deinen Pools entfernen noch deine Positionen ändern.",
	oldPngPools: "Alte {{ pngSymbol }}-Pools",
	newPngPools: "Neue {{ pngSymbol }}-Pools",
	participatingPools: "Pools, an denen du beteiligt bist",
	rewardsNeverEnd: "Die Vergütungen enden nie!",
	noActiveRewards: "Keine Vergütungen aktiv",
	liquidityMining: "Liquidity Mining",
	pngStaking: "{{ pngSymbol }} Staking",
	totalStaked: "Insgesamt gestakt",
	poolRate: "Pool-Rate",
	step1: "Schritt 1. Hole dir Arcanum Liquidity-Token (ARL)",
	pglTokenRequired: "Es sind ARL-Token erforderlich. Sobald du Liquidität zu dem {{ poolHandle }} Pool hinzugefügt hast, kannst du deine Liquiditätsprovider-Token auf dieser Seite staken.",
	addPoolLiquidity: "Füge {{ poolHandle }} Liquidität hinzu",
	liquidityDeposits: "Deine Liquiditätseinzahlungen",
	yourStakedToken: "Your staked {{ symbol }}",
	unclaimedReward: "Deine unbeanspruchten {{ symbol }}",
	claim: "Beanspruchen",
	rewardPerWeek: " {{ symbol }} / Woche",
	automagically: "Wenn du abbuchst, wird der Smart Contract automagisch {{ pngSymbol }} für dich beanspruchen!",
	deposit: "Einzahlen",
	depositStakingTokens: "Zahle {{ symbol }}-Token ein",
	stake: "Stake",
	stakeStakingTokens: "Stake {{ symbol }} Tokens",
	unstake: "Unstake",
	stakingTokensAvailable: "{{ symbol }}-Token verfügbar",
	getToken: "Get {{ symbol }}",
	migrateTitle: "Migrieren Sie Ihre gestapelte ARL",
	migrateDescription: "Arcanum hat die Tokenomik geändert. Sie müssen Ihre gestapelte ARL auf einen neuen Vertrag migrieren",
	migrate: "Wandern"
};
var pool$7 = {
	liquidityProviderRewards: "Liquiditätsprovider-Vergütungen",
	liquidityProvidersEarn: "Durch das Bereitstellen von Liquidität verdienen Liquiditätsprovider 0,25% an allen Trades auf diesem Paar, proportional zu ihren Anteil am Pool. Gebühren werden dem Pool hinzugefügt, fallen in Echtzeit an und können beansprucht werden, indem die Liquidität abgebucht wird.",
	readMoreProviding: "Erfahre mehr über das Bereitstellen von Liquidität",
	viewStakedLiquidity: "Lass dir deine gestakte Liquidität anzeigen",
	yourLiquidity: "Deine Liquidität",
	createPair: "Erstelle ein Paar",
	addLiquidity: "Füge Liquidität hinzu",
	connectWalletToView: "Verbinde mit einer Wallet, um deine Liquidität zu sehen.",
	loading: "Lädt",
	noLiquidity: "Keine Liquidität gefunden.",
	uniswapV1Found: "Uniswap V1-Liquidität gefunden!",
	noSeePoolJoined: "Siehst du den Pool, dem Du beigetreten bist nicht?",
	migrateNow: "Jetzt migrieren.",
	importIt: "Importiere ihn.",
	seeDetails: "SIEHE EINZELHEITEN",
	totalLockedValue: "Gesperrter Gesamtwert",
	yourLockedValue: "Ihr gesperrter Wert",
	allFarms: "Alle Bauernhöfe",
	yourFarms: "Ihre Höfe",
	yourPools: "Ihre Pools",
	noFarms: "Keine Höfe gefunden.",
	successWithdraw: "Ihre Liquidität wurde aus der Farm entfernt und aufgelaufene Prämien eingefordert!"
};
var poolFinder$7 = {
	connectToFind: "Verbinde mit einer Wallet, um Pools zu finden",
	selectTokenToFind: "Wähle einen Token, um deine Liquidität zu finden.",
	selectToken: "Wähle einen Token aus",
	poolFound: "Pool gefunden!",
	managePool: "Diesen Pool verwalten.",
	noLiquidityYet: "Du hast noch keine Liquidität in diesem Pool.",
	noPoolFound: "Kein Pool gefunden.",
	addLiquidity: "Liquidität hinzufügen.",
	createPool: "Pool erstellen.",
	invalidPair: "Ungültiges Paar.",
	loading: "Lädt"
};
var removeLiquidity$7 = {
	youWillReceive: "Du erhältst",
	simple: "Vereinfacht",
	detailed: "Detailliert",
	receiveAvax: "Erhalte {{ symbol }}",
	receiveWavax: "Erhalte {{ symbol }}",
	price: "Preis:",
	connectWallet: "Mit Wallet verbinden",
	approving: "Bestätige",
	approve: "Bestätigen",
	approved: "Bestätigt",
	remove: "Entferne",
	output: "Auszahlung",
	amount: "Anzahl"
};
var swapPage$7 = {
	addSend: "+ Empfängerwallet hinzufügen (optional)",
	toEstimated: "für (geschätzt)",
	to: "für",
	removeSend: "- Empfängerwallet entfernen",
	price: "Preis",
	slippageTolerance: "Slippage-Toleranz",
	connectWallet: "Mit Wallet verbinden",
	insufficientLiquidity: "Für diesen Trade ist nicht genügend Liquidität vorhanden.",
	wrap: "Wrappen",
	unwrap: "Entwrappen",
	approving: "Bestätige",
	approve: "Bestätigen ",
	approved: "Bestätigt",
	priceImpactHigh: "Hohe Preisauswirkung",
	swap: "Tauschen",
	anyway: " Trotzdem",
	from: "Tausche",
	fromEstimated: "Tausche (geschätzt)",
	velox: "Setzen Sie eine Limit-Order auf <1>Velox</1>",
	marginSwap: "Traden Sie mit Leverage auf <1>MarginSwap</1>",
	wowSwap: " oder <1>WOWswap</1>",
	veeFinance: " oder <1>Vee Finance</1>",
	gelatoFee: "Gelato-Gebühr",
	placeOrder: "Bestellung aufgeben",
	confirmOrder: "Bestellung bestätigen",
	"for": "Pro",
	submittingOrderToSwap: "Bestellung zum Tausch aufgeben",
	limitPrice: "Limitpreis",
	outputWillBeSentTo: "Ausgabe wird gesendet an",
	sell: "verkaufen",
	buy: "Kaufen",
	betaRelease: "Dies ist eine BETA-Version und sollte auf eigene Gefahr verwendet werden!",
	trade: "Handeln",
	watchList: "Beobachtungsliste",
	yourPortFolio: "Ihr Portfolio",
	comingSoon: "Kommt bald",
	connectWalletViewPortFolio: "Stellen Sie eine Verbindung zu einem Wallet her, um Ihr Portfolio anzuzeigen.",
	limitOrders: "Limitaufträge",
	cancelOrder: "Bestellung stornieren",
	all: "ALLE",
	open: "OFFEN",
	executed: "HINGERICHTET",
	cancelled: "STORNIERT",
	inputAmount: "Betrag eingeben",
	outputAmount: "Ausgabebetrag",
	status: "Status",
	noLimitOrder: "Nein {{ orderType }} Befehl",
	cancellingOrder: "Bestellung stornieren...",
	cancelLimitOrder: "Besorgen {{ outputCurrency }} mit {{ inputCurrency }}",
	executionPrice: "Ausführungspreis",
	seeMore: "Mehr sehen",
	seeLess: "Siehe Weniger"
};
var buyPage$7 = {
	buyAvaxInfo: "Kaufen Sie AVAX mit Fiatgeld von unserem Partner Wyre.",
	privacyInfo: "Arcanum speichert keine Kaufhistorie und persönliche Daten.",
	firstName: "Vorname",
	lastName: "Nachname",
	email: "E-Mail-Adresse",
	buyAvax: "Kaufen Sie AVAX"
};
var votePage$7 = {
	unlockVotes: "Stimmen freischalten",
	updateDelegation: "Delegierung aktualisieren",
	pangolinGovernance: "Arcanum-Governance",
	earnedPngTokens: "{{ pngSymbol }}-Token repräsentieren Stimmgewichte in der Arcanum Governance. Du kannst entweder über jeden Vorschlag selbst abstimmen oder deine Stimmen an einen Dritten delegieren.",
	eligibleToVote: "Um stimmberechtigt zu sein, musst du {{ pngSymbol }} in deiner Wallet haben und diese zu Beginn der Abstimmung delegieren. Nachdem die Abstimmung begonnen hat, kannst du deine {{ pngSymbol }} einem Pool hinzufügen oder ausgeben.",
	governanceVotes: "Abstimmungen zur Governance werden mit einfacher Mehrheit entschieden. Es gibt keine Mindestwahlbeteiligung.",
	proposals: "Anträge",
	allProposals: "Alle Anträge",
	backToProposals: "Zurück zu Vorschläge",
	unlockVoting: "Stimmabgabe freischalten",
	votes: " Stimmen",
	delegatedTo: "Delegiert an:",
	edit: "bearbeiten",
	noProposalsFound: "Keine Anträge gefunden.",
	proposalCommunityMembers: "Von Community-Mitgliedern eingereichte Vorschläge werden hier erscheinen.",
	minimumThreshold: "Zum Einreichen von Anträgen ist eine Mindestmenge von 1,000,000 {{ pngSymbol }} erforderlich",
	votingStarted: "Die Abstimmung hat begonnen ",
	votingStarts: "Die Abstimmung beginnt ",
	votingEnded: "Die Abstimmung ist beendet ",
	votingEnds: "Die Abstimmung endet ",
	voteFor: "Dafür abstimmen",
	voteAgainst: "Dagegen abstimmen",
	against: "dagegen",
	"for": "dafür",
	details: "Details",
	overview: "Übersicht",
	proposer: "Antragsteller",
	about: "Etwa",
	vote: "Abstimmung",
	executed: "Hingerichtet",
	rejected: "Abgelehnt",
	notSupported: "Wird auf dieser Kette nicht unterstützt"
};
var IDOPage$7 = {
	pangolinIDOs: "Initial DEX Offering (IDO)",
	pangolinIDODescription: "Initial DEX Offerings (IDO) ermöglichen es Projekten, ihre nativen Token an dezentralen Börsen zu finanzieren. Wir haben uns mit großartigen Teams zusammengetan, um großartige Projekte in die Avalanche-Community zu bringen",
	upcomingIDOs: "Bevorstehende",
	endedIDOs: "Beendet",
	allIDOs: "Alle IDOs",
	noIDOsFound: "Keine IDOs gefunden",
	IDOAnnounced: "Öffentlich angekündigte IDOs erscheinen hier."
};
var swapHooks$7 = {
	connectWallet: "Mit Wallet verbinden",
	enterAmount: "Gib einen Betrag ein",
	selectToken: "Wähle einen Token aus",
	enterRecipient: "Gib einen Empfänger ein",
	invalidRecipient: "Ungültiger Empfänger",
	insufficient: "Unzureichendes ",
	balance: " Guthaben"
};
var mintHooks$7 = {
	connectWallet: "Mit Wallet verbinden",
	insufficientInputAmount: "Unzureichende Eingangsmenge",
	invalidPair: "Ungültiges Paar",
	enterAmount: "Gib einen Betrag ein",
	insufficient: "Unzureichendes ",
	balance: " Guthaben"
};
var stakeHooks$7 = {
	connectWallet: "Mit Wallet verbinden",
	enterAmount: "Gib einen Betrag ein"
};
var burnHooks$7 = {
	connectWallet: "Mit Wallet verbinden",
	enterAmount: "Gib einen Betrag ein"
};
var migratePage$7 = {
	stake: "STAPEL",
	unstake: "ENTSTEHUNG",
	add: "HINZUFÜGEN",
	remove: "LÖSCHEN",
	startMigratingNow: "STARTEN SIE JETZT MIT DER MIGRATION",
	startMigratingNowDescription: "Unten finden Sie alle Farmen, die Sie für die Migration zu Pangolins V2-Verträgen benötigen",
	seeMore: "MEHR SEHEN",
	migrateWithEase: "MIT EINFACHEM MIGRIEREN",
	migrateWithDescription: "Wir haben einen eleganten Assistenten entwickelt, der Sie durch den Migrationsprozess Ihrer Farmen führt",
	alreadyMigrate: "bereits migriert",
	walletMigrate: "Brieftasche migriert",
	alreadyEarned: "Bereits verdienen",
	migrateNow: "JETZT MIGIEREN",
	learn: "LERNEN",
	moveYourTokensToNewContracts: "Migrieren Sie Ihre Farmen zu Arcanum V2",
	readyToMigrate: "Bereit zur Migration",
	apr: "APR:",
	totalValueLocked: "Gesamtwert gesperrt",
	lowVolatility: "Geringe Volatilität",
	compoundable: "Compoundierbar",
	migrate: "Wandern",
	migrationModalDescription: "Wir haben festgestellt, dass Sie diese Pools haben… Wählen Sie einen aus oder fügen Sie einen hinzu.",
	choosePool: "Wählen Sie Pool",
	pool: "Pool",
	availableToDeposit: "Einzahlung möglich: ",
	poolInfoDescription: "Jetzt haben Sie Ihren Pool ausgewählt und können Sie von dort abheben.",
	dollarWorth: "Dollarwert: ",
	usd: "USD",
	yourRate: "Ihr Tarif: ",
	unclaimedPng: "Nicht beanspruchtes {{ pngSymbol }}: ",
	shareOfPool: "Poolanteil: ",
	choose: "WÄHLEN",
	selectAll: "Wählen Sie Alle",
	loading: "Wird geladen",
	back: "Zurück",
	availableToUnstake: "Verfügbar zum Abnehmen: ",
	submittingTransaction: "Übermittlung der Transaktion",
	moveYourTokensToNewContractsDescription: "Als Teil der Einführung von Arcanum zu neuen verbesserten Verträgen müssen Sie Ihre Farmen migrieren. Wenn Sie Hilfe oder Anleitung benötigen, klicken Sie bitte auf die Schaltfläche „Lernen“.",
	migrateModalHeading: "Migration {{ current }} der {{ total }} Farm"
};
var dashboardPage$7 = {
	dashboard: "Dashboard",
	greetings: "Greetings kind guests! Let’s ape in today…",
	portfolioValue: "Portfolio Value",
	earned: "Earned",
	coins: "Coins",
	followedWallets: "Followed Wallets",
	earned_dailyIncome: "Daily Income",
	earned_weeklyIncome: "Weekly Income",
	earned_totalEarned: "Total Earned",
	earned_claim: "Claim",
	earned_customizePools: "Customize Pools",
	followed_address: "Address",
	followed_worth: "Worth",
	followed_interact: "Interact"
};
var stakePage$7 = {
	totalStaked: "Total Staked",
	apr: "Annual Percentage Rate",
	seeDetails: "SEE DETAILS",
	stake: "STAKE",
	earn: "Earn {{symbol}}",
	stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$7 = {
	missingCurrencyAmounts: "Fehlende Währungsbeträge",
	missingTokens: "Fehlende Token",
	missingDependencies: "Fehlende Abhängigkeiten",
	missingLiquidityAmount: "Fehlender Liquiditätsbetrag",
	couldNotWrap: "Konnte nicht umbrechen",
	attemptingToConfirmApproval: "Bestätigungsversuch ohne Genehmigung oder Unterschrift. Bitte kontaktieren Sie den Support."
};
var sarTitle$7 = {
	addMore: "MEHR HINZUFÜGEN",
	unstake: "EINE POSITION ABSETZEN",
	compound: "VERBUNDENE BELOHNUNGEN",
	claim: "BELOHNUNG ENTGEGENNEHMEN",
	interactingID: "Interaktion mit ID: {{ id }}"
};
var sarStake$7 = {
	createNewPosition: "Erstellen Sie eine neue Position",
	stake: "Anteil",
	staking: "Wettend",
	walletBalance: "Im Portemonnaie {{ Guthaben }} {{ symbol }}",
	max: "Max",
	dollarValue: "Dollar-Wert",
	buy: "{{ symbol }} kaufen",
	averageAPR: "Durchschnittlich Apr",
	startingApr: "Starten des effektiven Jahreszeitraums",
	weeklyDistributed: "Wöchentlich {{ symbol }} Verteilt",
	confirmDescription: "Durch eine Pfahlaktion wird ein SAR-Nft für Sie erstellt. Mit diesem NFT können Sie Ihren {{ symbol }} Einsatz verwalten.",
	successSubmit: "Sie haben Ihr Token erfolgreich abgesteckt.",
	yourAprRecalculated: "Ihr effektiver Jahreszins wird neu berechnet.",
	summary: "Zusammenfassung",
	pending: "Abstecken {{ balance }} {{ symbol }}",
	transactionSummary: "Abgesteckt {{ balance }} {{ symbol }}"
};
var sarStakeMore$7 = {
	stakeMore: "Mehr setzen",
	choosePosition: "Wählen Sie eine Position",
	confirmDescription: "Dies fügt Ihrer SAR NFT Position {{ symbol }} hinzu. Ihr ursprüngliches Guthaben wird ab demselben effektiven Jahreszins fortgesetzt. Der effektive Jahreszins Ihrer neu hinzugefügten Token beginnt bei 0 % und ändert sich je nach Länge des Einsatzes. Ihr NFT zeigt den Durchschnitt an.",
	newAPR: "Neuer effektiver Jahreszins",
	add: "Hinzufügen",
	pending: "Hinzufügen von {{ balance }} {{ symbol }}"
};
var sarUnstake$7 = {
	unstake: "Abstand",
	unstaking: "Abstecken {{ balance }} {{ symbol }}",
	stakedBalance: "Abgesteckt {{ balance }} {{ symbol }}",
	confirmDescription: "Es lohnt sich zu wissen, dass das Abstecken Ihrer Belohnungen Ihren effektiven Jahreszins für diese Position auf 0% erhöht. \nAnstatt sich zu lösen, können Sie auch in Betracht ziehen, Ihren NFT zu verkaufen.",
	successSubmit: "Sie haben Ihre Token erfolgreich abgesetzt.",
	pending: "Abstecken {{ balance }} {{ symbol }}",
	transactionSummary: "Nicht abgesteckt {{ balance }} {{ symbol }}",
	currentAPR: "Aktueller effektiver Jahreszins",
	unstakeWarning: "Wenn Sie den Einsatz aufheben, sinkt Ihr durchschnittlicher effektiver Jahreszins auf 0%.",
	aprAfter: "effektiver Jahreszins nach dem Einsatz"
};
var sarCompound$7 = {
	compound: "Verbindung",
	compounding: "Aufzinsung",
	successSubmit: "Sie haben Ihre Position erfolgreich gefestigt.",
	pending: "Aufzinsung",
	transactionSummary: "Zusammengesetzte Position",
	aprAfter: "APR nach Aufzinsung",
	reward: "Gesammelte Prämien",
	description: "Bitte beachten Sie, dass die Aufzinsung Ihrer Prämien Ihren durchschnittlichen effektiven Jahreszins verringern kann. Neu abgesteckte Token beginnen bei 0, während die alten Token mit dem gleichen effektiven Jahreszins weiterlaufen. Dadurch entsteht der Durchschnitt, der Ihnen angezeigt wird.",
	noRewards: "Keine Belohnungen zum Komponieren"
};
var sarClaim$7 = {
	claim: "Anspruch",
	claiming: "Fordernd",
	description: "Aufgrund der Natur des SAR-Einsatzsystems, das behauptet, dass Ihre Belohnungen Ihren effektiven Jahreszins auf 0 senken. Sie können stattdessen Ihre Belohnungen zusammensetzen, ohne Ihren effektiven Jahreszins zu verlieren.",
	successSubmit: "Sie haben Ihre Prämien erfolgreich beansprucht",
	pending: "Fordernd",
	transactionSummary: "Beanspruchte Positionsprämien",
	aprAfter: "effektiver Jahreszins nach der Reklamation",
	noRewards: "Keine Prämien zu beanspruchen"
};
var sarPortfolio$7 = {
	noPositions: "Sie haben kein PANGUARDIAN NFT.\nLASS UNS DIR EINEN BESORGEN",
	start: "ANFANGEN",
	positionId: "Positions-ID",
	apr: "APR",
	amount: "Menge",
	newest: "Neuest",
	oldest: "Älteste",
	sortBy: "Sortieren nach"
};
var pangoChef$7 = {
	claimWarning1: "Wenn Sie einen Anspruch geltend machen, ohne abzuheben, bleibt Ihre Liquidität im Mining-Pool.",
	claimWarning2: "Wenn Sie Ihre Prämien beanspruchen, sinkt Ihr effektiver Jahreszins auf 0. Stattdessen können Sie sich für eine Aufzinsung entscheiden.",
	compoundWarning: "Wenn Sie Ihre Belohnungen für die {{ token0 }}-{{ token1 }}-Farm zusammensetzen, werden Ihre Belohnungen in die {{ currency }}-{{ png }} farm eingesetzt. Sie müssen den gleichen Wert von {{ currency }}Token für Ihre angesammelten {{ png }} Prämien.",
	compoundAmountWarning: "Sie müssen {{ amount }} {{ symbol }} zur Verbindung hinzufügen.",
	compoundAmountWarning2: "Zum Zusammensetzen. Seien Sie vorsichtig, dass Sie Ihren {{ symbol }} {{ png }} pool sperren, bis Sie die Belohnungen dieses Pools beanspruchen.",
	highVolalityWarning: "Zu früh, versuchen Sie es in ein paar Stunden",
	compoundSuccess: "Sie haben Ihre Farm erfolgreich zusammengestellt.",
	compoundTransactionSummary: "Zusammengesetzte Farm.",
	removeWarning: "Wenn Sie einen beliebigen Betrag von der Farm entfernen, wird Ihr effektiver Jahreszins auf 0 gesetzt. Sie können stattdessen Ihre Belohnungen aufstocken, ohne Ihren effektiven Jahreszins zu verlieren.",
	lockingPoolZeroWarning: "Sie können Ihre Liquidität nicht entfernen oder Ihre Belohnungen von dieser Farm einfordern. Dazu müssen Sie zuerst entweder Ihren Anteil von diesen Farmen beanspruchen: "
};
var bridge$7 = {
	availableRoutes: "Available Routes ({{ number }})",
	activeTransfers: "Active Transfers ({{ number }})",
	historicalTransfers: "Historical Transfers ({{ number }})",
	bridgeCard: {
		advanceOptions: "Advance Options",
		title: "Cross Chain",
		swap: "Swap",
		loader: {
			labels: {
				waitingReceivingChain: "Waiting for receiving chain..."
			},
			bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
		},
		filter: {
			bridgePrioritization: "Bridge Prioritization",
			slippage: "Slippage",
			infiniteApproval: "Infinite Approval",
			activeInfiniteApproval: "Active Infinite Approval",
			bridges: "Bridges",
			exchanges: "Exchanges"
		}
	},
	bridgeInputsWidget: {
		tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
		max: "MAX"
	},
	bridgeRoute: {
		selected: "Selected",
		clickToSelect: "Click to select",
		singleTransaction: "Single transaction including",
		estimatedToken: "Estimated Token: {{ token }}",
		estimatedResult: "Estimated Result: {{ result }}",
		min: "{{ minute }} min",
		gasCost: "{{ gasCost }} Gas Cost"
	},
	bridgeTransfer: {
		date: "Date",
		from: "From",
		to: "To",
		via: "Via",
		state: "State",
		resumeSwap: "Resume Swap"
	},
	bridgePrioritizations: {
		recommended: "Recommended",
		fast: "Fast",
		normal: "Normal"
	}
};
var dropdown$7 = {
	select: "Select"
};
var deTranslation = {
	header: header$7,
	accountDetails: accountDetails$7,
	addressInputPanel: addressInputPanel$7,
	currencyInputPanel: currencyInputPanel$7,
	earn: earn$7,
	menu: menu$7,
	modalView: modalView$7,
	navigationTabs: navigationTabs$7,
	popups: popups$7,
	positionCard: positionCard$7,
	searchModal: searchModal$7,
	settings: settings$7,
	swap: swap$7,
	toggle: toggle$7,
	tokenWarningModal: tokenWarningModal$7,
	transactionConfirmation: transactionConfirmation$7,
	transactionSettings: transactionSettings$7,
	vote: vote$7,
	walletModal: walletModal$7,
	web3ReactManager: web3ReactManager$7,
	web3Status: web3Status$7,
	gasFeeAlert: gasFeeAlert$7,
	addLiquidity: addLiquidity$7,
	airdrop: airdrop$7,
	earnPage: earnPage$7,
	pool: pool$7,
	poolFinder: poolFinder$7,
	removeLiquidity: removeLiquidity$7,
	swapPage: swapPage$7,
	buyPage: buyPage$7,
	votePage: votePage$7,
	IDOPage: IDOPage$7,
	swapHooks: swapHooks$7,
	mintHooks: mintHooks$7,
	stakeHooks: stakeHooks$7,
	burnHooks: burnHooks$7,
	migratePage: migratePage$7,
	dashboardPage: dashboardPage$7,
	stakePage: stakePage$7,
	error: error$7,
	sarTitle: sarTitle$7,
	sarStake: sarStake$7,
	sarStakeMore: sarStakeMore$7,
	sarUnstake: sarUnstake$7,
	sarCompound: sarCompound$7,
	sarClaim: sarClaim$7,
	sarPortfolio: sarPortfolio$7,
	pangoChef: pangoChef$7,
	bridge: bridge$7,
	dropdown: dropdown$7
};

var header$6 = {
	dashboard: "Dashboard",
	swap: "Swap",
	buy: "Buy",
	pool: "Pool",
	farm: "Farm",
	version1: "Version 1",
	version2: "Version 2",
	stake: "Stake",
	newPng: "New {{ pngSymbol }}",
	oldPng: "Old {{ pngSymbol }}",
	vote: "Vote",
	ido: "IDO",
	charts: "Charts",
	forum: "Forum",
	pngBreakDown: "Your {{ symbol }} Breakdown",
	balance: "Balance: ",
	unclaimed: "Unclaimed: ",
	pngPrice: "{{ symbol }} price:",
	pngCirculation: "{{ symbol }} in circulation:",
	totalSupply: "Total Supply",
	makeSureURLWarning: "Make sure the URL is",
	alwaysMakeSureWarning: "Always make sure the URL is",
	bookmarkIt: "bookmark it to be safe.",
	addMetamask: "Add {{ symbol }} to MetaMask",
	bridge: "Bridge",
	ourPartners: "Our Partners",
	usefulLinks: "USEFUL LINKS",
	comeAndJoinUs: "Come & Join Us",
	tryOurNewBetaSite: "Try our new beta site",
	returnToLegacySite: "Return to legacy site",
	switchToNewUI: "Switch to beta UI"
};
var accountDetails$6 = {
	connectedWith: "Connected with ",
	account: "Account",
	disconnect: "Disconnect",
	change: "Change",
	copy: "Copy Address",
	viewExplorer: "View on explorer",
	clearAll: "(clear all)",
	transactionAppear: "Your transactions will appear here...",
	recentTransactions: "Recent Transactions",
	copied: "Copied"
};
var addressInputPanel$6 = {
	recipient: "Recipient",
	viewExplorer: "(View on explorer)",
	walletAddress: "Wallet Address"
};
var currencyInputPanel$6 = {
	selectToken: "Select a token",
	balance: "Balance: ",
	max: "MAX",
	to: "To"
};
var earn$6 = {
	claimAccumulated: "Claim accumulated {{ symbol }} rewards",
	connectWallet: "Connect Wallet",
	enterAmount: "Enter an amount",
	unclaimedReward: "Unclaimed {{ symbol }}",
	claim: "Claim",
	claimReward: "Claim {{ symbol }}",
	liquidityRemainsPool: "When you claim without withdrawing your liquidity remains in the mining pool.",
	withdrawingLiquidity: "Withdrawing {{ amount }} {{ symbol }}",
	claimingReward: "Claiming {{ amount }} {{ symbol }}",
	claimedReward: "Claimed {{ symbol }}!",
	manage: "Manage",
	deposit: "Deposit",
	poolRate: "Pool rate",
	currentReward: "Current reward",
	pngPerAvax: "{{ pngSymbol }} / Week per AVAX",
	rewardPerWeek: "{{ symbol }} / Week",
	earnUpTo: "Earn up to (yearly)",
	yourRate: "Your rate",
	totalDeposited: "Total deposited",
	totalStaked: "Total staked",
	depositLiquidity: "Deposit liquidity",
	attemptingToStakeError: "Attempting to stake without approval or a signature. Please contact support.",
	transactionSubmitted: "Transaction Submitted",
	depositingLiquidity: "Depositing Liquidity",
	depositingToken: "Depositing {{ symbol }}",
	depositedToken: "Deposited {{ symbol }}",
	availableToDeposit: "Available to deposit: ",
	weeklyRewards: "Weekly Rewards",
	missingLiquidityAmount: "missing liquidity amount",
	missingDependencies: "missing dependencies",
	deposited: "Deposited",
	withdrawDepositedLiquidity: "Withdraw deposited liquidity",
	depositedPglLiquidity: "Deposited ARL liquidity:",
	whenYouWithdrawWarning: "When you withdraw, your {{ symbol }} is claimed and your Arcanum Liquidity tokens, ARL, are returned to you. You will no longer earn {{ symbol }} rewards on this liquidity. Your original token liquidity will remain in its liquidity pool.",
	whenYouWithdrawSingleSideWarning: "When you withdraw, your {{ symbol }} is claimed and your {{ pngSymbol}} is returned to you. You will no longer earn {{ symbol }} rewards on this {{ pngSymbol}}.",
	withdrawAndClaim: "Withdraw & Claim",
	withdrewStakingToken: "Withdrew {{ symbol }}!",
	approve: "Approve",
	poolWeight: "Pool Weight",
	withdraw: "Withdraw",
	extraReward: "Extra Reward",
	poolRewards: "Pool Rewards",
	rewardsIn: "Rewards in",
	removeWarning: "You are removing liquidity from this pool. This action will give you back your tokens. Alternatively you can choose to stake your tokens to farm to earn rewards."
};
var menu$6 = {
	code: "Code",
	twitter: "Twitter",
	discord: "Discord",
	telegram: "Telegram",
	tutorials: "Tutorials",
	idos: "IDOs",
	about: "About"
};
var modalView$6 = {
	confirmTransaction: "Confirm this transaction in your wallet",
	viewTransaction: "View transaction on the Explorer"
};
var navigationTabs$6 = {
	useThisTool: "Use this tool to find pairs that don't automatically appear in the interface.",
	swap: "Swap",
	pool: "Pool",
	importPool: "Import Pool",
	createPair: "Create a pair",
	addLiquidity: "Add Liquidity",
	removeLiquidity: "Remove Liquidity",
	whenYouAddLiquidityInfo: "When you add liquidity, you are given pool tokens representing your position. These tokens automatically earn fees proportional to your share of the pool, and can be redeemed at any time.",
	removingPoolTokensInfo: "Removing pool tokens converts your position back into underlying tokens at the current rate, proportional to your share of the pool. Accrued fees are included in the amounts you receive."
};
var popups$6 = {
	tokenListUpdated: "The token list \" {{oldList}} \" has been updated to ",
	updateAvailable: "An update is available for the token list \" {{oldList}} \"",
	viewExplorer: "View on explorer",
	hash: "Hash: ",
	added: "added",
	removed: "removed",
	tokensUpdated: "tokens updated",
	acceptUpdate: "Accept update",
	dismiss: "Dismiss"
};
var positionCard$6 = {
	add: "Add",
	remove: "Remove",
	poolShare: "Your pool share:",
	pooled: "Pooled",
	poolTokens: "Your pool tokens",
	manage: "Manage",
	loading: "Loading",
	yourPosition: "Your position",
	byAddingLiquidityInfo: "By adding liquidity you'll earn 0.25% of all trades on this pair proportional to your share of the pool.\n Fees are added to the pool, accrue in real time and can be claimed by withdrawing your liquidity."
};
var searchModal$6 = {
	commonBases: "Common bases",
	tokensPairsHelper: "These tokens are commonly paired with other tokens.",
	addedByUser: "Added by user",
	foundByAddress: "Found by address",
	remove: "remove",
	add: "Add",
	findToken: "Find a token by searching for its name or symbol or by pasting its address below.",
	selectToken: "Select a token",
	tokenSearchPlaceholder: "Search name or paste address",
	tokenName: "Token Name",
	change: "Change",
	selectList: "Select a list",
	confirmListRemovalPrompt: "Please confirm you would like to remove this list by typing REMOVE",
	addList: "Add a List ",
	tokenListHelper: "Token lists are an open specification for lists of ERC20 tokens. You can use any token list by entering its URL below. Beware that third party token lists can contain fake or malicious ERC20 tokens.",
	httpsPlaceholder: "https:// or ipfs://",
	manageLists: "Manage Lists",
	viewList: "View list",
	updateList: "Update list",
	removeList: "Remove list",
	selected: "Selected",
	select: "Select",
	manageTokenLists: "Manage Token Lists"
};
var settings$6 = {
	areYouSure: "Are you sure?",
	expertInfo: "Expert mode turns off the confirm transaction prompt and allows high slippage trades that often result in bad rates and lost funds.",
	expertWarningCAPS: "ONLY USE THIS MODE IF YOU KNOW WHAT YOU ARE DOING.",
	confirm: "confirm",
	confirmExpertMode: "Please type the word \"confirm\" to enable expert mode.",
	turnOnExpertMode: "Turn On Expert Mode",
	transactionSettings: "Transaction Settings",
	interfaceSettings: "Interface Settings",
	toggleExpertMode: "Toggle Expert Mode",
	expertModeHelper: "Bypasses confirmation modals and allows high slippage trades. Use at your own risk.",
	toggleDarkMode: "Toggle Dark Mode",
	slippage: "Slippage",
	percent: "Percent"
};
var swap$6 = {
	priceImpact: "Price Impact",
	priceImpactHelper: "The difference between the market price and estimated price due to trade size.",
	liquidityProviderFee: "Liquidity Provider Fee",
	liquidityProviderHelper: "A portion of each trade (0.30%) goes to liquidity providers as a protocol incentive.",
	route: "Route",
	routingHelper: "Routing through these tokens resulted in the best price for your trade.",
	confirmSwap: "Confirm Swap",
	swapAnyway: "Swap Anyway",
	confirm: "confirm",
	price: "Price",
	accept: "Accept",
	minimumReceived: "Minimum Received",
	maximumSold: "Maximum Sold",
	transactionRevertHelper: "Your transaction will revert if there is a large, unfavorable price movement before it is confirmed.",
	priceUpdated: "Price Updated",
	outputEstimated: "Output is estimated. You will receive at least <strong>{{amount}} {{currencySymbol}}</strong> or the transaction will revert.",
	inputEstimated: "Input is estimated. You will sell at most <strong>{{amount}} {{currencySymbol}}</strong> or the transaction will revert.",
	outputSentTo: "Output will be sent to ",
	priceImpactMinPrompt: "This swap has a price impact of at least {{ priceImpact }}%. Please type the word \"confirm\" to continue with this swap.",
	priceImpactHighPrompt: "This swap has a price impact of at least {{ priceImpact }}%. Please confirm that you would like to continue with this swap."
};
var toggle$6 = {
	on: "On",
	off: "Off"
};
var tokenWarningModal$6 = {
	tokenImported: "Token imported",
	anyoneCanCreateWarning: "Anyone can create an ERC-20 token on Avalanche with <em>any</em> name, including creating fake versions of existing tokens and tokens that claim to represent projects that do not have a token.",
	loadArbitraryWarning: "This interface can load arbitrary tokens by token addresses. Please take extra caution and do your research when interacting with arbitrary ERC-20 tokens.",
	purchaseArbitraryWarning: "If you purchase an arbitrary token, <strong>you may be unable to sell it back.</strong>",
	understand: "I understand",
	"continue": "Continue",
	viewExplorer: "View on explorer"
};
var transactionConfirmation$6 = {
	waitingConfirmation: "Waiting For Confirmation",
	confirmTransaction: "Confirm this transaction in your wallet",
	transactionSubmitted: "Transaction Submitted",
	viewExplorer: "View on explorer",
	close: "Close",
	error: "Error",
	dismiss: "Dismiss",
	addToFarm: "Add to Farm"
};
var transactionSettings$6 = {
	slippageTolerance: "Slippage tolerance",
	transactionRevertSlippageHelper: "Your transaction will revert if the price changes unfavorably by more than this percentage.",
	transactionDeadline: "Transaction deadline",
	transactionRevertDeadlineHelper: "Your transaction will revert if it is pending for more than this long.",
	enterValidSlippage: "Enter a valid slippage percentage",
	transactionMayFail: "Your transaction may fail",
	transactionMayFrontrun: "Your transaction may be frontrun",
	transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
	minutes: "minutes"
};
var vote$6 = {
	earnedPng: "Earned {{ pngSymbol }} tokens represent voting shares in Arcanum governance.",
	canEitherVote: "You can either vote on each proposal yourself or delegate your votes to a third party.",
	delegateVotes: "Delegate Votes",
	selfDelegate: "Self Delegate",
	remove: "Remove",
	add: "Add",
	delegate: "Delegate",
	delegatingVotes: "Delegating votes",
	unlockingVotes: "Unlocking Votes",
	transactionSubmitted: "Transaction Submitted",
	"for": "for",
	against: "against",
	vote: "Vote",
	proposal: "proposal",
	votes: "Votes",
	submittingVote: "Submitting Vote",
	confirmTransaction: "Confirm this transaction in your wallet",
	viewExplorer: "View on explorer"
};
var walletModal$6 = {
	wrongNetwork: "Wrong Network",
	errorConnecting: "Error connecting",
	pleaseConnectAvalanche: "Please connect to the appropriate Avalanche network.",
	switchAvalanche: "Switch to Avalanche Chain",
	errorConnectingRefresh: "Error connecting. Try refreshing the page.",
	connectToWallet: "Connect to a wallet",
	newToAvalanche: "New to Avalanche? ",
	learnMoreWallet: "Learn more about setting up a wallet",
	initializing: "Initializing...",
	tryAgain: "Try Again"
};
var web3ReactManager$6 = {
	unknownError: "Oops! An unknown error occurred. Please refresh the page, or visit from another browser or device."
};
var web3Status$6 = {
	pending: "Pending",
	wrongNetwork: "Wrong Network",
	error: "Error",
	connectToWallet: "Connect to a wallet"
};
var gasFeeAlert$6 = {
	gasFeeReduction: "!!! Gas Fee Reduction !!!",
	transactionsNotAccept: "Transactions will not be accepted unless the gas fee is set to {{ gasPrice }} gwei."
};
var addLiquidity$6 = {
	deposited: "Deposited",
	shareOfPool: "Share of Pool",
	createPoolSupply: "Create Pool & Supply",
	confirmSupply: "Confirm Supply",
	giveOrder: "GIVE ORDER",
	outputEstimated: "Output is estimated. If the price changes by more than {{ allowedSlippage }}% your transaction will revert.",
	creatingPool: "You are creating a pool",
	willReceive: "You will receive",
	firstLP: "You are the first liquidity provider.",
	ratioTokens: "The ratio of tokens you add will set the price of this pool.",
	happyRate: "Once you are happy with the rate click supply to review.",
	initialPrices: "Initial Prices",
	prices: "Prices",
	poolShare: "and pool share",
	connectWallet: "Connect Wallet",
	approve: "Approve ",
	supply: "Supply",
	per: " per ",
	rates: "Rates",
	poolTokens: " Pool Tokens"
};
var airdrop$6 = {
	claimPngAirdrop: "Claim {{ pngSymbol }} from Airdrop",
	claimPeriodEnded: "The airdrop claim period has ended.",
	connectWalletViewLiquidity: "Connect to a wallet to view your liquidity.",
	noAvailableClaim: "You have no {{ pngSymbol }} available claim.",
	noUniNoSushi: "You have no UNI or SUSHI tokens. Please follow the tutorial here to add UNI or SUSHI tokens to your wallet.",
	youHave: "You have ",
	pngAvailableClaim: " {{ pngSymbol }} available to claim",
	loading: "Loading",
	welcomeToTeamPangolin: "Welcome to team Arcanum",
	claim: "Claim "
};
var earnPage$6 = {
	pangolinLiquidityMining: "Arcanum Liquidity mining",
	pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
	depositPangolinLiquidity: "Deposit your Arcanum Liquidity Provider ARL tokens to receive {{ pngSymbol }}, the Arcanum protocol governance token.",
	depositPangolinStaking: "Deposit and stake your {{ pngSymbol }} tokens to earn more tokens.",
	currentOpportunities: "Current opportunities",
	readMoreAboutPng: "Read more about {{ pngSymbol }}",
	getInsuranceCoverage: "Get cover on InsurAce.io",
	getCoverNexusMutual: "Get cover on Nexus Mutual",
	importantUpdate: "IMPORTANT UPDATE",
	pangolinGovernanceProposalResult: "As a result of Arcanum governance proposal 1, Arcanum is changing staking contracts! After approximately 08:59 UTC on 4/19, all staking rewards will be distributed to the new staking contracts. Before the switch, all rewards will still be distributed to the old contracts. To avoid interruptions to yield farming rewards, you need to unstake your liquidity from the old contracts and restake in the new contracts. You do not need to remove liquidity from your pools or alter your positions.",
	oldPngPools: "Old {{ pngSymbol }} pools",
	newPngPools: "New {{ pngSymbol }} pools",
	participatingPools: "Participating pools",
	rewardsNeverEnd: "The Rewards Never End!",
	noActiveRewards: "No active rewards",
	liquidityMining: "Liquidity Mining",
	pngStaking: "{{ pngSymbol }} Staking",
	totalStaked: "Total Staked",
	poolRate: "Pool Rate",
	step1: "Step 1. Get Arcanum Liquidity tokens (ARL)",
	pglTokenRequired: "ARL tokens are required. Once you've added liquidity to the {{ poolHandle }} pool you can stake your liquidity tokens on this page.",
	addPoolLiquidity: "Add {{ poolHandle }} liquidity",
	liquidityDeposits: "Your liquidity deposits",
	yourStakedToken: "Your staked {{ symbol }}",
	unclaimedReward: "Your unclaimed {{ symbol }}",
	claim: "Claim",
	rewardPerWeek: " {{ symbol }} / week",
	automagically: "When you withdraw, the contract will automagically claim {{ pngSymbol }} on your behalf!",
	deposit: "Deposit",
	depositStakingTokens: "Deposit {{ symbol }} Tokens",
	stake: "Stake",
	stakeStakingTokens: "Stake {{ symbol }} Tokens",
	unstake: "Unstake",
	stakingTokensAvailable: "{{ symbol }} tokens available",
	getToken: "Get {{ symbol }}",
	migrateTitle: "Migrate your staked ARL",
	migrateDescription: "Arcanum has changed tokonomics. You will need to migrate your staked ARL to new contract",
	migrate: "Migrate"
};
var pool$6 = {
	liquidityProviderRewards: "Liquidity provider rewards",
	liquidityProvidersEarn: "Liquidity providers earn a 0.25% fee on all trades proportional to their share of the pool. Fees are added to the pool, accrue in real time and can be claimed by withdrawing your liquidity.",
	readMoreProviding: "Read more about providing liquidity",
	viewStakedLiquidity: "View your staked liquidity",
	yourLiquidity: "Your liquidity",
	createPair: "Create a pair",
	addLiquidity: "Add liquidity",
	connectWalletToView: "Connect to a wallet to view your liquidity.",
	loading: "Loading",
	noLiquidity: "No liquidity found.",
	uniswapV1Found: "Uniswap V1 liquidity found!",
	noSeePoolJoined: "Don't see a pool you joined?",
	migrateNow: "Migrate now.",
	importIt: "Import it.",
	seeDetails: "SEE DETAILS",
	totalLockedValue: "Total Locked Value",
	yourLockedValue: "Your Locked Value",
	allFarms: "All Farms",
	yourFarms: "Your Farms",
	yourPools: "Your Pools",
	noFarms: "No farms found.",
	successWithdraw: "Your liquidity removed from farm, And accrued rewards claimed!"
};
var poolFinder$6 = {
	connectToFind: "Connect to a wallet to find pools",
	selectTokenToFind: "Select a token to find your liquidity.",
	selectToken: "Select a Token",
	poolFound: "Pool Found!",
	managePool: "Manage this pool.",
	noLiquidityYet: "You don't have liquidity in this pool yet.",
	noPoolFound: "No pool found.",
	addLiquidity: "Add liquidity",
	createPool: "Create pool.",
	invalidPair: "Invalid pair.",
	loading: "Loading"
};
var removeLiquidity$6 = {
	youWillReceive: "You will receive",
	simple: "Simple",
	detailed: "Detailed",
	receiveAvax: "Receive {{ symbol }}",
	receiveWavax: "Receive {{ symbol }}",
	price: "Price:",
	connectWallet: "Connect Wallet",
	approving: "Approving",
	approve: "Approve",
	approved: "Approved",
	remove: "Remove",
	output: "Output",
	amount: "Amount"
};
var swapPage$6 = {
	addSend: "+ Add a send (optional)",
	toEstimated: "To (estimated)",
	to: "To",
	removeSend: "- Remove send",
	price: "Price",
	slippageTolerance: "Slippage Tolerance",
	connectWallet: "Connect Wallet",
	insufficientLiquidity: "Insufficient liquidity for this trade.",
	wrap: "Wrap",
	unwrap: "Unwrap",
	approving: "Approving",
	approve: "Approve ",
	approved: "Approved",
	priceImpactHigh: "Price Impact High",
	swap: "Swap",
	anyway: " Anyway",
	from: "From",
	fromEstimated: "From (estimated)",
	velox: "Set a limit order on <1>Velox</1>",
	marginSwap: "Trade with leverage on <1>MarginSwap</1>",
	wowSwap: " or <1>WOWswap</1>",
	veeFinance: " or <1>Vee Finance</1>",
	gelatoFee: "Gelato Fee",
	placeOrder: "Place Order",
	confirmOrder: "Confirm Order",
	"for": "for",
	submittingOrderToSwap: "Submitting order to swap",
	limitPrice: "Limit Price",
	outputWillBeSentTo: "Output will be sent to",
	sell: "SELL",
	buy: "BUY",
	betaRelease: "This is a BETA release and should be used at your own risk!",
	trade: "Trade",
	watchList: "WatchList",
	yourPortFolio: "Your Portfolio",
	comingSoon: "Coming Soon",
	connectWalletViewPortFolio: "Connect to a wallet to check your portfolio.",
	limitOrders: "Limit Orders",
	cancelOrder: "Cancel Order",
	all: "ALL",
	open: "OPEN",
	executed: "EXECUTED",
	cancelled: "CANCELLED",
	inputAmount: "Input Amount",
	outputAmount: "Output Amount",
	status: "Status",
	noLimitOrder: "No {{ orderType }} Order",
	cancellingOrder: "Cancelling order...",
	cancelLimitOrder: "Buy {{ outputCurrency }} with {{ inputCurrency }}",
	executionPrice: "Execution Price",
	seeMore: "See More",
	seeLess: "See Less"
};
var buyPage$6 = {
	buyAvaxInfo: "Buy AVAX with fiat from our partner Wyre.",
	privacyInfo: "Arcanum does not store your purchase history or any personal data.",
	firstName: "First Name",
	lastName: "Last Name",
	email: "Email",
	buyAvax: "Buy AVAX"
};
var votePage$6 = {
	unlockVotes: "Unlock Votes",
	updateDelegation: "Update Delegation",
	pangolinGovernance: "Arcanum Governance",
	earnedPngTokens: "{{ pngSymbol }} tokens represent voting shares in Arcanum governance. You can vote on each proposal yourself or delegate your votes to a third party.",
	eligibleToVote: "To be eligible to vote, you must hold {{ pngSymbol }} in your wallet and delegate it at the start of voting. After voting has begun, you may pool or spend your {{ pngSymbol }}.",
	governanceVotes: "Governance votes are decided by simple majority. There is no quorum threshold.",
	proposals: "Proposals",
	allProposals: "All Proposals",
	backToProposals: "Back to Proposals",
	unlockVoting: "Unlock voting",
	votes: " Votes",
	delegatedTo: "Delegated to:",
	edit: "edit",
	noProposalsFound: "No proposals found.",
	proposalCommunityMembers: "Proposals submitted by community members will appear here.",
	minimumThreshold: "A minimum threshold of 1,000,000 {{ pngSymbol }} is required to submit proposals",
	votingStarted: "Voting started ",
	votingStarts: "Voting starts ",
	votingEnded: "Voting ended ",
	votingEnds: "Voting ends ",
	voteFor: "Vote For",
	voteAgainst: "Vote Against",
	against: "Against",
	"for": "For",
	details: "Details",
	overview: "Overview",
	proposer: "Proposer",
	about: "About",
	vote: "Vote",
	executed: "Executed",
	rejected: "Rejected",
	notSupported: "Not supported on this chain"
};
var IDOPage$6 = {
	pangolinIDOs: "Initial DEX Offering (IDO)",
	pangolinIDODescription: "Initial DEX Offerings (IDO) allows projects to crowdfund their native tokens on decentralized exchanges. We've partnered with amazing teams to bring great projects to the Avalanche community.",
	upcomingIDOs: "Upcoming",
	endedIDOs: "Ended",
	allIDOs: "All IDOs",
	noIDOsFound: "No IDOs found",
	IDOAnnounced: "IDOs publicly announced will appear here."
};
var swapHooks$6 = {
	connectWallet: "Connect Wallet",
	enterAmount: "Enter an amount",
	selectToken: "Select a token",
	enterRecipient: "Enter a recipient",
	invalidRecipient: "Invalid recipient",
	insufficient: "Insufficient ",
	balance: " balance"
};
var mintHooks$6 = {
	connectWallet: "Connect Wallet",
	insufficientInputAmount: "Insufficient input amount",
	invalidPair: "Invalid pair",
	enterAmount: "Enter an amount",
	insufficient: "Insufficient ",
	balance: " balance"
};
var stakeHooks$6 = {
	connectWallet: "Connect Wallet",
	enterAmount: "Enter an amount",
	insufficientBalance: "Insufficient {{ symbol }} balance"
};
var burnHooks$6 = {
	connectWallet: "Connect Wallet",
	enterAmount: "Enter an amount"
};
var migratePage$6 = {
	stake: "STAKE",
	unstake: "UNSTAKE",
	add: "ADD",
	remove: "REMOVE",
	startMigratingNow: "START MIGRATING NOW",
	startMigratingNowDescription: "Below you will find all the Farms you will need to migrate to Arcanum's V2 Contracts",
	seeMore: "SEE MORE",
	migrateWithEase: "MIGRATE WITH EASE",
	migrateWithDescription: "We have designed an elegant wizard, which will help guide you through the process of migrating your Farms",
	alreadyMigrate: "already migrated",
	walletMigrate: "wallet migrated",
	alreadyEarned: "already earned",
	migrateNow: "MIGRATE NOW",
	learn: "LEARN",
	moveYourTokensToNewContracts: "Migrate your Farms to Arcanum V2",
	readyToMigrate: "Ready to migrate",
	apr: "APR:",
	totalValueLocked: "Total Value Locked",
	lowVolatility: "Low Volatility",
	compoundable: "Compoundable",
	migrate: "Migrate",
	migrationModalDescription: "Select the pools you wish to migrate",
	choosePool: "Choose Pool",
	pool: "Pool",
	availableToDeposit: "Available to deposit: ",
	poolInfoDescription: "Select the amount you wish to migrate",
	dollarWorth: "Dollar Worth: ",
	usd: "USD",
	yourRate: "Your rate: ",
	unclaimedPng: "Unclaimed {{ pngSymbol }}: ",
	shareOfPool: "Share of Pool: ",
	choose: "CHOOSE",
	selectAll: "Select all",
	loading: "Loading",
	back: "Back",
	availableToUnstake: "Available to unstake: ",
	submittingTransaction: "Submitting transaction",
	moveYourTokensToNewContractsDescription: "As part of Arcanum's roll out to new improved contracts, you will need to migrate your Farms. If you need any help or guidance, please click on the “Learn” button.",
	migrateModalHeading: "Migrate {{ current }} of {{ total }} Farms"
};
var dashboardPage$6 = {
	dashboard: "Dashboard",
	greetings: "Greetings kind guests! Let's ape in today…",
	portfolioValue: "Portfolio Value",
	earned: "Earned",
	coins: "Coins",
	followedWallets: "Followed Wallets",
	earned_dailyIncome: "Daily Income",
	earned_weeklyIncome: "Weekly Income",
	earned_totalEarned: "Total Earned",
	earned_claim: "Claim",
	earned_customizePools: "Customize Pools",
	followed_address: "Address",
	followed_worth: "Worth",
	followed_interact: "Interact"
};
var stakePage$6 = {
	totalStaked: "Total Staked",
	apr: "Annual Percentage Rate",
	seeDetails: "SEE DETAILS",
	stake: "STAKE",
	earn: "Earn {{symbol}}",
	stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$6 = {
	missingCurrencyAmounts: "Missing currency amounts",
	missingTokens: "Missing tokens",
	missingDependencies: "Missing dependencies",
	missingLiquidityAmount: "Missing liquidity amount",
	couldNotWrap: "Could not wrap",
	attemptingToConfirmApproval: "Attempting to confirm without approval or a signature. Please contact support."
};
var sarTitle$6 = {
	addMore: "STAKE",
	unstake: "UNSTAKE",
	compound: "COMPOUND REWARDS",
	claim: "CLAIM REWARDS",
	interactingID: "Interacting with ID: {{ id }}"
};
var sarStake$6 = {
	createNewPosition: "Create a new position",
	stake: "Stake",
	staking: "Staking",
	walletBalance: "In Wallet {{ balance }} {{ symbol }}",
	max: "MAX",
	dollarValue: "Dollar Value",
	buy: "Buy {{ symbol }}",
	averageAPR: "Average APR",
	startingApr: "Starting APR",
	weeklyDistributed: "Weekly {{ symbol }} Distributed",
	confirmDescription: "Staking creates a SAR NFT position. This NFT manages your {{ symbol }} tokens and APR. Your APR will change based on the length of stake.",
	successSubmit: "You've successfully staked.",
	yourAprRecalculated: "Your APR will be recalculated.",
	summary: "Summary",
	pending: "Staking {{ balance }} {{ symbol }}",
	transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore$6 = {
	stakeMore: "Stake More",
	choosePosition: "Choose a Position",
	confirmDescription: "This adds {{ symbol }} to your SAR NFT position. Your original balance continues from the same APR. The APR of your newly added tokens starts from 0% and changes based on the length of stake. Your NFT will show the average.",
	newAPR: "New APR",
	add: "Stake",
	pending: "Staking {{ balance }} {{ symbol }}"
};
var sarUnstake$6 = {
	unstake: "Unstake",
	unstaking: "Unstaking {{ balance }} {{ symbol }}",
	stakedBalance: "Staked {{ balance }} {{ symbol }}",
	confirmDescription: "You’re about to unstake your NFT position which restarts the APR of the remaining balance from 0%. Is that what you want to do?",
	successSubmit: "You've successfully unstaked your tokens.",
	pending: "Unstaking {{ balance }} {{ symbol }}",
	transactionSummary: "Unstaked {{ balance }} {{ symbol }}",
	currentAPR: "Current APR",
	unstakeWarning: "Unstaking restarts the APR of this position from 0%. Instead of unstaking, you can also sell your NFT position on a secondary market.",
	aprAfter: "APR After Unstake"
};
var sarCompound$6 = {
	compound: "Compound",
	compounding: "Compounding",
	successSubmit: "You have successfully compounded your position.",
	pending: "Compounding",
	transactionSummary: "Compounded position",
	aprAfter: "APR After Compounding",
	reward: "Rewards accrued",
	description: "Please be aware that compounding your rewards may decrease your average APR. Newly staked tokens start from 0, while the old tokens will continue with the same APR. This creates the average that is displayed to you.",
	noRewards: "No rewards to compound"
};
var sarClaim$6 = {
	claim: "Claim",
	claiming: "Claiming",
	description: "Claiming your rewards will restart the APR of your position from 0%. Instead of claiming, you can also compound your rewards.",
	successSubmit: "You have successfully claimed your rewards",
	pending: "Claiming",
	transactionSummary: "Claimed position rewards",
	aprAfter: "APR After Claim",
	noRewards: "No rewards to claim"
};
var sarPortfolio$6 = {
	noPositions: "You don't have a staking position NFT.\nLET'S GET YOU ONE!",
	start: "START",
	positionId: "Position ID",
	apr: "APR",
	amount: "Amount",
	newest: "Newest",
	oldest: "Oldest",
	sortBy: "Sort By"
};
var pangoChef$6 = {
	claimWarning1: "When you claim without withdrawing, your liquidity remains in the farm.",
	claimWarning2: "Claiming rewards restarts your APR from 0%. Instead you may choose to compound.",
	compoundWarning: "Compounding your rewards for {{ token0 }}-{{ token1 }} farm will get your rewards staked into {{ currency }}-{{ png }} farm. You need to add equal value of {{ currency }} token to your accrued {{ png }} rewards.",
	compoundAmountWarning: "You need to add {{ amount }} {{ symbol }} to compound.",
	compoundAmountWarning2: "Be careful that you will be locking your {{ symbol }} {{ png }} pool till you claim the rewards of this pool.",
	highVolalityWarning: "Too early, try in few hours",
	compoundSuccess: "You have successfully composed your farm.",
	compoundTransactionSummary: "Compounded farm",
	removeWarning: "Removing any amount from farm will get your APR to 0. You can instead compound your rewards without losing your APR.",
	lockingPoolZeroWarning: "You can’t remove your liquidity or claim your rewards from this farm. To do this you first need to either claim your stake from this farms: "
};
var bridge$6 = {
	availableRoutes: "Available Routes ({{ number }})",
	activeTransfers: "Active Transfers ({{ number }})",
	historicalTransfers: "Historical Transfers ({{ number }})",
	bridgeCard: {
		advanceOptions: "Advance Options",
		title: "Cross Chain",
		swap: "Swap",
		loader: {
			labels: {
				waitingReceivingChain: "Waiting for receiving chain..."
			},
			bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
		},
		filter: {
			bridgePrioritization: "Bridge Prioritization",
			slippage: "Slippage",
			infiniteApproval: "Infinite Approval",
			activeInfiniteApproval: "Active Infinite Approval",
			bridges: "Bridges",
			exchanges: "Exchanges"
		}
	},
	bridgeInputsWidget: {
		tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
		max: "MAX"
	},
	bridgeRoute: {
		selected: "Selected",
		clickToSelect: "Click to select",
		singleTransaction: "Single transaction including",
		estimatedToken: "Estimated Token: {{ token }}",
		estimatedResult: "Estimated Result: {{ result }}",
		min: "{{ minute }} min",
		gasCost: "{{ gasCost }} Gas Cost"
	},
	bridgeTransfer: {
		date: "Date",
		from: "From",
		to: "To",
		via: "Via",
		state: "State",
		resumeSwap: "Resume Swap"
	},
	bridgePrioritizations: {
		recommended: "Recommended",
		fast: "Fast",
		normal: "Normal"
	}
};
var dropdown$6 = {
	select: "Select"
};
var enTranslation = {
	header: header$6,
	accountDetails: accountDetails$6,
	addressInputPanel: addressInputPanel$6,
	currencyInputPanel: currencyInputPanel$6,
	earn: earn$6,
	menu: menu$6,
	modalView: modalView$6,
	navigationTabs: navigationTabs$6,
	popups: popups$6,
	positionCard: positionCard$6,
	searchModal: searchModal$6,
	settings: settings$6,
	swap: swap$6,
	toggle: toggle$6,
	tokenWarningModal: tokenWarningModal$6,
	transactionConfirmation: transactionConfirmation$6,
	transactionSettings: transactionSettings$6,
	vote: vote$6,
	walletModal: walletModal$6,
	web3ReactManager: web3ReactManager$6,
	web3Status: web3Status$6,
	gasFeeAlert: gasFeeAlert$6,
	addLiquidity: addLiquidity$6,
	airdrop: airdrop$6,
	earnPage: earnPage$6,
	pool: pool$6,
	poolFinder: poolFinder$6,
	removeLiquidity: removeLiquidity$6,
	swapPage: swapPage$6,
	buyPage: buyPage$6,
	votePage: votePage$6,
	IDOPage: IDOPage$6,
	swapHooks: swapHooks$6,
	mintHooks: mintHooks$6,
	stakeHooks: stakeHooks$6,
	burnHooks: burnHooks$6,
	migratePage: migratePage$6,
	dashboardPage: dashboardPage$6,
	stakePage: stakePage$6,
	error: error$6,
	sarTitle: sarTitle$6,
	sarStake: sarStake$6,
	sarStakeMore: sarStakeMore$6,
	sarUnstake: sarUnstake$6,
	sarCompound: sarCompound$6,
	sarClaim: sarClaim$6,
	sarPortfolio: sarPortfolio$6,
	pangoChef: pangoChef$6,
	bridge: bridge$6,
	dropdown: dropdown$6
};

var header$5 = {
	dashboard: "Dashboard",
	swap: "Intercambio",
	buy: "Comprar",
	pool: "Pool",
	farm: "Farm",
	version1: "Versión 1",
	version2: "Versión 2",
	stake: "Stake",
	newPng: "Nuevo {{ pngSymbol }}",
	oldPng: "Viejo {{ pngSymbol }}",
	vote: "Votar",
	ido: "IDO",
	charts: "Gráficas",
	forum: "Foro",
	pngBreakDown: "Desglose de tu {{ symbol }}",
	balance: "Balance: ",
	unclaimed: "Sin reclamar: ",
	pngPrice: "Precio {{ symbol }}:",
	pngCirculation: "{{ symbol }} en circulación:",
	totalSupply: "Suministro total",
	makeSureURLWarning: "Asegúrese de que el URL es",
	alwaysMakeSureWarning: "Asegúrese siempre de que la URL sea",
	bookmarkIt: "marcarla para estar seguro.",
	addMetamask: "Agregar {{ symbol }} a MetaMask",
	bridge: "Puente",
	ourPartners: "Nuestros compañeros",
	usefulLinks: "ENLACES ÚTILES",
	comeAndJoinUs: "Ven y únete a nosotras",
	tryOurNewBetaSite: "Prueba nuestro nuevo sitio beta",
	returnToLegacySite: "Regresar al sitio heredado",
	switchToNewUI: "Cambiar a la nueva IU"
};
var accountDetails$5 = {
	connectedWith: "Connectado con ",
	account: "Cuenta",
	disconnect: "Desconectar",
	change: "Cambiar",
	copy: "Copiar dirección",
	viewExplorer: "Ver en el explorador",
	clearAll: "(borrar todo)",
	transactionAppear: "Tus transacciones aparecerán aquí...",
	recentTransactions: "Transacciones recientes",
	copied: "Copiado"
};
var addressInputPanel$5 = {
	recipient: "Recipient",
	viewExplorer: "(Ver en el explorador)",
	walletAddress: "Dirección de la cartera"
};
var currencyInputPanel$5 = {
	selectToken: "Selecciona un token",
	balance: "Balance: ",
	max: "MAX",
	to: "A"
};
var earn$5 = {
	claimAccumulated: "Reclama las recompensas accumulatadas de {{ symbol }}",
	connectWallet: "Connectar cartera",
	enterAmount: "Introduce una cantidad",
	unclaimedReward: "{{ symbol }} sin reclamar",
	claim: "Reclamar",
	claimReward: "{{ symbol }} Reclamar",
	liquidityRemainsPool: "Cuando reclamas sin retirar, tu liquidez permanece en la pool de minería.",
	withdrawingLiquidity: "Retirar {{ amount }} {{ symbol }}",
	claimingReward: "Reclamando {{ amount }} {{ symbol }}",
	claimedReward: "{{ symbol }} reclamados!",
	manage: "Gestionar",
	deposit: "Depositar",
	poolRate: "Ratio de la pool",
	currentReward: "Recompensa actual",
	pngPerAvax: "{{ pngSymbol }} / Semana por AVAX",
	rewardPerWeek: "{{ symbol }} / Semana",
	earnUpTo: "Gana hasta (anualmente)",
	yourRate: "Tu ritmo",
	totalDeposited: "Total depositado",
	totalStaked: "Total depositado",
	depositLiquidity: "Depositar liquidez",
	attemptingToStakeError: "Attempting to stake without approval or a signature. Por favor contacta con el soporte.",
	transactionSubmitted: "Transacción Enviada",
	depositingLiquidity: "depositando Liquidez",
	depositingToken: "Depositing {{ symbol }}",
	depositedToken: "Deposited {{ symbol }}",
	availableToDeposit: "Disponible para depositar: ",
	weeklyRewards: "Recompensas semanales",
	missingLiquidityAmount: "falta liquidez",
	missingDependencies: "faltan dependencias",
	deposited: "Depositado",
	withdrawDepositedLiquidity: "Retirar liquidez depositada",
	depositedPglLiquidity: "Liquidez ARL depositados:",
	whenYouWithdrawWarning: "Cuando retiras, sus {{ symbol }} son reclamados y tus Arcanum Liquidity tokens, ARL, le son devueltos. Usted no ganará {{ symbol }} de recompensa por esta liquidez. Tu token original de liquidez permanecerá en su pool de liquidez.",
	whenYouWithdrawSingleSideWarning: "When you withdraw, your {{ symbol }} is claimed and your {{ pngSymbol }} is returned to you. You will no longer earn {{ symbol }} rewards on this {{ pngSymbol }}.",
	withdrawAndClaim: "Retirar y reclamar",
	withdrewStakingToken: "{{ symbol }} retirados!",
	approve: "Aprobar",
	poolWeight: "Peso de la piscina",
	withdraw: "Retirar",
	extraReward: "Recompensa adicional",
	poolRewards: "Recompensas de la piscina",
	rewardsIn: "Recompensas en",
	removeWarning: "Está eliminando liquidez de este grupo. Esta acción te devolverá tus tokens. Alternativamente, puede optar por apostar sus tokens en la granja para ganar recompensas."
};
var menu$5 = {
	code: "Código",
	twitter: "Twitter",
	discord: "Discord",
	telegram: "Telegram",
	tutorials: "Tutoriales",
	idos: "IDOs",
	about: "Acerca de"
};
var modalView$5 = {
	confirmTransaction: "Confirma esta transacción en tu cartera",
	viewTransaction: "Ver transacción en el Explorador"
};
var navigationTabs$5 = {
	useThisTool: "Usa esta herramienta para encontrar parejas que no aparecen automáticamente en la interfaz.",
	swap: "Intercambiar",
	pool: "Pool",
	importPool: "Importar Pool",
	createPair: "Crear una pareja",
	addLiquidity: "Añadir Liquidez",
	removeLiquidity: "Retirar Liquidez",
	whenYouAddLiquidityInfo: "Cuando añade liquidez, se le dan pool tokens que represenan su posición. Estos tokens recolectan las tasas automáticamente de forma proporcional a su parte total de la pool, y pueden ser reclamados en cualquier momento.",
	removingPoolTokensInfo: "Retirar pool tokens revierte su posición a los tokens subyacentes al ratio actual, proporcionalmente a su parte de la pool. Las tasas acumuladas se incluyen en las cantidades que recibe."
};
var popups$5 = {
	tokenListUpdated: "la lista de Tokens \" {{oldList}} \" se ha actualizado a ",
	updateAvailable: "Hay una actualización disponible para la lista de Tokens \" {{oldList}} \"",
	viewExplorer: "Ver en el explorador",
	hash: "Hash: ",
	added: "añadido",
	removed: "retirado",
	tokensUpdated: "tokens actualizados",
	acceptUpdate: "Aceptar actualización",
	dismiss: "Descartar"
};
var positionCard$5 = {
	add: "Añadir",
	remove: "Retirar",
	poolShare: "Tu parte de la pool:",
	pooled: "En la Pool",
	poolTokens: "Tus Pool tokens:",
	manage: "Gestionar",
	loading: "Cargando",
	yourPosition: "Tu posición",
	byAddingLiquidityInfo: "Añadiendo liquidez ganará el 0.25% de todos los intercambios en la pareja de forma proporcional a su parte de la Pool.\n Las tasas se añaden a la Pool, se acumulan en tiempo real y pueden ser reclamadas retirando su liquidez."
};
var searchModal$5 = {
	commonBases: "Bases comunes",
	tokensPairsHelper: "Estos tokens se emparejan comunmente con otros tokens.",
	addedByUser: "Añadido por el usuario",
	foundByAddress: "Encontrado por la dirección",
	remove: "borrar",
	add: "Añadir",
	findToken: "Encuentra un token buscándolo por su nombre, símbolo o pegando su dirección.",
	selectToken: "Selecciona un token",
	tokenSearchPlaceholder: "Busca un nombre o pega una dirección",
	tokenName: "Nombre del token",
	change: "Cambiar",
	selectList: "Selecciona una lista",
	confirmListRemovalPrompt: "Por favor, confirme que quiere borrar esta lista escribiendo: \"borrar\"",
	addList: "Añadir una Lista ",
	tokenListHelper: "Las listas de tokens son an especificaciones abiertas para listas de tokens ERC20. Puede usar cualquier lista introduciendo su URL. Tenga en cuenta que las listas de tokens de terceros pueden contener tokens ERC20 falsos o maliciosos.",
	httpsPlaceholder: "https:// o ipfs://",
	manageLists: "Gestionar listas",
	viewList: "Ver lista",
	updateList: "Actualizar lista",
	removeList: "Borrar lista",
	selected: "Seleccionado",
	select: "Seleccionar",
	manageTokenLists: "Administrar listas de tokens"
};
var settings$5 = {
	areYouSure: "Estas seguro?",
	expertInfo: "El modo experto deshabilita el aviso de confirmar transacción y permite altos deslizamientos en intercambios que suelen causar malos ratios y fondos perdidos.",
	expertWarningCAPS: "USA ESTE MODO SOLO SI SABES LO QUE ESTÁS HACIENDO.",
	confirm: "confirmar",
	confirmExpertMode: "Por favor introduce la palabra \"confirmar\" para habilitar el modo experto.",
	turnOnExpertMode: "Habilitar modo experto",
	transactionSettings: "Ajustes de transacción",
	interfaceSettings: "Ajustes de la interfaz",
	toggleExpertMode: "Avticar modo experto",
	expertModeHelper: "Sobrepasa los avisos de confirmación y permite intercambios con altos deslizamientos. Úselo bajo su propio riesgo.",
	toggleDarkMode: "Activar modo oscuro",
	slippage: "Slippage",
	percent: "Percent"
};
var swap$5 = {
	priceImpact: "Impacto en el precio",
	priceImpactHelper: "La diferencia entre el precio de merkado y el precio estimado debido al tamaño del intercambio.",
	liquidityProviderFee: "Tasa de proveedor de liquidez",
	liquidityProviderHelper: "Una parte de cada intercambio (0.30%) va a los proveedores de liquidez como un incentivo protocolario.",
	route: "Ruta",
	routingHelper: "Enrutando estos tokens produce el mejor precio para su intercambio.",
	confirmSwap: "Confirmar intercambio",
	swapAnyway: "Intercambiar de todos modos",
	confirm: "confirmar",
	price: "Precio",
	accept: "Aceptar",
	minimumReceived: "Mínimo recibido",
	maximumSold: "Máximo vendido",
	transactionRevertHelper: "Tu transacción se revertirá si hay un gran movimiento de precio desfavorable antes de ser confirmada..",
	priceUpdated: "Precio actualiazdo",
	outputEstimated: "El resultado es estimado. Recibirá por lo menos <strong>{{amount}} {{currencySymbol}}</strong> o la transacción se revertirá.",
	inputEstimated: "El resultado es estimado. Venderá como mucho <strong>{{amount}} {{currencySymbol}}</strong> o la transacción se revertirá.",
	outputSentTo: "La salida se mandará a ",
	priceImpactMinPrompt: "Este intercambio tiene un impacto en el precio de por lo menos {{ priceImpact }}%. Por favor, escriba la palabra \"confirmar\" para continuar con este intercambio.",
	priceImpactHighPrompt: "Este intercambio tiene un impacto en el precio de por lo menos {{ priceImpact }}%. Por favor, confirme que quiere continuar con este intercambio."
};
var toggle$5 = {
	on: "Encendido",
	off: "Apagado"
};
var tokenWarningModal$5 = {
	tokenImported: "Token importado",
	anyoneCanCreateWarning: "Cualquiera puede crear un token ERC-20 en Avalanche con <em>cualquier</em> nombre, incluso creaer versiones falsas de tokens ya existentes y tokens que dicen representar a proyectos que no tienen un token.",
	loadArbitraryWarning: "Esta interfaz puede cargar tokens arbitrariamente por su dirección. Por favor tenga suma precaución y haga su propiar investigación al interactuar con tokens ERC-20 de forma arbitraria.",
	purchaseArbitraryWarning: "Si compras un token arbitrario, <strong>puede que no pueda venderlo devuelta.</strong>",
	understand: "Lo entiendo",
	"continue": "Continuar",
	viewExplorer: "Ver en el explorador"
};
var transactionConfirmation$5 = {
	waitingConfirmation: "Esperando confirmación",
	confirmTransaction: "Confirme esta transacción en su cartera",
	transactionSubmitted: "Transacción enviada",
	viewExplorer: "Ver en el explorador",
	close: "Cerrar",
	error: "Error",
	dismiss: "Descartar",
	addToFarm: "Agregar a la Farm"
};
var transactionSettings$5 = {
	slippageTolerance: "Tolerancia del deslizamiento",
	transactionRevertSlippageHelper: "Su transacción se revertirá si el precio cambia desfavorablemente más de este porcentaje.",
	transactionDeadline: "Plazo de la transacción",
	transactionRevertDeadlineHelper: "Su transacción se revertirá si permanece pendiente por más de este plazo.",
	enterValidSlippage: "Introduce un porcentaje de deslizamieinto válido",
	transactionMayFail: "Tu transacción puede fallar",
	transactionMayFrontrun: "Tu transacción puede sufrir inversión ventajista",
	transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
	minutes: "minutos"
};
var vote$5 = {
	earnedPng: "Earned {{ pngSymbol }} tokens represent voting shares in Arcanum governance.",
	canEitherVote: "You can either vote on each proposal yourself or delegate your votes to a third party.",
	delegateVotes: "Delegar votos",
	selfDelegate: "Autodelegar",
	remove: "Quitar",
	add: "Añadir",
	delegate: "Delegar",
	delegatingVotes: "Delegando votos",
	unlockingVotes: "Desbloqueando votos",
	transactionSubmitted: "Transacción enviada",
	"for": "a favor",
	against: "en contra",
	vote: "Votar",
	proposal: "proposición",
	votes: "Votos",
	submittingVote: "Enviando voto",
	confirmTransaction: "Confirme esta transacción en su cartera",
	viewExplorer: "Ver en el explorador"
};
var walletModal$5 = {
	wrongNetwork: "Red errónea",
	errorConnecting: "Error al conectar",
	pleaseConnectAvalanche: "Por favor, conéctese a la red de Avalanche correcta.",
	switchAvalanche: "Cambie a la Avalanche Chain",
	errorConnectingRefresh: "Error conectando. Pruebe a recargar la página.",
	connectToWallet: "Connect to a wallet",
	newToAvalanche: "Nuevo en Avalanche? ",
	learnMoreWallet: "Descubre más sobre como configurar una cartera",
	initializing: "Inicializanddo...",
	tryAgain: "Prueba otra vez"
};
var web3ReactManager$5 = {
	unknownError: "Oops! Ha ocurrido un error desconocido. Por favor, recarga la página, o utilice otro navegador o dispositivo."
};
var web3Status$5 = {
	pending: "Pendiente",
	wrongNetwork: "Red errónea",
	error: "Error",
	connectToWallet: "Conectar a la cartera"
};
var gasFeeAlert$5 = {
	gasFeeReduction: "!!! Reducción de la tasa de gas !!!",
	transactionsNotAccept: "Las transacciones no serán aceptadas si la tasa de gas no es de {{ gasPrice }} gwei."
};
var addLiquidity$5 = {
	deposited: "Depositado",
	shareOfPool: "Parte de la Pool",
	createPoolSupply: "Crear pool y suministrar",
	confirmSupply: "Confirmar suministro",
	giveOrder: "GIVE ORDER",
	outputEstimated: "El resultado es estimado. Si el precio cambia más de {{ allowedSlippage }}% su transacción será revertida.",
	creatingPool: "Está creando una pool",
	willReceive: "Recibirá",
	firstLP: "Es el primer proveedor de liquidez.",
	ratioTokens: "El ratio de tokens que añada determinará el precio de esta pool.",
	happyRate: "Una vez estea contento con el ratio haga click en suministrar.",
	initialPrices: "Precios iniciales",
	prices: "Precios",
	poolShare: "y parte de la pool",
	connectWallet: "Conectar cartera",
	approve: "Aprobar ",
	supply: "Suministrar",
	per: " por ",
	rates: "Ratios",
	poolTokens: " Pool Tokens"
};
var airdrop$5 = {
	claimPngAirdrop: "Reclamar {{ pngSymbol }} del Airdrop",
	claimPeriodEnded: "El período de reclamación del airdrop ha termindado.",
	connectWalletViewLiquidity: "Conecte la cartera para ver su liquidez.",
	noAvailableClaim: "No tiene recompensa disponible.",
	noUniNoSushi: "No tiene tokens UNI ni SUSHI. Por favor, siga el tutorial aquí para añadir tokens UNI o SUSHI a su cartera.",
	youHave: "Tiene ",
	pngAvailableClaim: " {{ pngSymbol }} disponible para reclamar",
	loading: "Cargando",
	welcomeToTeamPangolin: "Bienvenido al equipo Arcanum",
	claim: "reclamar "
};
var earnPage$5 = {
	pangolinLiquidityMining: "Minería de liquidez Arcanum",
	pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
	depositPangolinLiquidity: "Deposite sus tokens Arcanum Liquidity Provider ARL para recivir {{ pngSymbol }}, el token del protocolo de governanza de Arcanum.",
	depositPangolinStaking: "Deposit and stake your {{ pngSymbol }} tokens to earn more tokens.",
	currentOpportunities: "Current opportunities",
	readMoreAboutPng: "Leer más sobre {{ pngSymbol }}",
	getInsuranceCoverage: "Obtenga cobertura en InsurAce.io",
	getCoverNexusMutual: "Ponte a cubierto en Nexus Mutual",
	importantUpdate: "ACTUALIZACIÓN IMPORTANTE",
	pangolinGovernanceProposalResult: "Como resultado de la primera proposición de governanza de Arcanum, este está cambiando sus contratos de staking! Después de aproximadamente 08:59 UTC el 4/19, todas las recompensas serán distribuidas a los nuevos contratos. Antes del cambio, todas las recompensas serán distribuidas a los viejos contratos. para evitar interrupciones en las recompensas, necesita retirar su liquidez de los viejos contratos y depositarla en los nuevos. No necesita retirar su liquidez de sus pools ni alterar sus posiciones.",
	oldPngPools: "Viejas pools {{ pngSymbol }}",
	newPngPools: "Nuevas pools {{ pngSymbol }}",
	participatingPools: "Participating pools",
	rewardsNeverEnd: "Las recompensas nunca terminan!",
	noActiveRewards: "No hay recompensas activas",
	liquidityMining: "Minería de liquidez",
	pngStaking: "{{ pngSymbol }} Staking",
	totalStaked: "Total depositado",
	poolRate: "Ratio de la Pool",
	step1: "Step 1. Get Arcanum Liquidity tokens (ARL)",
	pglTokenRequired: "ARL tokens are required. Once you've added liquidity to the {{ poolHandle }} pool you can stake your liquidity tokens on this page.",
	addPoolLiquidity: "Add {{ poolHandle }} liquidity",
	liquidityDeposits: "Sus depósitods de liquidez",
	yourStakedToken: "Your staked {{ symbol }}",
	unclaimedReward: "Sus {{ symbol }} sin reclamar",
	claim: "Reclamar",
	rewardPerWeek: " {{ symbol }} / week",
	automagically: "Cuando retira, el contrato reclama los {{ pngSymbol }} por usted automáticamente",
	deposit: "Depositar",
	depositStakingTokens: "Depositar tokens {{ symbol }}",
	stake: "Stake",
	stakeStakingTokens: "Stake {{ symbol }} Tokens",
	unstake: "Unstake",
	stakingTokensAvailable: "Toens {{ symbol }} disponibles",
	getToken: "Get {{ symbol }}",
	migrateTitle: "Migre su ARL apilado",
	migrateDescription: "Arcanum ha cambiado la tokenómica. Deberá migrar su ARL apilado a un nuevo contrato",
	migrate: "Emigrar"
};
var pool$5 = {
	liquidityProviderRewards: "Recompensas a proveedores de liquidez",
	liquidityProvidersEarn: "Los proveedores de liquiez ganan una tasa del 0.25% de todos los intercambios de forma proporcional a su parte de la pool. Las tasas se añaden a la pool, se acumulan en tiempo real y pueden ser reclamadas retirando su liquidez.",
	readMoreProviding: "Leer más sobre la provisión de liquidez",
	viewStakedLiquidity: "Ver su liquidez depositada",
	yourLiquidity: "Su liquidez",
	createPair: "Crear una pareja",
	addLiquidity: "Añadir liquidez",
	connectWalletToView: "Conecte la cartera para ver su liquidez.",
	loading: "Cargando",
	noLiquidity: "No se ha encontrado liquidez.",
	uniswapV1Found: "Liquidez Uniswap V1 encontrada!",
	noSeePoolJoined: "No ves un pool a la que te has unido?",
	migrateNow: "Mirgrar ahora.",
	importIt: "Importar.",
	seeDetails: "VER DETALLES",
	totalLockedValue: "Valor bloqueado total",
	yourLockedValue: "Su valor bloqueado",
	allPools: "Todas las Farms",
	yourFars: "Tus Farms",
	yourPools: "Tus Pools",
	noFarms: "No se encontraron farms.",
	successWithdraw: "¡Su liquidez eliminada de la granja y las recompensas acumuladas reclamadas!"
};
var poolFinder$5 = {
	connectToFind: "Conecte la cartera para encontrar pools",
	selectTokenToFind: "Seleccione un token para encontrar su liquidez.",
	selectToken: "Selecionar un token",
	poolFound: "Pool encontrada!",
	managePool: "Gestionar esta pool.",
	noLiquidityYet: "Todavía no tiene liquidez en la pool.",
	noPoolFound: "No se ha encontrado la pool.",
	addLiquidity: "Añadir liquidez.",
	createPool: "Crear pool.",
	invalidPair: "Pareja no válida.",
	loading: "Cargando"
};
var removeLiquidity$5 = {
	youWillReceive: "Recivirá",
	simple: "Simple",
	detailed: "Detallado",
	receiveAvax: "Recibir {{ symbol }}",
	receiveWavax: "Recibir {{ symbol }}",
	price: "Precio:",
	connectWallet: "Conectar cartera",
	approving: "Aprobando",
	approve: "Aprobar",
	approved: "Aprobado",
	remove: "Remove",
	output: "Resultado",
	amount: "Cantida"
};
var swapPage$5 = {
	addSend: "+ Añadir un envío (opcional)",
	toEstimated: "A (estimado)",
	to: "A",
	removeSend: "- Quitar envio",
	price: "Precio",
	slippageTolerance: "Tolerancia de deslizamiento",
	connectWallet: "Conectar cartera",
	insufficientLiquidity: "Liquidez insuficiente para el intercambio.",
	wrap: "Envolver",
	unwrap: "Desenvolver",
	approving: "Aprobando",
	approve: "Aprobar ",
	approved: "Aprobado",
	priceImpactHigh: "Alto impacto en el precio",
	swap: "Intercambiar",
	anyway: " De todos modos",
	from: "Desde",
	fromEstimated: "Desde (estimado)",
	velox: "Pon una orden límite en <1>Velox</1>",
	marginSwap: "Opere con apalancamiento en <1>MarginSwap</1>",
	wowSwap: " o <1>WOWswap</1>",
	veeFinance: " o <1>Vee Finance</1>",
	gelatoFee: "Gelato Tarifa",
	placeOrder: "Realizar pedido",
	confirmOrder: "Confirmar pedido",
	"for": "por",
	submittingOrderToSwap: "Enviando orden para canje",
	limitPrice: "Precio límite",
	outputWillBeSentTo: "La salida se enviará a",
	sell: "vender",
	buy: "comprar",
	betaRelease: "Esta es una versión BETA y debe usarse bajo su propio riesgo.",
	trade: "Comercio",
	watchList: "WatchList",
	yourPortFolio: "Su portafolio",
	comingSoon: "Próximamente",
	connectWalletViewPortFolio: "Conéctese a una cartera para ver su portafolio .",
	limitOrders: "Límite de órdenes",
	cancelOrder: "Cancelar orden",
	all: "TODA",
	open: "ABIERTA",
	executed: "EJECUTADA",
	cancelled: "CANCELADA",
	inputAmount: "Importe de entrada",
	outputAmount: "Cantidad de salida",
	status: "Estado",
	noLimitOrder: "No {{ orderType }} Pedido",
	cancellingOrder: "Cancelando pedido...",
	cancelLimitOrder: "Comprar {{ outputCurrency }} con {{ inputCurrency }}",
	executionPrice: "Precio de ejecución",
	seeMore: "Ver más",
	seeLess: "Ver menos"
};
var buyPage$5 = {
	buyAvaxInfo: "Compre AVAX con fiat de nuestro socio Wyre.",
	privacyInfo: "Arcanum no almacena su historial de compras ni ningún dato personal.",
	firstName: "Nombre",
	lastName: "Apellido",
	email: "Email",
	buyAvax: "Compre AVAX"
};
var votePage$5 = {
	unlockVotes: "Desbloquear votos",
	updateDelegation: "Actualizar delegación",
	pangolinGovernance: "Governanza Arcanum",
	earnedPngTokens: "los tokens {{ pngSymbol }} representan participaciones en la governanza de Arcanum Puede votar en cada proposición usted mismo o delegar sus votos a un tercero.",
	eligibleToVote: "Para ser elegible para votar, debe tener {{ pngSymbol }} en su cartera y delegarlos al comienzo de la votación. Una vez la votación haya empezado, puede depositar en una pool o gastar sus {{ pngSymbol }}.",
	governanceVotes: "Los votos de la governanza se deciden por mayoría. No hay un límite de quorum.",
	proposals: "Proposiciones",
	allProposals: "Todas las proposiciones",
	backToProposals: "Volver a Propuestas",
	unlockVoting: "Desbloquear votación",
	votes: " Votos",
	delegatedTo: "Delegados a:",
	edit: "editar",
	noProposalsFound: "No se encontraron proposiciones.",
	proposalCommunityMembers: "Las proposiciones presentadas por miembros de la comunidad aparecerán aquí.",
	minimumThreshold: "Se requieren un mínimo de 1,000,000 {{ pngSymbol }} para presentar proposiciones",
	votingStarted: "La votación empezó ",
	votingStarts: "La votación empieza ",
	votingEnded: "La votación terminó ",
	votingEnds: "La votación termina ",
	voteFor: "Votar a favor",
	voteAgainst: "Votar en contra",
	against: "En contra",
	"for": "A favor",
	details: "Detalles",
	overview: "Resumen",
	proposer: "Proponente",
	about: "Acerca de",
	vote: "Votar",
	executed: "Ejecutado",
	rejected: "Rechazado",
	notSupported: "No compatible con esta cadena"
};
var IDOPage$5 = {
	pangolinIDOs: "Initial DEX Offering (IDO)",
	pangolinIDODescription: "Las Ofertas Iniciales DEX (IDO) permiten a los proyectos financiar en forma colectiva sus tokens nativos en plataformas de intercambio descentralizados. Nos hemos asociado con equipos increíbles para llevar grandes proyectos a la comunidad de Avalanche.",
	upcomingIDOs: "Próximos",
	endedIDOs: "Terminados",
	allIDOs: "Todos los IDOs",
	noIDOsFound: "No se encontraron IDOs",
	IDOAnnounced: "Los IDOs publicamente anunciados aparecerán aquí."
};
var swapHooks$5 = {
	connectWallet: "Conectar cartera",
	enterAmount: "Introduzca una cantidad",
	selectToken: "Select a token",
	enterRecipient: "Introduzca un destinatario",
	invalidRecipient: "Destinatario no válido",
	insufficient: "Insuficiente ",
	balance: " balance"
};
var mintHooks$5 = {
	connectWallet: "Conectar cartera",
	insufficientInputAmount: "Cantidad de aporte insuficiente",
	invalidPair: "Pareja no válida",
	enterAmount: "Introduzca una cantidad",
	insufficient: "Insufciciente ",
	balance: " balance"
};
var stakeHooks$5 = {
	connectWallet: "Conectar cartera",
	enterAmount: "Introduzca una cantidad"
};
var burnHooks$5 = {
	connectWallet: "Conectar cartera",
	enterAmount: "Introduzca una cantidad"
};
var migratePage$5 = {
	stake: "APOSTAR",
	unstake: "DESPRENDIMIENTO",
	add: "AGREGAR",
	remove: "RETIRAR",
	startMigratingNow: "EMPIECE A MIGRAR AHORA",
	startMigratingNowDescription: "A continuación encontrará todas las granjas que necesitará para migrar a los contratos V2 de Arcanum",
	seeMore: "VER MÁS",
	migrateWithEase: "MIGRA CON FACILIDAD",
	migrateWithDescription: "Hemos diseñado un asistente elegante, que lo guiará a través del proceso de migración de sus Fincas.",
	alreadyMigrate: "Ya migrada",
	walletMigrate: "billetera migrada",
	alreadyEarned: "ya gana",
	migrateNow: "MIGRA AHORA",
	learn: "APRENDER",
	moveYourTokensToNewContracts: "Migre sus granjas a Arcanum V2",
	readyToMigrate: "Lista para migrar",
	apr: "APR:",
	totalValueLocked: "Valor total bloqueado",
	lowVolatility: "Baja volatilidad",
	compoundable: "Compuesta",
	migrate: "Emigrar",
	migrationModalDescription: "Nos hemos dado cuenta de que tiene estas piscinas ... Elija una o agregue una.",
	choosePool: "Elige piscina",
	pool: "Pool",
	availableToDeposit: "Disponible para depositar: ",
	poolInfoDescription: "Ahora que ha elegido su grupo, dejemos de apostar desde allí.",
	dollarWorth: "Valor del dólar: ",
	usd: "USD",
	yourRate: "Tu tarifa: ",
	unclaimedPng: "{{ pngSymbol }} no reclamada: ",
	shareOfPool: "Participación de la piscina: ",
	choose: "ESCOGER",
	selectAll: "Seleccionar todo",
	loading: "Cargando",
	back: "atrás",
	availableToUnstake: "Disponible para desaplicar: ",
	submittingTransaction: "Enviar transacción",
	moveYourTokensToNewContractsDescription: "Como parte del lanzamiento de Arcanum a nuevos contratos mejorados, deberá migrar sus granjas. Si necesita ayuda u orientación, haga clic en el botón 'Aprender'",
	migrateModalHeading: "Migrar {{ current }} de {{ total }} granja"
};
var dashboardPage$5 = {
	dashboard: "Dashboard",
	greetings: "Greetings kind guests! Let’s ape in today…",
	portfolioValue: "Portfolio Value",
	earned: "Earned",
	coins: "Coins",
	followedWallets: "Followed Wallets",
	earned_dailyIncome: "Daily Income",
	earned_weeklyIncome: "Weekly Income",
	earned_totalEarned: "Total Earned",
	earned_claim: "Claim",
	earned_customizePools: "Customize Pools",
	followed_address: "Address",
	followed_worth: "Worth",
	followed_interact: "Interact"
};
var stakePage$5 = {
	totalStaked: "Total Staked",
	apr: "Annual Percentage Rate",
	seeDetails: "SEE DETAILS",
	stake: "STAKE",
	earn: "Earn {{symbol}}",
	stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$5 = {
	missingCurrencyAmounts: "Cantidades de moneda faltantes",
	missingTokens: "Fichas faltantes",
	missingDependencies: "Dependencias faltantes",
	missingLiquidityAmount: "Cantidad de liquidez faltante",
	couldNotWrap: "No se pudo envolver",
	attemptingToConfirmApproval: "Intentando confirmar sin aprobación o firma. Comuníquese con soporte."
};
var sarTitle$5 = {
	addMore: "AÑADIR MÁS",
	unstake: "QUITAR UNA POSICIÓN",
	compound: "RECOMPENSAS COMPUESTAS",
	claim: "RECLAMAR PREMIOS",
	interactingID: "Interactuando con ID: {{ id }}"
};
var sarStake$5 = {
	createNewPosition: "Crear un nuevo puesto",
	stake: "Apostar",
	staking: "Staking",
	walletBalance: "En Wallet {{ balance }} {{ symbol }}",
	max: "Máximo",
	dollarValue: "Valor en dólares",
	buy: "Comprar {{ symbol }}",
	averageAPR: "APR medio",
	startingApr: "APR inicial",
	weeklyDistributed: "Semanal {{ symbol }} Distribuido",
	confirmDescription: "Una acción de estaca creará un SAR Nft para usted. Con este NFT puede administrar su apuesta de {{ símbolo }}.",
	successSubmit: "Ha apostado con éxito su token.",
	yourAprRecalculated: "Su APR será recalculada.",
	summary: "Resumen",
	pending: "Staking {{ balance }} {{ symbol }}",
	transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore$5 = {
	stakeMore: "Apuesta Más",
	choosePosition: "Elija una posición",
	confirmDescription: "Esto agrega {{ symbol }} a su posición SAR NFT. Su saldo original continúa desde la misma APR. La APR de sus tokens recién agregados comienza desde 0% y cambia según la duración de la apuesta. Su NFT mostrará el promedio.",
	newAPR: "Nueva TAE",
	add: "Agregar",
	pending: "Agregar {{ balance }} {{ symbol }}"
};
var sarUnstake$5 = {
	unstake: "No tomar",
	unstaking: "Destamando {{ balance }} {{ symbol }}",
	stakedBalance: "Staked {{ balance }} {{ symbol }}",
	confirmDescription: "Vale la pena ser consciente de que desvincular sus recompensas hará que su APR sea del 0% para esta posición. \nEn lugar de destamar, también puede considerar vender su NFT.",
	successSubmit: "Ha desatado con éxito sus tokens.",
	pending: "Destamando {{ balance }} {{ symbol }}",
	transactionSummary: "No tomado {{ balance }} {{ symbol }}",
	currentAPR: "APR actual",
	unstakeWarning: "Cuando no tome, su APR promedio caerá a 0%.",
	aprAfter: "APR después de unstake"
};
var sarCompound$5 = {
	compound: "Compuesto",
	compounding: "Composición",
	successSubmit: "Ha compuesto con éxito su posición.",
	pending: "Composición",
	transactionSummary: "Posición compuesta",
	aprAfter: "APR después de la capitalización",
	reward: "Recompensas acumuladas",
	description: "Tenga en cuenta que la capitalización de sus recompensas puede disminuir su APR promedio. Los tokens recién apostados comienzan desde 0, mientras que los tokens antiguos continuarán con la misma APR. Esto crea el promedio que se muestra a usted.",
	noRewards: "No hay recompensas para componer"
};
var sarClaim$5 = {
	claim: "Reclamación",
	claiming: "Reclamando",
	description: "Debido a la naturaleza del sistema de apuesta SAR, reclamar sus recompensas reducirá su APR a 0. En su lugar, puede aumentar sus recompensas sin perder su APR.",
	successSubmit: "Has reclamado con éxito tus recompensas",
	pending: "Reclamando",
	transactionSummary: "Recompensas por posición reclamada",
	aprAfter: "APR después de la reclamación",
	noRewards: "No hay recompensas que reclamar"
};
var sarPortfolio$5 = {
	noPositions: "No tienes ningún PANGUARDIAN NFT.\nVAMOS A CONSEGUIRTE UNO",
	start: "EMPEZAR",
	positionId: "ID de posición",
	apr: "Apr",
	amount: "Importe",
	newest: "Nuevo",
	oldest: "Mayor",
	sortBy: "Ordenar por"
};
var pangoChef$5 = {
	claimWarning1: "Cuando reclamas sin retirar tu liquidez permanece en el pool de minería.",
	claimWarning2: "Reclamar sus recompensas reducirá su APR a 0. En su lugar, puede optar por capitalizar.",
	compoundWarning: "Combinar sus recompensas para {{ token0 }}-{{ token1 }} hará que sus recompensas se apuesten en {{ currency }}-{{ png }} granja. Debe agregar el mismo valor de {{ currency }} token a sus {{ png }} recompensas acumuladas.",
	compoundAmountWarning: "Necesitas agregar {{ amount }} {{ symbol }} al compuesto.",
	compoundAmountWarning2: "Tenga cuidado de bloquear su fondo de {{ symbol }} {{ png }} hasta que reclame las recompensas de este fondo.",
	highVolalityWarning: "Demasiado pronto, intente en unas pocas horas",
	compoundSuccess: "Ha compuesto correctamente su granja",
	compoundTransactionSummary: "Granja compuesta",
	removeWarning: "Eliminar cualquier cantidad de la granja hará que su APR sea 0. En su lugar, puede combinar sus recompensas sin perder su APR.",
	lockingPoolZeroWarning: "No puede eliminar su liquidez o reclamar sus recompensas de esta granja. Para hacer esto, primero debe reclamar su participación de estas granjas: "
};
var bridge$5 = {
	availableRoutes: "Available Routes ({{ number }})",
	activeTransfers: "Active Transfers ({{ number }})",
	historicalTransfers: "Historical Transfers ({{ number }})",
	bridgeCard: {
		advanceOptions: "Advance Options",
		title: "Cross Chain",
		swap: "Swap",
		loader: {
			labels: {
				waitingReceivingChain: "Waiting for receiving chain..."
			},
			bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
		},
		filter: {
			bridgePrioritization: "Bridge Prioritization",
			slippage: "Slippage",
			infiniteApproval: "Infinite Approval",
			activeInfiniteApproval: "Active Infinite Approval",
			bridges: "Bridges",
			exchanges: "Exchanges"
		}
	},
	bridgeInputsWidget: {
		tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
		max: "MAX"
	},
	bridgeRoute: {
		selected: "Selected",
		clickToSelect: "Click to select",
		singleTransaction: "Single transaction including",
		estimatedToken: "Estimated Token: {{ token }}",
		estimatedResult: "Estimated Result: {{ result }}",
		min: "{{ minute }} min",
		gasCost: "{{ gasCost }} Gas Cost"
	},
	bridgeTransfer: {
		date: "Date",
		from: "From",
		to: "To",
		via: "Via",
		state: "State",
		resumeSwap: "Resume Swap"
	},
	bridgePrioritizations: {
		recommended: "Recommended",
		fast: "Fast",
		normal: "Normal"
	}
};
var dropdown$5 = {
	select: "Select"
};
var esTranslation = {
	header: header$5,
	accountDetails: accountDetails$5,
	addressInputPanel: addressInputPanel$5,
	currencyInputPanel: currencyInputPanel$5,
	earn: earn$5,
	menu: menu$5,
	modalView: modalView$5,
	navigationTabs: navigationTabs$5,
	popups: popups$5,
	positionCard: positionCard$5,
	searchModal: searchModal$5,
	settings: settings$5,
	swap: swap$5,
	toggle: toggle$5,
	tokenWarningModal: tokenWarningModal$5,
	transactionConfirmation: transactionConfirmation$5,
	transactionSettings: transactionSettings$5,
	vote: vote$5,
	walletModal: walletModal$5,
	web3ReactManager: web3ReactManager$5,
	web3Status: web3Status$5,
	gasFeeAlert: gasFeeAlert$5,
	addLiquidity: addLiquidity$5,
	airdrop: airdrop$5,
	earnPage: earnPage$5,
	pool: pool$5,
	poolFinder: poolFinder$5,
	removeLiquidity: removeLiquidity$5,
	swapPage: swapPage$5,
	buyPage: buyPage$5,
	votePage: votePage$5,
	IDOPage: IDOPage$5,
	swapHooks: swapHooks$5,
	mintHooks: mintHooks$5,
	stakeHooks: stakeHooks$5,
	burnHooks: burnHooks$5,
	migratePage: migratePage$5,
	dashboardPage: dashboardPage$5,
	stakePage: stakePage$5,
	error: error$5,
	sarTitle: sarTitle$5,
	sarStake: sarStake$5,
	sarStakeMore: sarStakeMore$5,
	sarUnstake: sarUnstake$5,
	sarCompound: sarCompound$5,
	sarClaim: sarClaim$5,
	sarPortfolio: sarPortfolio$5,
	pangoChef: pangoChef$5,
	bridge: bridge$5,
	dropdown: dropdown$5
};

var header$4 = {
	dashboard: "Dashboard",
	swap: "Échanger",
	buy: "Acheter",
	pool: "Pool",
	farm: "Farm",
	version1: "Version 1",
	version2: "Version 2",
	stake: "Stake",
	newPng: "Nouveau {{ pngSymbol }}",
	oldPng: "Ancien {{ pngSymbol }}",
	vote: "Vote",
	ido: "IDO",
	charts: "Graphiques",
	forum: "Forum",
	pngBreakDown: "Votre répartition {{ symbol }}",
	balance: "Balance: ",
	unclaimed: "Non réclamé: ",
	pngPrice: "Prix {{ symbol }}",
	pngCirculation: "{{ symbol }} en circulation:",
	totalSupply: "Offre Totale",
	makeSureURLWarning: "Assurez-vous que l'URL est",
	alwaysMakeSureWarning: "Assurez-vous toujours que l'URL est",
	bookmarkIt: "mettez-le en favori pour être sûr.",
	addMetamask: "Ajouter {{ symbol }} à MetaMask",
	bridge: "Pont",
	ourPartners: "Nos partenaires",
	usefulLinks: "LIENS UTILES",
	comeAndJoinUs: "Venez nous rejoindre",
	tryOurNewBetaSite: "Essayez notre nouveau site bêta",
	returnToLegacySite: "Retour à l'ancien site",
	switchToNewUI: "Passer à la nouvelle interface utilisateur"
};
var accountDetails$4 = {
	connectedWith: "Connecté avec ",
	account: "Compte",
	disconnect: "Déconnexion",
	change: "Changer",
	copy: "Copie de l'adresse",
	viewExplorer: "Voir sur l'explorateur",
	clearAll: "(Effacer tout)",
	transactionAppear: "Vos transactions apparaîtront ici...",
	recentTransactions: "Transactions récentes",
	copied: "Copié"
};
var addressInputPanel$4 = {
	recipient: "Bénéficiaire",
	viewExplorer: "(Voir sur l'explorateur)",
	walletAddress: "Adresse du portefeuille"
};
var currencyInputPanel$4 = {
	selectToken: "Choisissez un jeton",
	balance: "Balance: ",
	max: "MAX",
	to: "Vers"
};
var earn$4 = {
	claimAccumulated: "Réclamer les récompenses {{ symbol }} accumulées",
	connectWallet: "Connecter le portefeuille",
	enterAmount: "Entrer un montant",
	unclaimedReward: "{{ symbol }} non réclamé",
	claim: "Réclamer",
	claimReward: "{{ symbol }} Réclamer",
	liquidityRemainsPool: "Lorsque vous réclamez sans retirer, vos liquidités restent dans la pool de minage.",
	withdrawingLiquidity: "Retirer {{ amount }} {{ symbol }}",
	claimingReward: "Réclamation en cours {{ amount }} {{ symbol }}",
	claimedReward: "{{ symbol }} Réclamé!",
	manage: "Gérer",
	deposit: "Dépôt",
	poolRate: "Taux de la pool",
	currentReward: "Récompense actuelle",
	pngPerAvax: "{{ symbol }} / Semaine par AVAX",
	rewardPerWeek: "{{ symbol }} / Semaine",
	earnUpTo: "Gagnez jusqu'à (par an)",
	yourRate: "Votre taux",
	totalDeposited: "Total déposé",
	totalStaked: "Total staké",
	depositLiquidity: "Liquidité des dépôts",
	attemptingToStakeError: "Tentative de staking sans autorisation ni signature. Veuillez contacter le support.",
	transactionSubmitted: "Transaction Soumise",
	depositingLiquidity: "Dépôt de liquidités",
	depositingToken: "Dépôt de {{ symbol }}",
	depositedToken: "Déposé: {{ symbol }}",
	availableToDeposit: "Disponible pour le dépôt: ",
	weeklyRewards: "Récompenses hebdomadaires",
	missingLiquidityAmount: "montant de liquidité manquant",
	missingDependencies: "dépendances manquantes",
	deposited: "Déposé",
	withdrawDepositedLiquidity: "Retirer les liquidités déposées",
	depositedPglLiquidity: "Liquidité ARL déposée :",
	whenYouWithdrawWarning: "Lorsque vous effectuez un retrait, votre {{ symbol }} est réclamé et vos jetons de liquidité Arcanum, ARL, vous sont rendus. Vous ne gagnerez plus de récompenses en {{ symbol }} sur cette liquidité. Votre jeton de liquidité original restera dans sa pool de liquidité.",
	whenYouWithdrawSingleSideWarning: "Lorsque vous retirez, vos {{ symbol }} sont réclamés et vous récupérez vos {{ pngSymbol }}. Vous ne gagnerez plus de récompenses en  {{ symbol }} sur ces {{ pngSymbol}}.",
	withdrawAndClaim: "Retirer & réclamer",
	withdrewStakingToken: "{{ symbol }} Retiré!",
	approve: "Approuver",
	poolWeight: "Poids de la piscine",
	withdraw: "Retirer",
	extraReward: "Récompense supplémentaire",
	poolRewards: "Récompenses de pool",
	rewardsIn: "Récompenses en",
	removeWarning: "Vous retirez des liquidités de ce pool. Cette action vous rendra vos jetons. Alternativement, vous pouvez choisir de miser vos jetons sur la ferme pour gagner des récompenses."
};
var menu$4 = {
	code: "Code",
	twitter: "Twitter",
	discord: "Discord",
	telegram: "Telegram",
	tutorials: "Tutoriels",
	idos: "IDOs",
	about: "À propos"
};
var modalView$4 = {
	confirmTransaction: "Confirmez cette transaction dans votre portefeuille",
	viewTransaction: "Afficher la transaction sur l'explorateur"
};
var navigationTabs$4 = {
	useThisTool: "Utilisez cet outil pour trouver les paires qui n'apparaissent pas automatiquement dans l'interface.",
	swap: "Échanger",
	pool: "Pool",
	importPool: "Importer une Pool",
	createPair: "Créer une paire",
	addLiquidity: "Ajouter de la liquidité",
	removeLiquidity: "Supprimer la liquidité",
	whenYouAddLiquidityInfo: "Lorsque vous ajoutez des liquidités, vous recevez des jetons de pool représentant votre position. Ces jetons rapportent automatiquement des frais proportionnels à votre part du pool, et peuvent être échangés à tout moment.",
	removingPoolTokensInfo: "En retirant des jetons du pool, votre position est reconvertie en jetons sous-jacents au taux actuel, proportionnellement à votre part du pool. Les frais accumulés sont inclus dans les montants que vous recevez."
};
var popups$4 = {
	tokenListUpdated: "La liste de jetons \" {{oldList}} \" a été mise à jour en ",
	updateAvailable: "Une mise à jour est disponible pour la liste de jetons \" {{oldList}} \"",
	viewExplorer: "Voir sur l'explorateur",
	hash: "Hash: ",
	added: "ajouté",
	removed: "supprimé",
	tokensUpdated: "jetons mis à jour",
	acceptUpdate: "Accepter la mise à jour",
	dismiss: "Rejeter"
};
var positionCard$4 = {
	add: "Ajouter",
	remove: "Retirer",
	poolShare: "Votre part de la pool:",
	pooled: "Mis en commun",
	poolTokens: "Les jetons de votre pool:",
	manage: "Gérer",
	loading: "Chargement",
	yourPosition: "Votre position",
	byAddingLiquidityInfo: "En ajoutant de la liquidité, vous gagnerez 0,25 % de toutes les transactions sur cette paire, proportionnellement à votre part de la pool.\n Les frais sont ajoutés au pool, s'accumulent en temps réel et peuvent être réclamés en retirant votre liquidité."
};
var searchModal$4 = {
	commonBases: "Bases communes",
	tokensPairsHelper: "Ces jetons sont généralement associés à d'autres jetons.",
	addedByUser: "Ajouté par l'utilisateur",
	foundByAddress: "Trouvé par l'adresse",
	remove: "supprimer",
	add: "Ajouter",
	findToken: "Trouvez un jeton en recherchant son nom ou son symbole ou en collant son adresse ci-dessous.",
	selectToken: "Sélectionnez un jeton",
	tokenSearchPlaceholder: "Rechercher le nom ou coller l'adresse",
	tokenName: "Nom du jeton",
	change: "Changer",
	selectList: "Sélectionnez une liste",
	confirmListRemovalPrompt: "Veuillez confirmer que vous souhaitez supprimer cette liste en tapant \"supprimer\".",
	addList: "Ajouter une liste ",
	tokenListHelper: "Les listes de jetons sont une spécification ouverte pour les listes de jetons ERC20. Vous pouvez utiliser n'importe quelle liste de jetons en saisissant son URL ci-dessous. Attention, les listes de jetons de tiers peuvent contenir des jetons ERC20 faux ou malveillants.",
	httpsPlaceholder: "https:// ou ipfs://",
	manageLists: "Gérer les listes",
	viewList: "Voir la liste",
	updateList: "Mise à jour de la liste",
	removeList: "Supprimer la liste",
	selected: "Sélectionné",
	select: "Sélectionner",
	manageTokenLists: "Gérer les listes de jetons"
};
var settings$4 = {
	areYouSure: "Vous êtes sûr ?",
	expertInfo: "Le mode expert désactive l'invite de confirmation de la transaction et autorise les transactions à fort slippage qui entraînent souvent de mauvais taux et des pertes de fonds.",
	expertWarningCAPS: "N'UTILISEZ CE MODE QUE SI VOUS SAVEZ CE QUE VOUS FAITES.",
	confirm: "confirmer",
	confirmExpertMode: "Veuillez taper le mot \"confirmer\" pour activer le mode expert.",
	turnOnExpertMode: "Activer le mode expert",
	transactionSettings: "Paramètres de transaction",
	interfaceSettings: "Paramètres de l'interface",
	toggleExpertMode: "Passer en mode expert",
	expertModeHelper: "Contourne les modales de confirmation et permet des transactions à fort slippage. À utiliser à vos risques et périls.",
	toggleDarkMode: "Basculer en mode sombre",
	slippage: "Slippage",
	percent: "Percent"
};
var swap$4 = {
	priceImpact: "Impact du prix",
	priceImpactHelper: "La différence entre le prix du marché et le prix estimé en raison de la taille de la transaction.",
	liquidityProviderFee: "Commission du fournisseur de liquidité",
	liquidityProviderHelper: "Une partie de chaque transaction (0,30 %) est reversée aux fournisseurs de liquidités à titre d'incitation protocolaire.",
	route: "Route",
	routingHelper: "En passant par ces jetons, vous obtenez le meilleur prix pour votre transaction.",
	confirmSwap: "Confirmer l'échange",
	swapAnyway: "Échanger quand même",
	confirm: "confirmer",
	price: "Prix",
	accept: "Accepter",
	minimumReceived: "Minimum Reçu",
	maximumSold: "Maximum vendu",
	transactionRevertHelper: "Votre transaction sera annulée si un mouvement de prix important et défavorable se produit avant sa confirmation.",
	priceUpdated: "Prix actualisé",
	outputEstimated: "La quantité produite est estimée. Vous recevrez au moins <strong>{{amount}} {{currencySymbol}}</strong> ou la transaction sera annulée.",
	inputEstimated: "La quantité produite est estimée. Vous vendrez au maximum <strong>{{amount}} {{currencySymbol}}</strong> ou la transaction sera annulée.",
	outputSentTo: "La production sera envoyée à ",
	priceImpactMinPrompt: "Cet échange a un impact sur les prix d'au moins {{ priceImpact }}%. Veuillez taper le mot \"confirmer\" pour poursuivre cet échange.",
	priceImpactHighPrompt: "Cet échange a un impact sur les prix d'au moins {{ priceImpact }}%. Veuillez confirmer que vous souhaitez poursuivre cet échange."
};
var toggle$4 = {
	on: "On",
	off: "Off"
};
var tokenWarningModal$4 = {
	tokenImported: "Jeton importé",
	anyoneCanCreateWarning: "N'importe qui peut créer un jeton ERC-20 sur Avalanche avec <em>any</em> nom, y compris créer de fausses versions de jetons existants et des jetons qui prétendent représenter des projets qui n'ont pas de jeton.",
	loadArbitraryWarning: "Cette interface peut charger des jetons arbitraires par des adresses de jetons. Veuillez prendre des précautions supplémentaires et faire des recherches lorsque vous interagissez avec des jetons ERC-20 arbitraires.",
	purchaseArbitraryWarning: "Si vous achetez un jeton arbitraire, <strong>vous ne pourrez peut-être pas le revendre.</strong>",
	understand: "Je comprends",
	"continue": "Continuer",
	viewExplorer: "Voir sur l'explorateur"
};
var transactionConfirmation$4 = {
	waitingConfirmation: "En attente de confirmation",
	confirmTransaction: "Confirmez cette transaction dans votre portefeuille",
	transactionSubmitted: "Transaction soumise",
	viewExplorer: "Voir sur l'explorateur",
	close: "Fermer",
	error: "Erreur",
	dismiss: "Rejeter",
	addToFarm: "Ajouter à la ferme"
};
var transactionSettings$4 = {
	slippageTolerance: "Tolérance du slippage",
	transactionRevertSlippageHelper: "Votre transaction sera annulée si le prix évolue défavorablement par plus que ce pourcentage.",
	transactionDeadline: "Délai de transaction",
	transactionRevertDeadlineHelper: "Votre transaction sera annulée si elle reste en attente plus que le temps imparti.",
	enterValidSlippage: "Entrez un pourcentage de slippage valide",
	transactionMayFail: "Votre transaction peut échouer",
	transactionMayFrontrun: "Votre transaction peut être devancée.",
	transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
	minutes: "minutes"
};
var vote$4 = {
	earnedPng: "Les jetons {{ pngSymbol }} gagnés représentent des parts de vote dans la gouvernance de Arcanum.",
	canEitherVote: "Vous pouvez soit voter vous-même sur chaque proposition, soit déléguer vos votes à un tiers.",
	delegateVotes: "Votes délégués",
	selfDelegate: "Autodélégué",
	remove: "Retirer",
	add: "Ajouter",
	delegate: "Délégué",
	delegatingVotes: "Délégation de votes",
	unlockingVotes: "Déverrouillage des votes",
	transactionSubmitted: "Transaction soumise",
	"for": "pour",
	against: "contre",
	vote: "Vote",
	proposal: "proposition",
	votes: "Votes",
	submittingVote: "Soumission du vote",
	confirmTransaction: "Confirmez cette transaction dans votre portefeuille",
	viewExplorer: "Voir sur l'explorateur"
};
var walletModal$4 = {
	wrongNetwork: "Mauvais réseau",
	errorConnecting: "Erreur de connexion",
	pleaseConnectAvalanche: "Veuillez vous connecter au réseau Avalanche approprié.",
	switchAvalanche: "Passer à la chaîne Avalanche",
	errorConnectingRefresh: "Erreur de connexion. Essayez de rafraîchir la page.",
	connectToWallet: "Se connecter à un portefeuille",
	newToAvalanche: "Nouveau sur Avalanche ? ",
	learnMoreWallet: "En savoir plus sur la création d'un portefeuille",
	initializing: "Initialisation...",
	tryAgain: "Essayez à nouveau"
};
var web3ReactManager$4 = {
	unknownError: "Oups ! Une erreur inconnue s'est produite. Veuillez rafraîchir la page ou la visiter à partir d'un autre navigateur ou appareil."
};
var web3Status$4 = {
	pending: "En attente",
	wrongNetwork: "Mauvais réseau",
	error: "Erreur",
	connectToWallet: "Se connecter à un portefeuille"
};
var gasFeeAlert$4 = {
	gasFeeReduction: "!!! Diminution de la taxe sur le gaz !!!",
	transactionsNotAccept: "Les transactions ne seront pas acceptées à moins que les frais de gaz ne soient réglés sur {{ gasPrice }} gwei."
};
var addLiquidity$4 = {
	deposited: "Déposé",
	shareOfPool: "Part de la Pool",
	createPoolSupply: "Créer la Pool & la Réserve",
	confirmSupply: "Confirmer l'approvisionnement",
	giveOrder: "GIVE ORDER",
	outputEstimated: "La quantité produite est estimée. Si le prix varie de plus de {{ allowedSlippage }}% votre transaction sera annulée.",
	creatingPool: "Vous êtes en train de créer une pool",
	willReceive: "Vous recevrez",
	firstLP: "Vous êtes le premier fournisseur de liquidités.",
	ratioTokens: "Le ratio de jetons que vous ajoutez déterminera le prix de cette pool.",
	happyRate: "Une fois que vous êtes satisfait du taux, cliquez sur l'approvisionnement pour le vérifier.",
	initialPrices: "Prix initiaux",
	prices: "Prix",
	poolShare: "et le partage de la pool",
	connectWallet: "Connecter le Portefeuille",
	approve: "Approuver ",
	supply: "Approvisionner",
	per: " par ",
	rates: "Taux",
	poolTokens: " Jetons de la pool"
};
var airdrop$4 = {
	claimPngAirdrop: "Réclamer {{ pngSymbol }} de l'Airdrop",
	claimPeriodEnded: "La période de réclamation de l'airdrop est terminée.",
	connectWalletViewLiquidity: "Connectez-vous à un portefeuille pour consulter vos liquidités.",
	noAvailableClaim: "Vous n'avez pas de réclamation disponible.",
	noUniNoSushi: "Vous n'avez pas de jetons UNI ou SUSHI. Veuillez suivre le tutoriel ici pour ajouter des jetons UNI ou SUSHI à votre portefeuille.",
	youHave: "Vous avez ",
	pngAvailableClaim: " {{ pngSymbol }} disponible à réclamer",
	loading: "Chargement",
	welcomeToTeamPangolin: "Bienvenue dans l'équipe Arcanum",
	claim: "Réclamer "
};
var earnPage$4 = {
	pangolinLiquidityMining: "Minage de la liquidité de Arcanum",
	pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
	depositPangolinLiquidity: "Déposez vos jetons ARL (Arcanum Liquidity Provider) pour recevoir {{ pngSymbol }}, le jeton de gouvernance du protocole Arcanum.",
	depositPangolinStaking: "Déposez vos {{ pngSymbol }} pour gagner plus de tokens parmi les opportunités présentées.",
	currentOpportunities: "Opportunités actuelles",
	readMoreAboutPng: "En savoir plus sur {{ pngSymbol }}",
	getInsuranceCoverage: "Obtenez une couverture sur InsurAce.io",
	getCoverNexusMutual: "Obtenez une couverture sur Nexus Mutual",
	importantUpdate: "IMPORTANTE MISE À JOUR",
	pangolinGovernanceProposalResult: "Suite à la proposition de gouvernance 1 de Arcanum, Arcanum change de contrat de staking ! Après environ 08:59 UTC le 19 avril, toutes les récompenses de staking seront distribuées aux nouveaux contrats de staking. Avant le changement, toutes les récompenses seront encore distribuées aux anciens contrats. Pour éviter toute interruption des récompenses du yield farming, vous devez retirer vos liquidités des anciens contrats et les remettre dans les nouveaux contrats. Vous n'avez pas besoin de retirer des liquidités de vos pools ou de modifier vos positions.",
	oldPngPools: "Anciennes Pools {{ pngSymbol }}",
	newPngPools: "Nouvelles Pools {{ pngSymbol }}",
	participatingPools: "Pools participantes",
	rewardsNeverEnd: "Les récompenses ne s'arrêtent jamais !",
	noActiveRewards: "Pas de récompenses actives",
	liquidityMining: "Mining des liquidités",
	pngStaking: "{{ pngSymbol }} Staking",
	totalStaked: "Total Staké",
	poolRate: "Taux de la pool",
	step1: "Etape 1. Obtenez des jetons de liquidité Arcanum (ARL)",
	pglTokenRequired: "Les jetons ARL sont nécessaires. Une fois que vous avez ajouté des liquidités à la {{ poolHandle }} pool vous pouvez stake vos jetons de liquidité sur cette page.",
	addPoolLiquidity: "Ajouter {{ poolHandle }} liquidité",
	liquidityDeposits: "Vos dépôts de liquidités",
	yourStakedToken: "Votre dépôt de {{ symbol }}",
	unclaimedReward: "Vos {{ symbol }} non réclamés",
	claim: "Réclamer",
	rewardPerWeek: " {{ symbol }} / semaine",
	automagically: "Lorsque vous vous retirez, le contrat réclame automatiquement le {{ pngSymbol }} en votre nom !",
	deposit: "Dépôt",
	depositStakingTokens: "Déposer des jetons {{ symbol }}",
	stake: "Dépôt",
	stakeStakingTokens: "Déposez vos tokens {{ symbol }}",
	unstake: "Retrait",
	stakingTokensAvailable: "Jetons {{ symbol }} disponibles",
	getToken: "Obtenir des {{ symbol }}",
	migrateTitle: "Migrez votre ARL empilé",
	migrateDescription: "Arcanum a changé de tokenomics. Vous devrez migrer votre ARL empilé vers un nouveau contrat",
	migrate: "Émigrer"
};
var pool$4 = {
	liquidityProviderRewards: "Rémunération du fournisseur de liquidités",
	liquidityProvidersEarn: "Les fournisseurs de liquidités perçoivent une commission de 0,25 % sur toutes les transactions, proportionnellement à leur part du pool. Les commissions sont ajoutées au pool, s'accumulent en temps réel et peuvent être réclamées en retirant vos liquidités.",
	readMoreProviding: "En savoir plus sur la fourniture de liquidités",
	viewStakedLiquidity: "Visualisez votre liquidité staké",
	yourLiquidity: "Vos liquidités",
	createPair: "Créer une paire",
	addLiquidity: "Ajouter de la liquidité",
	connectWalletToView: "Connectez-vous à un portefeuille pour voir vos liquidités.",
	loading: "Chargement",
	noLiquidity: "Aucune liquidité trouvée.",
	uniswapV1Found: "Liquidité Uniswap V1 trouvé !",
	noSeePoolJoined: "Vous ne voyez pas une pool que vous avez rejointe ?",
	migrateNow: "Migrer maintenant.",
	importIt: "Importez-le.",
	seeDetails: "VOIR LES DÉTAILS",
	totalLockedValue: "Valeur totale verrouillée",
	yourLockedValue: "Votre valeur verrouillée",
	allFarms: "Toutes les Farms",
	yourFarms: "Voos Farms",
	yourPools: "Vos Pools",
	noFarms: "Aucune ferme trouvée.",
	successWithdraw: "Vos liquidités retirées de la ferme, et les récompenses accumulées réclamées !"
};
var poolFinder$4 = {
	connectToFind: "Se connecter à un portefeuille pour trouver des pools",
	selectTokenToFind: "Sélectionnez un jeton pour trouver votre liquidité.",
	selectToken: "Sélectionnez un jeton",
	poolFound: "Pool Trouvée!",
	managePool: "Gérer cette pool.",
	noLiquidityYet: "ous n'avez pas encore de liquidités dans cette pool.",
	noPoolFound: "Aucune pool trouvée.",
	addLiquidity: "Ajouter de la liquidité.",
	createPool: "Créer une pool.",
	invalidPair: "Paire non valide.",
	loading: "Chargement"
};
var removeLiquidity$4 = {
	youWillReceive: "Vous recevrez",
	simple: "Simple",
	detailed: "Détaillé",
	receiveAvax: "Recevoir {{ symbol }}",
	receiveWavax: "Recevoir {{ symbol }}",
	price: "Prix:",
	connectWallet: "Connecter le Portefeuille",
	approving: "Approbation",
	approve: "Approuver",
	approved: "Approuvé",
	remove: "Retirer",
	output: "Sortie",
	amount: "Montant"
};
var swapPage$4 = {
	addSend: "+ Ajouter un envoi (facultatif)",
	toEstimated: "Vers (estimation)",
	to: "Vers",
	removeSend: "- Supprimer l'envoi",
	price: "Prix",
	slippageTolerance: "Tolérance du slippage",
	connectWallet: "Connecter le Portefeuille",
	insufficientLiquidity: "Liquidité insuffisante pour cette transaction.",
	wrap: "Wrap",
	unwrap: "Unwrap",
	approving: "Approbation",
	approve: "Approuver ",
	approved: "Approuvé",
	priceImpactHigh: "Impact du prix élevé",
	swap: "Échanger",
	anyway: " Peu importe",
	from: "De",
	fromEstimated: "De (estimation)",
	velox: "Définissez un ordre limité sur <1>Velox</1>",
	marginSwap: "Tradez avec levier sur <1>MarginSwap</1>",
	wowSwap: " ou <1>WOWswap</1>",
	veeFinance: " ou <1>Vee Finance</1>",
	gelatoFee: "Gelato Frais",
	placeOrder: "Passer la commande",
	confirmOrder: "Confirmer la commande",
	"for": "pour",
	submittingOrderToSwap: "Soumission de la commande pour échanger",
	limitPrice: "Prix ​​limite",
	outputWillBeSentTo: "La sortie sera envoyée à",
	sell: "vendre",
	buy: "acheter",
	betaRelease: "Ceci est une version BETA et doit être utilisé à vos risques et périls !",
	trade: "Échanger",
	watchList: "Liste de surveillance",
	yourPortFolio: "Votre portefeuille",
	comingSoon: "À venir",
	connectWalletViewPortFolio: "Connectez-vous à un portefeuille pour afficher votre portefeuille .",
	limitOrders: "Ordres à cours limité",
	cancelOrder: "annuler la commande",
	all: "TOUTE",
	open: "OUVERTE",
	executed: "RÉALISÉ",
	cancelled: "ANNULÉ",
	inputAmount: "Montant d'entrée",
	outputAmount: "Montant de sortie",
	status: "Statut",
	noLimitOrder: "Non {{ orderType }} Commander",
	cancellingOrder: "Annuler la commande...",
	cancelLimitOrder: "Acheter {{ outputCurrency }} avec {{ inputCurrency }}",
	executionPrice: "Prix ​​d'exécution",
	seeMore: "Voir plus",
	seeLess: "Voir moins"
};
var buyPage$4 = {
	buyAvaxInfo: "Achetez AVAX avec monnaie fiat chez notre partenaire Wyre.",
	privacyInfo: "Arcanum ne stocke pas votre historique d'achat ni aucune donnée personnelle.",
	firstName: "Prénom",
	lastName: "Nom de Famille",
	email: "Email",
	buyAvax: "Achetez AVAX"
};
var votePage$4 = {
	unlockVotes: "Déverrouiller les votes",
	updateDelegation: "Mise à jour de la délégation",
	pangolinGovernance: "Gouvernance de Arcanum",
	earnedPngTokens: "Les jetons {{ pngSymbol }} représentent des actions de vote dans la gouvernance de Arcanum. Vous pouvez voter vous-même sur chaque proposition ou déléguer vos votes à une tierce partie.",
	eligibleToVote: "Pour pouvoir voter, vous devez détenir des {{ pngSymbol }} dans votre portefeuille et les déléguer au début du vote. Après le début du vote, vous pouvez mettre en commun ou dépenser vos {{ pngSymbol }}.",
	governanceVotes: "Les votes de gouvernance sont décidés à la majorité simple. Il n'y a pas de seuil de quorum.",
	proposals: "Propositions",
	allProposals: "Toutes les propositions",
	backToProposals: "Retour aux propositions",
	unlockVoting: "Déverrouiller le vote",
	votes: " Votes",
	delegatedTo: "Délégué à:",
	edit: "modifier",
	noProposalsFound: "Aucune proposition trouvée.",
	proposalCommunityMembers: "Les propositions soumises par les membres de la communauté apparaîtront ici.",
	minimumThreshold: "Un seuil minimum de 1 000 000 {{ pngSymbol }} est requis pour soumettre des propositions.",
	votingStarted: "Le vote a commencé ",
	votingStarts: "Le vote commence ",
	votingEnded: "Fin du vote ",
	votingEnds: "Fin du vote ",
	voteFor: "Voter pour",
	voteAgainst: "Voter contre",
	against: "Contre",
	"for": "Pour",
	details: "Détails",
	overview: "Vue d'ensemble",
	proposer: "Auteur",
	about: "Sur",
	vote: "Voter",
	executed: "Réalisé",
	rejected: "Rejeté",
	notSupported: "Non pris en charge sur cette chaîne"
};
var IDOPage$4 = {
	pangolinIDOs: "Initial DEX Offering (IDO)",
	pangolinIDODescription: "Les offres DEX initiales (IDO) permettent aux projets de financer participatif leurs jetons natifs sur des échanges décentralisés. Nous nous sommes associés à des équipes incroyables pour apporter de grands projets à la communauté Avalanche.",
	upcomingIDOs: "A venir",
	endedIDOs: "Terminé",
	allIDOs: "Tous les IDO",
	noIDOsFound: "Aucun IDO trouvé",
	IDOAnnounced: "Les IDO annoncés publiquement apparaîtront ici."
};
var swapHooks$4 = {
	connectWallet: "Connecter un Portefeuille",
	enterAmount: "Entrer un montant",
	selectToken: "Selectionner un jeton",
	enterRecipient: "Saisir un destinataire",
	invalidRecipient: "Destinataire non valide",
	insufficient: "Insuffisant ",
	balance: " balance"
};
var mintHooks$4 = {
	connectWallet: "Connecter un Portefeuille",
	insufficientInputAmount: "Quantité d'entrée insuffisante",
	invalidPair: "Paire non valide",
	enterAmount: "Entrer un montant",
	insufficient: "Insuffisant ",
	balance: " balance"
};
var stakeHooks$4 = {
	connectWallet: "Connecter un Portefeuille",
	enterAmount: "Entrer un montant"
};
var burnHooks$4 = {
	connectWallet: "Connecter un Portefeuille",
	enterAmount: "Entrer un montant"
};
var migratePage$4 = {
	stake: "PIEU",
	unstake: "DÉGAGER",
	add: "AJOUTER",
	remove: "SUPPRIMER",
	startMigratingNow: "COMMENCER À MIGRER MAINTENANT",
	startMigratingNowDescription: "Vous trouverez ci-dessous toutes les fermes dont vous aurez besoin pour migrer vers les contrats V2 de Arcanum",
	seeMore: "VOIR PLUS",
	migrateWithEase: "MIGRER FACILEMENT",
	migrateWithDescription: "Nous avons conçu un assistant élégant qui vous guidera tout au long du processus de migration de vos fermes.",
	alreadyMigrate: "déjà migré",
	walletMigrate: "portefeuille migré",
	alreadyEarned: "déjà gagné",
	migrateNow: "MIGRER MAINTENANT",
	learn: "APPRENDRE",
	moveYourTokensToNewContracts: "Migrer vos fermes vers Arcanum V2",
	readyToMigrate: "Prêt à migrer",
	apr: "APR:",
	totalValueLocked: "Valeur totale verrouillée",
	lowVolatility: "Faible volatilité",
	compoundable: "Compoundable",
	migrate: "Émigrer",
	migrationModalDescription: "Nous avons réalisé que vous avez ces piscines… Choisissez-en une ou ajoutez-en une.",
	choosePool: "Choisissez la piscine",
	pool: "Pool",
	availableToDeposit: "Disponible en dépôt: ",
	poolInfoDescription: "Maintenant que vous avez choisi votre piscine, laissez-vous en dépareiller.",
	dollarWorth: "Valeur en dollars : ",
	usd: "USD",
	yourRate: "Votre tarif : ",
	unclaimedPng: "{{ pngSymbol }} non réclamé : ",
	shareOfPool: "Part du pool : ",
	choose: "CHOISIR",
	selectAll: "Tout sélectionner",
	loading: "Chargement",
	back: "Arrière",
	availableToUnstake: "Disponible à démêler: ",
	submittingTransaction: "Soumission de la transaction",
	moveYourTokensToNewContractsDescription: "Dans le cadre du déploiement de Arcanum vers de nouveaux contrats améliorés, vous devrez migrer vos fermes. Si vous avez besoin d'aide ou de conseils, veuillez cliquer sur le bouton « Apprendre ».",
	migrateModalHeading: "Migration {{ current }} de la {{ total }} ferme"
};
var dashboardPage$4 = {
	dashboard: "Dashboard",
	greetings: "Greetings kind guests! Let’s ape in today…",
	portfolioValue: "Portfolio Value",
	earned: "Earned",
	coins: "Coins",
	followedWallets: "Followed Wallets",
	earned_dailyIncome: "Daily Income",
	earned_weeklyIncome: "Weekly Income",
	earned_totalEarned: "Total Earned",
	earned_claim: "Claim",
	earned_customizePools: "Customize Pools",
	followed_address: "Address",
	followed_worth: "Worth",
	followed_interact: "Interact"
};
var stakePage$4 = {
	totalStaked: "Total Staked",
	apr: "Annual Percentage Rate",
	seeDetails: "SEE DETAILS",
	stake: "STAKE",
	earn: "Earn {{symbol}}",
	stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$4 = {
	missingCurrencyAmounts: "Montants en devise manquants",
	missingTokens: "Jetons manquants",
	missingDependencies: "Dépendances manquantes",
	missingLiquidityAmount: "Montant de liquidité manquant",
	couldNotWrap: "Impossible d'envelopper",
	attemptingToConfirmApproval: "Tentative de confirmation sans approbation ni signature. Veuillez contacter le support."
};
var sarTitle$4 = {
	addMore: "AJOUTER PLUS",
	unstake: "ANNULER UNE POSITION",
	compound: "RÉCOMPENSES COMPOSÉES",
	claim: "RÉCLAMER DES RÉCOMPENSES",
	interactingID: "Interagir avec l'ID: {{ id }}"
};
var sarStake$4 = {
	createNewPosition: "Créer un nouveau poste",
	stake: "Pieu",
	staking: "Jalonnement",
	walletBalance: "Dans wallet {{ balance }} {{ symbol }}",
	max: "Max",
	dollarValue: "Valeur en dollars",
	buy: "Acheter {{ symbol }}",
	averageAPR: "TAEG moyen",
	startingApr: "Démarrage de l’APR",
	weeklyDistributed: "Hebdomadaire {{ symbol }} Distribué",
	confirmDescription: "Une action de mise créera un Nft SAR pour vous. Avec ce NFT, vous pouvez gérer votre mise {{ symbol }}.",
	successSubmit: "Vous avez réussi à miser votre jeton.",
	yourAprRecalculated: "Votre TAEG sera recalculé.",
	summary: "Résumé",
	pending: "Jalonnement {{ balance }} {{ symbol }}",
	transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore$4 = {
	stakeMore: "En jeu plus",
	choosePosition: "Choisir un poste",
	confirmDescription: "Cela ajoute {{ symbol }} à votre position SAR NFT. Votre solde initial continue à partir du même APR. L'APR de vos jetons nouvellement ajoutés commence à 0 % et change en fonction de la durée de la mise. Votre NFT affichera la moyenne.",
	newAPR: "Nouveau TAEG",
	add: "Ajouter",
	pending: "Ajout de {{ balance }} {{ symbol }}"
};
var sarUnstake$4 = {
	unstake: "Non prendre",
	unstaking: "Annulation de {{ balance }} {{ symbol }}",
	stakedBalance: "Staked {{ balance }} {{ symbol }}",
	confirmDescription: "Il convient de savoir que le fait de ne pas prendre vos récompenses fera passer votre TAEG à 0% pour ce poste. \nAu lieu de vous détendre, vous pouvez également envisager de vendre votre NFT.",
	successSubmit: "Vous avez réussi à annuler vos jetons.",
	pending: "Annulation de {{ balance }} {{ symbol }}",
	transactionSummary: "Non pris {{ balance }} {{ symbol }}",
	currentAPR: "APR actuel",
	unstakeWarning: "Lorsque vous vous désengagez, votre TAEG moyen tombera à 0%.",
	aprAfter: "APR après l’enlèvement"
};
var sarCompound$4 = {
	compound: "Composé",
	compounding: "Compoundage",
	successSubmit: "Vous avez réussi à aggraver votre position.",
	pending: "Compoundage",
	transactionSummary: "Position composée",
	aprAfter: "APR après composition",
	reward: "Récompenses accumulées",
	description: "Veuillez noter que l'accumulation de vos récompenses peut diminuer votre APR moyen. Les jetons nouvellement misés commencent à partir de 0, tandis que les anciens jetons continueront avec le même APR. Cela crée la moyenne qui vous est affichée.",
	noRewards: "Aucune récompense à composer"
};
var sarClaim$4 = {
	claim: "Revendication",
	claiming: "Prétendant",
	description: "En raison de la nature du système de jalonnement SAR, réclamer vos récompenses réduira votre TAEG à 0. Vous pouvez plutôt composer vos récompenses sans perdre votre APR.",
	successSubmit: "Vous avez réclamé vos récompenses avec succès",
	pending: "Prétendant",
	transactionSummary: "Récompenses de position réclamées",
	aprAfter: "APR après réclamation",
	noRewards: "Aucune récompense à réclamer"
};
var sarPortfolio$4 = {
	noPositions: "Vous n’avez pas de NFT PANGUARDIAN.\nPERMET DE VOUS EN PROCURER UN",
	start: "COMMENCER",
	positionId: "ID de poste",
	apr: "APR",
	amount: "Quantité",
	newest: "Nouveau",
	oldest: "Aîné",
	sortBy: "Trier par"
};
var pangoChef$4 = {
	claimWarning1: "Lorsque vous réclamez sans retirer votre liquidité reste dans le pool de minage.",
	claimWarning2: "Réclamer vos récompenses fera tomber votre APR à 0. À la place, vous pouvez choisir de composer.",
	compoundWarning: "En combinant vos récompenses pour la ferme {{ token0 }}-{{ token1 }}, vos récompenses seront mises en jeu dans la ferme {{ currency }}-{{ png }}. Vous devez ajouter une valeur égale de {{ currency }}token à vos récompenses {{ png }} accumulées.",
	compoundAmountWarning: "Vous devez ajouter {{ amount }} {{ symbol }} au composé.",
	compoundAmountWarning2: "Faites attention que vous verrouillerez votre pool de {{ symbol }} {{ png }} jusqu'à ce que vous réclamiez les récompenses de ce pool.",
	highVolalityWarning: "Trop tôt, essayez dans quelques heures",
	compoundSuccess: "Vous avez réussi à composer votre ferme.",
	compoundTransactionSummary: "Ferme composée.",
	removeWarning: "En retirant n'importe quel montant de la ferme, vous obtiendrez votre APR à 0. Vous pouvez à la place accumuler vos récompenses sans perdre votre APR.",
	lockingPoolZeroWarning: "Vous ne pouvez pas retirer vos liquidités ou réclamer vos récompenses de cette ferme. Pour ce faire, vous devez d'abord réclamer votre participation à ces fermes : "
};
var bridge$4 = {
	availableRoutes: "Available Routes ({{ number }})",
	activeTransfers: "Active Transfers ({{ number }})",
	historicalTransfers: "Historical Transfers ({{ number }})",
	bridgeCard: {
		advanceOptions: "Advance Options",
		title: "Cross Chain",
		swap: "Swap",
		loader: {
			labels: {
				waitingReceivingChain: "Waiting for receiving chain..."
			},
			bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
		},
		filter: {
			bridgePrioritization: "Bridge Prioritization",
			slippage: "Slippage",
			infiniteApproval: "Infinite Approval",
			activeInfiniteApproval: "Active Infinite Approval",
			bridges: "Bridges",
			exchanges: "Exchanges"
		}
	},
	bridgeInputsWidget: {
		tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
		max: "MAX"
	},
	bridgeRoute: {
		selected: "Selected",
		clickToSelect: "Click to select",
		singleTransaction: "Single transaction including",
		estimatedToken: "Estimated Token: {{ token }}",
		estimatedResult: "Estimated Result: {{ result }}",
		min: "{{ minute }} min",
		gasCost: "{{ gasCost }} Gas Cost"
	},
	bridgeTransfer: {
		date: "Date",
		from: "From",
		to: "To",
		via: "Via",
		state: "State",
		resumeSwap: "Resume Swap"
	},
	bridgePrioritizations: {
		recommended: "Recommended",
		fast: "Fast",
		normal: "Normal"
	}
};
var dropdown$4 = {
	select: "Select"
};
var frTranslation = {
	header: header$4,
	accountDetails: accountDetails$4,
	addressInputPanel: addressInputPanel$4,
	currencyInputPanel: currencyInputPanel$4,
	earn: earn$4,
	menu: menu$4,
	modalView: modalView$4,
	navigationTabs: navigationTabs$4,
	popups: popups$4,
	positionCard: positionCard$4,
	searchModal: searchModal$4,
	settings: settings$4,
	swap: swap$4,
	toggle: toggle$4,
	tokenWarningModal: tokenWarningModal$4,
	transactionConfirmation: transactionConfirmation$4,
	transactionSettings: transactionSettings$4,
	vote: vote$4,
	walletModal: walletModal$4,
	web3ReactManager: web3ReactManager$4,
	web3Status: web3Status$4,
	gasFeeAlert: gasFeeAlert$4,
	addLiquidity: addLiquidity$4,
	airdrop: airdrop$4,
	earnPage: earnPage$4,
	pool: pool$4,
	poolFinder: poolFinder$4,
	removeLiquidity: removeLiquidity$4,
	swapPage: swapPage$4,
	buyPage: buyPage$4,
	votePage: votePage$4,
	IDOPage: IDOPage$4,
	swapHooks: swapHooks$4,
	mintHooks: mintHooks$4,
	stakeHooks: stakeHooks$4,
	burnHooks: burnHooks$4,
	migratePage: migratePage$4,
	dashboardPage: dashboardPage$4,
	stakePage: stakePage$4,
	error: error$4,
	sarTitle: sarTitle$4,
	sarStake: sarStake$4,
	sarStakeMore: sarStakeMore$4,
	sarUnstake: sarUnstake$4,
	sarCompound: sarCompound$4,
	sarClaim: sarClaim$4,
	sarPortfolio: sarPortfolio$4,
	pangoChef: pangoChef$4,
	bridge: bridge$4,
	dropdown: dropdown$4
};

var header$3 = {
	dashboard: "Dashboard",
	swap: "Swap",
	buy: "Comprar",
	pool: "Pool",
	farm: "Farm",
	version1: "Versão 1",
	version2: "Versão 2",
	stake: "Stake",
	newPng: "Novo {{ pngSymbol }}",
	oldPng: "Antigo {{ pngSymbol }}",
	vote: "Votar",
	ido: "IDO",
	charts: "Gráficos",
	forum: "Fórum",
	pngBreakDown: "Sua análise de {{ symbol }}",
	balance: "Saldo: ",
	unclaimed: "Não resgatado: ",
	pngPrice: "Preço do {{ symbol }}:",
	pngCirculation: "{{ symbol }} em circulação:",
	totalSupply: "Suprimento total",
	makeSureURLWarning: "Certifique-se que a URL seja",
	alwaysMakeSureWarning: "Certifique-se sempre que a URL seja",
	bookmarkIt: "marque para ser seguro.",
	addMetamask: "Adicionar {{ symbol }} no MetaMask",
	bridge: "Ponte",
	ourPartners: "Nossos Parceiros",
	usefulLinks: "LINKS ÚTEIS",
	comeAndJoinUs: "Junte-se a nós",
	tryOurNewBetaSite: "Experimente nosso novo site beta",
	returnToLegacySite: "Retornar ao site legado",
	switchToNewUI: "Mudar para nova UI"
};
var accountDetails$3 = {
	connectedWith: "Conectado com ",
	account: "Conta",
	disconnect: "Desconectar",
	change: "Trocar",
	copy: "Copiar endereço",
	viewExplorer: "Ver no explorador",
	clearAll: "(limpar tudo)",
	transactionAppear: "Suas transações aparecerão aqui ... ",
	recentTransactions: "Transações recentes",
	copied: "Copiado"
};
var addressInputPanel$3 = {
	recipient: "Recebedor",
	viewExplorer: "(Ver no explorador)",
	walletAddress: "Endereço da carteira"
};
var currencyInputPanel$3 = {
	selectToken: "Selecione um token",
	balance: "Saldo: ",
	max: "MAX",
	to: "Para"
};
var earn$3 = {
	claimAccumulated: "Resgate {{ symbol }} acumulados",
	connectWallet: "Conectar a uma carteira",
	enterAmount: "Insira um valor",
	unclaimedReward: "{{ symbol }} não resgatado",
	claim: "Reivindicar",
	claimReward: "Reivindicar {{ symbol }}",
	liquidityRemainsPool: "Quando você resgata sem retirar sua liquidez ela permanece na pool de mineração.",
	withdrawingLiquidity: "Retirado {{ amount }} {{ symbol }}",
	claimingReward: "Reivindicando {{ amount }} {{ symbol }}",
	claimedReward: "{{ symbol }} resgatado!",
	manage: "Gerenciar",
	deposit: "Deposite",
	poolRate: "Ganhos da pool",
	currentReward: "Recompensa atual",
	pngPerAvax: "{{ pngSymbol }} / Semana por AVAX",
	rewardPerWeek: "{{ symbol }} / Semana",
	earnUpTo: "Ganhe até (anual)",
	yourRate: "Sua taxa",
	totalDeposited: "Total depositado",
	totalStaked: "Total depositado",
	depositLiquidity: "Deposite Liquidez",
	attemptingToStakeError: "Tentando depositar sem aprovação ou assinatura. Entre em contato com o suporte.",
	transactionSubmitted: "Transação enviada",
	depositingLiquidity: "Depositando liquidez",
	depositingToken: "Depositing {{ symbol }}",
	depositedToken: "Deposited {{ symbol }}",
	availableToDeposit: "Disponível para desposito: ",
	weeklyRewards: "Recompensa semanal",
	missingLiquidityAmount: "Quantidade de liquidez ausente",
	missingDependencies: "Dependências ausentes",
	deposited: "Depositado",
	withdrawDepositedLiquidity: "Retirar a liquidez depositada",
	depositedPglLiquidity: "Deposited ARL liquidity:",
	whenYouWithdrawWarning: "Quando você retirar, seu {{ symbol }} é resgatado e seus tokens de liquidez do Arcanum, ARL, são devolvidos para você. Você não vai mais ganhar recompensas de {{ symbol }} nessa liquidez. Sua liquidez original de token permanecerá na sua pool de liquidez.",
	whenYouWithdrawSingleSideWarning: "When you withdraw, your {{ symbol }} is claimed and your {{ pngSymbol }} is returned to you. You will no longer earn {{ symbol }} rewards on this {{ pngSymbol }}.",
	withdrawAndClaim: "Retirar & resgatar",
	withdrewStakingToken: "Retirar {{ symbol }}!",
	approve: "Aprovar",
	poolWeight: "Peso da piscina",
	withdraw: "Retirar",
	poolRewards: "Recompensas de pool",
	rewardsIn: "Recompensas em",
	removeWarning: "Você está removendo liquidez deste pool. Esta ação devolverá seus tokens. Alternativamente, você pode optar por apostar seus tokens para farmar para ganhar recompensas."
};
var menu$3 = {
	code: "Código",
	twitter: "Twitter",
	discord: "Discord",
	telegram: "Telegram",
	tutorials: "Tutoriais",
	idos: "IDOs",
	about: "Sobre"
};
var modalView$3 = {
	confirmTransaction: "Confirme esta transação em sua carteira",
	viewTransaction: "Ver transação no Explorer"
};
var navigationTabs$3 = {
	useThisTool: "Use esta ferramenta para encontrar pares que não aparecem automaticamente na interface.",
	swap: "Swap",
	pool: "Pool",
	importPool: "Importar Pool",
	createPair: "Criar par",
	addLiquidity: "Adicionar liquidez",
	removeLiquidity: "Remover liquidez",
	whenYouAddLiquidityInfo: "Quando você adiciona liquidez, você recebe pool tokens representando sua posição. Esses tokens ganham automaticamente taxas proporcionais à sua parte do pool e podem ser resgatados a qualquer momento.",
	removingPoolTokensInfo: "Remover tokens do pool converte sua posição de volta em tokens subjacentes à taxa atual, proporcional à sua parte do pool. As taxas acumuladas são incluídas nos valores que você recebe."
};
var popups$3 = {
	tokenListUpdated: "A lista de tokens \" {{oldList}} \" foi atualizada para ",
	updateAvailable: "Uma atualização disponível para lista de tokens \" {{oldList}} \"",
	viewExplorer: "Ver no explorador",
	hash: "Hash: ",
	added: "adicionado",
	removed: "removido",
	tokensUpdated: "tokens atualizados",
	acceptUpdate: "Aceitar atualização",
	dismiss: "Dispensar"
};
var positionCard$3 = {
	add: "Adicionar",
	remove: "Remover",
	poolShare: "Sua participação na pool:",
	pooled: "Pooled",
	poolTokens: "Tokens da sua pool:",
	manage: "Gerenciar",
	loading: "Carregando",
	yourPosition: "Sua posição",
	byAddingLiquidityInfo: "Ao adicionar liquidez, você ganhará 0,25% de todas as trocas sobre este par, proporcional à sua parte do pool. \n Taxas são adicionadas ao pool, acumulando em tempo real e podem ser reivindicadas retirando sua liquidez."
};
var searchModal$3 = {
	commonBases: "Bases comuns",
	tokensPairsHelper: "Esses tokens são comumente emparelhados com outros tokens.",
	addedByUser: "Adicionado pelo usuario",
	foundByAddress: "Encontrado pelo endereço",
	remove: "remover",
	add: "Incluir",
	findToken: "Encontre um token procurando por seu nome ou símbolo ou colando seu endereço abaixo.",
	selectToken: "Selecione um token",
	tokenSearchPlaceholder: "Procurar por nome ou cole o endereço",
	tokenName: "Nome do Token",
	change: "Trocar",
	selectList: "Selecione uma lista",
	confirmListRemovalPrompt: "Por favor, confirme que gostaria de remover esta lista digitando: \"remover\"",
	addList: "Adicione uma lista ",
	tokenListHelper: "Listas de token são uma especificação aberta para listas de tokens ERC20. Você pode usar qualquer lista de token inserindo sua URL abaixo. Cuidado, pois listas de tokens de terceiros podem conter tokens ERC-20 falsos ou maliciosos.",
	httpsPlaceholder: "https:// or ipfs://",
	manageLists: "Gerenciar Listas",
	viewList: "Ver lista",
	updateList: "Atualizar lista",
	removeList: "Remover lista",
	selected: "Selecionado",
	select: "Selecionar",
	manageTokenLists: "Gerenciar Lista de Tokens"
};
var settings$3 = {
	areYouSure: "Você tem certeza?",
	expertInfo: "O modo expert desliga o prompt de confirmação de transação e permite alta variação de preço que muitas vezes resultam em taxas ruins e perdas.",
	expertWarningCAPS: "USE APENAS ESTE MODO SE VOCÊ SABE O QUE ESTÁ FAZENDO",
	confirm: "confirmar",
	confirmExpertMode: "Por favor digite a palavra \"confirmar\" para habilitar o modo expert.",
	turnOnExpertMode: "Ativar modo expert",
	transactionSettings: "Configurações de transação",
	interfaceSettings: "Configurações da Interface",
	toggleExpertMode: "Ativar modo expert",
	expertModeHelper: "Ignora os modais de confirmação e permite alta variação de preço. Use por sua conta e risco.",
	toggleDarkMode: "Ativar modo escuro",
	slippage: "Slippage",
	percent: "Percent"
};
var swap$3 = {
	priceImpact: "Impacto no preço",
	priceImpactHelper: "A diferença entre o preço de mercado e o preço estimado devido ao tamanho da troca.",
	liquidityProviderFee: "Taxa para os provedores de liquidez",
	liquidityProviderHelper: "Uma parte de cada troca (0,30%) vai para os provedores de liquidez como um incentivo do protocolo.",
	route: "Rota",
	routingHelper: "A rota através desses tokens resultaram no melhor preço para a sua troca",
	confirmSwap: "Confirmar Swap",
	swapAnyway: "Swap de qualquer maneira",
	confirm: "confirmar",
	price: "Preço",
	accept: "Aceitar",
	minimumReceived: "Mínimo recebido ",
	maximumSold: "Máximo vendido",
	transactionRevertHelper: "Sua transação será revertida se houver um movimento de preço grande e desfavorável antes de ser confirmada.",
	priceUpdated: "Preço atualizado",
	outputEstimated: "A saída é estimada. Você receberá pelo menos <strong>{{amount}} {{currencySymbol}}</strong> ou a transação será revertida.",
	inputEstimated: "A entrada é estimada. Você vai vender no máximo <strong>{{amount}} {{currencySymbol}}</strong> ou a transação será revertida.",
	outputSentTo: "Saída será enviada para ",
	priceImpactMinPrompt: "Este swap tem um impacto no preço de pelo menos {{ priceImpact }}%. Por favor, digite a palavra \"confirmar\" para continuar com este swap.",
	priceImpactHighPrompt: "Este swap tem um impacto no preço de pelo menos {{ priceImpact }}%. . Por favor, confirme que você gostaria de continuar com este swap."
};
var toggle$3 = {
	on: "On",
	off: "Off"
};
var tokenWarningModal$3 = {
	tokenImported: "Token importado",
	anyoneCanCreateWarning: "Qualquer um pode criar um token ERC-20 na Avalanche com <em>qualquer</em> nome, incluindo  a criação de versões falsas de tokens já existentes e tokens que afirmam representar projetos que não têm um token",
	loadArbitraryWarning: "Esta interface pode carregar tokens arbitrários por meio de endereços de token. Por favor, tome mais cuidado e faça sua pesquisa ao interagir com tokens arbitrários de ERC-20.",
	purchaseArbitraryWarning: "Se você comprar um token arbitrário, <strong>você pode não conseguir vendê-lo de volta.</strong>",
	understand: "Compreendo",
	"continue": "Continuar",
	viewExplorer: "Ver no explorador"
};
var transactionConfirmation$3 = {
	waitingConfirmation: "Esperando por confirmação",
	confirmTransaction: "Confirme esta transação em sua carteira",
	transactionSubmitted: "Transação enviada",
	viewExplorer: "Ver no explorador",
	close: "Fechar",
	error: "Erro",
	dismiss: "Dispensar",
	addToFarm: "Adicionar à Farm"
};
var transactionSettings$3 = {
	slippageTolerance: "Tolerância de variação de preço",
	transactionRevertSlippageHelper: "Sua transação será revertida se o preço For alterado de forma desfavorável acima dessa porcentagem.",
	transactionDeadline: "Prazo máximo da transação",
	transactionRevertDeadlineHelper: "Sua transação será revertida se ela demorar mais do que isso.",
	enterValidSlippage: "Digite uma porcentagem válida de variação de preço",
	transactionMayFail: "Sua transação pode falhar",
	transactionMayFrontrun: "Sua transação pode ser suscetível a frontrun",
	transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
	minutes: "minutos"
};
var vote$3 = {
	earnedPng: "Os tokens {{ pngSymbol }} ganhos representam ações de votação na governança do Arcanum.",
	canEitherVote: "Você pode votar em cada proposta você mesmo ou delegar seus votos a um terceiro.",
	delegateVotes: "Delegar votos",
	selfDelegate: "Delegar você mesmo",
	remove: "Remover",
	add: "Adicionar",
	delegate: "Delegate",
	delegatingVotes: "Delegando votos",
	unlockingVotes: "Desbloquear votos",
	transactionSubmitted: "Transação enviada",
	"for": "a favor",
	against: "contras",
	vote: "Vote",
	proposal: "proposta",
	votes: "Votos",
	submittingVote: "Enviar voto",
	confirmTransaction: "Confirme essa transação na sua carteira",
	viewExplorer: "Ver no explorador"
};
var walletModal$3 = {
	wrongNetwork: "Rede errada",
	errorConnecting: "Erro ao conectar",
	pleaseConnectAvalanche: "Por favor, conecte-se à rede de avalanche apropriada.",
	switchAvalanche: "Mude para Avalanche Chain",
	errorConnectingRefresh: "Erro ao conectar. Tente atualizar a página.",
	connectToWallet: "Conectar a uma carteira",
	newToAvalanche: "Novo na Avalanche? ",
	learnMoreWallet: "Saiba mais sobre como configurar uma carteira",
	initializing: "Inicializando...",
	tryAgain: "Tente novamente"
};
var web3ReactManager$3 = {
	unknownError: "Oops! Ocorreu um erro desconhecido. Por favor, atualize a página ou visite de outro navegador ou dispositivo."
};
var web3Status$3 = {
	pending: "Pendente",
	wrongNetwork: "Rede errada",
	error: "Erro",
	connectToWallet: "Conectar a uma carteira"
};
var gasFeeAlert$3 = {
	gasFeeReduction: "!!! Redução na taxa de GAS !!!",
	transactionsNotAccept: "As transações não serão aceitas, a menos que a taxa de GAS esteja definida como {{ gasPrice }} gwei."
};
var addLiquidity$3 = {
	deposited: "Depositado",
	shareOfPool: "Sua participação",
	createPoolSupply: "Criar Pool & Supply",
	confirmSupply: "Confirmar Supply",
	giveOrder: "GIVE ORDER",
	outputEstimated: "A saída é estimada. Se o preço alterar em mais de {{efetiveslippage}}% sua transação será revertida.",
	creatingPool: "Você está criando uma pool",
	willReceive: "Você receberá",
	firstLP: "Você é o primeiro provedor de liquidez.",
	ratioTokens: "A proporção de tokens que você adiciona vai definir o preço desta pool.",
	happyRate: "Assim que estiver satisfeito com a proporção, clique em supply para revisar.",
	initialPrices: "Preços inicias",
	prices: "Preços",
	poolShare: "e participação na pool",
	connectWallet: "Conectar a uma carteira",
	approve: "Aprovar ",
	supply: "Supply",
	per: " por ",
	rates: "Proporção",
	poolTokens: " Pool Tokens"
};
var airdrop$3 = {
	claimPngAirdrop: "Resgatar {{ pngSymbol }} do Airdrop",
	claimPeriodEnded: "O perído de resgate do airdrop acabou.",
	connectWalletViewLiquidity: "Conecte-se a uma carteira para ver sua liquidez.",
	noAvailableClaim: "Você não tem resgate diponível.",
	noUniNoSushi: "Você não tem tokens UNI ou SUSHI, Por favor, siga o tutorial para adicionar os tokens UNI ou SUSHI na sua carteira.",
	youHave: "Você tem ",
	pngAvailableClaim: " {{ pngSymbol }} disponível para resgate",
	loading: "Carregando",
	welcomeToTeamPangolin: "Bem vindo à equipe do Arcanum",
	claim: "Resgatar "
};
var earnPage$3 = {
	pangolinLiquidityMining: "Mineração de liquidez do Arcanum",
	pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} staking",
	depositPangolinLiquidity: "Deposite seus tokens ARL (Arcanum Liquidity Provider) para receber {{ pngSymbol }}, o token de governança do protocolo Arcanum.",
	depositPangolinStaking: "Deposit and stake your {{ pngSymbol }} tokens to earn more tokens.",
	currentOpportunities: "Current opportunities",
	readMoreAboutPng: "Leia mais sobre {{ pngSymbol }}",
	getInsuranceCoverage: "Obtenha cobertura em InsurAce.io",
	getCoverNexusMutual: "Obtenha cobertura no Nexus Mutual",
	importantUpdate: "ATUALIZAÇÃO IMPORTANTE",
	pangolinGovernanceProposalResult: "Como resultado da proposta de governança 1 do Arcanum, O Arcanum está mudando contratos de staking! Aproximadamente cerca de depois de 08:59 UTC no dia 19/4, todas as recompensas de staking serão distribuídas para os novos contratos de staking. Antes da mudança, todas as recompensas ainda serão distribuídas para os contratos antigos. Para evitar interrupções nas recompensas de yield farming, Você precisa remover sua liquidez dos contratos antigos e delegar novamente nos novos contratos. Você não precisa remover liquidez das suas pools ou alterar suas posições.",
	oldPngPools: "Pools antigas de {{ pngSymbol }}",
	newPngPools: "Novas pools de {{ pngSymbol }}",
	participatingPools: "Pools participantes",
	rewardsNeverEnd: "As recompensas nunca terminam!",
	noActiveRewards: "Não há recompensas ativas",
	liquidityMining: "Mineração de liquidez",
	pngStaking: "{{ pngSymbol }} Staking",
	totalStaked: "Total depositado",
	poolRate: "Proporção da Pool",
	step1: "Etapa 1. Obtenha Tokens Arcanum Liquidity (ARL)",
	pglTokenRequired: "Tokens ARL são necessários. Depois de adicionar liquidez na pool {{ poolHandle }}, você pode colocar seus tokens de liquidez nesta página.",
	addPoolLiquidity: "Adicionar liquidez de {{ poolHandle }} ",
	liquidityDeposits: "Suas liquidez despositadas",
	yourStakedToken: "Your staked {{ symbol }}",
	unclaimedReward: "{{ symbol }} não resgatado",
	claim: "Resgate",
	rewardPerWeek: " {{ symbol }} / Semana",
	automagically: "Quando você retirar, o contrato automagicamente irá resgatar {{ pngSymbol }} em seu nome!",
	deposit: "Deposite",
	depositStakingTokens: "Deposite Tokens {{ symbol }}",
	stake: "Stake",
	stakeStakingTokens: "Stake {{ symbol }} Tokens",
	unstake: "Unstake",
	stakingTokensAvailable: "Tokens {{ symbol }} disponíveis",
	getToken: "Get {{ symbol }}",
	migrateTitle: "Migrar seu ARL empilhado",
	migrateDescription: "O Arcanum mudou a tokenômica. Você precisará migrar seu ARL empilhado para o novo contrato",
	migrate: "Migrar"
};
var pool$3 = {
	liquidityProviderRewards: "Recompensas dos provedores de liquidez",
	liquidityProvidersEarn: "Os provedores de liquidez ganham uma taxa de 0,25% sobre todas as trocas proporcionais a sua parte na pool. As taxas são adicionadas à pool, acumulando em tempo real e podendo ser reivindicadas retirando sua liquidez.",
	readMoreProviding: "Leia mais sobre como fornecer liquidez",
	viewStakedLiquidity: "Veja sua liquidez depositada",
	yourLiquidity: "Sua liquidez",
	createPair: "Criar um par",
	addLiquidity: "Adicionar liquidez",
	connectWalletToView: "Conecte-se a uma carteira para ver sua liquidez.",
	loading: "Carregando",
	noLiquidity: "Nenhuma liquidez encontrada.",
	uniswapV1Found: "Liquidez da Uniswap V1 encontrada!",
	noSeePoolJoined: "Não vê uma pool da qual participa?",
	migrateNow: "Migre-a.",
	importIt: "Importe-a.",
	seeDetails: "VEJA DETALHES",
	totalLockedValue: "Valor total bloqueado",
	yourLockedValue: "Seu valor bloqueado",
	allFarms: "Todas as farms",
	yourFarms: "Suas farms",
	yourPools: "Suas pools",
	noFarms: "Nenhuma fazenda encontrada.",
	successWithdraw: "Sua liquidez removida da fazenda e recompensas acumuladas reivindicadas!"
};
var poolFinder$3 = {
	connectToFind: "Conecte-se a uma carteira para encontrar suas pools",
	selectTokenToFind: "Selecione um token para econtrar sua liquidez.",
	selectToken: "Selecione um Token",
	poolFound: "Pool encontrada!",
	managePool: "Gerencie esta pool.",
	noLiquidityYet: "Você não tem liquidez nesta pool ainda.",
	noPoolFound: "Nenhuma pool encontrada.",
	addLiquidity: "Adicionar liquidez.",
	createPool: "Criar pool.",
	invalidPair: "Par inválido.",
	loading: "Carregando"
};
var removeLiquidity$3 = {
	youWillReceive: "Você irá receber",
	simple: "Simples",
	detailed: "Detalhado",
	receiveAvax: "{{ symbol }} recebido",
	receiveWavax: "{{ symbol }} recebido",
	price: "Preço:",
	connectWallet: "Conectar a uma carteira",
	approving: "Aprovando",
	approve: "Aprovar",
	approved: "Aprovado",
	remove: "Remover",
	output: "Saída",
	amount: "Quantidade"
};
var swapPage$3 = {
	addSend: "+ adicione um envio (opcional)",
	toEstimated: "Para (estimado)",
	to: "Para",
	removeSend: "- Remover envio",
	price: "Preço",
	slippageTolerance: "Tolerância de variação de preço",
	connectWallet: "Conectar a uma carteira",
	insufficientLiquidity: "Liquidez insufiente para esta troca.",
	wrap: "Wrap",
	unwrap: "Unwrap",
	approving: "Aprovando",
	approve: "Aprovar ",
	approved: "Aprovado",
	priceImpactHigh: "Impacto no preço alto",
	swap: "Fazer Swap",
	anyway: " de qualquer forma",
	from: "De",
	fromEstimated: "De (estimado)",
	velox: "Definir uma ordem de limite no <1>Velox</1>",
	marginSwap: "Negocie com alavancagem no <1>MarginSwap</1>",
	wowSwap: " ou <1>WOWswap</1>",
	veeFinance: " ou <1>Vee Finance</1>",
	gelatoFee: "Gelato Taxa",
	placeOrder: "Faça a encomenda",
	confirmOrder: "Confirmar pedido",
	"for": "por",
	submittingOrderToSwap: "Enviando pedido de troca",
	limitPrice: "Preço Limite",
	outputWillBeSentTo: "A saída será enviada para",
	sell: "vender",
	buy: "Comprar",
	betaRelease: "Esta é uma versão BETA e deve ser usada por sua própria conta e risco!",
	trade: "Troca",
	watchList: "WatchList",
	yourPortFolio: "Seu Portfólio",
	comingSoon: "Em breve",
	connectWalletViewPortFolio: "Conecte-se a uma carteira para ver seu portfólio.",
	limitOrders: "Limite de pedidos",
	cancelOrder: "Cancelar pedido",
	all: "TUDO",
	open: "ABRIR",
	executed: "EXECUTADA",
	cancelled: "CANCELADA",
	inputAmount: "Valor de entrada",
	outputAmount: "Quantidade de saída",
	status: "Status",
	noLimitOrder: "Não {{ orderType }} Pedida",
	cancellingOrder: "Cancelando pedido...",
	cancelLimitOrder: "Comprar {{ outputCurrency }} com {{ inputCurrency }}",
	executionPrice: "Preço de execução",
	seeMore: "Ver mais",
	seeLess: "Ver menos"
};
var buyPage$3 = {
	buyAvaxInfo: "Compre AVAX com moeda fiduciária do nosso parceiro Wyre.",
	privacyInfo: "A Arcanum não armazena seu histórico de compras ou dados pessoais.",
	firstName: "Nome",
	lastName: "Apelido",
	email: "Email",
	buyAvax: "Compre AVAX"
};
var votePage$3 = {
	unlockVotes: "Desbloquear votos",
	updateDelegation: "Atualizar delegação",
	pangolinGovernance: "Governaça do Arcanum",
	earnedPngTokens: "Os tokens {{ pngSymbol }} representam ações de votação na governança do Arcanum. Você pode votar em cada proposta você mesmo ou delegar seus votos a um terceiro .",
	eligibleToVote: "Para ser elegível para votar, você deve ter {{ pngSymbol }} em sua carteira e deve delegar eles ao início da votação. Após o início da votação, você pode pode colocá-los em uma pool ou gastá-los.",
	governanceVotes: "Votações de governança são decididas por maioria simples. Não há quórum necessário.",
	proposals: "Propostas",
	allProposals: "Todas as propostas",
	backToProposals: "Voltar para propostas",
	unlockVoting: "Desbloquear votação ",
	votes: " Votos",
	delegatedTo: "Delegar para:",
	edit: "editar",
	noProposalsFound: "Nenhuma proposta encontrada.",
	proposalCommunityMembers: "Propostas submetidas por membros da comunidade irão aparecer aqui.",
	minimumThreshold: "Um mínimo de 1,000,000 {{ pngSymbol }} é requerido para submeter propostas",
	votingStarted: "Votação iniciada ",
	votingStarts: "Votação inicia em ",
	votingEnded: "Votação terminou ",
	votingEnds: "Votação encerra em ",
	voteFor: "Votos a favor",
	voteAgainst: "Votos contras",
	against: "Contra",
	"for": "A favor",
	details: "Detalhes",
	overview: "Visão geral",
	proposer: "Quem fez a proposta",
	about: "Cerca de",
	vote: "Voto",
	executed: "Executado",
	rejected: "Rejeitado",
	notSupported: "Não suportado nesta cadeia"
};
var IDOPage$3 = {
	pangolinIDOs: "Initial DEX Offering (IDO)",
	pangolinIDODescription: "As ofertas iniciais de DEX (IDO) permitem que os projetos façam crowdfund de seus tokens nativos em trocas descentralizadas. Fizemos parcerias com equipes incríveis para trazer grandes projetos para a comunidade Avalanche.",
	upcomingIDOs: "Por vir",
	endedIDOs: "Terminado",
	allIDOs: "Todos os IDOs",
	noIDOsFound: "Nenhum IDOs encontrado",
	IDOAnnounced: "IDOs anunciados publicamente aparecerão aqui."
};
var swapHooks$3 = {
	connectWallet: "Conectar a uma carteira",
	enterAmount: "Insira um valor",
	selectToken: "Selecione um token",
	enterRecipient: "Digite um destinatário",
	invalidRecipient: "Destinatário inválido",
	insufficient: "Saldo de ",
	balance: " insuficiente"
};
var mintHooks$3 = {
	connectWallet: "Conectar a uma carteira",
	insufficientInputAmount: "Quantidade de entrada insuficiente",
	invalidPair: "Par inválido",
	enterAmount: "Insira um valor",
	insufficient: "Saldo de ",
	balance: " insuficiente"
};
var stakeHooks$3 = {
	connectWallet: "Conectar a uma carteira",
	enterAmount: "Insira um valor"
};
var burnHooks$3 = {
	connectWallet: "Conectar a uma carteira",
	enterAmount: "Insira um valor"
};
var migratePage$3 = {
	stake: "ESTACA",
	unstake: "UNSTAKE",
	add: "ADICIONAR",
	remove: "RETIRAR",
	startMigratingNow: "COMECE A MIGRAR AGORA",
	startMigratingNowDescription: "Abaixo você encontrará todas as Fazendas de que precisará para migrar para os Contratos V2 da Arcanum",
	seeMore: "VER MAIS",
	migrateWithEase: "MIGRAR COM FACILIDADE",
	migrateWithDescription: "Projetamos um assistente elegante, que ajudará a guiá-lo durante o processo de migração de suas fazendas",
	alreadyMigrate: "já migrou",
	walletMigrate: "carteira migrada",
	alreadyEarned: "já ganhou",
	migrateNow: "MIGRAR AGORA",
	learn: "APRENDER",
	moveYourTokensToNewContracts: "Migre suas fazendas para Arcanum V2",
	readyToMigrate: "Pronto para migrar",
	apr: "APR:",
	totalValueLocked: "Valor total bloqueado",
	lowVolatility: "Baixa volatilidade",
	compoundable: "Composta",
	migrate: "Migrar",
	migrationModalDescription: "Percebemos que você tem essas piscinas ... Escolha uma ou adicione uma.",
	choosePool: "Escolha o Pool",
	pool: "Pool",
	availableToDeposit: "Disponível para depositar: ",
	poolInfoDescription: "Agora que você escolheu sua piscina, vamos desamarrá-lo dela.",
	dollarWorth: "Valor em dólar: ",
	usd: "USD",
	yourRate: "Sua taxa: ",
	unclaimedPng: "{{ pngSymbol }} não reivindicado: ",
	shareOfPool: "Participação na Pool: ",
	choose: "ESCOLHER",
	selectAll: "Selecionar tudo",
	loading: "Carregando",
	back: "Voltar",
	availableToUnstake: "Disponível para desestocar: ",
	submittingTransaction: "Enviando transação",
	moveYourTokensToNewContractsDescription: "Como parte da implementação do Arcanum para novos contratos aprimorados, você precisará migrar suas Fazendas. Se precisar de ajuda ou orientação, clique no botão “Aprender”.",
	migrateModalHeading: "Migrar {{ current }} de {{ total }} Fazenda"
};
var dashboardPage$3 = {
	dashboard: "Dashboard",
	greetings: "Greetings kind guests! Let’s ape in today…",
	portfolioValue: "Portfolio Value",
	earned: "Earned",
	coins: "Coins",
	followedWallets: "Followed Wallets",
	earned_dailyIncome: "Daily Income",
	earned_weeklyIncome: "Weekly Income",
	earned_totalEarned: "Total Earned",
	earned_claim: "Claim",
	earned_customizePools: "Customize Pools",
	followed_address: "Address",
	followed_worth: "Worth",
	followed_interact: "Interact"
};
var stakePage$3 = {
	totalStaked: "Total Staked",
	apr: "Annual Percentage Rate",
	seeDetails: "SEE DETAILS",
	stake: "STAKE",
	earn: "Earn {{symbol}}",
	stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$3 = {
	missingCurrencyAmounts: "Valores de moeda ausentes",
	missingTokens: "Tokens ausentes",
	missingDependencies: "Dependências ausentes",
	missingLiquidityAmount: "Quantidade de liquidez ausente",
	couldNotWrap: "Não foi possível fazer Wrap",
	attemptingToConfirmApproval: "Tentando confirmar sem aprovação ou assinatura. Por favor, contate o suporte."
};
var sarTitle$3 = {
	addMore: "ADICIONAR MAIS",
	unstake: "RETIRAR UMA POSIÇÃO",
	compound: "COMPOR RECOMPENSAS",
	claim: "REIVINDICAR RECOMPENSAS",
	interactingID: "Interagindo com o ID: {{ id }}"
};
var sarStake$3 = {
	createNewPosition: "Crie uma nova posição",
	stake: "Stake",
	staking: "Staking",
	walletBalance: "Na wallet {{ balance }} {{ symbol }}",
	max: "MAX",
	dollarValue: "Valor em Dólar",
	buy: "Comprar {{ symbol }}",
	averageAPR: "APR médio",
	startingApr: "APR começando em",
	weeklyDistributed: "{{ symbol }} semanal distribuído",
	confirmDescription: "Uma ação de stake criará um SAR Nft para você. Com esta NFT você pode gerenciar seu stake de {{ symbol }}.",
	successSubmit: "Você depositou com sucesso seus tokens.",
	yourAprRecalculated: "Seu APR será recalculado.",
	summary: "Resumo",
	pending: "Depositando {{ balance }} {{ symbol }}",
	transactionSummary: "Em stake {{ balance }} {{ symbol }}"
};
var sarStakeMore$3 = {
	stakeMore: "Depositar Mais",
	choosePosition: "Escolha uma posição",
	confirmDescription: "Isso adiciona {{ symbol }} à sua posição SAR NFT. Seu saldo original continua a partir da mesmo APR. O APR de seus tokens recém-adicionados começa em 0% e muda com base na duração do stake. Sua NFT mostrará a média.",
	newAPR: "Novo APR",
	add: "Adicionar",
	pending: "Adicionando {{ balance }} {{ symbol }}"
};
var sarUnstake$3 = {
	unstake: "Retirar",
	unstaking: "Retirando {{ balance }} {{ symbol }}",
	stakedBalance: "Depositado {{ balance }} {{ symbol }}",
	confirmDescription: "Vale a pena estar ciente de que retirar suas recompensas fará com que sua APR seja de 0% para esta posição. \nEm vez de retirar, você também pode considerar vender sua NFT.",
	successSubmit: "Você retirou seus tokens com sucesso.",
	pending: "Retirando {{ balance }} {{ symbol }}",
	transactionSummary: "Retirado {{ balance }} {{ symbol }}",
	currentAPR: "APR atual",
	unstakeWarning: "Quando você retira seus tokens, sua média de APR cairá para 0%.",
	aprAfter: "APR após a retirada"
};
var sarCompound$3 = {
	compound: "Compor",
	compounding: "Compondo",
	successSubmit: "Você compôs com sucesso sua posição.",
	pending: "Compondo",
	transactionSummary: "Posição composta",
	aprAfter: "APR Após composição",
	reward: "Recompensas acumuladas",
	description: "Esteja ciente de que a composição de suas recompensas pode diminuir sua TAEG média. Os tokens recentemente depositados começam apartir de 0%, enquanto os tokens antigos continuarão com o mesmo APR. Isso cria a média que é exibida para você",
	noRewards: "Sem recompensas para compor"
};
var sarClaim$3 = {
	claim: "Reivindicar",
	claiming: "Reivindicando",
	description: "Devido à natureza do sistema de stake SAR, reivindicar suas recompensas reduzirá sua APR para 0%. Em vez disso, você pode compor suas recompensas sem perder seu APR.",
	successSubmit: "Você reivindicou com sucesso suas recompensas",
	pending: "Reivindicando",
	transactionSummary: "Recompensas da posição reivindicadas",
	aprAfter: "APR após reivindicação",
	noRewards: "Não há recompensas para reivindicar"
};
var sarPortfolio$3 = {
	noPositions: "Você não tem nenhuma NFT PANGUARDIAN.\nVAMOS TER UMA.",
	start: "COMEÇAR",
	positionId: "ID da posição",
	apr: "APR",
	amount: "Quantidade",
	newest: "Mais recente",
	oldest: "Menos recente",
	sortBy: "Ordernar por"
};
var pangoChef$3 = {
	claimWarning1: "Quando você reivindica sem retirar sua liquidez permanece no pool de mineração.",
	claimWarning2: "Reivindicar suas recompensas reduzirá sua APR para 0. Em vez disso, você pode optar por compor.",
	compoundWarning: "A composição de suas recompensas para a farm {{ token0 }}-{{ token1 }} fará com que suas recompensas sejam apostadas na farm {{ currency }}-{{ png }}. Você precisa adicionar o valor igual de {{ currency }} token para suas recompensas acumuladas de {{ png }}.",
	compoundAmountWarning: "Você precisa adicionar {{ amount }} {{ symbol }} para compor.",
	compoundAmountWarning2: "Tenha cuidado para bloquear sua pool de {{ symbol }} {{ png }} até reivindicar as recompensas desta pool.",
	highVolalityWarning: "Muito cedo, tente em algumas horas",
	compoundSuccess: "Você compôs com sucesso.",
	compoundTransactionSummary: "Farm composta.",
	removeWarning: "A remoção de qualquer valor da fazenda fará com que seu APR seja 0. Você pode, em vez disso, compor suas recompensas sem perder seu APR.",
	lockingPoolZeroWarning: "Você não pode remover sua liquidez ou reivindicar suas recompensas desta farm. Para fazer isso, primeiro você precisa reivindicar sua participação nestas farms: "
};
var bridge$3 = {
	availableRoutes: "Available Routes ({{ number }})",
	activeTransfers: "Active Transfers ({{ number }})",
	historicalTransfers: "Historical Transfers ({{ number }})",
	bridgeCard: {
		advanceOptions: "Advance Options",
		title: "Cross Chain",
		swap: "Swap",
		loader: {
			labels: {
				waitingReceivingChain: "Waiting for receiving chain..."
			},
			bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
		},
		filter: {
			bridgePrioritization: "Bridge Prioritization",
			slippage: "Slippage",
			infiniteApproval: "Infinite Approval",
			activeInfiniteApproval: "Active Infinite Approval",
			bridges: "Bridges",
			exchanges: "Exchanges"
		}
	},
	bridgeInputsWidget: {
		tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
		max: "MAX"
	},
	bridgeRoute: {
		selected: "Selected",
		clickToSelect: "Click to select",
		singleTransaction: "Single transaction including",
		estimatedToken: "Estimated Token: {{ token }}",
		estimatedResult: "Estimated Result: {{ result }}",
		min: "{{ minute }} min",
		gasCost: "{{ gasCost }} Gas Cost"
	},
	bridgeTransfer: {
		date: "Date",
		from: "From",
		to: "To",
		via: "Via",
		state: "State",
		resumeSwap: "Resume Swap"
	},
	bridgePrioritizations: {
		recommended: "Recommended",
		fast: "Fast",
		normal: "Normal"
	}
};
var dropdown$3 = {
	select: "Select"
};
var ptBrTranslation = {
	header: header$3,
	accountDetails: accountDetails$3,
	addressInputPanel: addressInputPanel$3,
	currencyInputPanel: currencyInputPanel$3,
	earn: earn$3,
	menu: menu$3,
	modalView: modalView$3,
	navigationTabs: navigationTabs$3,
	popups: popups$3,
	positionCard: positionCard$3,
	searchModal: searchModal$3,
	settings: settings$3,
	swap: swap$3,
	toggle: toggle$3,
	tokenWarningModal: tokenWarningModal$3,
	transactionConfirmation: transactionConfirmation$3,
	transactionSettings: transactionSettings$3,
	vote: vote$3,
	walletModal: walletModal$3,
	web3ReactManager: web3ReactManager$3,
	web3Status: web3Status$3,
	gasFeeAlert: gasFeeAlert$3,
	addLiquidity: addLiquidity$3,
	airdrop: airdrop$3,
	earnPage: earnPage$3,
	pool: pool$3,
	poolFinder: poolFinder$3,
	removeLiquidity: removeLiquidity$3,
	swapPage: swapPage$3,
	buyPage: buyPage$3,
	votePage: votePage$3,
	IDOPage: IDOPage$3,
	swapHooks: swapHooks$3,
	mintHooks: mintHooks$3,
	stakeHooks: stakeHooks$3,
	burnHooks: burnHooks$3,
	migratePage: migratePage$3,
	dashboardPage: dashboardPage$3,
	stakePage: stakePage$3,
	error: error$3,
	sarTitle: sarTitle$3,
	sarStake: sarStake$3,
	sarStakeMore: sarStakeMore$3,
	sarUnstake: sarUnstake$3,
	sarCompound: sarCompound$3,
	sarClaim: sarClaim$3,
	sarPortfolio: sarPortfolio$3,
	pangoChef: pangoChef$3,
	bridge: bridge$3,
	dropdown: dropdown$3
};

var header$2 = {
	dashboard: "Panel",
	swap: "Swap Yap",
	buy: "Satın Al",
	pool: "Havuz",
	farm: "Farm",
	version1: "1. Versiyon",
	version2: "2. Versiyon",
	stake: "Stake Et",
	newPng: "Yeni {{ pngSymbol }}",
	oldPng: "Eski {{ pngSymbol }}",
	vote: "Oy Ver",
	ido: "IDO",
	charts: "Çizelgeler",
	forum: "Forum",
	pngBreakDown: "{{ symbol }} dağılımınız",
	balance: "Bakiye: ",
	unclaimed: "Talep edilmemiş: ",
	pngPrice: "{{ symbol }} Fiyatı:",
	pngCirculation: "Dolaşan {{ symbol }} Arz:",
	totalSupply: "Toplam Arz",
	makeSureURLWarning: "URL'nin bu olduğundan emin olun:",
	alwaysMakeSureWarning: "Her zaman URL'nin bu olduğundan emin olun:",
	bookmarkIt: "güvenliğiniz için yer imlerine ekleyin.",
	addMetamask: "{{ symbol }}'yi MetaMask'e Ekle",
	bridge: "Köprü",
	ourPartners: "Partnerlerimiz",
	usefulLinks: "Faydalı Linkler",
	comeAndJoinUs: "Aramıza Katıl",
	tryOurNewBetaSite: "Yeni beta sitemizi deneyin",
	returnToLegacySite: "Eski arayüze dön",
	switchToNewUI: "Yeni beta arayüze geç"
};
var accountDetails$2 = {
	connectedWith: "Bağlı: ",
	account: "Hesap",
	disconnect: "Bağlantıyı Kes",
	change: "Değiştir",
	copy: "Adresi Kopyala",
	viewExplorer: "Gezginde görüntüle",
	clearAll: "(hepsini temizle)",
	transactionAppear: "İşlemleriniz burada görünecektir...",
	recentTransactions: "Son İşlemler",
	copied: "Kopyalandı"
};
var addressInputPanel$2 = {
	recipient: "Alıcı",
	viewExplorer: "(Gezginde görüntüle)",
	walletAddress: "Cüzdan Adresi"
};
var currencyInputPanel$2 = {
	selectToken: "Bir token seçin",
	balance: "Bakiye: ",
	max: "Max",
	to: "Hangi tokena"
};
var earn$2 = {
	claimAccumulated: "Birikmiş {{ symbol }} ödüllerini talep et",
	connectWallet: "Cüzdanı Bağla",
	enterAmount: "Bir tutar girin",
	unclaimedReward: "Talep edilmemiş {{ symbol }}",
	claim: "Talep Et",
	claimReward: "{{ symbol }} Ödüllerini Talep Et",
	liquidityRemainsPool: "Ödülleri, likiditenizi çekmeden talep ettiğinizde sağladığınız likidite farmda kalır.",
	withdrawingLiquidity: "{{ amount }} {{ symbol }} Çekiliyor",
	claimingReward: "{{ amount }} {{ symbol }} Talep Ediliyor",
	claimedReward: "{{ symbol }} talep edildi!",
	manage: "Yönet",
	deposit: "Yatır",
	poolRate: "Havuzun getirisi",
	currentReward: "Mevcut ödüller",
	pngPerAvax: "{{ pngSymbol }} (AVAX başına, haftalık)",
	rewardPerWeek: "{{ symbol }} (haftalık)",
	earnUpTo: "Yıllık şu kadara kadar kazanın: ",
	yourRate: "Getiriniz",
	totalDeposited: "Toplam yatırılan",
	totalStaked: "Yatırılan toplam",
	depositLiquidity: "Likidite Yatır",
	attemptingToStakeError: "Onay veya imza olmadan likidite sağlamaya çalışıyorsunuz. Lütfen onay verdikten veya işlemi imzaladıktan sonra tekrar deneyin.",
	transactionSubmitted: "İşlem Gönderildi",
	depositingLiquidity: "Likidite Yatırılıyor",
	depositingToken: "{{ symbol }} Yatırılıyor",
	depositedToken: "{{ symbol }} Yatırıldı",
	availableToDeposit: "Yatırmaya müsait olan miktar: ",
	weeklyRewards: "Haftalık Ödüller",
	missingLiquidityAmount: "eksik likidite miktarı",
	missingDependencies: "eksik değer",
	deposited: "Yatırıldı",
	withdrawDepositedLiquidity: "Yatırılan likiditeyi çek",
	depositedPglLiquidity: "Yatırılan ARL likiditesi:",
	whenYouWithdrawWarning: "Sağladığınız likiditeyi çektiğinizde ARL tokenlarınız ve kazandığınız {{ symbol }}'ler hesabınıza gelecektir. ARL tokenlarının farmdan çekilmesi durumunda ise artık {{ symbol }} kazanamayacaksınız. Asıl tokenlarınız ise siz çekene kadar likidite havuzunda kalacaktır.",
	whenYouWithdrawSingleSideWarning: "Çekim işlemi yaptığınızda {{ symbol }} tokenları talep edilir ve {{ pngSymbol }} tokenlarınız size iade edilir. Bu, {{ pngSymbol }} staking üzerinden artık {{ symbol }} ödülü kazanamayacaksınız anlamına gelir.",
	withdrawAndClaim: "Çek & Ödülleri Talep Et",
	withdrewStakingToken: "{{ symbol }} çekildi!",
	approve: "Onayla",
	poolWeight: "Havuz Ağırlığı",
	withdraw: "Çek",
	extraReward: "Ekstra Ödül",
	poolRewards: "Havuz Ödülleri",
	rewardsIn: "Ödüller: ",
	removeWarning: "Bu havuzdan likiditeyi kaldırıyorsunuz. Bu işlem size jetonlarınızı geri verecektir. Alternatif olarak, ödül kazanmak için jetonlarınızı çiftliğe yatırmayı seçebilirsiniz."
};
var menu$2 = {
	code: "Kaynak Kodu",
	twitter: "Twitter",
	discord: "Discord",
	telegram: "Telegram",
	tutorials: "Rehber",
	idos: "IDO",
	about: "Hakkımızda"
};
var modalView$2 = {
	confirmTransaction: "Bu işlemi cüzdanınızda onaylayın",
	viewTransaction: "İşlemi Explorer'da görüntüleyin"
};
var navigationTabs$2 = {
	useThisTool: "Otomatik olarak görünmeyen havuzlara erişmek için bu aracı kullanın.",
	swap: "Swap Yap",
	pool: "Havuz",
	importPool: "Dışarıdan Havuz Ekle",
	createPair: "İşlem çifti oluştur",
	addLiquidity: "Likidite Ekle",
	removeLiquidity: "Likidite Çıkar",
	whenYouAddLiquidityInfo: "Likidite eklediğinizde tarafınıza pozisyonunuzu temsil eden havuz tokenları verilir. Bu tokenlar, havuzdaki payınıza göre Arcanum üzerinde gerçekleşen işlemlerden komisyon ücreti kazanır ve istenildiği zaman talep edilebilir.",
	removingPoolTokensInfo: "Havuz tokenlarını çekmek istediğinizde; pozisyonunuz, havuzdaki payınızla orantılı olarak mevcut parite üzerinden likidite sağladığınız tokenlara dönüştürülür. İşlemlerden kazandığınız komisyon ücreti, aldığınız tutara dahildir."
};
var popups$2 = {
	tokenListUpdated: "\" {{oldList}} \" token listesi güncellendi: ",
	updateAvailable: "Token listesi için bir güncelleme mevcut: \" {{oldList}} \"",
	viewExplorer: "Gezginde görüntüle",
	hash: "Hash: ",
	added: "eklendi",
	removed: "çıkarıldı",
	tokensUpdated: "tokenlar güncellendi",
	acceptUpdate: "Güncellemeyi kabul et",
	dismiss: "Yoksay"
};
var positionCard$2 = {
	add: "Ekle",
	remove: "Çıkar",
	poolShare: "Havuz payınız:",
	pooled: "Havuzda",
	poolTokens: "Havuz tokenlarınız:",
	manage: "Yönet",
	loading: "Yükleniyor",
	yourPosition: "Pozisyonunuz",
	byAddingLiquidityInfo: "Likidite ekleyerek, havuzdaki payınızla orantılı olarak bu havuzdaki/çiftteki tüm işlemlerden %0.25 komisyon ücreti kazanacaksınız.\n Ücretler havuza eklenir, gerçek zamanlı olarak birikir ve likidite havuzdan çıkarıldığında talep edilebilir."
};
var searchModal$2 = {
	commonBases: "Ortak bazlar",
	tokensPairsHelper: "Bu tokenlar genellikle diğer tokenlarla eşleştiriliyor.",
	addedByUser: "Şu kullanıcı tarafından eklendi: ",
	foundByAddress: "Şu adres tarafından bulundu:",
	remove: "Çıkar",
	add: "Ekle",
	findToken: "Bir token bulmak için adını/sembolünü yazın veya adresini yapıştırın.",
	selectToken: "Bir token seçin",
	tokenSearchPlaceholder: "İsme göre arayın veya adresi yapıştırın",
	tokenName: "Token Adı",
	change: "Değiştir",
	selectList: "Bir liste seçin",
	confirmListRemovalPrompt: "Lütfen \"kaldır\" yazarak bu listeyi kaldırmak istediğinizi onaylayın",
	addList: "Bir Liste Ekle ",
	tokenListHelper: "Token listesine yeni bir ERC20 token listesi ekleyebilirsiniz. Eklemek istediğiniz token listenin URL'sini aşağıya girerek o listeyi kullanabilirsiniz. Üçüncü parti token listelerinin sahte veya kötü amaçlı ERC20 tokenları içerebileceğine lütfen dikkat edin.",
	httpsPlaceholder: "https:// veya ipfs://",
	manageLists: "Listeleri yönet",
	viewList: "Listeyi görüntüle",
	updateList: "Listeyi güncelle",
	removeList: "Listeyi çıkar",
	selected: "Seçildi",
	select: "Seç",
	manageTokenLists: "Token Listelerini Yönet"
};
var settings$2 = {
	areYouSure: "Emin misiniz?",
	expertInfo: "Uzman modu, işlem onayı aşamasını pas geçmenize ve yüksek slipajlı işlemler yapmanıza olanak sağlar.",
	expertWarningCAPS: "BU MODU SADECE NE YAPTIĞINIZI BİLİYORSANIZ KULLANIN.",
	confirm: "onayla",
	confirmExpertMode: "Uzman modunu etkinleştirmek için lütfen \"onayla\" yazın.",
	turnOnExpertMode: "Uzman Modunu Aç",
	transactionSettings: "İşlem Ayarları",
	interfaceSettings: "Arayüz Ayarları",
	toggleExpertMode: "Uzman Modu",
	expertModeHelper: "İşlem onayları atlar ve yüksek slipajlı işlemlere izin verir. Kendi sorumluluğunuzda kullanın.",
	toggleDarkMode: "Karanlık Mod",
	slippage: "Slippage",
	percent: "Percent"
};
var swap$2 = {
	priceImpact: "Fiyat Etkisi",
	priceImpactHelper: "Swap(takas) işleminin büyüklüğüne bağlı olarak piyasa fiyatı ile tahmini fiyat arasında oluşacak fark.",
	liquidityProviderFee: "Likidite Sağlayıcı Ücreti",
	liquidityProviderHelper: "Her swaptan %0.3 oranında komisyon alınır.",
	route: "Rota",
	routingHelper: "İşleminiz için en iyi fiyatı bu tokenlar aracılığıyla izlenen rota veriyor.",
	confirmSwap: "Takası Onayla",
	swapAnyway: "Yine de Takasla",
	confirm: "onayla",
	price: "Fiyat",
	accept: "Kabul Et",
	minimumReceived: "Minimum Alınacak",
	maximumSold: "Maksimum Satılacak",
	transactionRevertHelper: "İşleminiz onaylanmadan önce büyük ve olumsuz bir fiyat hareketi olması halinde işleminiz gerçekleşmeyecektir.",
	priceUpdated: "Fiyat Güncellendi",
	outputEstimated: "Çıktı(hasıla) yaklaşıktır. En az şu kadar alacaksınız: <strong>{{amount}} {{currencySymbol}}</strong> veya işleminiz gerçekleşmeyecektir.",
	inputEstimated: "Girdi yaklaşıktır. En fazla şu kadar satacaksınız: <strong>{{amount}} {{currencySymbol}}</strong> veya işleminiz gerçekleşmeyecektir.",
	outputSentTo: "Çıktı(hasıla) şuraya gönderilecektir: ",
	priceImpactMinPrompt: "Bu takas işleminin fiyata etkisi en az %{{ priceImpact }}'dır. Bu işleme devam etmek için lütfen \"onayla\" yazın.",
	priceImpactHighPrompt: "Bu takas işleminin fiyata etkisi en az %{{ priceImpact }}'dır. Lütfen işleme devam etmek istediğinizi onaylayın."
};
var toggle$2 = {
	on: "Aç",
	off: "Kapat"
};
var tokenWarningModal$2 = {
	tokenImported: "Token dışarıdan eklendi",
	anyoneCanCreateWarning: "Herhangi bir kimse, mevcut tokenların sahte versiyonlarını veya bir tokena sahip olmayan projeleri temsil ettiğini iddia eden tokenları oluşturmak da buna dahil olmak üzere, <em>herhangi bir</em> isimle bir ERC-20 token oluşturabilir.",
	loadArbitraryWarning: "Bu arayüze adresini bildiğiz herhangi bir token eklenebilir. Lütfen dikkatli olun ve rastgele ERC-20 tokenlarıyla etkileşim kurmadan önce gerekli araştırmayı yaptığınıza emin olun.",
	purchaseArbitraryWarning: "Eğer rastgele bir token alırsanız, <strong>geri satamayabilirsiniz.</strong>",
	understand: "Anladım",
	"continue": "Devam et",
	viewExplorer: "Gezginde görüntüle"
};
var transactionConfirmation$2 = {
	waitingConfirmation: "Onay Bekleniyor",
	confirmTransaction: "Bu işlemi cüzdanınızda onaylayın",
	transactionSubmitted: "İşlem Gönderildi",
	viewExplorer: "Gezginde görüntüle",
	close: "Kapat",
	error: "Hata",
	dismiss: "Yoksay",
	addToFarm: "çiftliğe ekle"
};
var transactionSettings$2 = {
	slippageTolerance: "Slipaj toleransı",
	transactionRevertSlippageHelper: "Fiyatın bu yüzdelik değerden daha fazla olumsuz etkilenmesi durumunda işleminiz gerçekleşmeyecektir.",
	transactionDeadline: "İşlemin geçerlilik süresi",
	transactionRevertDeadlineHelper: "İşleminiz, bu değerden daha uzun süre beklemede kalırsa gerçekleşmeyecektir.",
	enterValidSlippage: "Geçerli bir slipaj yüzdesi girin",
	transactionMayFail: "İşleminiz başarısız olabilir",
	transactionMayFrontrun: "İşleminiz önden koşma ile karşılaşabilir",
	transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
	minutes: "dakika"
};
var vote$2 = {
	earnedPng: "{{ pngSymbol }} tokenları size Arcanum'in yönetişiminde oy hakkı tanır.",
	canEitherVote: "Her önergeye kendiniz oy verebilir veya oylarınızı üçüncü bir partiye devredebilirsiniz.",
	delegateVotes: "Oylarınızın Yetkisini Başkasına Verin",
	selfDelegate: "Kendinizi Temsil Edin",
	remove: "Çıkar",
	add: "Ekle",
	delegate: "Yetki Ver",
	delegatingVotes: "Yetki verilmiş olan oylar",
	unlockingVotes: "Oyların Kilidi Kaldırılıyor",
	transactionSubmitted: "İşlem Gönderildi",
	"for": "Önergenin lehine(destekliyorum)",
	against: "Önergenin alehine(karşıyım)",
	vote: "Oy Ver:",
	proposal: "",
	votes: "Oylar",
	submittingVote: "Oy Gönderiliyor",
	confirmTransaction: "Bu işlemi cüzdanınızda onaylayın",
	viewExplorer: "Gezginde görüntüle"
};
var walletModal$2 = {
	wrongNetwork: "Yanlış Ağ",
	errorConnecting: "Bağlantı hatası",
	pleaseConnectAvalanche: "Lütfen doğru Avalanche ağına bağlanın.",
	switchAvalanche: "Avalanche Chain’e Geç",
	errorConnectingRefresh: "Bağlantı hatası. Sayfayı yenilemeyi deneyin.",
	connectToWallet: "Cüzdanı Bağla",
	newToAvalanche: "İlk kez mi Avalanche kullanıyorsunuz?",
	learnMoreWallet: "Cüzdan oluşturma hakkında daha fazla bilgi edinin",
	initializing: "Başlatılıyor...",
	tryAgain: "Tekrar Deneyin"
};
var web3ReactManager$2 = {
	unknownError: "Beklenmedik bir hata oluştu. Lütfen sayfayı yenileyin veya başka bir tarayıcıdan/cihazdan tekrar deneyin."
};
var web3Status$2 = {
	pending: "Bekleniyor",
	wrongNetwork: "Yanlış Ağ",
	error: "Hata",
	connectToWallet: "Bir Cüzdan Bağlayın"
};
var gasFeeAlert$2 = {
	gasFeeReduction: "!!! Düşük İşlem Ücreti !!!",
	transactionsNotAccept: "İşlem ücreti {{ gasPrice }} gwei olarak ayarlanmadığı sürece işlemler kabul edilmeyecektir."
};
var addLiquidity$2 = {
	deposited: "Yatırılan",
	shareOfPool: "Havuzun Payı",
	createPoolSupply: "Havuz Oluştur & Likidite Sağla",
	confirmSupply: "Likiditeyi Onayla",
	giveOrder: "EMIR VER",
	outputEstimated: "Çıktı(hasıla) tahminidir. Fiyat, %{{ allowedSlippage }} oranından daha fazla değişirse işleminiz gerçekleşmeyecektir.",
	creatingPool: "Bir havuz oluşturuyorsunuz",
	willReceive: "Şu kadar elde edeceksiniz:",
	firstLP: "İlk likidite sağlayıcısı sizsiniz.",
	ratioTokens: "Eklediğiniz tokenların oranı, bu havuzun fiyatını belirleyecektir.",
	happyRate: "Orandan memnun olduğunuzda likidite sağla tuşuna basın.",
	initialPrices: "Başlangıçtaki Fiyatlar",
	prices: "Fiyatlar",
	poolShare: "ve havuz payı",
	connectWallet: "Cüzdanı Bağla",
	approve: "Onayla",
	supply: "Likidite Sağla",
	per: " başına ",
	rates: "Oranlar",
	poolTokens: " Havuz Tokenları"
};
var airdrop$2 = {
	claimPngAirdrop: "Airdropdan Gelen {{ pngSymbol }}’leri Talep Et",
	claimPeriodEnded: "Airdropu talep etme süresi sonra erdi.",
	connectWalletViewLiquidity: "Likiditenizi görmek için bir cüzdan bağlayın.",
	noAvailableClaim: "Talep edebileceğiniz mevcut PNG: 0.",
	noUniNoSushi: "UNI veya SUSHI tokenınız mevcut değil. Cüzdanınıza UNI veya SUSHI tokenını eklemek için lütfen buradaki rehberi inceleyin.",
	youHave: "Talep edebileceğiniz mevcut PNG: ",
	pngAvailableClaim: "",
	loading: "Yükleniyor",
	welcomeToTeamPangolin: "Arcanum'e hoşgeldiniz",
	claim: "Talep Et"
};
var earnPage$2 = {
	pangolinLiquidityMining: "Arcanum likidite madenciliği",
	pangolinLiquidityStaking: "Likidite sağlama",
	depositPangolinLiquidity: "Arcanum protokolünün yönetişim tokenı olan {{ pngSymbol }}'yi elde etmek için Arcanum Likidite Sağlayıcı(ARL) tokenlarınızı farma yatırın.",
	depositPangolinStaking: "Daha fazla ödül kazanmak için {{ pngSymbol }} tokenlarınızı staking havuzuna yatırın.",
	currentOpportunities: "Mevcut Fırsatlar",
	readMoreAboutPng: "{{ pngSymbol }} hakkında daha fazla bilgi edinin",
	getInsuranceCoverage: "InsurAce.io üzerinden sigorta teminatı alın",
	getCoverNexusMutual: "Nexus Mutual üzerinden fonlarınızı koruma altına alın",
	importantUpdate: "ÖNEMLİ GÜNCELLEME",
	pangolinGovernanceProposalResult: "Arcanum yönetişiminin 1. önergesinin oylama sonucuna göre: Arcanum, yatırma işlemlerinde kullanılan akıllı kontratlarını değiştirmiştir. 19/04/2021 tarihinde saat 08:59’dan sonra (UTC saat dilimi), likidite sağlama karşılığında verilen tüm ödüller, yeni kontratlara dağıtılacaktır. Geçişten önce ise, tüm ödüller eski kontratlara dağıtılmaya devam edecektir. Yield farming ödüllerinin kesintiye uğramasını önlemek adına likiditenizi eski kontratlardan kaldırmanız ve yeni kontratlara geçiş sağlamanız gerekmektedir. Bununla birlikte havuzlardaki likiditenizi çekmenize veya pozisyonlarınızı değiştirmenize gerek yoktur.",
	oldPngPools: "Eski {{ pngSymbol }} havuzları",
	newPngPools: "Yeni {{ pngSymbol }} havuzları",
	participatingPools: "Katılım sağlanılan havuzlar",
	rewardsNeverEnd: "Ödüller Hiç Bitmiyor!",
	noActiveRewards: "Aktif ödül yok",
	liquidityMining: "Likidite Madenciliği",
	pngStaking: "{{ pngSymbol }} Stake Etme",
	totalStaked: "Yatırılan Toplam",
	poolRate: "Havuzun Getirisi",
	step1: "1. Aşama: ARL token(Arcanum'in likidite tokenı) edinin.",
	pglTokenRequired: "ARL tokenı gereklidir. {{ poolHandle }} havuzuna likidite ekledikten sonra bu sayfadan likidite tokenlarınızı farma yatırabilirsiniz.",
	addPoolLiquidity: "{{ poolHandle }} havuzuna likidite ekle",
	liquidityDeposits: "Likidite yatırımlarınız",
	yourStakedToken: "Stake edilmiş {{ symbol }} tokenlarınız",
	unclaimedReward: "Talep edilmemiş {{ symbol }}’larınız",
	claim: "Talep Et",
	rewardPerWeek: " {{ symbol }} / hafta",
	automagically: "Havuz üzerinde yeni bir çekim veya yatırma işlemi yaptığınızda sözleşme otomatik olarak {{ pngSymbol }}'lerinizi sizin adınıza talep edecek ve cüzdanınıza yollayacaktır.",
	deposit: "Yatır",
	depositStakingTokens: "{{ symbol }} Tokenı Yatır",
	stake: "Stake Et",
	stakeStakingTokens: "{{ symbol }} tokenlarınızı stake edin",
	unstake: "Stakeden çıkar",
	stakingTokensAvailable: "Kullanılabilir {{ symbol }} tokenı",
	getToken: "{{ symbol }} elde edin",
	migrateTitle: "Yatırmış olduğunuz ARL'leri taşıyın",
	migrateDescription: "Arcanum'in tokenomicsi değişti. Bu nedenle önceden yatırmış olduğunuz ARL'leri yeni sözleşmeye taşımanız gerekiyor.",
	migrate: "Taşı"
};
var pool$2 = {
	liquidityProviderRewards: "Likidite sağlayanlara verilen ödüller",
	liquidityProvidersEarn: "Likidite sağlayanlar, havuzdaki paylarıyla orantılı olarak tüm işlemlerden %0.25 komisyon ücreti kazanır. Ücretler havuza eklenir, gerçek zamanlı olarak birikir ve likiditenizi çekerken talep edilebilir.",
	readMoreProviding: "Likidite sağlama hakkında daha fazla bilgi edinin",
	viewStakedLiquidity: "Sağladığınız likiditeyi görüntüleyin",
	yourLiquidity: "Likiditeniz",
	createPair: "Bir işlem çifti oluştur",
	addLiquidity: "Likidite ekle",
	connectWalletToView: "Likiditenizi görüntülemek için bir cüzdan bağlayın.",
	noLiquidity: "Likidite bulunamadı.",
	uniswapV1Found: "Uniswap V1 likiditesi bulundu!",
	noSeePoolJoined: "Likidite sağladığınız bir havuzu görmüyor musunuz?",
	migrateNow: "Şimdi taşı.",
	importIt: "Dışarıdan ekle.",
	seeDetails: "DETAYLARI GÖR",
	totalLockedValue: "Toplam Kilitli Değer",
	yourLockedValue: "Kilitli Değeriniz",
	allFarms: "Tüm çiftlikler",
	yourFarms: "senin çiftliklerin",
	yourPools: "Havuzlarınız",
	noFarms: "Çiftlik bulunamadı.",
	successWithdraw: "Likiditeniz çiftlikten kaldırıldı ve tahakkuk eden ödüller talep edildi!"
};
var poolFinder$2 = {
	connectToFind: "Havuzları bulmak için bir cüzdan bağlayın",
	selectTokenToFind: "Likiditenizi görmek için bir token seçin.",
	selectToken: "Bir Token Seçin",
	poolFound: "Havuz Bulundu!",
	managePool: "Havuzu yönet.",
	noLiquidityYet: "Bu havuzda likiditeniz yok.",
	noPoolFound: "Havuz bulunamadı.",
	addLiquidity: "Likidite ekle.",
	createPool: "Havuz oluştur.",
	invalidPair: "Geçersiz işlem çifti.",
	loading: "Yükleniyor"
};
var removeLiquidity$2 = {
	youWillReceive: "Şu kadar teslim alacaksınız: ",
	simple: "Basit",
	detailed: "Detaylı",
	receiveAvax: "{{ symbol }}'ları Teslim Al",
	receiveWavax: "{{ symbol }}'ları Teslim Al",
	price: "Fiyat:",
	connectWallet: "Cüzdanı Bağla",
	approving: "Onaylanıyor",
	approve: "Onayla",
	approved: "Onaylandı",
	remove: "Çıkar",
	output: "Hasıla",
	amount: "Miktar"
};
var swapPage$2 = {
	addSend: "+ Bir alıcı ekleyin (opsiyonel)",
	toEstimated: "Hangi tokena (yaklaşık)",
	to: "Hangi tokena",
	removeSend: "- Alıcıyı sil",
	price: "Fiyat",
	slippageTolerance: "Slipaj Toleransı",
	connectWallet: "Cüzdanı Bağla",
	insufficientLiquidity: "Yetersiz bakiye.",
	wrap: "Wraple",
	unwrap: "Unwraple",
	approving: "Onaylanıyor",
	approve: "Onayla ",
	approved: "Onaylandı",
	priceImpactHigh: "Fiyat Etkisi Yüksek",
	swap: "Swap Yap",
	anyway: " (Yine de)",
	from: "Hangi tokendan",
	fromEstimated: "Hangi tokendan (yaklaşık)",
	velox: "<1>Velox</1> üzerinden limit emri girin",
	marginSwap: "<1>MarginSwap</1>",
	wowSwap: " veya <1>WOWswap</1> üzerinden kaldıraçlı işlem yapın",
	veeFinance: " veya <1>Vee Finance</1> üzerinden kaldıraçlı işlem yapın",
	gelatoFee: "Gelato Ücreti",
	placeOrder: "Limit Emri Oluştur",
	confirmOrder: "Limit Emrini Onayla",
	"for": "için",
	submittingOrderToSwap: "Limit emri oluşturuluyor",
	limitPrice: "Emir Fiyatı",
	outputWillBeSentTo: "buraya gönderilecek: ",
	sell: "SAT",
	buy: "AL",
	betaRelease: "Bu bir BETA sürümüdür ve riski size ait olmak üzere kullanılmalıdır!",
	trade: "Alım-Satım",
	watchList: "İzleme Listesi",
	yourPortFolio: "Portföyünüz",
	comingSoon: "Çok yakında",
	connectWalletViewPortFolio: "Portföyünüzü görüntülemek için cüzdanı bağlayın.",
	limitOrders: "Limit Emirleri",
	cancelOrder: "Emri iptal et",
	all: "TÜMÜ",
	open: "AÇIK",
	executed: "GERÇEKLEŞTİ",
	cancelled: "İPTAL EDİLDİ",
	inputAmount: "Girdi Miktarı",
	outputAmount: "Çıktı Miktarı",
	status: "Durum",
	noLimitOrder: "Emir No: {{ orderType }}",
	cancellingOrder: "işlemi iptal ediliyor..",
	cancelLimitOrder: "{{ inputCurrency }} ile {{ outputCurrency }} swap yapma",
	executionPrice: "Emrin Gerçekleştiği Fiyat",
	seeMore: "Daha Fazlasını Gör",
	seeLess: "Daha Azını Gör"
};
var buyPage$2 = {
	buyAvaxInfo: "Partnerimiz Wyre aracılığıyla AVAX satın alın.",
	privacyInfo: "Arcanum, satın alma geçmişinizi ya da şahsi bilgilerinizi kaydetmez.",
	firstName: "Ad",
	lastName: "Soyad",
	email: "E-mail",
	buyAvax: "AVAX Satın Al"
};
var votePage$2 = {
	unlockVotes: "Oyların Kilidini Kaldır",
	updateDelegation: "Delegasyonu(Yetkilerdirme) Güncelle",
	pangolinGovernance: "Arcanum Yönetişimi",
	earnedPngTokens: "{{ pngSymbol }} tokenları, Arcanum'in yönetişiminde kullanabildiğiniz oy hakkını temsil eder. Her önergede kendiniz oy verebilir veya oy haklarınızı üçüncü bir partiye devredebilirsiniz.",
	eligibleToVote: "Oy kullanmaya uygun olmak için cüzdanınızda {{ pngSymbol }} tutmanız ve oylama başında {{ pngSymbol }}'lerinizi yetkilendirmeniz gerekir. Oylama başladıktan sonra {{ pngSymbol }}'lerinizi bir farma/havuza yatırabilir veya harcayabilirsiniz.",
	governanceVotes: "Yönetişimin sunduğu önergeler, basit çoğunlukla kararlaştırılır. Ulaşılması veya geçilmesi gereken bir çoğunluk eşiği yoktur.",
	proposals: "Önergeler",
	allProposals: "Tüm Önergeler",
	backToProposals: "Önergelere Geri Dön",
	unlockVoting: "Oylamanın kilidini kaldır",
	votes: " Oylar",
	delegatedTo: "Yetkilendirilen adres:",
	edit: "düzenle",
	noProposalsFound: "Önerge bulunamadı.",
	proposalCommunityMembers: "Topluluk üyeleri tarafından sunulan önergeler burada görünecektir.",
	minimumThreshold: "Önerge sunmak için gerekli olan minimum eşik 1 milyon {{ pngSymbol }}'dir",
	votingStarted: "Oylama başladı ",
	votingStarts: "Oylama başlıyor ",
	votingEnded: "Oylama bitti ",
	votingEnds: "Oylama bitiyor ",
	voteFor: "Lehine(Destekleyen) Oy Ver",
	voteAgainst: "Alehine(Karşı) Oy Ver",
	against: "Karşı Çıkan",
	"for": "Destekleyen",
	details: "Detaylar",
	overview: "Genel Bakış",
	proposer: "Önergeyi sunan",
	about: "Hakkında",
	vote: "Oy",
	executed: "Kabul Edildi",
	rejected: "Reddedildi",
	notSupported: "Bu zincirde desteklenmiyor"
};
var IDOPage$2 = {
	pangolinIDOs: "Initial DEX Offering (IDO)",
	pangolinIDODescription: "Projelerin kendi tokenlarını merkeziyetsiz borsalarda kitle fonlamasına IDO(İlk DEX Teklifleri) adı verilir. Arcanum de Avalanche ekosisteminde çıkan ve bu listede yer alan projelerin bazılarıyla partner oluyor.",
	upcomingIDOs: "Yaklaşan",
	endedIDOs: "Bitti",
	allIDOs: "Tüm IDO'lar",
	noIDOsFound: "IDO bulunamadı",
	IDOAnnounced: "Açıklanan IDO'lar burada görünecektir."
};
var swapHooks$2 = {
	connectWallet: "Cüzdanı Bağla",
	enterAmount: "Bir tutar girin",
	selectToken: "Bir token seçin",
	enterRecipient: "Bir alıcı girin",
	invalidRecipient: "Geçersiz alıcı",
	insufficient: "Yetersiz ",
	balance: " bakiyesi"
};
var mintHooks$2 = {
	connectWallet: "Cüzdanı Bağla",
	insufficientInputAmount: "Yetersiz bakiye",
	invalidPair: "Geçersiz işlem çifti",
	enterAmount: "Bir tutar girin",
	insufficient: "Yetersiz",
	balance: " bakiyesi"
};
var stakeHooks$2 = {
	connectWallet: "Cüzdanı Bağla",
	enterAmount: "Bir tutar girin"
};
var burnHooks$2 = {
	connectWallet: "Cüzdanı Bağla",
	enterAmount: "Bir tutar girin"
};
var migratePage$2 = {
	stake: "STAKE ET",
	unstake: "STAKE ETMEYİ DURDUR",
	add: "EKLE",
	remove: "ÇIKAR",
	startMigratingNow: "ŞİMDİ TAŞIMAYA BAŞLA",
	startMigratingNowDescription: "Aşağıda Arcanum'in V2 akıllı kontratlarına geçiş sağlaması gereken tüm farmları görebilirsiniz.",
	seeMore: "DAHA FAZLASINI GÖR",
	migrateWithEase: "KOLAYLIKLA TAŞIYIN",
	migrateWithDescription: "Farmlarınızı taşıma sürecinde size rehberlik edecek bir sihirbaz tasarladık.",
	alreadyMigrate: "zaten taşındı",
	walletMigrate: "cüzdan taşındı",
	alreadyEarned: "zaten kazanıldı",
	migrateNow: "ŞİMDİ TAŞI",
	learn: "ÖĞREN",
	moveYourTokensToNewContracts: "Farmlarınızı Arcanum V2'ye Taşıyın",
	readyToMigrate: "Taşımaya hazır",
	apr: "APR(Yıllık Getiri Oranı):",
	totalValueLocked: "Toplam Kilitli Değer",
	lowVolatility: "Düşük Volatilite",
	compoundable: "birleştirilebilir",
	migrate: "Taşı",
	migrationModalDescription: "Taşımak istediğiniz havuzları seçin",
	choosePool: "Havuz Seç",
	pool: "Havuz",
	availableToDeposit: "Yatırmaya müsait olan miktar: ",
	poolInfoDescription: "Taşımak istediğiniz miktarı girin",
	dollarWorth: "Dolar Karşılığı: ",
	usd: "USD",
	yourRate: "Getiriniz: ",
	unclaimedPng: "Talep Edilmemiş {{ pngSymbol }}: ",
	shareOfPool: "Havuz Payı: ",
	choose: "SEÇ",
	selectAll: "Hepsini seç",
	loading: "Yükleniyor",
	back: "Geri",
	availableToUnstake: "Stake etmeyi durdurmaya müsait olan miktar: ",
	submittingTransaction: "İşlem gönderiliyor",
	moveYourTokensToNewContractsDescription: "Arcanum'in yeni geliştirilmiş olduğu kontratlara geçişin bir parçası olarak, farmlarınızı taşımanız gerekiyor. Herhangi bir konuda yardıma ihtiyacınız varsa, lütfen “Öğren” tuşuna tıklayın.",
	migrateModalHeading: "{{ total }} farmlar içinden {{ current }}'ı taşı"
};
var dashboardPage$2 = {
	dashboard: "Panel",
	greetings: "Arcanum'e Hoşgeldiniz.",
	portfolioValue: "Portfolyonuzun Değeri",
	earned: "Kazanılan",
	coins: "Coinler",
	followedWallets: "Takip Edilen Cüzdanlar",
	earned_dailyIncome: "Günlük Getiri",
	earned_weeklyIncome: "Haftalık Getiri",
	earned_totalEarned: "Toplam Kazanılan",
	earned_claim: "Talep Et",
	earned_customizePools: "Havuzları Özelleştir",
	followed_address: "Adres",
	followed_worth: "Değer",
	followed_interact: "İncele"
};
var stakePage$2 = {
	totalStaked: "Toplam Stake Edilen Miktar",
	apr: "APR(Yıllık Getiri Oranı)",
	seeDetails: "DETAYLARI GÖR",
	stake: "STAKE ET",
	earn: "{{symbol}} Kazan",
	stakeAndEarn: "{{ pngSymbol }}'lerinizi stake edin ve ödüller kazanın!"
};
var error$2 = {
	missingCurrencyAmounts: "Eksik para birimi tutarları",
	missingTokens: "Eksik jetonlar",
	missingDependencies: "Eksik bağımlılıklar",
	missingLiquidityAmount: "Eksik likidite tutarı",
	couldNotWrap: "Kaydırılamadı",
	attemptingToConfirmApproval: "Onay veya imza olmadan onaylamaya çalışılıyor. Lütfen destek ile iletişime geçin."
};
var sarTitle$2 = {
	addMore: "DAHA EKLE",
	unstake: "BİR POZİSYONU KALDIR",
	compound: "BİLEŞİK ÖDÜLLER",
	claim: "ÖDÜL TALEBİ",
	interactingID: "Kimlik ile etkileşim: {{ id }}"
};
var sarStake$2 = {
	createNewPosition: "Yeni bir pozisyon oluşturma",
	stake: "Kazık",
	staking: "Staking",
	walletBalance: "Cüzdan'da {{ balance }} {{ symbol }}",
	max: "Max",
	dollarValue: "Dolar Değeri",
	buy: "{{ symbol }} satın alın",
	averageAPR: "Ortalama APR",
	startingApr: "APR'nin Başlatılması",
	weeklyDistributed: "Haftalık {{ symbol }} Dağıtıldı",
	confirmDescription: "Bir bahis eylemi sizin için bir SAR Nft yaratacaktır. Bu NFT ile {{ symbol }} payınızı yönetebilirsiniz.",
	successSubmit: "Jetonunuzu başarıyla yatırdınız.",
	yourAprRecalculated: "APR'niz yeniden hesaplanır.",
	summary: "Özet",
	pending: "Staking {{ balance }} {{ symbol }}",
	transactionSummary: "Stake edilmiş {{ balance }} {{ symbol }}"
};
var sarStakeMore$2 = {
	stakeMore: "Bahis Tutarı Daha Fazla",
	choosePosition: "Bir Pozisyon Seçin",
	confirmDescription: "Bu, SAR NFT pozisyonunuza {{ symbol }} ekler. Orijinal bakiyeniz aynı Nisan'dan itibaren devam eder. Yeni eklenen jetonlarınızın APR'si %0'dan başlar ve bahis miktarına göre değişir. NFT'niz ortalamayı gösterecektir.",
	newAPR: "Yeni APR",
	add: "Eklemek",
	pending: "{{ balance }} {{ symbol }} ekleme"
};
var sarUnstake$2 = {
	unstake: "Bahis Dışı",
	unstaking: "Unstaking {{ balance }} {{ symbol }}",
	stakedBalance: "Stake edilmiş {{ balance }} {{ symbol }}",
	confirmDescription: "Ödüllerinizi geri almanın APR'nizi bu pozisyon için% 0'a çıkaracağının farkında olmaya değer. \nRiskten kurtulmak yerine NFT'nizi satmayı da düşünebilirsiniz.",
	successSubmit: "Jetonlarınızı başarıyla kaldırdınız.",
	pending: "Unstaking {{ balance }} {{ symbol }}",
	transactionSummary: "Yatırılmamış {{ balance }} {{ symbol }}",
	currentAPR: "Mevcut APR",
	unstakeWarning: "Bahsi kaldırdığınızda, ortalama APR'niz% 0'a düşecektir.",
	aprAfter: "Bahis Sonrası APR"
};
var sarCompound$2 = {
	compound: "Bileşik",
	compounding: "Bileşik",
	successSubmit: "Pozisyonunuzu başarıyla birleştirdiniz.",
	pending: "Bileşik",
	transactionSummary: "Bileşik pozisyon",
	aprAfter: "Bileşikten Sonra Nisan",
	reward: "Tahakkuk eden ödüller",
	description: "Lütfen ödüllerinizi birleştirmenin ortalama APR'nizi azaltabileceğini unutmayın. Yeni stake edilen jetonlar 0'dan başlar, eski jetonlar aynı APR ile devam eder. Bu, size gösterilen ortalamayı oluşturur.",
	noRewards: "Bestelenecek ödül yok"
};
var sarClaim$2 = {
	claim: "İddia etmek",
	claiming: "Iddia",
	description: "SAR staking sisteminin doğası gereği ödüllerinizi talep etmek APR'nizi 0'a düşürecektir. Bunun yerine APR'nizi kaybetmeden ödüllerinizi birleştirebilirsiniz.",
	successSubmit: "Ödüllerinizi başarıyla aldınız",
	pending: "Iddia",
	transactionSummary: "Talep edilen pozisyon ödülleri",
	aprAfter: "Talep Sonrası APR",
	noRewards: "Talep edilecek ödül yok"
};
var sarPortfolio$2 = {
	noPositions: "Herhangi bir PANGUARDIAN NFT'niz yok.\nSİZE BİR TANE ALABİLİR",
	start: "BAŞLAMAK",
	positionId: "Konum Kimliği",
	apr: "Nisan",
	amount: "Miktar",
	newest: "Yeni",
	oldest: "Eski",
	sortBy: "Sıralama Ölçütü"
};
var pangoChef$2 = {
	claimWarning1: "Likiditenizi çekmeden talep ettiğinizde madencilik havuzunda kalır.",
	claimWarning2: "Ödüllerinizi talep etmek, APR'nizi 0'a düşürür. Bunun yerine birleştirmeyi seçebilirsiniz.",
	compoundWarning: "{{ token0 }}-{{ token1 }} çiftliği için ödüllerinizi birleştirmek, ödüllerinizi {{ para birimi }}-{{ png }} çiftliğine yatırır. {{ currency }} 'a eşit değer eklemeniz gerekir. jeton, tahakkuk eden {{ png }} ödüllerinize.",
	compoundAmountWarning: "Bileşik için {{ amount }} {{ symbol }} eklemeniz gerekiyor.",
	compoundAmountWarning2: "Bu havuzun ödüllerini alana kadar {{ symbol }} {{ png }} havuzunuzu kilitleyeceğinize dikkat edin.",
	highVolalityWarning: "Çok erken, birkaç saat sonra deneyin",
	compoundSuccess: "Çiftliğinizi başarıyla oluşturdunuz.",
	compoundTransactionSummary: "Birleşik çiftlik.",
	removeWarning: "Çiftlikten herhangi bir miktarı çıkarmak, APR'nizi 0'a getirecektir. Bunun yerine ödüllerinizi, APR'nizi kaybetmeden birleştirebilirsiniz.",
	lockingPoolZeroWarning: "Bu çiftlikten likiditenizi kaldıramaz veya ödüllerinizi talep edemezsiniz. Bunu yapmak için önce bu çiftliklerden hissenizi talep etmeniz gerekir: "
};
var bridge$2 = {
	availableRoutes: "Mevcut Rotalar ({{ number }})",
	activeTransfers: "Aktif Transferler ({{ number }})",
	historicalTransfers: "Geçmiş Transferler ({{ number }})",
	bridgeCard: {
		advanceOptions: "Gelişmiş Seçenekler",
		title: "Cross Chain",
		swap: "Swap",
		loader: {
			labels: {
				waitingReceivingChain: "Waiting for receiving chain..."
			},
			bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
		},
		filter: {
			bridgePrioritization: "Bridge Prioritization",
			slippage: "Slippage",
			infiniteApproval: "Infinite Approval",
			activeInfiniteApproval: "Active Infinite Approval",
			bridges: "Bridges",
			exchanges: "Exchanges"
		}
	},
	bridgeInputsWidget: {
		tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
		max: "MAX"
	},
	bridgeRoute: {
		selected: "Seçildi",
		clickToSelect: "Seçmek için tıkla",
		singleTransaction: "Single transaction including",
		estimatedToken: "Tahmini Token: {{ token }}",
		estimatedResult: "Tahmini Result: {{ result }}",
		min: "{{ minute }} dk",
		gasCost: "{{ gasCost }} Gas Cost"
	},
	bridgeTransfer: {
		date: "Tarih",
		from: "From",
		to: "To",
		via: "Üzerinden",
		state: "State",
		resumeSwap: "Resume Swap"
	},
	bridgePrioritizations: {
		recommended: "Önerilen",
		fast: "Hızlı",
		normal: "Normal"
	}
};
var dropdown$2 = {
	select: "Seç"
};
var trTranslation = {
	header: header$2,
	accountDetails: accountDetails$2,
	addressInputPanel: addressInputPanel$2,
	currencyInputPanel: currencyInputPanel$2,
	earn: earn$2,
	menu: menu$2,
	modalView: modalView$2,
	navigationTabs: navigationTabs$2,
	popups: popups$2,
	positionCard: positionCard$2,
	searchModal: searchModal$2,
	settings: settings$2,
	swap: swap$2,
	toggle: toggle$2,
	tokenWarningModal: tokenWarningModal$2,
	transactionConfirmation: transactionConfirmation$2,
	transactionSettings: transactionSettings$2,
	vote: vote$2,
	walletModal: walletModal$2,
	web3ReactManager: web3ReactManager$2,
	web3Status: web3Status$2,
	gasFeeAlert: gasFeeAlert$2,
	addLiquidity: addLiquidity$2,
	airdrop: airdrop$2,
	earnPage: earnPage$2,
	pool: pool$2,
	poolFinder: poolFinder$2,
	removeLiquidity: removeLiquidity$2,
	swapPage: swapPage$2,
	buyPage: buyPage$2,
	votePage: votePage$2,
	IDOPage: IDOPage$2,
	swapHooks: swapHooks$2,
	mintHooks: mintHooks$2,
	stakeHooks: stakeHooks$2,
	burnHooks: burnHooks$2,
	migratePage: migratePage$2,
	dashboardPage: dashboardPage$2,
	stakePage: stakePage$2,
	error: error$2,
	sarTitle: sarTitle$2,
	sarStake: sarStake$2,
	sarStakeMore: sarStakeMore$2,
	sarUnstake: sarUnstake$2,
	sarCompound: sarCompound$2,
	sarClaim: sarClaim$2,
	sarPortfolio: sarPortfolio$2,
	pangoChef: pangoChef$2,
	bridge: bridge$2,
	dropdown: dropdown$2
};

var header$1 = {
	dashboard: "Dashboard",
	swap: "Hoán đổi",
	buy: "Mua",
	pool: "Bể",
	farm: "Farm",
	version1: "Phiên bản 1",
	version2: "Phiên bản 2",
	stake: "Stake",
	newPng: "{{ pngSymbol }} mới",
	oldPng: "{{ pngSymbol }} cũ",
	vote: "Bình chọn",
	ido: "IDO",
	charts: "Bảng",
	forum: "Diễn đàn",
	pngBreakDown: "{{ symbol }} của bạn gặp sự cố",
	balance: "Số dư: ",
	unclaimed: "Chưa được nhận: ",
	pngPrice: "Giá {{ symbol }}:",
	pngCirculation: "Tổng {{ symbol }} đang lưu thông:",
	totalSupply: "Tổng cung",
	makeSureURLWarning: "Đảm bảo rằng URL là:",
	alwaysMakeSureWarning: "Luôn đảm bảo rằng URL là:",
	bookmarkIt: "Đánh dấu nó để an toàn.",
	addMetamask: "Thêm {{ symbol }} vào MetaMask",
	bridge: "Cầu",
	ourPartners: "Những cộng sự của chúng ta",
	usefulLinks: "LIÊN KẾT HỮU ÍCH",
	comeAndJoinUs: "Hãy đến và tham gia cùng chúng tôi",
	tryOurNewBetaSite: "Hãy thử trang web beta mới của chúng tôi",
	returnToLegacySite: "Quay lại trang web cũ",
	switchToNewUI: "Chuyển sang giao diện người dùng mới"
};
var accountDetails$1 = {
	connectedWith: "Kết nối với",
	account: "Tài khoản",
	disconnect: "Mất kết nối",
	change: "Thay đổi",
	copy: "Sao chép địa chỉ",
	viewExplorer: "Xem trên explorer",
	clearAll: "(xóa tất cả)",
	transactionAppear: "Các giao dịch của bạn sẽ xuất hiện tại đây ...",
	recentTransactions: "Các giao dịch gần đây",
	copied: "Sao chép"
};
var addressInputPanel$1 = {
	recipient: "Người nhận",
	viewExplorer: "(Xem trên explorer)",
	walletAddress: "Địa chỉ ví"
};
var currencyInputPanel$1 = {
	selectToken: "Chọn token",
	balance: "Số dư: ",
	max: "MAX",
	to: "Tới"
};
var earn$1 = {
	claimAccumulated: "Yêu cầu phần thưởng {{symbol}} tích lũy được",
	connectWallet: "Kết nối ví",
	enterAmount: "Nhập số lượng",
	unclaimedReward: " Phần thưởng chưa được nhận{{ symbol }}",
	claim: "nhận",
	claimReward: "{{ symbol }} Nhận phần thưởng",
	liquidityRemainsPool: "Nếu bạn yêu cầu khoản thanh khoản của mình mà không rút tiền, tiền của bạn sẽ vẫn ở trong bể khai thác.",
	withdrawingLiquidity: "Rút {{ amount }} {{ symbol }}",
	claimingReward: "Đang nhận phần thưởng {{ amount }} {{ symbol }}",
	claimedReward: "{{ symbol }} đã nhận!",
	manage: "Quản lý",
	deposit: "Gửi",
	poolRate: "Tỷ suất bể",
	currentReward: "Phần thưởng hiện tại",
	pngPerAvax: "{{ pngSymbol }}/tuần trên mỗi AVAX",
	rewardPerWeek: "{{ symbol }} / Tuần",
	earnUpTo: "Lợi nhuận hàng năm lên đến",
	yourRate: "Tỷ lệ của bạn",
	totalDeposited: "Tổng giá trị đã gửi",
	totalStaked: "Tổng số giá trị đã đặt cổ phần",
	depositLiquidity: "Ký gửi thanh khoản",
	attemptingToStakeError: "Đang cố gắng đăt cổ phần mà không có sự chấp thuận hoặc chữ ký. Xin vui lòng liên hệ bộ phận hỗ trợ",
	transactionSubmitted: "Giao dịch đã được gửi",
	depositingLiquidity: "Đang gửi thanh khoản",
	depositingToken: "Đang gửi {{ symbol }}",
	depositedToken: "Đã gửi{{ symbol }}",
	availableToDeposit: "Khả dụng để gửi: ",
	weeklyRewards: "Phần thưởng hàng tuần",
	missingLiquidityAmount: "Số lượng thanh khoản bị mất",
	missingDependencies: "Mất phụ thuộc",
	deposited: "Đã gửi",
	withdrawDepositedLiquidity: "Rút thanh khoản đã gửi",
	depositedPglLiquidity: "Thanh khoản ARL đã gửi:",
	whenYouWithdrawWarning: "Khi bạn rút tiền, số phần thưởng {{ symbol }} được nhận và mã thông báo Arcanum Liquidity của bạn, ARL, được trả lại cho bạn. Bạn sẽ không được thưởng thêm {{ symbol }} trên mã thanh khoản này nữa. Số token thanh khoản ban đầu vẫn còn lại trong bể",
	whenYouWithdrawSingleSideWarning: "Khi bạn rút tiền, {{symbol}} của bạn sẽ được nhận và {{ pngSymbol }} của bạn sẽ được trả lại. Bạn sẽ không còn kiếm được phần thưởng {{Symbol}} trên token {{ pngSymbol }} này nữa.",
	withdrawAndClaim: "Rút và nhận",
	withdrewStakingToken: "Đã rút!{{ symbol }}",
	approve: "Chấp nhận",
	poolWeight: "Khối lượng bể",
	withdraw: "Rút",
	extraReward: "Phần thưởng bổ sung",
	poolRewards: "Phần thưởng hồ bơi",
	rewardsIn: "Phần thưởng trong",
	removeWarning: "Bạn đang xóa thanh khoản khỏi nhóm này. Hành động này sẽ trả lại cho bạn các mã thông báo của bạn. Ngoài ra, bạn có thể chọn đặt cược mã thông báo của mình vào trang trại để kiếm phần thưởng."
};
var menu$1 = {
	code: "Mã",
	twitter: "Twitter",
	discord: "Discord",
	telegram: "Telegram",
	tutorials: "Hướng dẫn",
	idos: "IDOs",
	about: "Thông tin về chúng tôi"
};
var modalView$1 = {
	confirmTransaction: "Xác nhận giao dịch này trong ví của bạn",
	viewTransaction: "Xem giao dịch trên Explorer"
};
var navigationTabs$1 = {
	useThisTool: "Sử dụng công cụ này để tìm các cặp không tự động xuất hiện trong giao diện.",
	swap: "Hoán đổi",
	pool: "Bể",
	importPool: "Nhập bể",
	createPair: "Tạo cặp",
	addLiquidity: "Thêm thanh khoản",
	removeLiquidity: "Loại bỏ thanh khoản",
	whenYouAddLiquidityInfo: "Khi bạn thêm thanh khoản, bạn sẽ nhận được mã token chung đại diện cho cổ phần của bạn trong bể. Các mã token này sẽ được tự động phân phối phần thưởng dựa vào cổ phần của bạn trong bể. Bạn có thể đổi mã token của mình trong bể bất cứ lúc nào!",
	removingPoolTokensInfo: "Việc xóa mã token chung sẽ chuyển đổi vị trí của bạn trở lại thành các mã token cơ bản với tỷ lệ hiện tại, tỷ lệ thuận với thị phần của bạn trong nhóm. Phí tích lũy được bao gồm trong số tiền bạn nhận được."
};
var popups$1 = {
	tokenListUpdated: "Danh sách mã token \" {{oldList}} \" đã được cập nhật đến ",
	updateAvailable: "Bản cập nhật khả dụng cho danh sách token\" {{oldList}} \"",
	viewExplorer: "Xem trên explorer",
	hash: "Băm:",
	added: "thêm",
	removed: "loại bỏ",
	tokensUpdated: "Các token đã cập nhật",
	acceptUpdate: "Chấp nhận cập nhật",
	dismiss: "Bỏ qua"
};
var positionCard$1 = {
	add: "Thêm",
	remove: "Loại bỏ",
	poolShare: "Cổ phần của bạn trong bể:",
	pooled: "Chung vốn",
	poolTokens: "Token bể của bạn:",
	manage: "Quản lý",
	loading: "Đang tải",
	yourPosition: "Vị thế của bạn",
	byAddingLiquidityInfo: "Bằng cách thêm thanh khoản, bạn sẽ nhận được 0,3% tất cả các giao dịch trên cặp tiền này tỷ lệ với phần của bạn trong bể .\n Phí được thêm vào bể, sẽ tích lũy trong thời gian thực và có thể được nhận bằng cách rút thanh khoản của bạn ."
};
var searchModal$1 = {
	commonBases: "Cơ sở chung",
	tokensPairsHelper: "Các mã token này thường được ghép với các mã token khác.",
	addedByUser: "Đã thêm bởi người dùng",
	foundByAddress: "Đã tìm thấy bởi địa chỉ",
	remove: "loại bỏ",
	add: "Thêm",
	findToken: "Tìm mã token bằng cách tìm kiếm tên hoặc ký hiệu của nó hoặc bằng cách dán địa chỉ của nó bên dưới.",
	selectToken: "Lựa chọn một token",
	tokenSearchPlaceholder: "Tìm tên hoặc dán địa chỉ",
	tokenName: "Tên Token",
	change: "Thay đổi",
	selectList: "Lựa chọn một danh sách",
	confirmListRemovalPrompt: "Vui lòng xác nhận rằng bạn muốn xóa danh sách này bằng cách nhập REMOVE",
	addList: "Thêm một danh sách ",
	tokenListHelper: "Danh sách mã token là một đặc điểm kỹ thuật mở cho danh sách mã token ERC20. Bạn có thể sử dụng bất kỳ danh sách mã token nào bằng cách nhập URL của nó vào bên dưới. Lưu ý rằng danh sách mã token của bên thứ ba có thể chứa mã token ERC20 giả mạo hoặc độc hại.",
	httpsPlaceholder: "https:// hoặc ipfs://",
	manageLists: "Quản lý danh sách",
	viewList: "Quan sát danh sách",
	updateList: "Cập nhật danh sách",
	removeList: "Loại bỏ danh sách",
	selected: "Đã chọn",
	select: "Chọn",
	manageTokenLists: "Quản lý danh sách token"
};
var settings$1 = {
	areYouSure: "Bạn chắc chắn chứ?",
	expertInfo: "Chế độ chuyên gia tắt lời nhắc xác nhận giao dịch và cho phép các giao dịch trượt giá cao thường dẫn đến tỷ giá xấu và mất tiền.",
	expertWarningCAPS: "CHỈ SỬ DỤNG CHẾ ĐỘ NÀY NẾU BẠN BIẾT BẠN ĐANG LÀM GÌ.",
	confirm: "xác nhận",
	confirmExpertMode: "Vui lòng đánh từ \"confirm\" để kích hoạt chế độ chuyên gia.",
	turnOnExpertMode: "Bật chế độ chuyên gia",
	transactionSettings: "Cài đặt giao dịch",
	interfaceSettings: "Giao diện cài đặt",
	toggleExpertMode: "Chuyển đổi chế độ chuyên gia",
	expertModeHelper: "Bỏ qua các phương thức xác nhận và cho phép các giao dịch có độ trượt cao. Sẽ sử dụng với nguy cơ của riêng bạn .",
	toggleDarkMode: "Chuyển đổi chế độ ban đêm",
	slippage: "Slippage",
	percent: "Percent"
};
var swap$1 = {
	priceImpact: "Tác động giá",
	priceImpactHelper: "Chênh lệch giữa giá thị trường và giá ước tính do khối lượng chuyển đổi.",
	liquidityProviderFee: "Phí người cung cấp thanh khoản",
	liquidityProviderHelper: "Một phần của mỗi giao dịch (0,30%) được chuyển đến các người cung cấp thanh khoản như một biện pháp để khuyến khích giao thức. ",
	route: "Lộ tuyến",
	routingHelper: "Định tuyến thông qua các mã token này đưa ra giá tốt nhất cho giao dịch của bạn .",
	confirmSwap: "Xác nhận hóan đổi",
	swapAnyway: "Hoán đổi dù sao đi nữa",
	confirm: "xác nhận",
	price: "Giá",
	accept: "Chấp nhận",
	minimumReceived: "Nhận được tối thiểu",
	maximumSold: "Bán tối đa",
	transactionRevertHelper: "Giao dịch của bạn sẽ hoàn lại nếu có một biến động giá lớn, bất lợi trước khi nó được xác nhận .",
	priceUpdated: "Giá đã được cập nhật",
	outputEstimated: "Đầu ra được ước tính.Bạn sẽ nhận lại tối thiểu <strong>{{amount}} {{currencySymbol}}</strong> hoặc giao dịch sẽ hoàn lại.",
	inputEstimated: "Đầu vào được ước tính. Bạn sẽ bán được nhiều nhất <strong>{{amount}} {{currencySymbol}}</strong> hoặc giao dịch sẽ hoàn lại.",
	outputSentTo: "Đầu ra sẽ được gửi tới ",
	priceImpactMinPrompt: "Sự hoán đổi này có tác động về giá ít nhất là  {{ priceImpact }}%. Vui lòng gõ từ \"confirm\" để tiếp tục thao tác hoán đổi này.",
	priceImpactHighPrompt: "Sự hoán đổi này có tác động về giá ít nhất là  {{ priceImpact }}%. Vui lòng xác nhận rằng bạn muốn tiếp tục thao tác hoán đổi này."
};
var toggle$1 = {
	on: "Mở",
	off: "Tắt"
};
var tokenWarningModal$1 = {
	tokenImported: "Đã nhập mã token",
	anyoneCanCreateWarning: "Bất kỳ ai cũng có thể tạo mã thông báo ERC-20 trên Avalanche với  <em>any</em> tên, bao gồm cả việc tạo các phiên bản giả mạo của mã token hiện có và mã token tuyên bố đại diện cho các dự án không có mã token.",
	loadArbitraryWarning: "Giao diện này có thể tải mã token tùy chỉnh theo địa chỉ. Vui lòng thận trọng hơn và thực hiện nghiên cứu của bạn khi tương tác với các mã token ERC-20 tùy chỉnh.",
	purchaseArbitraryWarning: "Nếu bạn mua một mã token tùy chỉnh, <strong>bạn có thể không bán lại được.</strong>",
	understand: "Tôi hiểu",
	"continue": "Tiếp tục",
	viewExplorer: "Xem trên explorer"
};
var transactionConfirmation$1 = {
	waitingConfirmation: "Đang chờ xác nhận",
	confirmTransaction: "Xác nhận giao dịch này trong ví của bạn",
	transactionSubmitted: "Giao dịch đã được gửi đi",
	viewExplorer: "Xem trên explorer",
	close: "Đóng",
	error: "Lỗi",
	dismiss: "Bỏ qua",
	addToFarm: "Thêm vào trang trại"
};
var transactionSettings$1 = {
	slippageTolerance: "Chống trượt giá",
	transactionRevertSlippageHelper: "Giao dịch của bạn sẽ hoàn nguyên nếu giá thay đổi bất lợi hơn tỷ lệ phần trăm này.",
	transactionDeadline: "Thời hạn giao dịch",
	transactionRevertDeadlineHelper: "Giao dịch của bạn sẽ hoàn nguyên nếu nó đang chờ xử lý lâu hơn thế này.",
	enterValidSlippage: "Nhập phần trăm trượt giá hợp lệ ",
	transactionMayFail: "Giao dịch của bạn có thể thất bại",
	transactionMayFrontrun: "Giao dịch của bạn có thể bị chèn",
	transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
	minutes: "phút"
};
var vote$1 = {
	earnedPng: "Mã token {{ pngSymbol }} kiếm được đại diện cho cổ phần biểu quyết trong quản trị Arcanum.",
	canEitherVote: "Bạn có thể tự bỏ phiếu cho từng đề xuất hoặc ủy thác phiếu bầu của mình cho bên thứ ba. ",
	delegateVotes: "Phiếu bầu ủy quyền",
	selfDelegate: "Tự ủy quyền",
	remove: "Loại bỏ",
	add: "Thêm",
	delegate: "Ủy quyền",
	delegatingVotes: "Đang ủy quyền phiếu bầu",
	unlockingVotes: "Đang mở khóa phiếu bầu",
	transactionSubmitted: "Giao dịch đã được gửi",
	"for": "cho",
	against: "chống",
	vote: "Bầu",
	proposal: "đề xuất",
	votes: "những phiếu bầu",
	submittingVote: "Đang gửi phiếu bầu",
	confirmTransaction: "Xác nhận giao dịch này trên ví của bạn",
	viewExplorer: "Xem trên explorer"
};
var walletModal$1 = {
	wrongNetwork: "Sai mạng lưới",
	errorConnecting: "Kết nỗi xảy ra lỗi",
	pleaseConnectAvalanche: "Vui lòng kết nối với mạng Avalanche thích hợp.",
	switchAvalanche: "Chuyển sang chuỗi Avalanche",
	errorConnectingRefresh: "Lỗi khi kết nối.Thử làm mới trang",
	connectToWallet: "Kết nối tới một ví",
	newToAvalanche: "Bạn mới sử dụng Avalanche? ",
	learnMoreWallet: "Tìm hiểu thêm về cách thiết lập ví",
	initializing: "Đang khởi tạo...",
	tryAgain: "Thử lại"
};
var web3ReactManager$1 = {
	unknownError: "Oops! Đã xảy ra lỗi không xác định. Vui lòng làm mới trang hoặc truy cập từ trình duyệt hoặc thiết bị khác. "
};
var web3Status$1 = {
	pending: "Đang chờ xử lý",
	wrongNetwork: "Sai mạng lưới",
	error: "Lỗi",
	connectToWallet: "Kết nối với một ví"
};
var gasFeeAlert$1 = {
	gasFeeReduction: "!!! Giảm phí gas !!!",
	transactionsNotAccept: "Giao dịch sẽ không được chấp nhận trừ khi phí gas được đặt thành {{ gasPrice }} gwei."
};
var addLiquidity$1 = {
	deposited: "Ký gửi",
	shareOfPool: "Cổ phần bể",
	createPoolSupply: "Tạo bể & nguồn cung cấp",
	confirmSupply: "Xác nhận cung cấp",
	giveOrder: "GIVE ORDER",
	outputEstimated: "Đầu ra được ước tính. Nếu giá thay đổi nhiều hơn {{ allowedSlippage }}% giao dịch của bạn sẽ hoàn nguyên.",
	creatingPool: "Bạn đang tạo ra một bể",
	willReceive: "Bạn sẽ nhận",
	firstLP: "Bạn là người đầu tiên cung cấp thanh khoản.",
	ratioTokens: "Tỷ lệ mã token bạn thêm vào sẽ đặt giá của bể này.",
	happyRate: "Một khi bạn hài lòng với tỷ lệ, nhấp Supply để tiến hành xem xét.",
	initialPrices: "Giá ban đầu",
	prices: "Giá",
	poolShare: "và cổ phần bể",
	connectWallet: "Kết nối ví",
	approve: "Chấp nhận ",
	supply: "Cung cấp",
	per: " mỗi ",
	rates: "Tỷ lệ",
	poolTokens: " Bể token"
};
var airdrop$1 = {
	claimPngAirdrop: "Nhận {{ pngSymbol }} từ Aidrop",
	claimPeriodEnded: "Thời gian nhận airdrop đã kết thúc.",
	connectWalletViewLiquidity: "Kết nối với ví để tìm hiều thanh khoản của bạn.",
	noAvailableClaim: "Bạn không có phần thưởng nào.",
	noUniNoSushi: "Bạn không có mã token UNI hoặc SUSHI. Vui lòng làm theo hướng dẫn tại đây để thêm mã token UNI hoặc SUSHI vào ví của bạn .",
	youHave: "Bạn có ",
	pngAvailableClaim: " {{ pngSymbol }} khả dụng để nhận",
	loading: "Đang tải",
	welcomeToTeamPangolin: "Chào mừng đến đội Pagonlin",
	claim: "Nhận "
};
var earnPage$1 = {
	pangolinLiquidityMining: "Khai thác thanh khoản Arcanum",
	pangolinLiquidityStaking: "Đặt cổ phần Arcanum {{ pngSymbol }} ",
	depositPangolinLiquidity: "Gửi mã token ARL của vị thế cung cấp thanh khoản Arcanum của bạn để nhận {{ pngSymbol }}, mã thông báo quản trị giao thức Arcanum.",
	depositPangolinStaking: "Gửi và đặt cổ phần mã token {{ pngSymbol }} của bạn để nhận được nhiều token hơn.",
	currentOpportunities: "Cơ hội hiện tại",
	readMoreAboutPng: "Tìm hiểu nhiều hơn về {{ pngSymbol }}",
	getInsuranceCoverage: "Nhận trang bìa trên InsurAce.io",
	getCoverNexusMutual: "Nhận trang bìa trên Nexus Mutual",
	importantUpdate: "CẬP NHẬT QUAN TRỌNG",
	pangolinGovernanceProposalResult: "Theo kết quả của đề xuất quản trị Arcanum 1, Arcanum đang thay đổi các hợp đồng đặt cổ phần! Sau khoảng 08:59 UTC vào ngày 19 tháng 4, tất cả phần thưởng đặt cổ phần sẽ được phân phối cho các hợp đồng đặt cổ phần mới. Trước khi chuyển đổi, tất cả phần thưởng sẽ vẫn được phân phối cho các hợp đồng cũ. Để tránh bị gián đoạn việc kiếm phần thưởng farming, bạn cần loại bỏ thanh khoản của mình khỏi các hợp đồng cũ và thực hiện lại các hợp đồng mới. Bạn không cần phải xóa thanh khoản khỏi bể của mình hoặc thay đổi vị thế của mình. ",
	oldPngPools: "Những bể {{ pngSymbol }} cũ",
	newPngPools: "Những bể {{ pngSymbol }} mới",
	participatingPools: "Đang tham gia vào các bể",
	rewardsNeverEnd: "Phần thưởng không bao giờ kết thúc!",
	noActiveRewards: "Không có phần thưởng hoạt động",
	liquidityMining: "Khai thác thanh khoản",
	pngStaking: "Đang đặt cổ phần {{ pngSymbol }}",
	totalStaked: "Tổng số cổ phần đã đặt",
	poolRate: "Tỷ suất bể",
	step1: "Bước 1. Nhận token thanh khoản Arcanum (ARL)",
	pglTokenRequired: "Mã token ARL là bắt buộc. Khi bạn thêm thanh khoản vào {{ poolHandle }} bể bạn có thể đặt cổ phần mã token thanh khoản của mình trên trang này.",
	addPoolLiquidity: "Thêm {{ poolHandle }} thanh khoản",
	liquidityDeposits: "Số tiền thanh khoản của bạn",
	yourStakedToken: "Số cổ phần {{ symbol }} đã đặt của bạn",
	unclaimedReward: "Số {{ symbol }} của bạn chưa nhận",
	claim: "Nhận",
	rewardPerWeek: " {{ symbol }} / tuần",
	automagically: "Khi bạn rút tiền, hợp đồng sẽ tự động nhận phần thưởng {{ pngSymbol }} thay cho bạn! ",
	deposit: "Gửi",
	depositStakingTokens: "Gửi token {{ symbol }}",
	stake: "Đặt cổ phần",
	stakeStakingTokens: "Đặt cổ phần {{ symbol }}",
	unstake: "Rút cổ phần",
	stakingTokensAvailable: "{{ symbol }} khả dụng",
	getToken: "Nhận {{ symbol }}",
	migrateTitle: "Di chuyển ARL xếp chồng của bạn",
	migrateDescription: "Arcanum đã thay đổi tokenomics. Bạn sẽ cần di chuyển ARL xếp chồng của mình sang hợp đồng mới",
	migrate: "Di cư"
};
var pool$1 = {
	liquidityProviderRewards: "Phần thưởng người cung cấp thanh khoản",
	liquidityProvidersEarn: "Những người cung cấp thanh khoản kiếm được một khoản phí 0,3% cho tất cả các giao dịch tỷ lệ với cổ phần của họ trong bể. Phí được thêm vào bể, tích lũy trong thời gian thực và có thể được nhận bằng cách rút tiền thanh khoản của bạn.",
	readMoreProviding: "Tìm hiểu thêm về cung cấp thanh khoản",
	viewStakedLiquidity: "Quan sát số lượng thanh khoản đã cung cấp của bạn",
	yourLiquidity: "Số lượng thanh khoản của bạn",
	createPair: "Tạo một cặp",
	addLiquidity: "Thêm thanh khoản",
	connectWalletToView: "Kết nối với một ví bất kỳ để quan sát thanh khoản của bạn",
	loading: "Đang tải",
	noLiquidity: "Không tìm thấy thanh khoản.",
	uniswapV1Found: "Thanh khoản uniswap V1 được tìm thấy",
	noSeePoolJoined: "Bạn không tìm thấy bể mà bạn đã tham gia?",
	migrateNow: "Chuyển đổi ngay bây giờ.",
	importIt: "Nhập.",
	seeDetails: "XEM CHI TIẾT",
	totalLockedValue: "Tổng giá trị đã khóa",
	yourLockedValue: "Giá trị đã khóa của bạn",
	allFarms: "tất cả các trang trại",
	yourFarms: "trang trại của bạn",
	yourPools: "Hồ bơi của bạn",
	noFarms: "Không tìm thấy trang trại nào.",
	successWithdraw: "Thanh khoản của bạn đã bị xóa khỏi trang trại và đã nhận được phần thưởng tích lũy!"
};
var poolFinder$1 = {
	connectToFind: "Kêt nối với một ví để nhìn thấy bể",
	selectTokenToFind: "Chọn một token để tìm thanh khoản của bạn.",
	selectToken: "SChọn một token",
	poolFound: "Bể đã tìm thấy!",
	managePool: "Quản lý bể này.",
	noLiquidityYet: "Bạn chưa có thanh khoản trong bể này.",
	noPoolFound: "Không tìm thấy bể.",
	addLiquidity: "Thêm thanh khoản.",
	createPool: "Tạo bể.",
	invalidPair: "Cặp không hợp lệ.",
	loading: "Đang tải"
};
var removeLiquidity$1 = {
	youWillReceive: "Bạn sẽ nhận",
	simple: "Đơn giản",
	detailed: "Chi tiết",
	receiveAvax: "Nhận {{ symbol }}",
	receiveWavax: "Nhận {{ symbol }}",
	price: "Giá:",
	connectWallet: "Kết nối ví",
	approving: "Đang chấp nhận",
	approve: "Chấp nhận",
	approved: "Đã chấp nhận",
	remove: "Loại bỏ",
	output: "Đầu ra",
	amount: "Số lượng"
};
var swapPage$1 = {
	addSend: "+ Thêm lần gửi (tùy chọn) ",
	toEstimated: "Đến (đã ước tính)",
	to: "Đến",
	removeSend: "- Xóa gửi",
	price: "Giá",
	slippageTolerance: "Chống trượt giá",
	connectWallet: "Kết nối ví",
	insufficientLiquidity: "Không đủ thanh khoản cho hoán đổi này.",
	wrap: "Bọc",
	unwrap: "Gỡ bọc",
	approving: "Đang chấp nhận",
	approve: "Chấp nhận ",
	approved: "Đã chấp nhận",
	priceImpactHigh: "Tác động giá cao",
	swap: "Hoán đổi",
	anyway: " Dù sao đi nữa",
	from: "Từ",
	fromEstimated: "Từ (ước tính)",
	velox: "Đặt lệnh giới hạn trên  <1>Velox</1>",
	marginSwap: "Hoán đổi với đòn bẩy trên <1>MarginSwap</1>",
	wowSwap: " hoặc <1>WOWswap</1>",
	veeFinance: " hoặc <1>Vee Finance</1>",
	gelatoFee: "Gelato Học phí",
	placeOrder: "Đặt hàng",
	confirmOrder: "Xác nhận đơn hàng",
	"for": "vì",
	submittingOrderToSwap: "Gửi đơn đặt hàng để hoán đổi",
	limitPrice: "Giá giới hạn",
	outputWillBeSentTo: "Đầu ra sẽ được gửi đến",
	sell: "sell",
	buy: "mua",
	betaRelease: "Đây là bản phát hành BETA và bạn nên tự chịu rủi ro khi sử dụng!",
	trade: "Buôn bán",
	watchList: "WatchList",
	yourPortFolio: "Danh mục đầu tư của bạn",
	comingSoon: "Sắp có",
	connectWalletViewPortFolio: "Kết nối với ví để xem danh mục đầu tư của bạn.",
	limitOrders: "Đơn hàng giới hạn",
	cancelOrder: "Hủy đơn hàng",
	all: "TẤT CẢ",
	open: "MỞ",
	executed: "THỰC THI",
	cancelled: "HỦY",
	inputAmount: "Số lượng đầu vào",
	outputAmount: "Số lượng đầu ra",
	status: "Trạng thái",
	noLimitOrder: "Không {{ orderType }} Gọi món",
	cancellingOrder: "Đang hủy đơn đặt hàng...",
	cancelLimitOrder: "Mua {{ outputCurrency }} với {{ inputCurrency }}",
	executionPrice: "Giá thực hiện",
	seeMore: "Xem thêm",
	seeLess: "Thấy ít"
};
var buyPage$1 = {
	buyAvaxInfo: "Mua AVAX bằng fiat từ đối tác Wyre của chúng tôi.",
	privacyInfo: "Arcanum không lưu trữ lịch sử mua hàng của bạn hoặc bất kỳ dữ liệu cá nhân nào.",
	firstName: "Tên đầu",
	lastName: "Tên cuối",
	email: "Thư điện tử",
	buyAvax: "Mua AVAX"
};
var votePage$1 = {
	unlockVotes: "Mở khóa phiếu bầu",
	updateDelegation: "Cập nhật ủy quyền",
	pangolinGovernance: "Quản trị Arcanum",
	earnedPngTokens: "Các mã token {{ pngSymbol }} đại diện cho cổ phần có quyền biểu quyết trong quản trị Arcanum. Bạn có thể tự bỏ phiếu cho từng đề xuất hoặc ủy thác phiếu bầu của mình cho bên thứ ba.",
	eligibleToVote: "Để đủ điều kiện bỏ phiếu, bạn phải giữ {{ pngSymbol }} trong ví của mình và ủy quyền khi bắt đầu bỏ phiếu. Sau khi bắt đầu bỏ phiếu, bạn có thể gộp hoặc sử dụng {{ pngSymbol }} của mình.",
	governanceVotes: "Các phiếu bầu quản trị được quyết định theo đa số. Không có ngưỡng đại biểu. ",
	proposals: "Đề xuất",
	allProposals: "Tất cả đề xuất",
	backToProposals: "Quay lại Đề xuất",
	unlockVoting: "Mở khóa biểu quyết",
	votes: " Phiếu bầu",
	delegatedTo: "Ủy quyền cho:",
	edit: "sửa",
	noProposalsFound: "Không đề xuất nào được tìm thấy.",
	proposalCommunityMembers: "Các đề xuất do các thành viên cộng đồng gửi sẽ xuất hiện ở đây.",
	minimumThreshold: "Yêu cầu ngưỡng tối thiểu 1.000.000 {{ pngSymbol }} để gửi đề xuất ",
	votingStarted: "Bỏ phiếu đã bắt đầu",
	votingStarts: "Bắt đầu bỏ phiếu ",
	votingEnded: "Bỏ phiếu đã kết thúc ",
	votingEnds: "Kết thúc bỏ phiếu ",
	voteFor: "Bỏ phiếu cho",
	voteAgainst: "Bỏ phiếu chống lại",
	against: "Chống",
	"for": "Cho",
	details: "Chi tiết",
	overview: "Tổng quan",
	proposer: "Người đề xuất",
	about: "Về",
	vote: "Bầu cử",
	executed: "Thực thi",
	rejected: "Bác bỏ",
	notSupported: "Không được hỗ trợ trên chuỗi này"
};
var IDOPage$1 = {
	pangolinIDOs: "Initial DEX Offering (IDO)",
	pangolinIDODescription: "Initial DEX Offerings (IDO) cho phép các dự án huy động vốn từ các mã token bản vị của họ trên các sàn giao dịch phi tập trung. Chúng tôi đã hợp tác với các nhóm tuyệt vời để mang lại những dự án tuyệt vời cho cộng đồng Avalanche. ",
	upcomingIDOs: "Sắp tới",
	endedIDOs: "Kết thúc",
	allIDOs: "Tất cả IDO",
	noIDOsFound: "Không IDO nào được tìm thấy",
	IDOAnnounced: "Các IDO được thông báo công khai sẽ xuất hiện tại đây ."
};
var swapHooks$1 = {
	connectWallet: "Kết nối ví",
	enterAmount: "Nhập số lượng",
	selectToken: "Chọn một token",
	enterRecipient: "Nhập một người nhận",
	invalidRecipient: "Người nhận không hợp lệ",
	insufficient: "Không đủ ",
	balance: " số dư"
};
var mintHooks$1 = {
	connectWallet: "Kết nối ví",
	insufficientInputAmount: "Số lượng đầu vào không đủ",
	invalidPair: "Cặp không hợp lệ ",
	enterAmount: "Nhập số lượng",
	insufficient: "Không đủ ",
	balance: " số dư"
};
var stakeHooks$1 = {
	connectWallet: "Kết nối ví",
	enterAmount: "Nhập số lượng"
};
var burnHooks$1 = {
	connectWallet: "Kết nối ví",
	enterAmount: "Nhập số lượng"
};
var migratePage$1 = {
	stake: "CỔ PHẦN",
	unstake: "BẤT NGỜ",
	add: "CỘNG",
	remove: "TẨY",
	startMigratingNow: "BẮT ĐẦU DI CƯ NGAY BÂY GIỜ",
	startMigratingNowDescription: "Dưới đây, bạn sẽ tìm thấy tất cả các Trang trại mà bạn sẽ cần để di chuyển sang Hợp đồng V2 của Arcanum",
	seeMore: "XEM THÊM",
	migrateWithEase: "DI CHUYỂN VỚI EASE",
	migrateWithDescription: "Chúng tôi đã thiết kế một trình hướng dẫn thanh lịch, sẽ giúp hướng dẫn bạn trong quá trình di chuyển Trang trại của bạn",
	alreadyMigrate: "đã di cư",
	walletMigrate: "ví đã di chuyển",
	alreadyEarned: "đã kiếm được",
	migrateNow: "DI TRÚ NGAY BÂY GIỜ",
	learn: "HỌC",
	moveYourTokensToNewContracts: "Di chuyển trang trại của bạn sang Arcanum V2",
	readyToMigrate: "Sẵn sàng di chuyển",
	apr: "APR:",
	totalValueLocked: "Tổng giá trị đã khóa",
	lowVolatility: "Sự biến động thấp",
	compoundable: "Hợp chất",
	migrate: "Di cư",
	migrationModalDescription: "Chúng tôi nhận thấy rằng bạn có các nhóm này… Hãy chọn một hoặc thêm một nhóm.",
	choosePool: "Chọn nhóm",
	pool: "Hồ bơi",
	availableToDeposit: "Có sẵn để đặt cọc: ",
	poolInfoDescription: "Bây giờ bạn đã chọn hồ bơi của mình, sau đó cho phép bạn rời khỏi đó.",
	dollarWorth: "Giá trị đô la: ",
	usd: "USD",
	yourRate: "Tỷ lệ của bạn: ",
	unclaimedPng: "{{ pngSymbol }} vô thừa nhận: ",
	shareOfPool: "Chia sẻ của Pool: ",
	choose: "LỰA CHỌN",
	selectAll: "Chọn tất cả",
	loading: "Đang tải",
	back: "Mặt sau",
	availableToUnstake: "Có sẵn để hủy bỏ: ",
	submittingTransaction: "Gửi giao dịch",
	moveYourTokensToNewContractsDescription: "Là một phần trong kế hoạch triển khai các hợp đồng cải tiến mới của Arcanum, bạn sẽ cần phải di chuyển Trang trại của mình. Nếu bạn cần bất kỳ trợ giúp hoặc hướng dẫn nào, vui lòng nhấp vào nút “Tìm hiểu”.",
	migrateModalHeading: "Di cư {{ current }} của {{ total }} trang trại"
};
var dashboardPage$1 = {
	dashboard: "Dashboard",
	greetings: "Greetings kind guests! Let’s ape in today…",
	portfolioValue: "Portfolio Value",
	earned: "Earned",
	coins: "Coins",
	followedWallets: "Followed Wallets",
	earned_dailyIncome: "Daily Income",
	earned_weeklyIncome: "Weekly Income",
	earned_totalEarned: "Total Earned",
	earned_claim: "Claim",
	earned_customizePools: "Customize Pools",
	followed_address: "Address",
	followed_worth: "Worth",
	followed_interact: "Interact"
};
var stakePage$1 = {
	totalStaked: "Total Staked",
	apr: "Annual Percentage Rate",
	seeDetails: "SEE DETAILS",
	stake: "STAKE",
	earn: "Earn {{symbol}}",
	stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error$1 = {
	missCurrencyAmounts: "Thiếu số tiền",
	missTokens: "Thiếu mã thông báo",
	"Thiếu phụ thuộc": "Thiếu phụ thuộc",
	missingLiquidityAmount: "Thiếu số tiền thanh khoản",
	couldNotWrap: "Không thể quấn",
	trytingToConfirmApproval: "Đang cố gắng xác nhận mà không cần phê duyệt hoặc chữ ký. Vui lòng liên hệ với bộ phận hỗ trợ."
};
var sarTitle$1 = {
	addMore: "BỔ SUNG THÊM",
	unstake: "BỎ LỠ VỊ TRÍ",
	compound: "PHẦN THƯỞNG HỢP LỆ",
	claim: "PHẦN THƯỞNG KHIẾU NẠI",
	interactingID: "Tương tác với ID: {{ id }}"
};
var sarStake$1 = {
	createNewPosition: "Tạo một vị trí mới",
	stake: "Cọc",
	staking: "Staking",
	walletBalance: "Trong Ví {{ balance }} {{ symbol }}",
	max: "Max",
	dollarValue: "Giá trị đô la",
	buy: "Mua {{ symbol }}",
	averageAPR: "APR trung bình",
	startingApr: "Bắt đầu APR",
	weeklyDistributed: "Hàng tuần {{ biểu tượng }} Phân phối",
	confirmDescription: "Một hành động đặt cược sẽ tạo ra SAR Nft cho bạn. Với NFT này, bạn có thể quản lý số tiền đặt cược {{ symbol }} của mình.",
	successSubmit: "Bạn đã stake thành công token của mình.",
	yourAprRecalculated: "APR của bạn sẽ được tính toán lại.",
	summary: "Tóm tắt",
	pending: "Staking {{ balance }} {{ symbol }}",
	transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore$1 = {
	stakeMore: "Đặt cọc nhiều hơn",
	choosePosition: "Chọn một vị trí",
	confirmDescription: "Điều này sẽ thêm {{ symbol }} vào vị trí SAR NFT của bạn. Số dư ban đầu của bạn vẫn tiếp tục từ cùng một APR. APR của các mã thông báo mới thêm của bạn bắt đầu từ 0% và thay đổi dựa trên độ dài cổ phần. NFT của bạn sẽ hiển thị mức trung bình.",
	newAPR: "APR mới",
	add: "Thêm",
	pending: "Thêm {{ balance }} {{ symbol }}"
};
var sarUnstake$1 = {
	unstake: "Hủy tham gia",
	unstaking: "Unstaking {{ balance }} {{ symbol }}",
	stakedBalance: "Staked {{ balance }} {{ symbol }}",
	confirmDescription: "Cần lưu ý rằng việc bỏ đặt cược phần thưởng của bạn sẽ giúp APR của bạn về 0% cho vị trí này. \nThay vì bỏ đặt cược, bạn cũng có thể cân nhắc bán NFT của mình.",
	successSubmit: "Bạn đã hủy sử dụng thành công token của mình.",
	pending: "Unstaking {{ balance }} {{ symbol }}",
	transactionSummary: "Unstaked {{ balance }} {{ symbol }}",
	currentAPR: "APR hiện tại",
	unstakeWarning: "Khi bạn hủy tham gia, APR trung bình của bạn sẽ giảm xuống 0%.",
	aprAfter: "APR sau khi unstake"
};
var sarCompound$1 = {
	compound: "Hợp chất",
	compounding: "Kép",
	successSubmit: "Bạn đã thành công trong việc kết hợp vị trí của mình.",
	pending: "Kép",
	transactionSummary: "Vị trí kết hợp",
	aprAfter: "APR sau khi kết hợp",
	reward: "Phần thưởng tích lũy",
	description: "Xin lưu ý rằng việc cộng gộp phần thưởng của bạn có thể làm giảm APR trung bình của bạn. Các mã thông báo đặt cược mới bắt đầu từ 0, trong khi các mã thông báo cũ sẽ tiếp tục với cùng một APR. Điều này tạo ra mức trung bình được hiển thị cho bạn.",
	noRewards: "Không có phần thưởng để kết hợp"
};
var sarClaim$1 = {
	claim: "Đòi",
	claiming: "Tuyên bố",
	description: "Do tính chất của hệ thống đặt cọc SAR yêu cầu phần thưởng của bạn sẽ giảm APR của bạn xuống 0. Thay vào đó, bạn có thể cộng gộp phần thưởng của mình mà không mất APR của mình.",
	successSubmit: "Bạn đã nhận thành công phần thưởng của mình",
	pending: "Tuyên bố",
	transactionSummary: "Phần thưởng vị trí đã nhận",
	aprAfter: "APR sau khi yêu cầu bồi thường",
	noRewards: "Không có phần thưởng để yêu cầu"
};
var sarPortfolio$1 = {
	noPositions: "Bạn không có bất kỳ PANGUARDIAN NFT nào.\nHÃY GIÚP BẠN CÓ ĐƯỢC MỘT",
	start: "BẮT ĐẦU",
	positionId: "ID vị trí",
	apr: "Apr",
	amount: "Lượng",
	newest: "Mới nhất",
	oldest: "Cũ nhất",
	sortBy: "Sắp xếp theo"
};
var pangoChef$1 = {
	claimWarning1: "Khi bạn yêu cầu mà không rút tiền, thanh khoản của bạn vẫn còn trong nhóm khai thác.",
	claimWarning2: "Yêu cầu phần thưởng của bạn sẽ giảm APR của bạn xuống 0. Thay vào đó, bạn có thể chọn kết hợp.",
	compoundWarning: "Tích lũy phần thưởng của bạn cho trang trại {{token0}} - {{token1}} sẽ nhận được phần thưởng của bạn vào trang trại {{currency}} - {{png}}. Bạn cần thêm giá trị tương đương của mã thông báo {{currency}} vào phần thưởng {{png}} đã tích lũy của mình.",
	compoundAmountWarning: "Bạn cần thêm {{amount}} {{symbol}} để kết hợp.",
	compoundAmountWarning2: "Hãy cẩn thận rằng bạn sẽ khóa nhóm {{symbol}} {{png}} của mình cho đến khi bạn nhận được phần thưởng của nhóm này.",
	highVolalityWarning: "Còn quá sớm, hãy thử sau vài giờ",
	compoundSuccess: "Bạn đã soạn thành công trang trại của mình.",
	compoundTransactionSummary: "Trang trại tổng hợp.",
	removeWarning: "Loại bỏ bất kỳ số tiền nào khỏi trang trại sẽ nhận được APR của bạn thành 0. Thay vào đó, bạn có thể gộp phần thưởng của mình mà không bị mất APR.",
	lockingPoolZeroWarning: "Bạn không thể xóa thanh khoản của mình hoặc yêu cầu phần thưởng của mình từ trang trại này. Để làm điều này, trước tiên bạn cần phải yêu cầu cổ phần của bạn từ các trang trại này: "
};
var bridge$1 = {
	availableRoutes: "Available Routes ({{ number }})",
	activeTransfers: "Active Transfers ({{ number }})",
	historicalTransfers: "Historical Transfers ({{ number }})",
	bridgeCard: {
		advanceOptions: "Advance Options",
		title: "Cross Chain",
		swap: "Swap",
		loader: {
			labels: {
				waitingReceivingChain: "Waiting for receiving chain..."
			},
			bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
		},
		filter: {
			bridgePrioritization: "Bridge Prioritization",
			slippage: "Slippage",
			infiniteApproval: "Infinite Approval",
			activeInfiniteApproval: "Active Infinite Approval",
			bridges: "Bridges",
			exchanges: "Exchanges"
		}
	},
	bridgeInputsWidget: {
		tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
		max: "MAX"
	},
	bridgeRoute: {
		selected: "Selected",
		clickToSelect: "Click to select",
		singleTransaction: "Single transaction including",
		estimatedToken: "Estimated Token: {{ token }}",
		estimatedResult: "Estimated Result: {{ result }}",
		min: "{{ minute }} min",
		gasCost: "{{ gasCost }} Gas Cost"
	},
	bridgeTransfer: {
		date: "Date",
		from: "From",
		to: "To",
		via: "Via",
		state: "State",
		resumeSwap: "Resume Swap"
	},
	bridgePrioritizations: {
		recommended: "Recommended",
		fast: "Fast",
		normal: "Normal"
	}
};
var dropdown$1 = {
	select: "Select"
};
var vnTranslation = {
	header: header$1,
	accountDetails: accountDetails$1,
	addressInputPanel: addressInputPanel$1,
	currencyInputPanel: currencyInputPanel$1,
	earn: earn$1,
	menu: menu$1,
	modalView: modalView$1,
	navigationTabs: navigationTabs$1,
	popups: popups$1,
	positionCard: positionCard$1,
	searchModal: searchModal$1,
	settings: settings$1,
	swap: swap$1,
	toggle: toggle$1,
	tokenWarningModal: tokenWarningModal$1,
	transactionConfirmation: transactionConfirmation$1,
	transactionSettings: transactionSettings$1,
	vote: vote$1,
	walletModal: walletModal$1,
	web3ReactManager: web3ReactManager$1,
	web3Status: web3Status$1,
	gasFeeAlert: gasFeeAlert$1,
	addLiquidity: addLiquidity$1,
	airdrop: airdrop$1,
	earnPage: earnPage$1,
	pool: pool$1,
	poolFinder: poolFinder$1,
	removeLiquidity: removeLiquidity$1,
	swapPage: swapPage$1,
	buyPage: buyPage$1,
	votePage: votePage$1,
	IDOPage: IDOPage$1,
	swapHooks: swapHooks$1,
	mintHooks: mintHooks$1,
	stakeHooks: stakeHooks$1,
	burnHooks: burnHooks$1,
	migratePage: migratePage$1,
	dashboardPage: dashboardPage$1,
	stakePage: stakePage$1,
	error: error$1,
	sarTitle: sarTitle$1,
	sarStake: sarStake$1,
	sarStakeMore: sarStakeMore$1,
	sarUnstake: sarUnstake$1,
	sarCompound: sarCompound$1,
	sarClaim: sarClaim$1,
	sarPortfolio: sarPortfolio$1,
	pangoChef: pangoChef$1,
	bridge: bridge$1,
	dropdown: dropdown$1
};

var header = {
	dashboard: "Dashboard",
	swap: "兌換",
	buy: "购买",
	pool: "矿池",
	farm: "农场",
	version1: "版本 1",
	version2: "版本 2",
	stake: "质押",
	newPng: "新的 {{ pngSymbol }}",
	oldPng: "旧的 {{ pngSymbol }}",
	vote: "投票",
	ido: "IDO",
	charts: "图表",
	forum: "论坛区",
	pngBreakDown: "你的 {{ symbol }} 細項",
	balance: "资产: ",
	unclaimed: "未领取: ",
	pngPrice: "{{ symbol }} 价格:",
	pngCirculation: "流通中的{{ symbol }} :",
	totalSupply: "总供应量",
	makeSureURLWarning: "确保 URL 是",
	alwaysMakeSureWarning: "总是确保 URL 是",
	bookmarkIt: "将其加入书签以确保安全。",
	addMetamask: "将 {{ symbol }} 添加到 MetaMask",
	bridge: "桥",
	ourPartners: "我们的伙伴",
	usefulLinks: "有用的链接",
	comeAndJoinUs: "来加入我们",
	tryOurNewBetaSite: "试试我们的新测试版网站",
	returnToLegacySite: "返回旧网站",
	switchToNewUI: "切换到新用户界面"
};
var accountDetails = {
	connectedWith: "与连结 ",
	account: "帐户",
	disconnect: "登出帐户",
	change: "更改",
	copy: "复制地址",
	viewExplorer: "在资源管理器上查看",
	clearAll: "(清除所有)",
	transactionAppear: "您的交易将显示在此处...",
	recentTransactions: "近期的交易",
	copied: "已复制"
};
var addressInputPanel = {
	recipient: "接收者",
	viewExplorer: "(在资源管理器上查看)",
	walletAddress: "钱包地址"
};
var currencyInputPanel = {
	selectToken: "选择一个代币",
	balance: "资产: ",
	max: "最大值",
	to: "給"
};
var earn = {
	claimAccumulated: "领取累积的 {{ symbol }} 奖励",
	connectWallet: "连接钱包",
	enterAmount: "输入金额",
	unclaimedReward: "未領取的 {{ symbol }}",
	claim: "领取",
	claimReward: "领取 {{ symbol }}",
	liquidityRemainsPool: "当您在不提取LP的情况下领取奖励，您的流动性仍留在矿池中。",
	withdrawingLiquidity: "取款 {{ amount }} {{ symbol }}",
	claimingReward: "领取中 {{ amount }} {{ symbol }}",
	claimedReward: "已领取 {{ symbol }}!",
	manage: "管理",
	deposit: "入金",
	poolRate: "池率",
	currentReward: "当前奖励",
	pngPerAvax: "{{ pngSymbol }} / 周 AVAX",
	rewardPerWeek: "{{ symbol }} / 周",
	earnUpTo: "赚取高达（每年）",
	yourRate: "您的费率",
	totalDeposited: "存款总额",
	totalStaked: "总质押",
	depositLiquidity: "存款流动性",
	attemptingToStakeError: "试图在未经批准或签名的情况下进行抵押。请至帮助联系我们。",
	transactionSubmitted: "交易提交",
	depositingLiquidity: "存入流动性",
	depositingToken: "存取 {{ symbol }}",
	depositedToken: "已存取 {{ symbol }}",
	availableToDeposit: "可存入: ",
	weeklyRewards: "每周奖励",
	missingLiquidityAmount: "缺少流动性金额",
	missingDependencies: "缺少依赖项",
	deposited: "存入",
	withdrawDepositedLiquidity: "提取存入的流动性",
	depositedPglLiquidity: "存入 ARL 流动性:",
	whenYouWithdrawWarning: "当您退出时，您的 {{ symbol }} 将被认领，您的Pangolin流动性代币 ARL 将退还给您。您将不再透过此流动性获得 {{ symbol }} 奖励。您的流动性代币将在保持流动状态。",
	whenYouWithdrawSingleSideWarning: "当您取出资产时，您的 {{ symbol }}将被认领且您的 {{ pngSymbol }} 将会退还，您将不会再赚取此 {{ pngSymbol }} 池 {{ symbol }} 的奖励",
	withdrawAndClaim: "提取 & 收成",
	withdrewStakingToken: "提取 {{ symbol }}!",
	approve: "批准",
	poolWeight: "泳池重量",
	withdraw: "提取",
	extraReward: "额外奖励",
	poolRewards: "矿池奖励",
	rewardsIn: "奖励在",
	removeWarning: "您正在从该池中移除流动性。 此操作将退还您的代币。 或者，您可以选择将您的代币投入农场以赚取奖励。"
};
var menu = {
	code: "Code",
	twitter: "推特",
	discord: "Discord",
	telegram: "Telegram",
	tutorials: "Tutorials",
	idos: "IDOs",
	about: "关于我们"
};
var modalView = {
	confirmTransaction: "在您的钱包中确认此交易",
	viewTransaction: "在资源管理器上查看交易"
};
var navigationTabs = {
	useThisTool: "使用此工具查找交易对不会自动出现在界面中",
	swap: "兌換",
	pool: "矿池",
	importPool: "导入矿池中",
	createPair: "创建一个交易对",
	addLiquidity: "增加流动性",
	removeLiquidity: "去除流动性",
	whenYouAddLiquidityInfo: "当您增加流动性时，您将获得代表您部位的LP代币。这些代币会自动赚取与您在池中所占份额成比例的费用，并且可以随时赎回。",
	removingPoolTokensInfo: "移除池中的代币会按照当前的比率将您的部位转换回基础代币，与您在池中的份额成正比。应计费用包含在您收到的金额中。"
};
var popups = {
	tokenListUpdated: "代币列表\" {{oldList}} \" 已更新为 ",
	updateAvailable: "代币列表有更新可用 \" {{oldList}} \"",
	viewExplorer: "在资源管理器上查看",
	hash: "哈希: ",
	added: "已添加",
	removed: "已移除",
	tokensUpdated: "代币已更新",
	acceptUpdate: "接受更新",
	dismiss: "撤出"
};
var positionCard = {
	add: "添加",
	remove: "移除",
	poolShare: "您池中的份额:",
	pooled: "汇集",
	poolTokens: "您池中的代币:",
	manage: "管理",
	loading: "加载中",
	yourPosition: "您的部位",
	byAddingLiquidityInfo: "通过增加流动性，您将获得该货币对所有交易的 0.25%，与您在池中的份额成比例。\n 交易手续费随时累积并添加到池中，可以透过提取您的流动性来收成收益。"
};
var searchModal = {
	commonBases: "共同底层",
	tokensPairsHelper: "这些代币通常与其他代币配对。.",
	addedByUser: "用户添加",
	foundByAddress: "在地址中找到",
	remove: "移除",
	add: "添加",
	findToken: "通过搜索其名称或符号或在下方粘贴其地址来查找该币。",
	selectToken: "选择一个代币",
	tokenSearchPlaceholder: "搜索名称或粘贴地址",
	tokenName: "代币名称",
	change: "改变",
	selectList: "选择一个列表",
	confirmListRemovalPrompt: "请输入 \"移除\" 确认您要删除此列表",
	addList: "添加列表 ",
	tokenListHelper: "代币列表是 ERC20 代币列表的开放规范。您可以通过在下面输入其 URL 来使用任何令牌列表。请注意第三方令牌列表可能包含虚假或恶意的 ERC20 令牌。",
	httpsPlaceholder: "https:// 或 ipfs://",
	manageLists: "管理列表",
	viewList: "查看列表",
	updateList: "更新列表",
	removeList: "删除列表",
	selected: "已选",
	select: "选择",
	manageTokenLists: "管理令牌列表"
};
var settings = {
	areYouSure: "你确定吗?",
	expertInfo: "专家模式会关闭确认交易提示，并允许高滑点交易可能导致不良的利率和资金损失。",
	expertWarningCAPS: "仅当您知道自己在做什么时才使用此模式。",
	confirm: "确",
	confirmExpertMode: "请输入 \"确\" 一词以启用专家模式。",
	turnOnExpertMode: "开启专家模式",
	transactionSettings: "交易设置",
	interfaceSettings: "界面设置",
	toggleExpertMode: "切换专家模式",
	expertModeHelper: "绕过确认模式并允许高滑点交易。使用风险自负。",
	toggleDarkMode: "切换深色模式",
	slippage: "Slippage",
	percent: "Percent"
};
var swap = {
	priceImpact: "价格影响",
	priceImpactHelper: "由于交易规模而导致的市场价格和估计价格之间的差异。",
	liquidityProviderFee: "流动性提供者费用",
	liquidityProviderHelper: "每笔交易的一部分（0.30%）作为协议激励流动性提供者。",
	route: "路由",
	routingHelper: "通过这些代币路由可以为您的交易带来最优惠的价格。",
	confirmSwap: "确认兌换",
	swapAnyway: "仍然兌換",
	confirm: "确",
	price: "价格",
	accept: "接受",
	minimumReceived: "最低收到",
	maximumSold: "最大销售量",
	transactionRevertHelper: "如果在确认前出现较大的不利价格变动，您的交易将取消。",
	priceUpdated: "价格更新",
	outputEstimated: "估计输出。你至少会收到 <strong>{{amount}} {{currencySymbol}}</strong>  否则交易将取消。",
	inputEstimated: "输入是估计的。你最多会卖掉 <strong>{{amount}} {{currencySymbol}}</strong>  否则交易将取消。",
	outputSentTo: "输出将发送到 ",
	priceImpactMinPrompt: "此兌換对价格的影响至少为 {{ priceImpact }}%. 请输入\"确\" 继续这个兌換。",
	priceImpactHighPrompt: "此兌換对价格的影响至少为 {{ priceImpact }}%. 请确认您想继续进行此兌换。"
};
var toggle = {
	on: "开",
	off: "关"
};
var tokenWarningModal = {
	tokenImported: "代币导入",
	anyoneCanCreateWarning: "任何人都可以在 Avalanche 上以<em>任何</em>名称创建 ERC-20 代币，包括创建现有代币的假版本和声称代表项目方而創建一個假代币",
	loadArbitraryWarning: "该介面可以透过代币地址加载任意代币。在与任意 ERC-20 代币交互时，请格外小心并进行研究。",
	purchaseArbitraryWarning: "如果您购买任意代币，<strong>您可能无法将其卖回。</strong>",
	understand: "我明白",
	"continue": "继续",
	viewExplorer: "在资源管理器上查看"
};
var transactionConfirmation = {
	waitingConfirmation: "等待确认",
	confirmTransaction: "在您的钱包中确认此交易",
	transactionSubmitted: "交易提交",
	viewExplorer: "在资源管理器上查看",
	close: "关闭",
	error: "错误",
	dismiss: "撤回",
	addToFarm: "添加到农场"
};
var transactionSettings = {
	slippageTolerance: "滑点公差",
	transactionRevertSlippageHelper: "如果价格的不利变化超过此百分比，您的交易将取消。",
	transactionDeadline: "交易截止時間",
	transactionRevertDeadlineHelper: "如果待处理的时间超过这个时间，您的交易将取消。",
	enterValidSlippage: "输入有效的滑点百分比",
	transactionMayFail: "您的交易可能会失败",
	transactionMayFrontrun: "您的交易可能提前",
	transactionActiveExpertMode: "Very high slippage, activate expert mode to be able to use more than 50%",
	minutes: "分钟"
};
var vote = {
	earnedPng: "获得的 {{ pngSymbol }} 代币代表 Arcanum 治理中的投票份额。",
	canEitherVote: "您可以自己对每个提案进行投票，也可以将您的投票委托给第三方。",
	delegateVotes: "委托投票",
	selfDelegate: "自我委托",
	remove: "清除",
	add: "添加",
	delegate: "代表",
	delegatingVotes: "委托投票",
	unlockingVotes: "解锁投票",
	transactionSubmitted: "交易提交",
	"for": "給",
	against: "反对",
	vote: "投票",
	proposal: "提案",
	votes: "投票",
	submittingVote: "提交投票",
	confirmTransaction: "在您的钱包中确认此交易",
	viewExplorer: "在资源管理器上查看"
};
var walletModal = {
	wrongNetwork: "错误的网络",
	errorConnecting: "连接错误",
	pleaseConnectAvalanche: "请连接到适当的 Avalanche 网络。",
	switchAvalanche: "切换到 Avalanche 链",
	errorConnectingRefresh: "连接错误。尝试刷新页面。",
	connectToWallet: "连接到钱包",
	newToAvalanche: "Avalanche 的新手? ",
	learnMoreWallet: "了解有关设置钱包的更多信息",
	initializing: "初始化...",
	tryAgain: "再试一次"
};
var web3ReactManager = {
	unknownError: "哎呀！出现未知错误。请刷新页面，或从其他浏览器或设备访问。"
};
var web3Status = {
	pending: "待办的",
	wrongNetwork: "错误的网络",
	error: "错误",
	connectToWallet: "连接到钱包"
};
var gasFeeAlert = {
	gasFeeReduction: "!!! Gas 费减免 !!!",
	transactionsNotAccept: "除非将gas费用设置为，否则交易将不被接受{{ gasPrice }} gwei."
};
var addLiquidity = {
	deposited: "",
	shareOfPool: "建池份额",
	createPoolSupply: "创建矿池和供应",
	confirmSupply: "确认供应",
	giveOrder: "GIVE ORDER",
	outputEstimated: "估计输出。如果价格变化超过 {{ allowedSlippage }}% 您的交易将取消。",
	creatingPool: "您正在创建一个矿池",
	willReceive: "您将收到",
	firstLP: "您是第一个流动性提供者。",
	ratioTokens: "您添加的代币比例将决定该矿池的价格。",
	happyRate: "一旦您对费率感到满意，请点击供应查看.",
	initialPrices: "初始价格",
	prices: "价格",
	poolShare: "佔池份额",
	connectWallet: "连接钱包",
	approve: "批准 ",
	supply: "供应",
	per: " 每亇 ",
	rates: "费率",
	poolTokens: " 矿池代币"
};
var airdrop = {
	claimPngAirdrop: "领取你的 {{ pngSymbol }} 空投",
	claimPeriodEnded: "空投申领期已经结束。",
	connectWalletViewLiquidity: "连接到钱包以查看您的流动性。",
	noAvailableClaim: "您没有可以领取的",
	noUniNoSushi: "您没有 UNI 或 SUSHI 代币。请按照此处的教程将 UNI 或 SUSHI 代币添加到您的钱包。",
	youHave: "你有 ",
	pngAvailableClaim: " {{ pngSymbol }} 可以领取",
	loading: "Loading",
	welcomeToTeamPangolin: "欢迎加入 Arcanum 团队",
	claim: "领取 "
};
var earnPage = {
	pangolinLiquidityMining: "Arcanum 流动性挖矿",
	pangolinLiquidityStaking: "Arcanum {{ pngSymbol }} 质押",
	depositPangolinLiquidity: "存入您的 Arcanum LP 代币PGL 以接收 Arcanum 协议治理代币 {{ pngSymbol }}。",
	depositPangolinStaking: "存取并质押你的 {{ pngSymbol }} 以赚取更多其他代币",
	currentOpportunities: "启用的农场",
	readMoreAboutPng: "阅读有关 {{ pngSymbol }} 的更多信息",
	getInsuranceCoverage: "在 InsurAce.io 上获得保障",
	getCoverNexusMutual: "获得 Nexus Mutual 的保障",
	importantUpdate: "重要更新",
	pangolinGovernanceProposalResult: "由于 Arcanum 治理提案1，穿山甲正在改变Staking合约！ 在 4/19 UTC 大约 08:59 之后，所有 Staking 奖励将分配给新的 Staking 合约。 切换前，所有奖励仍将分配给旧合约。 为避免产生农业奖励的中断，您需要从旧合约中取消您的流动性并在新合约中重新投入。 您不需要从您的池中移除流动性或改变您的部位。",
	oldPngPools: "旧的 {{ pngSymbol }} 矿池",
	newPngPools: "新 {{ pngSymbol }} 矿池",
	participatingPools: "参与矿池",
	rewardsNeverEnd: "奖励永无止境！",
	noActiveRewards: "没有主动奖励",
	liquidityMining: "流动性挖掘",
	pngStaking: "{{ pngSymbol }} 质押",
	totalStaked: "总质押",
	poolRate: "池率",
	step1: "S 获取 Arcanum 流动性代币 (ARL)",
	pglTokenRequired: "需要PGL代币。 向 {{ poolHandle }} 池添加流动性后，您可以在此页面上抵押您的流动性代币。",
	addPoolLiquidity: "添加 {{ poolHandle }} 流动性",
	liquidityDeposits: "您的流动资金存款",
	yourStakedToken: "你质押了 {{ symbol }}",
	unclaimedReward: "您未收成的{{ symbol }}",
	claim: "收成",
	rewardPerWeek: " {{ symbol }} / 周",
	automagically: "当您退出时，合约会自动为您申领 {{ pngSymbol }}!",
	deposit: "存入",
	depositStakingTokens: "存入 {{ symbol }} 代币",
	stake: "质押",
	stakeStakingTokens: "质押 {{ symbol }} 代币",
	unstake: "取消质押",
	stakingTokensAvailable: "可用的 {{ symbol }} 代币",
	getToken: "获得 {{ symbol }}",
	migrateTitle: "迁移您的堆叠 ARL",
	migrateDescription: "穿山甲改变了代币经济。你需要将堆叠的 ARL 迁移到新合约",
	migrate: "迁移"
};
var pool = {
	liquidityProviderRewards: "流动性提供者奖励",
	liquidityProvidersEarn: "流动性提供者在所有交易中收取 0.25% 的费用，费用与其在池中的份额成正比。费用被添加到池中，实时累积，可以通过提取您的流动性来索取。",
	readMoreProviding: "阅读有关提供流动性的更多信息",
	viewStakedLiquidity: "查看您质押的流动性",
	yourLiquidity: "您的流动性",
	createPair: "创建一个交易对",
	addLiquidity: "增加流动性",
	connectWalletToView: "连接到钱包以查看您的流动性。",
	loading: "加载中",
	noLiquidity: "没有发现流动性。",
	uniswapV1Found: "“Uniswap V1 发现流动性!",
	noSeePoolJoined: "看不到您加入的矿池?",
	migrateNow: "立即迁移。",
	importIt: "导入它。",
	seeDetails: "阅读详情",
	totalLockedValue: "总锁定值",
	yourLockedValue: "您的锁定值",
	allFarms: "所有农场",
	yourFarms: "你的农场",
	yourPools: "你的游泳池",
	noFarms: "没有找到农场。",
	successWithdraw: "您的流动性从农场中移除，并获得了应计奖励"
};
var poolFinder = {
	connectToFind: "连接到钱包以查找矿池",
	selectTokenToFind: "选择一个代币以找到您的流动性",
	selectToken: "选择一个代币",
	poolFound: "矿池找到了！",
	managePool: "管理这个池。",
	noLiquidityYet: "你在这个池中还没有流动性。",
	noPoolFound: "未找到資金池",
	addLiquidity: "增加流动性",
	createPool: "创建資金池",
	invalidPair: "无效的交易对.",
	loading: "加载中"
};
var removeLiquidity = {
	youWillReceive: "您将获得",
	simple: "简易的",
	detailed: "详细的",
	receiveAvax: "获得 AVAX",
	receiveWavax: "获得 WAVAX",
	price: "价格:",
	connectWallet: "连接钱包",
	approving: "正在批准",
	approve: "批准",
	approved: "已批准",
	remove: "移除",
	output: "输出",
	amount: "合计"
};
var swapPage = {
	addSend: "+ 添加发送（可选）",
	toEstimated: "到（估计）",
	to: "到",
	removeSend: "- 删除发送",
	price: "價格",
	slippageTolerance: "滑点公差",
	connectWallet: "连接钱包",
	insufficientLiquidity: "这笔交易的流动性不足。",
	wrap: "包裹",
	unwrap: "展开",
	approving: "正在批准",
	approve: "批准 ",
	approved: "已批准",
	priceImpactHigh: "价格影响高",
	swap: "兌換",
	anyway: " 反正",
	from: "来自",
	fromEstimated: "来自（估计）",
	velox: "在 <1>Velox</1> 上设置限价单",
	marginSwap: "通过 <1>Marginswap</1>",
	wowSwap: " 或 <1>WOWswap</1> 使用保证金交易",
	veeFinance: " 或 <1>Vee Finance</1> 使用保证金交易",
	gelatoFee: "Gelato 费用",
	placeOrder: "下订单",
	confirmOrder: "确认订单",
	"for": "为了",
	submittingOrderToSwap: "提交订单交换",
	limitPrice: "限价",
	outputWillBeSentTo: "输出将被发送到",
	sell: "卖",
	buy: "买",
	betaRelease: "这是一个 BETA 版本，使用时应自担风险",
	trade: "贸易",
	watchList: "观察名单",
	yourPortFolio: "您的投资组合",
	connectWalletViewPortFolio: "连接到钱包以检查您的投资组合.",
	limitOrders: "限价单",
	cancelOrder: "取消订单",
	all: "全部",
	open: "打开",
	executed: "已执行",
	cancelled: "取消",
	inputAmount: "输入金额",
	outputAmount: "输出量",
	status: "地位",
	noLimitOrder: "不 {{ orderType }} 命令",
	cancellingOrder: "取消订单...",
	cancelLimitOrder: "买 {{ outputCurrency }} 和 {{ inputCurrency }}",
	executionPrice: "执行价格",
	seeMore: "查看更多",
	seeLess: "少看"
};
var buyPage = {
	buyAvaxInfo: "用我们的合作伙伴怀尔的法定资金购买 AVAX。",
	privacyInfo: "Arcanum 不存储您的购买历史记录或任何个人数据。",
	firstName: "名",
	lastName: "姓",
	email: "邮箱",
	buyAvax: "购买 AVAX"
};
var votePage = {
	unlockVotes: "解锁投票",
	updateDelegation: "更新委托",
	pangolinGovernance: "Pangolin治理",
	earnedPngTokens: "{{ pngSymbol }} 代币代表Pangolin治理中的投票份额。 您可以自己对每个提案进行投票，也可以将您的投票委托给第三方。",
	eligibleToVote: "要获得投票资格，您必须在钱包中持有 {{ pngSymbol }} 并在投票开始时委托它。投票开始后，您可以汇集或花费您的 {{ pngSymbol }}。",
	governanceVotes: "治理投票由简单多数决定。没有法定人数阈值。",
	proposals: "提案",
	allProposals: "所有提案",
	backToProposals: "回到提案",
	unlockVoting: "解锁投票",
	votes: " 投票 ",
	delegatedTo: "委托给：",
	edit: "编辑",
	noProposalsFound: "未找到任何提案",
	proposalCommunityMembers: "社区成员提交的提案将显示在此处",
	minimumThreshold: "提交提案的最低门槛为 1,000,000 {{ pngSymbol }}",
	votingStarted: "投票已开始",
	votingStarts: "投票开始 ",
	votingEnded: "投票已结束 ",
	votingEnds: "投票截止",
	voteFor: "投票给",
	voteAgainst: "投反对票",
	against: "反对",
	"for": "給",
	details: "细节",
	overview: "概述",
	proposer: "建议",
	about: "关于",
	vote: "投票",
	executed: "已执行",
	rejected: "拒绝",
	notSupported: "此链不支持"
};
var IDOPage = {
	pangolinIDOs: "Initial DEX Offering (IDO)",
	pangolinIDODescription: "初始 DEX 产品 (IDO) 允许项目在去中心化交易所上众筹其原生代币。 我们与出色的团队合作，为 Avalanche 社区带来了伟大的项目.",
	upcomingIDOs: "即将到来",
	endedIDOs: "结束",
	allIDOs: "所有 IDO",
	noIDOsFound: "未找到 IDO",
	IDOAnnounced: "公开宣布的 IDO 将出现在这里."
};
var swapHooks = {
	connectWallet: "连接钱包",
	enterAmount: "输入金额",
	selectToken: "选择一个代币",
	enterRecipient: "输入收件人",
	invalidRecipient: "收件人无效",
	insufficient: "不足的 ",
	balance: "资产"
};
var mintHooks = {
	connectWallet: "连接钱包",
	insufficientInputAmount: "输入数量不足",
	invalidPair: "无效交易对",
	enterAmount: "输入金额",
	insufficient: "不足的 ",
	balance: " balance"
};
var stakeHooks = {
	connectWallet: "连接钱包",
	enterAmount: "输入金额"
};
var burnHooks = {
	connectWallet: "连接钱包",
	enterAmount: "输入金额"
};
var migratePage = {
	stake: "赌注",
	unstake: "取消赌注",
	add: "添加",
	remove: "消除",
	startMigratingNow: "立即开始迁移",
	startMigratingNowDescription: "您将在下方找到您需要迁移到的所有农场 Arcanum's V2 合同",
	seeMore: "查看更多",
	migrateWithEase: "轻松迁移",
	migrateWithDescription: "我们设计了一个优雅的向导，它将帮助指导您完成迁移农场的过程",
	alreadyMigrate: "已经迁移",
	walletMigrate: "钱包迁移",
	alreadyEarned: "已经赚了",
	migrateNow: "立即迁移",
	learn: "学习",
	moveYourTokensToNewContracts: "将您的农场迁移到 Arcanum V2",
	readyToMigrate: "准备迁移",
	apr: "APR:",
	totalValueLocked: "总价值锁定",
	lowVolatility: "低波动性",
	compoundable: "可复合",
	migrate: "迁移",
	migrationModalDescription: "我们已经意识到您有这些池……选择一个或添加一个。",
	choosePool: "选择泳池",
	pool: "水池",
	availableToDeposit: "可存入 ",
	poolInfoDescription: "现在您已经选择了您的池，然后让您从那里取消赌注",
	dollarWorth: "美元价值 ",
	usd: "USD",
	yourRate: "您的费率 ",
	unclaimedPng: "无人认领的{{ pngSymbol }}: ",
	shareOfPool: "池份额 ",
	choose: "选择",
	selectAll: "全选",
	loading: "加载中",
	back: "后退",
	availableToUnstake: "可取消抵押: ",
	submittingTransaction: "提交交易",
	moveYourTokensToNewContractsDescription: "作为...的一部分 Arcanum's 推出新的改进合同，您将需要迁移您的农场。如果您需要任何帮助或指导，请单击“学习”按钮。",
	migrateModalHeading: "迁移 {{ current }} 的 {{ total }} 农场"
};
var dashboardPage = {
	dashboard: "Dashboard",
	greetings: "Greetings kind guests! Let’s ape in today…",
	portfolioValue: "Portfolio Value",
	earned: "Earned",
	coins: "Coins",
	followedWallets: "Followed Wallets",
	earned_dailyIncome: "Daily Income",
	earned_weeklyIncome: "Weekly Income",
	earned_totalEarned: "Total Earned",
	earned_claim: "Claim",
	earned_customizePools: "Customize Pools",
	followed_address: "Address",
	followed_worth: "Worth",
	followed_interact: "Interact"
};
var stakePage = {
	totalStaked: "Total Staked",
	apr: "Annual Percentage Rate",
	seeDetails: "SEE DETAILS",
	stake: "STAKE",
	earn: "Earn {{symbol}}",
	stakeAndEarn: "Stake Your {{ pngSymbol }} and Earn Rewards!"
};
var error = {
	missingCurrencyAmounts: "缺少货币金额",
	missingTokens: "丢失的令牌",
	missingDependencies: "缺少依赖",
	missingLiquidityAmount: "缺少流动性金额",
	couldNotWrap: "不能换行",
	attemptingToConfirmApproval: "尝试在未经批准或签名的情况下进行确认。请联系支持人员。"
};
var sarTitle = {
	addMore: "添加更多",
	unstake: "取消仓位",
	compound: "复合奖励",
	claim: "索取奖励",
	interactingID: "与 ID 交互： {{ id }}"
};
var sarStake = {
	createNewPosition: "创建新职位",
	stake: "桩",
	staking: "质押",
	walletBalance: "在钱包中 {{ balance }} {{ symbol }}",
	max: "麦克斯",
	dollarValue: "美元价值",
	buy: "购买 {{ symbol }}",
	averageAPR: "平均年利率",
	startingApr: "从 4 月起",
	weeklyDistributed: "每周 {{ symbol }} 分布",
	confirmDescription: "质押行动将为您创建一个 SAR Nft。 使用此 NFT，您可以管理您的 {{ symbol }} 股份。",
	successSubmit: "您已经成功押注了您的代币。",
	yourAprRecalculated: "您的实际年利率将被重新计算。",
	summary: "总结",
	pending: "Staking {{ balance }} {{ symbol }}",
	transactionSummary: "Staked {{ balance }} {{ symbol }}"
};
var sarStakeMore = {
	stakeMore: "赌注更多",
	choosePosition: "选择职位",
	confirmDescription: "这会将 {{ symbol }} 添加到您的 SAR NFT 头寸。 您的原始余额从同一个 APR 继续。 您新添加的代币的 APR 从 0% 开始，并根据权益的长度而变化。 您的 NFT 将显示平均值。",
	newAPR: "新年利率",
	add: "加",
	pending: "添加 {{ balance }} {{ symbol }}"
};
var sarUnstake = {
	unstake: "取消获取",
	unstaking: "取消存根 {{ balance }} {{ symbol }}",
	stakedBalance: "Staked {{ balance }} {{ symbol }}",
	confirmDescription: "值得注意的是，取消您的奖励将使该头寸的APR达到0%。\n与其取消stake，您还可以考虑出售您的NFT。",
	successSubmit: "您已经成功取消了令牌。",
	pending: "取消存根 {{ balance }} {{ symbol }}",
	transactionSummary: "Unstaked {{ balance }} {{ symbol }}",
	currentAPR: "当前实际年利率",
	unstakeWarning: "当您取消持股时，您的平均实际年利率将降至0%。",
	aprAfter: "APR 后 取消"
};
var sarCompound = {
	compound: "复合",
	compounding: "复合",
	successSubmit: "你已经成功地巩固了你的位置。",
	pending: "复合",
	transactionSummary: "复合位置",
	aprAfter: "复利后的 APR",
	reward: "累积奖励",
	description: "请注意，复合奖励可能会降低您的平均 APR。 新质押的代币从 0 开始，而旧代币将以相同的 APR 继续。 这将创建显示给您的平均值",
	noRewards: "没有复合奖励"
};
var sarClaim = {
	claim: "索赔",
	claiming: "声称",
	description: "由于SAR质押系统的性质，声称您的奖励将使您的APR降至0。相反，您可以在不损失APR的情况下复利您的奖励。",
	successSubmit: "您已成功领取奖励",
	pending: "声称",
	transactionSummary: "已申请的职位奖励",
	aprAfter: "理赔后年利率",
	noRewards: "没有可领取的奖励"
};
var sarPortfolio = {
	noPositions: "你没有任何PANGUARDIAN NFT。\n让您得到一个",
	start: "开始",
	positionId: "职位编号",
	apr: "四月",
	amount: "量",
	newest: "最新",
	oldest: "古老",
	sortBy: "排序方式"
};
var pangoChef = {
	claimWarning1: "当您在未提取流动性的情况下申领时，您的流动性仍保留在矿池中。",
	claimWarning2: "领取您的奖励将使您的 APR 降至 0。相反，您可以选择复合。",
	compoundWarning: "将您对 {{ token0 }}-{{ token1 }} 农场的奖励组合起来，您的奖励将投入 {{ currency }}-{{ png }} 农场。 您需要在累积的 {{ png }} 奖励中添加等值的 {{ currency }} 代币。",
	compoundAmountWarning: "您需要添加 {{ amount }} {{ symbol }} 来复合。",
	compoundAmountWarning2: "请注意，您将锁定您的 {{ symbol }} {{ png }} 池，直到您获得该池的奖励。",
	highVolalityWarning: "太早了，过几个小时试试",
	compoundSuccess: "你已经成功地组成了你的农场。",
	compoundTransactionSummary: "复合农场。",
	removeWarning: "从农场中删除任何金额将使您的 APR 变为 0。您可以在不损失 APR 的情况下复合您的奖励。",
	lockingPoolZeroWarning: "您无法从该农场移除您的流动性或索取您的奖励。 为此，您首先需要从该农场申领您的股份： "
};
var bridge = {
	availableRoutes: "Available Routes ({{ number }})",
	activeTransfers: "Active Transfers ({{ number }})",
	historicalTransfers: "Historical Transfers ({{ number }})",
	bridgeCard: {
		advanceOptions: "Advance Options",
		title: "Cross Chain",
		swap: "Swap",
		loader: {
			labels: {
				waitingReceivingChain: "Waiting for receiving chain..."
			},
			bottomText: "Your transaction is still being processed. Sit back and relax. There is nothing you need to do on your end. It is also not possible to speed up this part of the process. If it takes an unusually long time for this to process, please do not worry. your funds are not missing."
		},
		filter: {
			bridgePrioritization: "Bridge Prioritization",
			slippage: "Slippage",
			infiniteApproval: "Infinite Approval",
			activeInfiniteApproval: "Active Infinite Approval",
			bridges: "Bridges",
			exchanges: "Exchanges"
		}
	},
	bridgeInputsWidget: {
		tooltip: "The final amount might change due to slippage but will not fall below {{ amount }} {{ currency }}",
		max: "MAX"
	},
	bridgeRoute: {
		selected: "Selected",
		clickToSelect: "Click to select",
		singleTransaction: "Single transaction including",
		estimatedToken: "Estimated Token: {{ token }}",
		estimatedResult: "Estimated Result: {{ result }}",
		min: "{{ minute }} min",
		gasCost: "{{ gasCost }} Gas Cost"
	},
	bridgeTransfer: {
		date: "Date",
		from: "From",
		to: "To",
		via: "Via",
		state: "State",
		resumeSwap: "Resume Swap"
	},
	bridgePrioritizations: {
		recommended: "Recommended",
		fast: "Fast",
		normal: "Normal"
	}
};
var dropdown = {
	select: "Select"
};
var zhTranslation = {
	header: header,
	accountDetails: accountDetails,
	addressInputPanel: addressInputPanel,
	currencyInputPanel: currencyInputPanel,
	earn: earn,
	menu: menu,
	modalView: modalView,
	navigationTabs: navigationTabs,
	popups: popups,
	positionCard: positionCard,
	searchModal: searchModal,
	settings: settings,
	swap: swap,
	toggle: toggle,
	tokenWarningModal: tokenWarningModal,
	transactionConfirmation: transactionConfirmation,
	transactionSettings: transactionSettings,
	vote: vote,
	walletModal: walletModal,
	web3ReactManager: web3ReactManager,
	web3Status: web3Status,
	gasFeeAlert: gasFeeAlert,
	addLiquidity: addLiquidity,
	airdrop: airdrop,
	earnPage: earnPage,
	pool: pool,
	poolFinder: poolFinder,
	removeLiquidity: removeLiquidity,
	swapPage: swapPage,
	buyPage: buyPage,
	votePage: votePage,
	IDOPage: IDOPage,
	swapHooks: swapHooks,
	mintHooks: mintHooks,
	stakeHooks: stakeHooks,
	burnHooks: burnHooks,
	migratePage: migratePage,
	dashboardPage: dashboardPage,
	stakePage: stakePage,
	error: error,
	sarTitle: sarTitle,
	sarStake: sarStake,
	sarStakeMore: sarStakeMore,
	sarUnstake: sarUnstake,
	sarCompound: sarCompound,
	sarClaim: sarClaim,
	sarPortfolio: sarPortfolio,
	pangoChef: pangoChef,
	bridge: bridge,
	dropdown: dropdown
};

const resources = {
    en: {
        translation: enTranslation,
    },
    de: {
        translation: deTranslation,
    },
    tr: {
        translation: trTranslation,
    },
    zh: {
        translation: zhTranslation,
    },
    es: {
        translation: esTranslation,
    },
    fr: {
        translation: frTranslation,
    },
    pt: {
        translation: ptBrTranslation,
    },
    vn: {
        translation: vnTranslation,
    },
};
const availableLanguages = ['en', 'de', 'tr', 'zh', 'es', 'fr', 'pt-br', 'vn'];
const defaultLocale = 'en';
const determineLngFn = (code) => {
    if (!code || code.length === 0) {
        return (i18next__default["default"].language = defaultLocale);
    }
    // Full locale match
    if (availableLanguages.includes(code.toLowerCase())) {
        return (i18next__default["default"].language = code.toLowerCase());
    }
    // Base locale match
    const codeBase = code.split('-')[0].toLowerCase();
    if (availableLanguages.includes(codeBase)) {
        return (i18next__default["default"].language = codeBase);
    }
    // Fallback
    return (i18next__default["default"].language = defaultLocale);
};
i18next__default["default"]
    .use(LanguageDetector__default["default"])
    .use(reactI18next.initReactI18next)
    .init({
    resources,
    react: {
        useSuspense: true,
    },
    load: 'languageOnly',
    lowerCaseLng: true,
    fallbackLng: determineLngFn,
    preload: [defaultLocale],
    keySeparator: '.',
    interpolation: { escapeValue: false },
});

function Updater() {
    const { chainId } = usePangolinWeb3();
    const { library } = useLibrary();
    const dispatch = useDispatch();
    const feeTo = useSelector((state) => state.pswap.feeTo);
    const router = React.useMemo(() => {
        if (!chainId || !library || !feeTo || feeTo === ZERO_ADDRESS)
            return null;
        return getRouterContractDaaS(chainId, library);
    }, [chainId, library, feeTo]);
    const feeInfoResponse = useSingleCallResult(router, 'getFeeInfo', [feeTo], NEVER_RELOAD).result;
    React.useEffect(() => {
        if (!feeInfoResponse || !dispatch || !updateFeeInfo)
            return;
        const feeInfo = {
            feePartner: feeInfoResponse.feePartner,
            feeProtocol: feeInfoResponse.feeProtocol,
            feeTotal: feeInfoResponse.feeTotal,
            feeCut: feeInfoResponse.feeCut,
            initialized: feeInfoResponse.initialized,
        };
        dispatch(updateFeeInfo({ feeInfo }));
    }, [feeInfoResponse, dispatch, updateFeeInfo]);
    return null;
}

const queryClient = new reactQuery.QueryClient({
    defaultOptions: {
        queries: {
            staleTime: 5 * 1000 * 60,
            refetchOnWindowFocus: false,
        },
    },
});
function PangolinProvider({ chainId = sdk.ChainId.AVALANCHE, library, children, account, theme, }) {
    return (jsxRuntime.jsx(reactRedux.Provider, Object.assign({ store: store, context: StoreContext }, { children: jsxRuntime.jsx(PangolinWeb3Provider, Object.assign({ chainId: chainId, library: library, account: account }, { children: jsxRuntime.jsx(ThemeProvider, Object.assign({ theme: theme }, { children: jsxRuntime.jsxs(reactQuery.QueryClientProvider, Object.assign({ client: queryClient }, { children: [jsxRuntime.jsx(Updater$3, {}), jsxRuntime.jsx(ApplicationUpdater, {}), jsxRuntime.jsx(Updater$2, {}), jsxRuntime.jsx(Updater$1, {}), jsxRuntime.jsx(Updater, {}), isEvmChain(chainId) ? (jsxRuntime.jsx(reactRedux.Provider, Object.assign({ store: galetoStore }, { children: jsxRuntime.jsx(limitOrdersReact.GelatoProvider, Object.assign({ library: library, chainId: chainId, account: account !== null && account !== void 0 ? account : undefined, useDefaultTheme: false, handler: 'pangolin' }, { children: children })) }))) : (children)] })) })) })) })));
}

Object.defineProperty(exports, 'Trans', {
  enumerable: true,
  get: function () { return reactI18next.Trans; }
});
Object.defineProperty(exports, 'useTranslation', {
  enumerable: true,
  get: function () { return reactI18next.useTranslation; }
});
Object.defineProperty(exports, 'i18n', {
  enumerable: true,
  get: function () { return i18next__default["default"]; }
});
exports.ALLOWED_PRICE_IMPACT_HIGH = ALLOWED_PRICE_IMPACT_HIGH;
exports.ALLOWED_PRICE_IMPACT_LOW = ALLOWED_PRICE_IMPACT_LOW;
exports.ALLOWED_PRICE_IMPACT_MEDIUM = ALLOWED_PRICE_IMPACT_MEDIUM;
exports.ANALYTICS_PAGE = ANALYTICS_PAGE;
exports.AVALANCHE_CHAIN_PARAMS = AVALANCHE_CHAIN_PARAMS;
exports.AddLiquidityModal = AddLiquidityModal;
exports.BASES_TO_CHECK_TRADES_AGAINST = BASES_TO_CHECK_TRADES_AGAINST;
exports.BASES_TO_TRACK_LIQUIDITY_FOR = BASES_TO_TRACK_LIQUIDITY_FOR;
exports.BIG_INT_SECONDS_IN_WEEK = BIG_INT_SECONDS_IN_WEEK;
exports.BIG_INT_TWO = BIG_INT_TWO;
exports.BIG_INT_ZERO = BIG_INT_ZERO;
exports.BIPS_BASE = BIPS_BASE;
exports.BLOCKED_PRICE_IMPACT_NON_EXPERT = BLOCKED_PRICE_IMPACT_NON_EXPERT;
exports.Box = Box;
exports.Bridge = Bridge;
exports.Button = Button;
exports.COINGECKO_API = COINGECKO_API;
exports.COINGECKO_CURRENCY_ID = COINGECKO_CURRENCY_ID;
exports.COINGEKO_BASE_URL = COINGEKO_BASE_URL;
exports.CUSTOM_BASES = CUSTOM_BASES;
exports.Checkbox = Checkbox;
exports.CheckboxGroup = CheckboxGroup;
exports.CoinDescription = CoinDescription;
exports.Collapsed = Collapsed;
exports.CurrencyInput = CurrencyInput;
exports.CurrencyLogo = CurrencyLogo;
exports.DEFAULT_DEADLINE_FROM_NOW = DEFAULT_DEADLINE_FROM_NOW;
exports.DIRECTUS_URL_NEWS = DIRECTUS_URL_NEWS;
exports.DoubleCurrencyLogo = DoubleCurrencyLogo;
exports.Drawer = Drawer;
exports.DropdownMenu = DropdownMenu;
exports.INITIAL_ALLOWED_SLIPPAGE = INITIAL_ALLOWED_SLIPPAGE;
exports.IS_IN_IFRAME = IS_IN_IFRAME;
exports.LANDING_PAGE = LANDING_PAGE;
exports.Loader = Loader;
exports.Logo = Logo$1;
exports.MINICHEF_ADDRESS = MINICHEF_ADDRESS;
exports.MIN_ETH = MIN_ETH;
exports.Modal = Modal;
exports.MyPortfolio = MyPortfolio;
exports.NATIVE = NATIVE;
exports.NEAR_ACCOUNT_MIN_STORAGE_AMOUNT = NEAR_ACCOUNT_MIN_STORAGE_AMOUNT;
exports.NEAR_API_BASE_URL = NEAR_API_BASE_URL;
exports.NEAR_EXCHANGE_CONTRACT_ADDRESS = NEAR_EXCHANGE_CONTRACT_ADDRESS;
exports.NEAR_LP_STORAGE_AMOUNT = NEAR_LP_STORAGE_AMOUNT;
exports.NEAR_MIN_DEPOSIT_PER_TOKEN = NEAR_MIN_DEPOSIT_PER_TOKEN;
exports.NEAR_MIN_DEPOSIT_PER_TOKEN_FARM = NEAR_MIN_DEPOSIT_PER_TOKEN_FARM;
exports.NEAR_STORAGE_PER_TOKEN = NEAR_STORAGE_PER_TOKEN;
exports.NEAR_STORAGE_TO_REGISTER_WITH_FT = NEAR_STORAGE_TO_REGISTER_WITH_FT;
exports.NETWORK_CHAIN_ID = NETWORK_CHAIN_ID;
exports.NearConnector = NearConnector;
exports.NetworkContextName = NetworkContextName;
exports.NetworkSelection = NetworkSelection;
exports.NewsWidget = NewsWidget;
exports.NumberOptions = NumberOptions;
exports.ONE_BIPS = ONE_BIPS;
exports.ONE_FRACTION = ONE_FRACTION;
exports.ONE_TOKEN = ONE_TOKEN;
exports.ONE_YOCTO_NEAR = ONE_YOCTO_NEAR;
exports.ONLY_ZEROS = ONLY_ZEROS;
exports.OPEN_API_DEBANK = OPEN_API_DEBANK;
exports.PANGOCHEF_ADDRESS = PANGOCHEF_ADDRESS;
exports.PANGOCHEF_COMPOUND_SLIPPAGE = PANGOCHEF_COMPOUND_SLIPPAGE;
exports.PANGOLIN_API_BASE_URL = PANGOLIN_API_BASE_URL;
exports.PANGOLIN_PERSISTED_KEYS = PANGOLIN_PERSISTED_KEYS;
exports.PANGOLIN_TOKENS_REPO_RAW_BASE_URL = PANGOLIN_TOKENS_REPO_RAW_BASE_URL;
exports.PINNED_PAIRS = PINNED_PAIRS;
exports.PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN = PRICE_IMPACT_WITHOUT_FEE_CONFIRM_MIN;
exports.PROVIDER_MAPPING = PROVIDER_MAPPING;
exports.PangolinProvider = PangolinProvider;
exports.PoolImportModal = PoolImportModal;
exports.Pools = Pools;
exports.Portfolio = Portfolio$1;
exports.ROUTER_ADDRESS = ROUTER_ADDRESS;
exports.ROUTER_DAAS_ADDRESS = ROUTER_DAAS_ADDRESS;
exports.RadioButton = RadioButton;
exports.RadioButtonGroup = RadioButtonGroup;
exports.SAR_STAKING_ADDRESS = SAR_STAKING_ADDRESS;
exports.SUBGRAPH_BASE_URL = SUBGRAPH_BASE_URL;
exports.SUPPORTED_WALLETS = SUPPORTED_WALLETS;
exports.SWAP_DEFAULT_CURRENCY = SWAP_DEFAULT_CURRENCY;
exports.SarManageWidget = SarMangePortfolio;
exports.SarNFTPortfolio = SarNFTPortfolio;
exports.SarStakeWidget = SarManageWidget;
exports.SelectTokenDrawer = SelectTokenDrawer$1;
exports.ShowMore = ShowMore;
exports.Stat = Stat;
exports.Step = Step;
exports.Steps = Steps;
exports.SwapWidget = SwapWidget;
exports.Switch = Switch;
exports.TIMEFRAME = TIMEFRAME;
exports.TRUSTED_TOKEN_ADDRESSES = TRUSTED_TOKEN_ADDRESSES;
exports.Text = Text;
exports.TextInput = TextInput;
exports.ToggleButtons = ToggleButtons;
exports.Tooltip = Tooltip;
exports.TransactionCompleted = TransactionCompleted;
exports.Wallet = Wallet;
exports.WalletModal = WalletModal;
exports.WatchList = WatchList;
exports.ZERO_ADDRESS = ZERO_ADDRESS;
exports.availableLanguages = availableLanguages;
exports.bitKeep = bitKeep;
exports.calculateTotalStakedAmountInAvax = calculateTotalStakedAmountInAvax;
exports.calculateTotalStakedAmountInAvaxFromPng = calculateTotalStakedAmountInAvaxFromPng;
exports.existSarContract = existSarContract;
exports.fetchChunkedAprs = fetchChunkedAprs;
exports.fetchMinichefData = fetchMinichefData;
exports.getEtherscanLink = getEtherscanLink;
exports.getNetworkLibrary = getNetworkLibrary;
exports.gnosisSafe = gnosisSafe;
exports.injected = injected;
exports.near = near;
exports.nearFn = nearFn;
exports.network = network;
exports.pangolinReducers = pangolinReducers;
exports.shortenAddress = shortenAddress;
exports.talisman = talisman;
exports.useAccountBalanceHook = useAccountBalanceHook;
exports.useActivePopups = useActivePopups;
exports.useAddPopup = useAddPopup;
exports.useAllTokens = useAllTokens;
exports.useAllTransactions = useAllTransactions;
exports.useAllTransactionsClearer = useAllTransactionsClearer;
exports.useDerivedStakeInfo = useDerivedStakeInfo;
exports.useDerivedSwapInfo = useDerivedSwapInfo;
exports.useGelatoLimitOrderDetail = useGelatoLimitOrderDetail;
exports.useGelatoLimitOrderList = useGelatoLimitOrderList;
exports.useGetAllFarmData = useGetAllFarmData;
exports.useGetAllFarmDataHook = useGetAllFarmDataHook;
exports.useGetMinichefStakingInfosViaSubgraphHook = useGetMinichefStakingInfosViaSubgraphHook;
exports.useGetUserLP = useGetUserLP;
exports.useLibrary = useLibrary;
exports.useMinichefPools = useMinichefPools;
exports.useMinichefStakingInfos = useMinichefStakingInfos;
exports.useMinichefStakingInfosHook = useMinichefStakingInfosHook;
exports.usePair = usePair;
exports.usePangoChefInfos = usePangoChefInfos;
exports.useParsedQueryString = useParsedQueryString;
exports.useRemovePopup = useRemovePopup;
exports.useSarPositions = useSarPositions;
exports.useSarStakeInfo = useSarStakeInfo;
exports.useSwapActionHandlers = useSwapActionHandlers;
exports.useTokenBalance = useTokenBalance;
exports.useTokenBalanceHook = useTokenBalanceHook;
exports.useTotalSupply = useTotalSupply;
exports.useTotalSupplyHook = useTotalSupplyHook;
exports.useUSDCPrice = useUSDCPrice;
exports.useUSDCPriceHook = useUSDCPriceHook;
exports.walletconnect = walletconnect;
exports.walletlink = walletlink;
exports.wrappedCurrency = wrappedCurrency;
exports.xDefi = xDefi;
Object.keys(limitOrdersReact).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return limitOrdersReact[k]; }
  });
});
//# sourceMappingURL=index.js.map
